/*----------------------------------------------------------------------------*
 * Copyright Statement:                                                       *
 *                                                                            *
 *   This software/firmware and related documentation ("MediaTek Software")   *
 * are protected under international and related jurisdictions'copyright laws *
 * as unpublished works. The information contained herein is confidential and *
 * proprietary to MediaTek Inc. Without the prior written permission of       *
 * MediaTek Inc., any reproduction, modification, use or disclosure of        *
 * MediaTek Software, and information contained herein, in whole or in part,  *
 * shall be strictly prohibited.                                              *
 * MediaTek Inc. Copyright (C) 2010. All rights reserved.                     *
 *                                                                            *
 *   BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND     *
 * AGREES TO THE FOLLOWING:                                                   *
 *                                                                            *
 *   1)Any and all intellectual property rights (including without            *
 * limitation, patent, copyright, and trade secrets) in and to this           *
 * Software/firmware and related documentation ("MediaTek Software") shall    *
 * remain the exclusive property of MediaTek Inc. Any and all intellectual    *
 * property rights (including without limitation, patent, copyright, and      *
 * trade secrets) in and to any modifications and derivatives to MediaTek     *
 * Software, whoever made, shall also remain the exclusive property of        *
 * MediaTek Inc.  Nothing herein shall be construed as any transfer of any    *
 * title to any intellectual property right in MediaTek Software to Receiver. *
 *                                                                            *
 *   2)This MediaTek Software Receiver received from MediaTek Inc. and/or its *
 * representatives is provided to Receiver on an "AS IS" basis only.          *
 * MediaTek Inc. expressly disclaims all warranties, expressed or implied,    *
 * including but not limited to any implied warranties of merchantability,    *
 * non-infringement and fitness for a particular purpose and any warranties   *
 * arising out of course of performance, course of dealing or usage of trade. *
 * MediaTek Inc. does not provide any warranty whatsoever with respect to the *
 * software of any third party which may be used by, incorporated in, or      *
 * supplied with the MediaTek Software, and Receiver agrees to look only to   *
 * such third parties for any warranty claim relating thereto.  Receiver      *
 * expressly acknowledges that it is Receiver's sole responsibility to obtain *
 * from any third party all proper licenses contained in or delivered with    *
 * MediaTek Software.  MediaTek is not responsible for any MediaTek Software  *
 * releases made to Receiver's specifications or to conform to a particular   *
 * standard or open forum.                                                    *
 *                                                                            *
 *   3)Receiver further acknowledge that Receiver may, either presently       *
 * and/or in the future, instruct MediaTek Inc. to assist it in the           *
 * development and the implementation, in accordance with Receiver's designs, *
 * of certain softwares relating to Receiver's product(s) (the "Services").   *
 * Except as may be otherwise agreed to in writing, no warranties of any      *
 * kind, whether express or implied, are given by MediaTek Inc. with respect  *
 * to the Services provided, and the Services are provided on an "AS IS"      *
 * basis. Receiver further acknowledges that the Services may contain errors  *
 * that testing is important and it is solely responsible for fully testing   *
 * the Services and/or derivatives thereof before they are used, sublicensed  *
 * or distributed. Should there be any third party action brought against     *
 * MediaTek Inc. arising out of or relating to the Services, Receiver agree   *
 * to fully indemnify and hold MediaTek Inc. harmless.  If the parties        *
 * mutually agree to enter into or continue a business relationship or other  *
 * arrangement, the terms and conditions set forth herein shall remain        *
 * effective and, unless explicitly stated otherwise, shall prevail in the    *
 * event of a conflict in the terms in any agreements entered into between    *
 * the parties.                                                               *
 *                                                                            *
 *   4)Receiver's sole and exclusive remedy and MediaTek Inc.'s entire and    *
 * cumulative liability with respect to MediaTek Software released hereunder  *
 * will be, at MediaTek Inc.'s sole discretion, to replace or revise the      *
 * MediaTek Software at issue.                                                *
 *                                                                            *
 *   5)The transaction contemplated hereunder shall be construed in           *
 * accordance with the laws of Singapore, excluding its conflict of laws      *
 * principles.  Any disputes, controversies or claims arising thereof and     *
 * related thereto shall be settled via arbitration in Singapore, under the   *
 * then current rules of the International Chamber of Commerce (ICC).  The    *
 * arbitration shall be conducted in English. The awards of the arbitration   *
 * shall be final and binding upon both parties and shall be entered and      *
 * enforceable in any court of competent jurisdiction.                        *
 *---------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------
 *
 * $Author: p4admin $
 * $Date: 2015/02/15 $
 * $RCSfile: swdmx_mpg.c,v $
 * $Revision: #1 $
 *
 *---------------------------------------------------------------------------*/

/** @file swdmx_avi.c
 *  Software demux for avi - internal interface
 */

//-----------------------------------------------------------------------------
// Include files
//-----------------------------------------------------------------------------
#define SWDMX_MPG_SYNC_DTV_MODE

#include "dmx_if.h"
#include "dmx_mm_if.h"
#include "vdec_drvif.h"
#include "aud_drvif.h"
#include "aud_if.h"
#ifdef LINUX_TURNKEY_SOLUTION
#include "aud_drv.h"
#include "mtdrm.h"
#include "mthdcp2.h"
#endif
#include "swdmx_drvif.h"
#include "swdmx_if.h"
#include "swdmx_mpg.h"
#include "swdmx_mpg_dmx.h"
#include "swdmx_mpg_pvr.h"
#include "swdmx_mpg_psipsr_if.h"
#include "fbm_drvif.h"
#include "x_util.h"
#include "rtc_if.h"
#include "swdmx_debug.h"
#include "swdmx_mpg_idx.h"
#ifdef SWDMX_MPG_SYNC_DTV_MODE
#include "stc_drvif.h"
#endif

#if defined(CC_MT5387) || defined(CC_MT5363) || defined(CC_MT5365) || defined(CC_MT5395) || defined(VDEC_IS_POST_MT5368)
#include "b2r_drvif.h"
#include "b2r_if.h"
#endif

#if defined(CC_TRUSTZONE_SUPPORT)
#include "tz_if.h"
#endif

#include "x_rm_dev_types.h"
#include "x_vid_dec.h"
#include "x_aud_dec.h"


#ifdef SWDMX_DUMP_DATA
#include "swdmx_debug_util.h"
#endif

#ifdef __KERNEL__
#include <linux/time.h>
#endif

//-----------------------------------------------------------------------------
// Constant definitions
//-----------------------------------------------------------------------------
#ifdef HANDLE_PTS_SKIP
#define SKIP_PTS           (2 * 90000)
#define SKIP_PTS_RECOVER_THRESHOLD (3*90000)
#define NO_SKIP_PTS        (0)
#define AUDIO_PTS_SKIP     (1)
#define VIDEO_PTS_SKIP     (1 << 1)
#define NEED_RESET_STC     (AUDIO_PTS_SKIP | VIDEO_PTS_SKIP)
#endif

#ifdef HANDLE_CHANGE_AUDIO_TYPE
#define UNKNOWN_AUDIO_TYPE      0x1
#define ONCE_DEALY_TIME         20
#define AUDIO_TYPE_FOUND        0x32
#define AUDIO_TYPE_HANDLE_END   0xFF
#endif

#define INVALID_FILESIZE    (0xFFFFFFFFUL)
#define SWDMX_MPG_DMX_20
#define DEMUX_MPG_AV_PERIOD   90000
#define FILE_SIZE_PACKET_RESERVE    10
#define THRESHOLD_FRAME_COUNT 30
#define DEFAULT_FRAME_SIZE (100 * 1024)
//#define MPG_PUSH_REAL

//#define MPG_CHECK_FEEDER_REQ

#ifdef CC_IPTV_SUPPORT
#define IPTV_FAST_START
#endif

#define SWDMX_FEEDER_ID_GAP (5000)
#define SWDMX_AUDIO_FULL_PTS_INTERVAL (90000*2)

#define MAX_EMSG_NUM        600
#define MAX_AVC_EMSG_NUM    1600
#define MAX_USB_EMSG_NUM                        30
#define MAX_LOCAL_NET_EMSG_NUM                  (MAX_USB_EMSG_NUM * 1)
#define MAX_NET_EMSG_NUM                        (MAX_USB_EMSG_NUM * 3)
#define MAX_QUICK_START_NUM                     12
#define MAX_AUDIO_DATA_SIZE                     200 * 1024
#define MIN_AUDIO_DATA_SIZE                     20 * 1024

#define AVG_BIT_RATE_THRESHOLD                 (300 * 1024) //300K Byte 

#if 0// ndef IS_NETWORK_SRC
#define IS_NETWORK_SOURCE(x)   ((x == MM_SRC_TYPE_NETWORK_VUDU) || (x == MM_SRC_TYPE_NETWORK_CMPB) \
                             || (x == MM_SRC_TYPE_NETWORK_DLNA) || (x == MM_SRC_TYPE_PUSH)   \
                             || (x == MM_SRC_TYPE_NETWORK_XUNLEI) || (x == MM_SRC_TYPE_QUICK_START)\
                             || (x == MM_SRC_TYPE_NETWORK_LIVE_STREAMING) || (x ==  MM_SRC_TYPE_NETWORK_HLS) \
                             || (x == MM_SRC_TYPE_NETWORK_RVU))
#else
#define IS_NETWORK_SOURCE IS_NETWORK_SRC
#endif

#define IS_TS_FILE(x)        ( (x == SWDMX_FMT_MPEG2_TS)    \
                            || (x == SWDMX_FMT_MPEG2_TS_192) \
                            || (x == SWDMX_FMT_MPEG2_TS_ZERO_192) \
                            || (x == SWDMX_FMT_MPEG2_TS_130) \
                            || (x == SWDMX_FMT_MPEG2_TS_134) \
                            || (x == SWDMX_FMT_MPEG2_TS_204) \
                            || (x == SWDMX_FMT_MPEG2_TS_206) \
                            || (x == SWDMX_FMT_MPEG2_TS_ENCRYPT_192))

#define IS_PUSH_MODE(x)     ((x == MM_SRC_TYPE_PUSH) \
                            || (x == MM_SRC_TYPE_NETWORK_MPEG_REAL_PUSH) \
                            || (x == MM_SRC_TYPE_IPTV) \
                            || (x == MM_SRC_TYPE_WIFI_DISPLAY)\
                            || (x == MM_SRC_TYPE_QUICK_START)\
                            || (x == MM_SRC_TYPE_NETWORK_LIVE_STREAMING) \
                            || (x == MM_SRC_TYPE_NETWORK_HLS) \
                            || (x == MM_SRC_TYPE_NETWORK_RVU)\
                            || (x == MM_SRC_TYPE_NETWORK_DASH)\
              				|| (x == MM_SRC_TYPE_NETWORK_MHEG5)\
				            || (x == MM_SRC_TYPE_NETWORK_VUDU))

#define NEED_QUICK_START(x)    ((x == MM_SRC_TYPE_NETWORK_MPEG_REAL_PUSH) \
                            || (x == MM_SRC_TYPE_IPTV) \
                            || (x == MM_SRC_TYPE_WIFI_DISPLAY)\
                            || (x == MM_SRC_TYPE_QUICK_START)\
                            || (x == MM_SRC_TYPE_NETWORK_MHEG5))

#define IS_LOCAL_NET(x)        ((x == MM_SRC_TYPE_NETWORK_DLNA))

#define USB_SOURCE(x)          ((x == MM_SRC_TYPE_HIGH_SPEED_STORAGE))

#define AUDIO_IS_LPCM(x)       (x == MM_SRC_TYPE_WIFI_DISPLAY)

#ifdef SWDMX_RVU_PARSE_PTS
static DMX_PES_MSG_T _arDmxPes[SWDMX_SOURCE_MAX];
#endif

#define SWDMX_RVU_30K_BASE_PTS_MAX      0xDA740D        // The last 30K base PTS for RVU, 0xFFFFFFFF/300
#define SWDMX_RVU_SHAKE_START_PTS       0xD50000        // PTS will jump to a little one later
#define SWDMX_RVU_SHAKE_END_PTS         0x50000         // PTS will leave jump status
#define SWDMX_RVU_VIDEO_SHAKE_TIME      90              // For video case, decoder order!=display order
#define IN_NORMAL_STATE(pts)            ((SWDMX_RVU_SHAKE_END_PTS  <= (pts)) && (SWDMX_RVU_SHAKE_START_PTS >= (pts)) && (0 !=(pts)))
#define SWDMX_PTS_GAP(pts1, pts2)       (((pts1)>(pts2)) ? ((pts1)-(pts2)) : ((pts2)-(pts1)))

//-----------------------------------------------------------------------------
// Static variables
//-----------------------------------------------------------------------------

static VDEC_SEQUENCE_DATA_T _arSeqInfo[SWDMX_SOURCE_MAX];
static UCHAR ucCount = 0;
static UINT32 _u4DoubleDataSize = 1;
//#ifdef CC_VUDU_SUPPORT
static DMX_VUDU_KEY_T _arVuduKey[SWDMX_SOURCE_MAX][MPG_BUF_NUM_MAX];
//#endif
static SWDMX_BUF_AGT_CTRL_IBC_PARAM_STRM_INFO_T _arIBCStrmInfo[SWDMX_SOURCE_MAX][MPG_BUF_NUM_MAX];
SWDMX_IBC_DASH_SET_INFO_T _arIBCDashSetInfo[SWDMX_SOURCE_MAX][MPG_BUF_NUM_MAX];
#ifdef LINUX_TURNKEY_SOLUTION 
static UINT8* g_ptHDCPKey = NULL;
#endif

MM_GNRC_STREAM_T gt_gnrc_stream;

//#define SWDMX_MPG_DEBUG_FIFO
#ifdef SWDMX_MPG_DEBUG_FIFO
#define SWDMX_MPG_AFIFO_SIZE 0x200000
#define SWDMX_MPG_DMXFIFO_SIZE 0x500000
#ifdef SWDMX_MPG_AFIFO_SIZE
BOOL _fgAManual = TRUE;
BOOL _fgAFifo = FALSE;
UINT32 _u4AFifoStart = 0;
UINT32 _u4AFifoEnd = 0;
UINT32 _u4AFifoCur = 0;
UINT32 _u4AudioLastWriter = 0;
#endif
#ifdef SWDMX_MPG_DMXFIFO_SIZE
BOOL _fgDmxManual = TRUE;
BOOL _fgDmxFifo = FALSE;
UINT32 _u4DmxFifoStart = 0;
UINT32 _u4DmxFifoEnd = 0;
UINT32 _u4DmxFifoCur = 0;
#endif
VOID _SWDMX_COPY_RING_BUF(
    UINT32 u4TarStart,
    UINT32 u4TarEnd,
    UINT32* pu4TarCur,
    UINT32 u4SrcStart,
    UINT32 u4SrcEnd,
    UINT32 u4SrcCur,
    UINT32 u4Size);
#endif

//-----------------------------------------------------------------------------
// Static functions
//-----------------------------------------------------------------------------
#ifdef SWDMX_RVU_PARSE_PTS
static VOID _SWDMX_MpgTs130Reset(UINT8 u1SrcId);
#endif
extern UINT32 _VDP_SetSyncSpeed(UCHAR u1B2rId, BOOL fgOffOn, UINT32 u4Speed);
VOID _SWDMX_MpgCreateFindSema(UINT8 u1SrcId);
VOID _SWDMX_MpgDeleteFindSema(UINT8 u1SrcId);
VOID _SWDMX_MpgFlushVFifo(UINT8 u1SrcId);
VOID _SWDMX_MpgFlushAFifo(UINT8 u1SrcId);
VOID _SWDMX_MpgFlushAFifo2(UINT8 u1SrcId);
VOID _SWDMX_MpgFlushAFifo3(UINT8 u1SrcId);
BOOL _SWDMX_MpgWatchVideoPTS(UINT8 u1SrcId, const DMX_PES_MSG_T* prPes);
BOOL _SWDMX_MpgWatchAudioPTS(UINT8 u1SrcId, const DMX_AUDIO_PES_T* prPes);
VOID _SWDMX_MpgSeekFinNotify(UINT8 u1SrcId, UINT32 u4PTS, BOOL fgAgain);

#ifndef CC_PS_DISABLE
BOOL _SWDMX_MpgPsSetVideoId(UINT8 u1SrcId, UINT8 u1Pidx, UINT16 u2VideoId);
BOOL _SWDMX_MpgPsSetAudioId(UINT8 u1SrcId, UINT8 u1Pidx, UINT16 u2AudioId, UINT16 u2AudioSubId);
BOOL _SWDMX_MpgPsFreeVideoId(UINT8 u1SrcId);
BOOL _SWDMX_MpgPsFreeAudioId(UINT8 u1SrcId);
#endif

#ifndef CC_TS_DISABLE
BOOL _SWDMX_MpgTsSetVideoId(UINT8 u1SrcId, UINT8 u1Pidx, UINT16 u2VideoId, UINT8 u1KeyIndex, UINT32 u4DescMode, BOOL fgSecondVideo);
BOOL _SWDMX_MpgTsSetAudioId(UINT8 u1SrcId, UINT8 u1Pidx, UINT16 u2AudioId, UINT16 u2DeviceId, UINT8 u1KeyIndex, UINT32 u4DescMode);
BOOL _SWDMX_MpgTsSetPCRId(UINT8 u1SrcId, UINT16 u2PCRId);
BOOL _SWDMX_MpgTsFreeVideoId(UINT8 u1SrcId, BOOL fgSecondVideo);
BOOL _SWDMX_MpgTsFreeAudioId(UINT8 u1SrcId);
BOOL _SWDMX_MpgTsFreeAudio2Id(UINT8 u1SrcId); // 0831
BOOL _SWDMX_MpgTsFreeAudio3Id(UINT8 u1SrcId); // 0831
BOOL _SWDMX_MpgTsFreePCRId(UINT8 u1SrcId);
#endif

#ifndef CC_ES_DISABLE
BOOL _SWDMX_MpgEsSetVideoId(UINT8 u1SrcId, UINT8 u1Pidx);
BOOL _SWDMX_MpgEsSetAudioId(UINT8 u1SrcId, UINT8 u1Pidx);
BOOL _SWDMX_MpgEsFreeVideoId(UINT8 u1SrcId);
BOOL _SWDMX_MpgEsFreeAudioId(UINT8 u1SrcId);
#endif

BOOL _SWDMX_MpgWatchDuration(UINT8 u1SrcId, UINT32 u4CurentTime);
UINT32 _SWDMX_MpgWatchLastPTS(UINT8 u1SrcId, UINT32 u4Type, UINT32 u4Pts);
VOID _SWDMX_MpgResetVariable(UINT8 u1SrcId);
VOID _SWDMX_MpgJumpToNormal(UINT8 u1SrcId, BOOL fgSeek, BOOL fgSeekOffset, BOOL fgJumpping, INT32 i4Speed);
VOID _SWDMX_MpgHandleChange(UINT8 u1SrcId, SWDMX_CUR_CMD_T* prCmd);
VOID _SWDMX_MpgHandleEOS(UINT8 u1SrcId, INT32 i4PlaySpeed);
BOOL _SWDMX_MpgResetFeeder(UINT8 u1SrcId);
VOID _SWDMX_MpgResetInputData(UINT8 u1SrcId);
VOID _SWDMX_MpgResetData(UINT8 u1SrcId);
INT32 _SWDMX_MpgHandleFifoFull(UINT8 u1SrcId, INT32 i4PlaySpeed, BOOL fgLast);
INT32 _SWDMX_MpgHandleMoveData(UINT8 u1SrcId, DMX_MM_DATA_T* prDmxMMData, INT32 i4PlaySpeed);
BOOL _SWDMX_MpgHandleMoveDataSysB(UINT8 u1SrcId, DMX_MM_DATA_T* prDmxMMData, INT32 i4PlaySpeed);
UINT32 _SWDMX_MpgHandleAudioIndex(UINT8 u1SrcId, UINT64 u8StartAddr, UINT32 u4ReadSize,
    UINT64 *pu8OutStartAddr, UINT32 *pu4OutReadSize, UINT32 *pu4OutReadPTS, INT32 i4PlaySpeed);
UINT32 _SWDMX_MpgHandleRing(UINT8 u1SrcId, UINT64 u8StartAddr, UINT32 u4ReadSize,
    UINT64 *pu8OutStartAddr, UINT32 *pu4OutReadSize, INT32 i4PlaySpeed);
INT32 _SWDMX_ReceiveFeederAck(UINT8 u1SrcId, VOID *pvData);
void _SWDMX_MpgHandleSeek(UINT8 u1SrcId, INT32 i4PlaySpeed, BOOL fgSeek);
VOID _SWDMX_MpgHandleSeekAudio(UINT8 u1SrcId, INT32 i4PlaySpeed, BOOL fgSeek);
INT32 _SWDMX_MpgHandleFeeder(UINT8 u1SrcId, SWDMX_RANGE_LIST_T* prRangeList, INT32 i4PlaySpeed);
INT32 _SWDMX_MpgSendData(UINT8 u1SrcId, SWDMX_RANGE_LIST_T* prRangeList,
            SWDMX_CUR_CMD_T* prCmd);
BOOL _SWDMX_MpgSendDataBatch(UINT8 u1SrcId);
BOOL _SWDMX_MpgSendDataBatchForTotalTime(UINT8 u1SrcId);
BOOL _SWDMX_MpgBaseInit(UINT8 u1SrcId, ENUM_SWDMX_FMT_T eType);
BOOL _SWDMX_MpgOpen(UINT8 u1SrcId, ENUM_SWDMX_FMT_T eType,
    UINT32 u4TrackId,
    UINT64 u8FileSize,
    SWDMX_STREAM_INFO_T* prOpenInfo);
BOOL _SWDMX_MpgBaseGetInfo(UINT8 u1SrcId, ENUM_SWDMX_FMT_T eType,
        UINT32 u4InfoMask,
        UINT64 u8FileSize,
        SWDMX_STREAM_INFO_T* prStreamInfo);
BOOL _SWDMX_MpgGetSeqInfo(UINT8 u1SrcId, ENUM_SWDMX_FMT_T eType,
        UINT32 u4InfoMask,
        UINT64 u8FileSize,
        SWDMX_PROGRAM_INFO_T* prPInfo);
BOOL _SWDMX_MpgIsSpeedAvailable(UINT8 u1SrcId, BOOL fgForward);
INT32 _SWDMX_MpgHandleNoSignel(UINT8 u1SrcId, UINT64 *pu8SeekPos, INT32 i4PlaySpeed);
INT32 _SWDMX_MpgHandleEmpty(UINT8 u1SrcId, UINT64 *pu8SeekPos, INT32 i4PlaySpeed);
BOOL _SWDMX_MpgResetFeederReq(UINT8 u1SrcId);
#ifdef TIME_SHIFT_SUPPORT
UINT64 _SWDMX_MpgTSAlignDown(UINT8 u1SrcId, UINT64 u8Position);
UINT64 _SWDMX_MpgLBA2Pos(UINT8 u1SrcId, UINT32 u4LBA);
#endif
INT32 _SWDMX_MpgHandlePidChg(UINT8 u1SrcId);
INT32 _SWDMX_MpgHandleCodecChg(UINT8 u1SrcId);
INT32 _SWDMX_MpgHandleStrmChg(UINT8 u1SrcId,SWDMX_BUF_AGT_CTRL_IBC_PARAM_STRM_INFO_T* prIBCStrmInfo);
INT32 _SWDMX_MpgHandleFifoEmpty(UINT8 u1SrcId);
static ENUM_SWDMX_VDEC_T _SWDMX_MpgVidCodecConvert(UINT8 e_vid_codec);
static ENUM_SWDMX_ADEC_T _SWDMX_MpgAudCodecConvert(UINT8 e_aud_codec);
BOOL _SWDMX_MpgHandleFlushFeeder(UINT8 u1SrcId,UINT8 u1Type,VOID* pvMMFlushInfo,UINT32 u4Para2,UINT32 u4Para3);

#ifdef HANDLE_CODEC_PID_CHG
VOID _SWDMX_MpgPvrHandleCodecPidChg(UINT8 u1SrcId);
#endif

VOID _SWDMX_MpgHandleScrambleState(UINT8 u1SrcId,UINT8 u1StrmType,UINT8 u1Pidx);
/* timebased seek api */
VOID _SWDMX_MpgCalcNextTime(UINT8 u1SrcId,INT32 i4PlaySpeed);
INT32 _SWDMX_MpgHandleNextTrick(UINT8 u1SrcId,INT32 i4PlaySpeed);
VOID _SWDMX_MpgHandleTimeSeek(UINT8 u1SrcId);
VOID _SWDMX_MpgHandleTimeTrick(UINT8 u1SrcId,INT32 i4PlaySpeed);
VOID _SWDMX_MpgHandleTimeNextTrick(UINT8 u1SrcId,INT32 i4PlaySpeed);
VOID _SWDMX_MpgPlayOneFrame(UINT8 u1SrcId);
VOID _SWDMX_MpgVdecPlay(UINT8 u1SrcId);
INT32 _SWDMX_MpgHandleReq(UINT8 u1SrcId,UINT32 u4ReadSize,UINT64 u8ReadAddr);

VOID _SWDMX_MpgPvrHandleCodecPidChg(UINT8 u1SrcId);

static VOID _SWDMX_MpgGetFrameSize(UINT8 u1SrcId, UINT64 *u8Size);
static BOOL _SWDMX_MpgInitPrebuffer(UINT8 u1SrcId);
static BOOL _SWDMX_MpgInitDmx(UINT8 u1SrcId,UINT8 u1StrmType);
static void _SWDMX_MpgFlushAudio(UINT8 u1SrcId);

VOID _SWDMX_MpgFlushPreBuffer(UINT8 u1SrcId);
VOID _SWDMX_MpgDetectStrmChgInfo(UINT8 u1SrcId);
VOID _SWDMX_MpgSetActivePix(UINT8 u1SrcId);
VOID _SWDMX_MpgHandleLastMemory(UINT8 u1SrcId,SWDMX_RANGE_LIST_T* prRangeList);
BOOL _SWDMX_MpgHDCP2SetRivPid(UINT16 Pidx);
BOOL _SWDMX_MpgEnableHdcpKey(UINT8 u1SrcId,UINT8 u1Type);
#ifdef SWDMX_MPG_DEBUG_FIFO
VOID _SWDMX_COPY_RING_BUF(
    UINT32 u4TarStart,
    UINT32 u4TarEnd,
    UINT32* pu4TarCur,
    UINT32 u4SrcStart,
    UINT32 u4SrcEnd,
    UINT32 u4SrcCur,
    UINT32 u4Size)
{
    UINT32 u4TmpSize;
    UINT32 u4TarCur;

    if(!pu4TarCur)
    {
        LOG(1, "pu4TarCur null\n");
        return;
    }

    u4TarCur = *pu4TarCur;
    while( u4Size > 0)
    {
        u4TmpSize = u4Size;
        u4TmpSize = (u4SrcEnd - u4SrcCur) > u4TmpSize ? u4TmpSize : (u4SrcEnd - u4SrcCur);
        u4TmpSize = (u4TarEnd - u4TarCur) > u4TmpSize ? u4TmpSize : (u4TarEnd - u4TarCur);
        if(u4TmpSize > 0)
        {
            x_memcpy((VOID*)u4TarCur, (VOID*)u4SrcCur, u4TmpSize);
            u4SrcCur += u4TmpSize;
            u4TarCur += u4TmpSize;
            u4Size -= u4TmpSize;
            if(u4SrcCur >= u4SrcEnd)
            {
                u4SrcCur = u4SrcStart;
            }
            if(u4TarCur >= u4TarEnd)
            {
                u4TarCur = u4TarStart;
            }
        }
    }

    *pu4TarCur = u4TarCur;
}
#endif


#ifdef SWDMX_STATISTICS
VOID _CalFeederTime(UINT8 u1SrcId)
{
    UINT32 u4Delta;
    HAL_TIME_T rDelta;
    HAL_TIME_T *rFeederReqStartTime;
    HAL_TIME_T *rFeederReqEndTime;
    UINT32 *u4FeederAvgTime;
    UINT32 *u4FeederMaxTime;
    UINT32 *u4FeederMinTime;
    UINT32 *u4FeederCount;

    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    rFeederReqStartTime=&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rFeederReqStartTime;
    rFeederReqEndTime=&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rFeederReqEndTime;
    u4FeederAvgTime=&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederAvgTime;
    u4FeederMaxTime=&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederMaxTime;
    u4FeederMinTime=&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederMinTime;
    u4FeederCount=&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederCount;


    HAL_GetTime(rFeederReqEndTime);
    HAL_GetDeltaTime(&rDelta, rFeederReqStartTime, rFeederReqEndTime);

    u4Delta = rDelta.u4Micros;
    if (rDelta.u4Micros > 1000) // 1ms
    {
        *u4FeederAvgTime = ((*u4FeederAvgTime * (*u4FeederCount)) + u4Delta) / (*u4FeederCount + 1);

        (*u4FeederCount) ++;

        *u4FeederMaxTime = (*u4FeederMaxTime > u4Delta) ? *u4FeederMaxTime : u4Delta;
        *u4FeederMinTime = (*u4FeederMinTime < u4Delta) ? *u4FeederMinTime : u4Delta;
    }

    if ((*u4FeederCount % 1000) == (1000 - 1))
    {
        LOG(0, "Feeder Count(%d) Time(%d, %d, %d)\n",
            *u4FeederCount,
            *u4FeederMaxTime, *u4FeederAvgTime, *u4FeederMinTime);
    }
}
#endif

/**
*/
static BOOL _SWDMX_MpgCheckVdecState(UINT8 u1SrcId)
{
    UINT32 u4Status;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);

    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    u4Status = MPV_GetDecMode(prSwdmxInst->u1VdecId);
    if ((u4Status == VDEC_ST_STOP) || (u4Status == VDEC_ST_IDLE))
    {
        LOG(0, "VDEC not play, u4Status=%d!!!\n", u4Status);
        return FALSE;
    }
    if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
        (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
    {
        u4Status = MPV_GetDecMode(prSwdmxInst->u1Vdec2Id);
        if ((u4Status == VDEC_ST_STOP) || (u4Status == VDEC_ST_IDLE))
        {
            LOG(0, "VDEC2 not play, u4Status=%d!!!\n", u4Status);
            return FALSE;
        }
    }
    return TRUE;
}

static UINT32 _SWDMX_MpgAudESGetAlignBase(MM_RANGE_ELMT_IDXTBL_T *pt_idxtbl_lst)
{
    if (pt_idxtbl_lst == NULL)
    {
        return 0;
    }

    if ((pt_idxtbl_lst->ui4_number_of_entry > 0) && (pt_idxtbl_lst->u.pt_pb_idx_tbl_entry))
    {
        // with index, we don't need to check alignment
        return 1;
    }
    else if (pt_idxtbl_lst->ui4_align > 0)
    {
        return pt_idxtbl_lst->ui4_align;
    }
    else if (pt_idxtbl_lst->ui4_align == 0)
    {
        return 1;
    }

    return 0;
}

static VOID _SWDMX_MpgAudESSetReqSize(UINT8 u1SrcId)
{
  UINT32 u4AlignBase = 0;
    MM_RANGE_ELMT_IDXTBL_T* prIdxTbl = NULL;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq) &&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo) &&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst))
    {
        prIdxTbl = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst;

        if (prIdxTbl)
        {
            u4AlignBase = _SWDMX_MpgAudESGetAlignBase(prIdxTbl);

            if (u4AlignBase)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase = u4AlignBase;
            }
            
            if (prIdxTbl->t_aud_spec_info.e_fmt == ASH_AUDIO_FMT_AMR)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = 0;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = 
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = 
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
            }
        }
    }
    
    if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase > 1) &&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase < 
         (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - 
          prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset)))
    {
        UINT32 u4Tmp = 0;

        u4Tmp = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize;
        u4Tmp /= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase;
        if (u4Tmp == 0)
        {
            LOG(1, "line:%d, the alignment size (0x%x) is too large!!\n", __LINE__,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase);
        }
        else
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize = 
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase * u4Tmp;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeReadSize = 
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize * MPG_BATCH_READ_SIZE;
        }
    }
    // Under low bitrate environment, set smaller feeder request size
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type == MM_SRC_TYPE_NETWORK_DLNA)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeReadSize = 
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize;
        LOG(1, "DLNA AudioES set u4OneTimeReadSize to 0x%X\n",
           prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeReadSize); 
    }
}

static VOID _SWDMX_MpgModifyPlayPos(UINT8 u1SrcId)
{
    UINT64 u8Remainder = 0;
    SWDMX_MPG_INFO_T* prMpgInst;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);

    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    prMpgInst = &(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo);
    
    if((prMpgInst->rVar.u4AlignBase <= 1) 
        || (prMpgInst->rVar.u4AlignBase > (prMpgInst->rVar.u8FileSize - prMpgInst->rVar.u8StartFileOffset))
        || (prMpgInst->rVar.u8PlayPos > prMpgInst->rVar.u8FileSize))
    {
        return;
    }
    if((prMpgInst->rVar.u8PlayPos < prMpgInst->rVar.u8StartFileOffset) 
        || ((prMpgInst->rVar.u8PlayPos - prMpgInst->rVar.u8StartFileOffset) < prMpgInst->rVar.u4AlignBase))
    {
        prMpgInst->rVar.u8PlayPos = prMpgInst->rVar.u8StartFileOffset;
    }
    else
    {
        UNUSED(_SWDMX_Div6464((prMpgInst->rVar.u8PlayPos - prMpgInst->rVar.u8StartFileOffset), 
            prMpgInst->rVar.u4AlignBase, &u8Remainder));
        prMpgInst->rVar.u8PlayPos -= u8Remainder;
    }    
}

static BOOL _SWDMX_DMX_Reset(UINT8 u1SrcId)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

#ifdef TIME_SHIFT_SUPPORT
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        if(!_SWDMX_PVR_Stop(u1SrcId))
        {
            LOG(3, "_SWDMX_DMX_Reset _SWDMX_PVR_Stop fail\n");
            return FALSE;
        }
        // Todo:
        return DMX_PVRPlay_RequestReset();
    }
    else
#endif
    {
        // because audio only is use CPU move data, we don't need reset it.
        // Todo: how about CPU reset?
        if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_RAW_AUDIO_ES) &&
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_UNKNOWN))
        {
            #ifdef SWDMX_MPG_DMX_20
            return DMX_MUL_RequestReset(prSwdmxInst->u1DmxId);
            #else
            UINT8 u1SrcIdSecond;
            SWDMX_INFO_T* prSwdmxInstSecond;
            u1SrcIdSecond = (u1SrcId+1)%SWDMX_SOURCE_MAX;
            prSwdmxInstSecond = _SWDMX_GetInst(u1SrcIdSecond);
            if(!prSwdmxInstSecond->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
            {
                return DMX_DDI_RequestReset();
            }
            #endif
        }
    }
    return TRUE;
}

#ifdef SWDMX_MPG_PS_GET_INFO
static VOID _SWDMX_FlushFindMsgQ(UINT8 u1SrcId)
{
    UINT16 u2Cnt;
    UINT16 u2MsgQIdx;
    UINT32 u4DecFin;
    SIZE_T zMsgSize;

    zMsgSize = sizeof(INT32);
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    while (x_msg_q_receive(&u2MsgQIdx, &u4DecFin, &zMsgSize,
        &prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hFindMsgQ, 1, X_MSGQ_OPTION_NOWAIT) == OSR_OK)
    {
    }

    VERIFY(x_msg_q_num_msgs(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hFindMsgQ, &u2Cnt) == OSR_OK);
    ASSERT(u2Cnt== 0);
}

static VOID _SWDMX_TimerFindTimeout(UINT8 u1SrcId, HANDLE_T  pt_tm_handle, VOID *pv_tag)
{
    UINT32 u4DecFin;

    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);
    u4DecFin = DETECT_TIMEOUT;
    VERIFY(x_msg_q_send(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hFindMsgQ, (VOID *)&u4DecFin, sizeof(UINT32), 255) == OSR_OK);

    UNUSED(pt_tm_handle);
    UNUSED(pv_tag);
}
#endif

#ifdef SWDMX_MPG_PS_GET_INFO
static VOID _SWDMX_FlushDataMsgQ(UINT8 u1SrcId)
{
    UINT16 u2Cnt;
    UINT16 u2MsgQIdx;
    UINT32 u4DecFin;
    SIZE_T zMsgSize;

    zMsgSize = sizeof(INT32);
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    while (x_msg_q_receive(&u2MsgQIdx, &u4DecFin, &zMsgSize,
        &prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hDataMsgQ, 1, X_MSGQ_OPTION_NOWAIT) == OSR_OK)
    {
    }

    VERIFY(x_msg_q_num_msgs(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hDataMsgQ, &u2Cnt) == OSR_OK);
    ASSERT(u2Cnt== 0);
}


static VOID _SWDMX_TimerDataTimeout(UINT8 u1SrcId, HANDLE_T  pt_tm_handle, VOID *pv_tag)
{
    UINT32 u4DecFin;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    u4DecFin = DETECT_TIMEOUT;
    VERIFY(x_msg_q_send(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hDataMsgQ, (VOID *)&u4DecFin, sizeof(UINT32), 255) == OSR_OK);

    UNUSED(pt_tm_handle);
}
#endif

#ifdef SWDMX_MPG_PS_GET_INFO
VOID _SWDMX_MpgCreateFindSema(UINT8 u1SrcId)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hFindMsgQ)
    {
        VERIFY(x_msg_q_create(&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hFindMsgQ, "Find-Q", sizeof(UINT32), 2) == OSR_OK);
    }
    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hDataMsgQ)
    {
        VERIFY(x_msg_q_create(&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hDataMsgQ, "Data-Q", sizeof(UINT32), 2) == OSR_OK);
    }
    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hFindTimer)
    {
        VERIFY(x_timer_create(&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hFindTimer) == OSR_OK);
    }
    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hDataTimer)
    {
        VERIFY(x_timer_create(&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hDataTimer) == OSR_OK);
    }
}

VOID _SWDMX_MpgDeleteFindSema(UINT8 u1SrcId)
{

    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hFindMsgQ)
    {
        VERIFY(x_msg_q_delete(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hFindMsgQ) == OSR_OK);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hFindMsgQ = 0;
    }
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hDataMsgQ)
    {
        VERIFY(x_msg_q_delete(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hDataMsgQ) == OSR_OK);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hDataMsgQ = 0;
    }
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hFindTimer)
    {
        VERIFY(x_timer_delete(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hFindTimer) == OSR_OK);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hFindTimer = 0;
    }
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hDataTimer)
    {
        VERIFY(x_timer_delete(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hDataTimer) == OSR_OK);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hDataTimer = 0;
    }
}
#endif

VOID _SWDMX_MpgDetectStrmChgInfo(UINT8 u1SrcId)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);
  
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgNotifyAllAudPid)
    {
        UINT32 i,j;
        DMX_MM_T rPid;
        MM_GNRC_STREAM_T t_gnrc_stream;
        SWDMX_AUDIO_STREAM_T *ptAudioStream = &prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.t_audio_stream_info;
        SWDMX_VIDEO_STREAM_T *ptVideoStream = &prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.t_video_stream_info;
        x_memset((void*)&t_gnrc_stream,0x0,sizeof(MM_GNRC_STREAM_T));
        x_memcpy((void*)&t_gnrc_stream,(void*)&gt_gnrc_stream,sizeof(MM_GNRC_STREAM_T));
        LOG(1,"receive  notify audio pid\n");
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgNotifyAllAudPid = FALSE;
      
        if ( ptAudioStream->u4_audio_pid_num >= 1)  // during playback, updated pmt
        {
            UINT8 u1PidxAudio = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio;
            if (u1PidxAudio != 0xFF && !t_gnrc_stream.fg_aud_exist)
            {
                if (_SWDMX_MpgTsFreeAudioId(u1SrcId))
                {
                    DMX_MUL_FreePidx(u1PidxAudio);
                }               
            }
            
            if(prSwdmxInst->fgEnablePrebuffer)
            {
                if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnADmx)
                {
                  /* release prebuffer */
                  rPid.fgEnable = FALSE;
                  ptAudioStream = &prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.t_audio_stream_info;
                  for (i = 0; i < ptAudioStream->u4_audio_pid_num; i++)
                  {
                      LOG(5,"Pidx %d\n",ptAudioStream->t_audio_stream[i].u1Pidx);
                      
                      VERIFY(DMX_MM_Set(ptAudioStream->t_audio_stream[i].u1Pidx,
                                        DMX_MM_FLAG_VALID, &rPid));
                      DMX_MM_Free(ptAudioStream->t_audio_stream[i].u1Pidx);
                      DMX_MUL_FreePidx( ptAudioStream->t_audio_stream[i].u1Pidx);
                      DMX_AudHandler_Free(ptAudioStream->t_audio_stream[i].u1Pidx);
                      LOG(5,"Free Prebuffer Pidx %d stream id %d\n",
                          ptAudioStream->t_audio_stream[i].u1Pidx,
                          ptAudioStream->t_audio_stream[i].u2StreamId);
                  }
                  DMX_AudHandler_SetEnable(FALSE);
                  DMX_AudHandler_SetActivePidx(DMX_AUDIO_HANDLER_NULL_PIDX);                              
                  prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSetActivePid = FALSE;                  
                }


            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnADmx = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgPMTChanged = TRUE;
			if(t_gnrc_stream.ui2_video_pid_num > 0)
			{
            	prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidOn = FALSE;
			}
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudOn = FALSE;     
            
            for (i = 0;i < t_gnrc_stream.ui2_video_pid_num;i++)
            {
                for (j = 0;j< ptVideoStream->u4_video_pid_num; j++)
                {
                    if (ptVideoStream->t_video_stream[j].u2StreamId == t_gnrc_stream.at_video_list[i].ui2_video_pid)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidOn = TRUE;
                        LOG(5,"video pid not change,pid %d \n",ptVideoStream->t_video_stream[j].u2StreamId);
                        break;
                    }
                }                
            }
            for (i = 0;i < t_gnrc_stream.ui2_audio_pid_num;i++)
            {
                for (j = 0;j< ptAudioStream->u4_audio_pid_num; j++)
                {
                    if (ptAudioStream->t_audio_stream[j].u2StreamId == t_gnrc_stream.at_audio_list[i].ui2_audio_pid)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudOn = TRUE;
                        LOG(5,"audio pid not change,pid %d \n",ptAudioStream->t_audio_stream[j].u2StreamId);
                        break;
                    }
                }
            }            
        }
        ptAudioStream->u4_audio_pid_num = t_gnrc_stream.ui2_audio_pid_num;
        ptVideoStream->u4_video_pid_num =  t_gnrc_stream.ui2_video_pid_num;
      
      if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type == MM_SRC_TYPE_HIGH_SPEED_STORAGE ) ||
	  	  (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type == MM_SRC_TYPE_NETWORK_CMPB ))
      {
      for (i = 0;i < t_gnrc_stream.ui2_audio_pid_num; i++)
      {
        ptAudioStream->t_audio_stream[i].u2StreamId    = t_gnrc_stream.at_audio_list[i].ui2_audio_pid;
                        
        ptAudioStream->t_audio_stream[i].e_aud_dec_fmt = 
            _SWDMX_MpgAudCodecConvert(t_gnrc_stream.at_audio_list[i].e_aud_dec_fmt);
            
        LOG(5,"stream[%d].streamid %d aud dec fmt (%d in mw) (%d in swdmx)\n",
            i,
            ptAudioStream->t_audio_stream[i].u2StreamId,
            t_gnrc_stream.at_audio_list[i].e_aud_dec_fmt,
            ptAudioStream->t_audio_stream[i].e_aud_dec_fmt);
      }      
            for (i = 0;i < t_gnrc_stream.ui2_video_pid_num; i++)
            {
                ptVideoStream->t_video_stream[i].u2StreamId = t_gnrc_stream.at_video_list[i].ui2_video_pid;
                LOG(5,"video stream[%d].streamid %d\n",i,ptVideoStream->t_video_stream[i].u2StreamId);
            }     
      
      if ((ptAudioStream->u4_audio_pid_num > 1) &&
              (!t_gnrc_stream.fg_enable_ad))
      {    
          prSwdmxInst->fgEnablePrebuffer = TRUE;
          
          for(i = 0;i < ptAudioStream->u4_audio_pid_num;i++)
          {
              for(j=i+1;j < ptAudioStream->u4_audio_pid_num;j++)
              {
                  if (ptAudioStream->t_audio_stream[i].u2StreamId == ptAudioStream->t_audio_stream[j].u2StreamId)
                  {
                      prSwdmxInst->fgEnablePrebuffer = FALSE;
                      LOG(5,"audio pids are same!!,so disable prebuffer\n");
                      break;
                  }
              }
          }           
      }
      else
      {
	      	if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed == 1000)
		    {
		        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2AudioId = ptAudioStream->t_audio_stream[0].u2StreamId;                
		    }
	      	prSwdmxInst->eAudioType = ptAudioStream->t_audio_stream[0].e_aud_dec_fmt;
		  
	      	prSwdmxInst->fgEnablePrebuffer = FALSE;

			if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type  == MM_SRC_TYPE_NETWORK_CMPB)	
			{
			    if(90000 <= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime )
			    {
			    	UINT32  u4AudioTmpThreshold = 0;
					UINT64  u8Remainder = 0;
					
			        u4AudioTmpThreshold = _SWDMX_Div6464(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize, 
			                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime/90000, &u8Remainder);

					LOG(5,"u4AudioTmpThreshold %d\n",u4AudioTmpThreshold);
			        
					if (u4AudioTmpThreshold < AVG_BIT_RATE_THRESHOLD) 
					    
					{
			            prSwdmxInst->fgEnablePrebuffer = TRUE;
					}		
			    }						
				
			}			
		  
    	}
        /* for debug ,if audio dec fmt is lpcm ,can not enable this flag */
          if (PREBUFFER_FORCE_ENABLE == prSwdmxInst->ui8ForceEnablePrebuffer)
          {
          prSwdmxInst->fgEnablePrebuffer = TRUE;
          }
          else if (PREBUFFER_FORCE_DISABLE == prSwdmxInst->ui8ForceEnablePrebuffer)
          {
          prSwdmxInst->fgEnablePrebuffer = FALSE;
          }
            if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgPMTChanged)
            {
                LOG(5,"pat/pmt changed ,again config afifo\n");
                if(!_SWDMX_MpgInitDmx(u1SrcId,eSWDMX_STRM_TYPE_AUD))
                {
                    LOG(0,"Mpg init audio pid index fail\n");
                }  
                
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnADmx = TRUE;                
            }
           
        }
        
    }
        
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgDisableVideo)
    {
        LOG(5,"disable video\n");
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgDisableVideo = FALSE;
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgChangeVideo = TRUE;
            prSwdmxInst->u2VideoThreshold = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo = FALSE;     

#ifdef HANDLE_CODEC_PID_CHG 
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
    {
      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgDisableTriggerErrHdlr = TRUE;
    }
#endif
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4DeltaVideoPTS = 0;

            if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo != 0xFF)
            {
                if(IS_TS_FILE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
                {
                    _SWDMX_DmxUpdatePid(u1SrcId,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo,
                            0x1FFF); //0x1FFF empty packet
                }                
            }            
        }
#ifdef HANDLE_CODEC_PID_CHG   
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgDisableStrm = TRUE;
#endif
    }
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgDisableVideo2)
    {
        LOG(5,"disable video2\n");
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgDisableVideo2 = FALSE;   
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo2)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo2 = FALSE;
            
            if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo2 != 0xFF)
            {
                if(IS_TS_FILE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
                {
                    _SWDMX_DmxUpdatePid(u1SrcId,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo2,
                            0x1FFF); //0x1FFF empty packet
                }                
            }
            
        }        
    }    
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgDisableAudio)
    {
        LOG(5,"disable audio\n");
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgDisableAudio = FALSE; 
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
        {            
            prSwdmxInst->u4AudioThreshold = 0;
            prSwdmxInst->u4PreAudUnderFlowCnt = 0;

#ifdef HANDLE_CODEC_PID_CHG 
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
    {
      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgDisableTriggerErrHdlr = TRUE;
    }
#endif
            
            //DTV00091703 when play to the end of the file, audio EOS has been sent by swdmx, but audio drv has 
            //not notify mw, at this time change audio trick, will cause playback hang (swmdx can't send eos again) 
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos)
            {              
              prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = FALSE;
            }

            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetFirstAudPts = FALSE;    //DTV00093908
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4GetFirstAudioPTS = 0;     
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS = 0; 
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4DeltaAudioPTS = 0;
#ifdef HANDLE_PTS_SKIP
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1SkipPts = NO_SKIP_PTS;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4VBaseSkipPts = 0;      
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4ABaseSkipPts = 0;  
#endif 
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio = FALSE;                
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio = FALSE;

#ifdef HANDLE_CODEC_PID_CHG
      if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFlushVidData == TRUE)
      {
         LOG(1, "BINGO cannot flush video if audio is not available\n");
         prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFlushVidData = FALSE;
      }
#endif
            
      if(prSwdmxInst->fgEnablePrebuffer)      
      {
        DMX_AudHandler_SetActivePidx(DMX_AUDIO_HANDLER_NULL_PIDX);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSetActivePid = FALSE;
      }
      else
      {
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio != 0xFF)
                {
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioWptr != 0)
                    {
                        BOOL fgRet1;
                        fgRet1 = DMX_UpdateReadPointer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio, 
                                                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioWptr, 
                                                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioWptr);
                        if(!fgRet1)
                        {
                            LOG(5, "_SWDMX_MpgDisableStrm DMX_UpdateReadPointer Fail\n");
                        }
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioWptr = 0;
                    }
                    UNUSED(DMX_MM_FlushBuffer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio));

                    if(IS_TS_FILE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
                    {
                        _SWDMX_DmxUpdatePid(u1SrcId,
                                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio,
                                0x1FFF); //0x1FFF empty packet
                    }
                }
          
      }
            LOG(3,"Disable Cur Prebuffer\n");                
        }        
#ifdef HANDLE_CODEC_PID_CHG   
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgDisableStrm = TRUE;
#endif
  }   
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgDisableAudio2)
    {
        LOG(5,"disable audio2\n");    
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetFirstAudPts = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4GetFirstAudioPTS = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgDisableAudio2 = FALSE;
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio2)
      {
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio2Eos)
            {              
              prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio2Eos = FALSE;
            }

            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio2 = FALSE;                
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio2 = FALSE;
            _SWDMX_MpgFlushAFifo2(u1SrcId);
            DMX_MM_FlushBuffer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2);
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2 != 0xFF)
            {
                if(IS_TS_FILE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
                {
                    _SWDMX_DmxUpdatePid(u1SrcId,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2,
                            0x1FFF); //0x1FFF empty packet
                }                
            }
            
        }
        
    }    
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgDisableAudio3)
    {
        LOG(5,"disable audio3\n");    
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgDisableAudio3 = FALSE;
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio3)
      {
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio3Eos)
            {              
              prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio3Eos = FALSE;
            }

            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio3 = FALSE;                
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio3 = FALSE;
            
            _SWDMX_MpgFlushAFifo3(u1SrcId);
            DMX_MM_FlushBuffer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3);
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3 != 0xFF)
            {
                if(IS_TS_FILE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
                {
                    _SWDMX_DmxUpdatePid(u1SrcId,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3,
                            0x1FFF); //0x1FFF empty packet
                }                
            }            
        }        
    }    
    
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnableVideo)
    {
        LOG(5,"enable video pid %d\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2VideoId);    
        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnableVideo = FALSE;
        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgPMTChanged)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidOn = TRUE;  
        }
        if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendSeqHdr = FALSE;
#ifdef SWDMX_MPG_VC1_SUPPORT
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendSeqHdrVc1 = FALSE;
#endif
            // when current is not 1x
            // force to jump next position
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpping)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext = TRUE;
            }
            if(IS_TS_FILE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_AVS_VIDEO_ES) ||
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT) ||
               IS_PUSH_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type))
            {
                // We can't change file position on TS file
                if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo != 0xFF)
                {
                    _SWDMX_DmxUpdatePid(u1SrcId,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2VideoId);                    
                }                
            }

            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgHaveVideoData = FALSE;           
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidPidChg = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudPidChg = FALSE;                
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdVidId  = 0xFFFF;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdAudId  = 0xFFFF; 
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidCodecChg = FALSE; 
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudCodecChg = FALSE; 
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4DmxPreviousAvailSizeVideo = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4DmxPreviousAvailSizeAudio = 0;                    
            prSwdmxInst->eUpdVideoType = ENUM_SWDMX_VDEC_UNKNOWN;
            prSwdmxInst->eUpdAudioType = ENUM_SWDMX_ADEC_UNKNOWN;                           
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideoReady = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurABasePTS = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurVBasePTS = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ShakeTime = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo = TRUE;
        }        
#ifdef HANDLE_CODEC_PID_CHG 
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192 &&
      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgDisableStrm)
    {
      LOG(5,"SWDMX reEnable video!\n");       
      if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
      {
        LOG(0,"%s:renable video and flush aud data\n",__FUNCTION__);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFlushAudData = TRUE;
      }
      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = FALSE;
      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = FALSE;
      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio = FALSE;
      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = FALSE;
      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgDisableStrm = FALSE;
    }
#endif
    }
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnableVideo2)
    {
        LOG(5,"enable video2 pid %d\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2Video2Id);  
        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnableVideo2 = FALSE; 
        if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo2)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo2 = TRUE;
            if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo2 != 0xFF)
            {
                _SWDMX_DmxUpdatePid(u1SrcId,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo2,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2Video2Id);                    
            }             
        }    
    }
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnableAudio)
    {
        LOG(5,"enable audio pid %d\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2AudioId);  
        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnableAudio = FALSE;
        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgPMTChanged)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudOn = TRUE;  
        }        
        if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
        {
      UINT32 i;
      SWDMX_AUDIO_STREAM_T *ptAudioStreamInfo = NULL;
      
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X == 0)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = FALSE;
#ifdef SWDMX_MPG_CHECK_MP3_AUDIO
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4Mp3Cnt = 0;
#endif
            if(!prSwdmxInst->fgEnablePrebuffer)
            {
                if(IS_TS_FILE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
                {
                    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio != 0xFF)
                    {
                        _SWDMX_DmxUpdatePid(u1SrcId,
                                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio,
                                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2AudioId);                        
                    }
                }
            }
            else
            {
                ptAudioStreamInfo = &prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.t_audio_stream_info;
                
                for ( i = 0; (i < ptAudioStreamInfo->u4_audio_pid_num) && (i < MAX_SWDMX_PID_INDEX); i++)
                {
                    if (ptAudioStreamInfo->t_audio_stream[i].u2StreamId == 
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2AudioId)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1CurATrackIdx = i;
                        LOG(5, "Cur Track Idx Changed %d\n", i);
              break;
                    }
                }

				if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgPendingATrackIdx == TRUE) && 
						(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed == 1000) &&
						(ptAudioStreamInfo->u4_audio_pid_num > 0))
				{
					LOG(1,"%s:there's pending active idx need to be update pid %u pid index%u\n",__FUNCTION__,
						ptAudioStreamInfo->t_audio_stream[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1CurATrackIdx].u1Pidx,
						prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1CurATrackIdx);
					DMX_AudHandler_SetActivePidx(ptAudioStreamInfo->t_audio_stream[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1CurATrackIdx].u1Pidx); 
	        		prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSetActivePid = TRUE;
					prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgPendingATrackIdx = FALSE;
                }  
            }
            
      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio = TRUE;    
        }

#ifdef HANDLE_CODEC_PID_CHG   
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgDisableStrm)
    {
      LOG(0,"reEnable audio and flush video data!\n");     
      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgDisableStrm = FALSE;
      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFlushVidData = TRUE;
    }
#endif
    }
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnableAudio2)
    {
        LOG(5,"enable audio2 pid %d\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2Audio2Id);   
        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnableAudio2 = FALSE;
        if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio2)
        {
      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = FALSE;
      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = FALSE;
          prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio2 = FALSE;
          prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio2Eos = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio2 = TRUE;   
            if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2 != 0xFF)
            {
                _SWDMX_DmxUpdatePid(u1SrcId,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2Audio2Id);                    
            }              
            
        }
    }
  if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnableAudio3)
  {
        LOG(5,"enable audio3 pid %d\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2Audio3Id);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnableAudio3 = FALSE;
        if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio3)
        {
          prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio3 = FALSE;
          prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio3Eos = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio3 = TRUE;       
            if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3 != 0xFF)
            {
                _SWDMX_DmxUpdatePid(u1SrcId,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2Audio3Id);                    
            } 
        }       
  }     
  
}

VOID _SWDMX_MpgFlushPreBuffer(UINT8 u1SrcId)
{
    UINT32 i;
  SWDMX_AUDIO_STREAM_T *ptAudioStreamInfo = NULL;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);
    if(prSwdmxInst->fgEnablePrebuffer)
    {
        ptAudioStreamInfo = &prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.t_audio_stream_info;
        for (i = 0; i < ptAudioStreamInfo->u4_audio_pid_num; i++)
        {
            LOG(5,"flush prebuffer pidx %d\n",ptAudioStreamInfo->t_audio_stream[i].u1Pidx);
            DMX_MM_FlushBuffer(ptAudioStreamInfo->t_audio_stream[i].u1Pidx);
        }
    }

}

VOID _SWDMX_MpgFlushVFifo(UINT8 u1SrcId)
{
    BOOL fgRet;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo != 0xFF)
    {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoWptr != 0)
        {
            fgRet = DMX_UpdateReadPointer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoWptr, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoWptr);
            if(!fgRet)
            {
                LOG(5, "_SWDMX_MpgFlushVFifo DMX_UpdateReadPointer Fail\n");
            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoWptr = 0;
        }
    }

#ifdef SWDMX_RVU_PARSE_PTS
    if ( (SWDMX_FMT_MPEG2_TS_130 == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
         (SWDMX_FMT_MPEG2_TS_134 == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) )
    {
        _SWDMX_MpgTs130Reset(u1SrcId);
    }
#endif

    return ;
}

VOID _SWDMX_MpgFlushVFifo2(UINT8 u1SrcId)
{
    BOOL fgRet;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo2 != 0xFF)
    {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideo2Wptr != 0)
        {
            fgRet = DMX_UpdateReadPointer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo2, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideo2Wptr, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideo2Wptr);
            if(!fgRet)
            {
                LOG(5, "_SWDMX_MpgFlushVFifo2 DMX_UpdateReadPointer Fail\n");
            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideo2Wptr = 0;
        }
    }

#ifdef SWDMX_RVU_PARSE_PTS
    if ( (SWDMX_FMT_MPEG2_TS_130 == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
         (SWDMX_FMT_MPEG2_TS_134 == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) )
    {
        _SWDMX_MpgTs130Reset(u1SrcId);
    }
#endif

    return ;
}

VOID _SWDMX_MpgFlushAFifo(UINT8 u1SrcId)
{
    BOOL fgRet;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio != 0xFF)
    {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioWptr != 0)
        {
            fgRet = DMX_UpdateReadPointer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioWptr, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioWptr);
            if(!fgRet)
            {
                LOG(5, "_SWDMX_MpgFlushAFifo DMX_UpdateReadPointer Fail\n");
            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioWptr = 0;
        }
    }
}
// 0831
VOID _SWDMX_MpgFlushAFifo2(UINT8 u1SrcId)
{
    BOOL fgRet;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2 != 0xFF)
    {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio2Wptr != 0)
        {
            fgRet = DMX_UpdateReadPointer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio2Wptr, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio2Wptr);
            if(!fgRet)
            {
                LOG(5, "_SWDMX_MpgFlushAFifo DMX_UpdateReadPointer Fail\n");
            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio2Wptr = 0;
        }
    }
}

// 0831
VOID _SWDMX_MpgFlushAFifo3(UINT8 u1SrcId)
{
    BOOL fgRet;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3 != 0xFF)
    {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio3Wptr != 0)
        {
            fgRet = DMX_UpdateReadPointer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio3Wptr, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio3Wptr);
            if(!fgRet)
            {
                LOG(5, "_SWDMX_MpgFlushAFifo DMX_UpdateReadPointer Fail\n");
            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio3Wptr = 0;
        }
    }
}

BOOL _SWDMX_MpgWatchDuration(UINT8 u1SrcId, UINT32 u4CurentTime)
{
    UINT32 u4FilteredTime;
    UINT32 u4NewTotalTime;
    UINT64 u8NewTotalTime;
    UINT64 u8Remainder;

    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    u4FilteredTime = _SWDMX_MpgWatchLastPTS(u1SrcId, 0xFF, (u4CurentTime + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS));
    u4FilteredTime -= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS;
    // be careful with u4FilteredTime when it is closed to u4TotalTime
    // add 10 second time for monitor
    if((u4FilteredTime >
        ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTimeOffset) + (10*90000))) &&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize > 0))
    {
        u8NewTotalTime = _SWDMX_Div6464((UINT64)(u4FilteredTime+1), prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize, &u8Remainder);
        u8NewTotalTime = u8NewTotalTime * (UINT64)(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset);
        u8NewTotalTime *= 90;
        u8NewTotalTime = _SWDMX_Div6464(u8NewTotalTime, (UINT64)100, &u8Remainder);
        if(u8NewTotalTime < (UINT64)0xFFFFFFFF)
        {
            u4NewTotalTime = (UINT32)u8NewTotalTime;
            if(u4NewTotalTime > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTimeOffset = (u4NewTotalTime - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime);
                LOG(3, "_SWDMX_MpgWatchDuration u4TotalTimeOffset %d\n",
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTimeOffset);
            }
        }
    }

    return TRUE;
}


UINT32 _SWDMX_MpgWatchLastPTS(UINT8 u1SrcId, UINT32 u4Type, UINT32 u4Pts)
{
    UINT32 i;
    UINT32 u4Temp = 0;
    UINT32 u4Big = 0;
    UINT32 u4Small = 0;
    UINT32 u4RetPts = u4Pts;
    UINT64 u8Temp = 0;
    UINT64 u8Remainder;

    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
    //if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToDecoder)
    // DTV00210035, There is two wrong PTS around 10 sec in this clip.
    // pre-parsing case and normal all use this filter
    {
        // Handle some unexpect PTS
        u8Temp = 0;
        u4Temp = 0;
        u4Big = 0;
        u4Small = 0xFFFFFFFF;
        for(i=0;i<MPG_PTS_CHECK_NUM;i++)
        {
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.au4LastPTS[i] != 0)
            {
                if(u4Big < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.au4LastPTS[i])
                {
                    u4Big = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.au4LastPTS[i];
                }
                if(u4Small > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.au4LastPTS[i])
                {
                    u4Small = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.au4LastPTS[i];
                }
            }
        }
        for(i=0;i<(MPG_PTS_CHECK_NUM-1);i++)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.au4LastPTS[i] =
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.au4LastPTS[i+1];
            if(u4Big == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.au4LastPTS[i])
            {
                continue;
            }
            if(u4Small == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.au4LastPTS[i])
            {
                continue;
            }
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.au4LastPTS[i] != 0)
            {
                u8Temp += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.au4LastPTS[i];
                u4Temp++;
            }
        }
        // we don't record non a/v PTS.
        if(u4Type != 0xFF)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.au4LastPTS[MPG_PTS_CHECK_NUM-1] = u4Pts;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTSCnt++;
        }
        if(u4Temp > 0)
        {
            u8Temp = _SWDMX_Div6464(u8Temp, (UINT64)u4Temp, &u8Remainder);
            u4Temp = (UINT32)u8Temp;
            if(u4Pts > u4Temp)
            {
                if((u4Pts - u4Temp) > (5*90000*MPG_PTS_CHECK_NUM))
                {
                    LOG(1, "_SWDMX_MpgWatchLastPTS u4Type %d, u4PTS %d -> %d\n",
                        u4Type, u4Pts, u4Temp);
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToDecoder)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS = u4Temp;
                    }
                    if(u4Type != 0xFF)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.au4LastPTS[i] = u4Temp;
                    }
                    u4RetPts = u4Temp;
                }
            }
            else
            {
                if((u4Temp - u4Pts) > (5*90000*MPG_PTS_CHECK_NUM))
                {
                    LOG(1, "_SWDMX_MpgWatchLastPTS u4Type %d, u4PTS %d -> %d\n",
                        u4Type, u4Pts, u4Temp);
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToDecoder)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS = u4Temp;
                    }
                    if(u4Type != 0xFF)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.au4LastPTS[i] = u4Temp;
                    }
                    u4RetPts = u4Temp;
                }
            }
        }
    }
    return u4RetPts;
}

inline static BOOL _SWDMX_MpgTo27KBasedTimestamp( UINT8 u1SrcId,
                                                                  const UINT32 u4TimeStampIn,
                                                                  UINT32 *pu4TimeStampOut)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if (NULL == pu4TimeStampOut)
    {
        LOG(1, "Null Pointer... ...\n");
        return FALSE;
    }

#define SWDMX_MPG_27M_DIV_90K_VALUE     300

    *pu4TimeStampOut = u4TimeStampIn;
    
    if ((SWDMX_FMT_MPEG2_TS_130 == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
        (SWDMX_FMT_MPEG2_TS_134 == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) )
    {
        // For RVU, the PTS&DTS is 27M based, align to 27K based value
        if (u4TimeStampIn>0 && u4TimeStampIn<SWDMX_MPG_27M_DIV_90K_VALUE)
        {
            *pu4TimeStampOut = 1; 
        }
        else
        {
             *pu4TimeStampOut /= SWDMX_MPG_27M_DIV_90K_VALUE;
        }
    }

    return TRUE;
}

BOOL _SWDMX_MpgWatchVideoPTS(UINT8 u1SrcId, const DMX_PES_MSG_T* prPes)
{
    UINT32 u4Temp = 0;
    UINT32 u4PTS = 0;
    
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if(prPes == NULL)
    {
        LOG(1, "_SWDMX_MpgWatchVideoPTS prPes NULL\n");
        return FALSE;
    }

    UNUSED (_SWDMX_MpgTo27KBasedTimestamp(u1SrcId, prPes->u4Pts, &u4PTS));
    
    if ((prPes->fgPtsDts) && (u4PTS > 0))
    {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS == 0)
        {
            LOG(0,"%s:get first pts %u\n",__FUNCTION__,u4PTS);
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS = u4PTS;

            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type ==
                MM_SRC_TYPE_NETWORK_VUDU) ||
               IS_PUSH_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type))
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS = MPG_STC_BASE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS = MPG_STC_BASE;
            }

#ifdef TIME_SHIFT_SUPPORT
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT) &&
               (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetInfo))
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS = MPG_STC_BASE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS = MPG_STC_BASE;
            }
#endif
            LOG(5, "_SWDMX_MpgWatchVideoPTS u4FirstPTS 0x%x\n"
                , prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS);
        }
        else
        {
            if((u4PTS < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) &&
                ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS - u4PTS) < (8*90000)))
            {
                // only consider PTS in same GOP.
                // First PTS might be I frame's PTS.
                // current one might be PTS of B frame before I frame.
                // temp reference max is 255
                // 255 / 30 -> 9 second.
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS = u4PTS;
            }
        }

        if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = TRUE;
            LOG(5, "_SWDMX_MpgWatchVideoPTS fgSetStc\n");

            if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToDecoder)
            {
                //DTV00144863 When time shift for audio only file
                //no place to resume STC, so we can't stop stc
                LOG(3, "_SWDMX_MpgWatchVideoPTS STC_SetStcValue 0x%x\n",
                    ((u4PTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + MPG_STC_BASE));

                STC_StopStc(prSwdmxInst->u1StcId);
                // When there is video stream, stc value will set at vdec_flw.c
                if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
                {
                    u4Temp = STC_GetStcValue(prSwdmxInst->u1StcId);
                    STC_SetStcValue(prSwdmxInst->u1StcId, (UINT32)((u4PTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + MPG_STC_BASE));
                    u4Temp = STC_GetStcValue(prSwdmxInst->u1StcId);
                    if (u4Temp != (UINT32)((u4PTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + MPG_STC_BASE))
                    {
                        LOG(3, "_SWDMX_MpgWatchVideoPTS STC_SetStcValue Fail\n");
                        //return FALSE;
                    }
                }

                // do on vdec_flw.c
                //STC_StartStc(prSwdmxInst->u1StcId);
            }
        }

        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
        {
            UNUSED(_SWDMX_MpgWatchLastPTS(u1SrcId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo, u4PTS));
        }

        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT) && 
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_ENCRYPT_192))
        {
            // DTV00210035, two wrong audio PTS. We should not update duration
            //firstPTS=0x8ca9,LastPTS=0xcb139
            //audio PTS=0x3e4cc936
            //audio PTS=0x3e4cc936
            if(((u4PTS > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS) && ((u4PTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS) < (600*90000)))||
               ((u4PTS < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS) && ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - u4PTS) < (600*90000))))
            {
                if(u4PTS >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS)
                {
                    UNUSED(_SWDMX_MpgWatchDuration(u1SrcId, u4PTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS));
                }
            }
        }

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS = u4PTS;
    }

    if (((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
        (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK)) &&
        (prPes->u1Channel == prSwdmxInst->u1Vdec2Id))
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideo2Wptr = prPes->u4FrameAddr;
    }
    else
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoWptr = prPes->u4FrameAddr;
    }

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicCnt++;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgPesFound = TRUE;
    #if 0
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicCnt%150)
    {
        LOG(6, "_SWDMX_MpgWatchVideoPTS u4PicCnt 150\n");
    }
    #endif

    return TRUE;
}

BOOL _SWDMX_MpgWatchAudioPTS(UINT8 u1SrcId, const DMX_AUDIO_PES_T* prPes)
{
    UINT32 u4PTS = 0;
    UINT32 u4Temp;
    UINT32 u4DmxAvailSize;
    UINT32 u4DmxAvailSizeAudio;
#ifdef SUPPORT_CIPLUS_RECORD
    UINT32 u4RetentionTime;
#endif
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if(prPes == NULL)
    {
        LOG(1, "_SWDMX_MpgWatchAudioPTS prPes NULL\n");
        return FALSE;
    }
#ifdef SUPPORT_CIPLUS_RECORD
    if(prSwdmxInst->rCurRangeReq.prDmxRangeInfo == NULL)
    {
        u4RetentionTime = (UINT32)0xFFFFFFFF;
    }
    else
    {
        u4RetentionTime = prSwdmxInst->rCurRangeReq.prDmxRangeInfo->ui4_rl_time;
    }
#endif
    UNUSED (_SWDMX_MpgTo27KBasedTimestamp(u1SrcId, prPes->u4Pts, &u4PTS));
    
/*
    Can't hear the first second sound in Pandora.
    root cause:
    Playback skip audio data which pts is 0 in the begining of stream.
    Originaly playback does lip sync, so it waits valid (!= 0) audio pts.
    However this is not necessary for Pandora.

    Solution:
    Playback pass the whole audio data to audio driver.
*/
    if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio)&&
       (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)&&
       (u4PTS == 0)&&
       ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type ==
         MM_SRC_TYPE_NETWORK_VUDU) ||
        IS_PUSH_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type)))
    {
        u4PTS = (MPG_STC_BASE);
    }
#ifdef MPG_PUSH_REAL  
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type ==
         MM_SRC_TYPE_NETWORK_MPEG_REAL_PUSH)
    {
        if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio)
        {
            LOG(1, "get audio data\n");
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = TRUE;
            if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS)
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS = MPG_STC_BASE;            
        }
        if(prPes->u4Pts != 0)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS = prPes->u4Pts;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS = prPes->u4Pts;
        }
        return TRUE;
    }
#endif

#ifdef IPTV_FAST_START
    else if(MM_SRC_TYPE_IPTV == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type)
    {
        if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio && prPes->u4Pts)
        {
            LOG(1, "audio(0x%x), video(0x%x), first video(0x%x)\n", prPes->u4Pts,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS);  
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = TRUE;          
        }
        #if 0
        if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio && 
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio &&
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady &&
            (prPes->u4Pts > _u4FirstAudioPts))
        {
            LOG(1, "enable audio\n");
            {
                STC_StartStc(prSwdmxInst->u1StcId);
            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio = TRUE;
            AUD_MMAoutEnable(prSwdmxInst->u1AdecId, TRUE);
        }
        #endif
        
        if (prPes->u4Pts != 0)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS = prPes->u4Pts;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS = prPes->u4Pts;
        }
        
        LOG(2, "888888888 OWP(0x%X) NWP(0x%X)\n", prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioWptr, prPes->u4Wp);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgPesFound = TRUE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioWptr = prPes->u4Wp;
        
        return TRUE;
    }
#endif

    if(u4PTS > 0)
    {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS == 0)
        {
            LOG(0,"%s:get first pts %u\n",__FUNCTION__,u4PTS);
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS = (u4PTS);

            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type ==
                MM_SRC_TYPE_NETWORK_VUDU) ||
               IS_PUSH_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type))
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS = MPG_STC_BASE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS = MPG_STC_BASE;
            }

#ifdef TIME_SHIFT_SUPPORT
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT) &&
               (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetInfo))
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS = MPG_STC_BASE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS = MPG_STC_BASE;
            }
#endif
            // in es file, we never get pts.
            // so assume we already found pts.
            if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS = MPG_STC_BASE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS = MPG_STC_BASE;
                LOG(5, "_SWDMX_MpgWatchAudioPTS u4FirstPTS 0x%x\n",
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS);
            }

            LOG(5, "_SWDMX_MpgWatchAudioPTS u4FirstPTS %d\n",
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS);
        }
        else
        {
            if((u4PTS < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) &&
                ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS - u4PTS) < (8*90000)))
            {
                // only consider PTS in same GOP.
                // First PTS might be I frame's PTS.
                // current one might be PTS of B frame before I frame.
                // temp reference max is 255
                // 255 / 30 -> 9 second.
                //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS = u4PTS;
            }
        }
#ifdef SUPPORT_CIPLUS_RECORD
        // We may drop some audio data
        if ( (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt==SWDMX_FMT_MPEG2_TS_ENCRYPT_192) &&
             (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio) )
        {
            if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AudStartPlayOrgPTS!=0 && u4PTS!=0)
            {
                if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AudStartPlayOrgPTS + 4000 > u4PTS)
                {
                    if (prSwdmxInst->u4LogFilter & check_rl)
                    {
                        LOG(1,"callback audio pts %u not exceed 4000 over u4AudStartPlayOrgPTS %u\n",u4PTS, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AudStartPlayOrgPTS);
                    }
                    return TRUE;
                }
                else
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AudStartPlayOrgPTS = 0;
                }
            }
        }
#endif  

        //DTV00093908
        if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetFirstAudPts)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetFirstAudPts = TRUE;
            //record the first audio pts after reset fgSetStc(for exp:do seek)
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4GetFirstAudioPTS = u4PTS;

            LOG(5, "_SWDMX_MpgWatchAudioPTS fgSetStc GetFirstAudioPTS:0x%x\n",
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4GetFirstAudioPTS);
        }

        if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
        {
            //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = TRUE;
            //record the first audio pts after reset fgSetStc(for exp:do seek)
            //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4GetFirstAudioPTS=u4PTS;

            //LOG(5, "_SWDMX_MpgWatchAudioPTS fgSetStc GetFirstAudioPTS:0x%x\n",
            //    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4GetFirstAudioPTS);

            if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToDecoder)
            {
                LOG(3, "_SWDMX_MpgWatchAudioPTS STC_SetStcValue 0x%x\n",
                    (((u4PTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + MPG_STC_BASE)));

                STC_StopStc(prSwdmxInst->u1StcId);
                // When there is video stream, stc value will set at vdec_flw.c
                if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
                {
                    u4Temp = STC_GetStcValue(prSwdmxInst->u1StcId);
                    STC_SetStcValue(prSwdmxInst->u1StcId, (UINT32)((u4PTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + MPG_STC_BASE));
                    u4Temp = STC_GetStcValue(prSwdmxInst->u1StcId);
                    if (u4Temp != (UINT32)((u4PTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + MPG_STC_BASE))
                    {
                        LOG(3, "_SWDMX_MpgWatchAudioPTS STC_SetStcValue Fail\n");
                        //return FALSE;
                    }
                }

                // do on vdec_flw.c
                //STC_StartStc(prSwdmxInst->u1StcId);
            }
        }

        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
        {
            UNUSED(_SWDMX_MpgWatchLastPTS(u1SrcId,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio, u4PTS));
        }

#ifdef SWDMX_MPG_SYNC_DTV_MODE
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = TRUE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X = 0;

            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS =
                ((u4PTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + (MPG_STC_BASE));
            //VDP_TriggerAudReceive(prSwdmxInst->u1B2rId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS);
            //UNUSED(AUD_SetStartPts(prSwdmxInst->u1AdecId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS));

            //LOG(3, "_SWDMX_MpgWatchAudioPTS AUD_SetStartPts 1 pts 0x%x pos 0x%llx\n",
            //    ((u4PTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + (MPG_STC_BASE)),
            //    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize);
        }
#endif
        //DTV00093908 check 8 second if audio pts still < first video pts, we will start audio for some specail pvr file
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192)&&
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo && (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio)&&
            (((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4GetFirstAudioPTS)&&
          ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4GetFirstAudioPTS)>(90000*8)))||
          ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4GetFirstAudioPTS)&&
          ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4GetFirstAudioPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS)>(90000*8))&&
          prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS != 0 ))&&
          (prPes->u1DeviceId == AUD_DEC_MAIN)
#ifdef HANDLE_CODEC_PID_CHG     
      && (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgDisableTriggerErrHdlr)
#endif
#ifdef SUPPORT_CIPLUS_RECORD
          &&
          u4RetentionTime == 0xFFFFFFFF
#endif
          )
        {        
              prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = TRUE;
              prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = TRUE;
              prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS = (MPG_STC_BASE);
     #ifdef TIME_SHIFT_SUPPORT
               if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
     #endif
             {
                 UNUSED(AUD_SetStartPts(prSwdmxInst->u1AdecId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS));
             }
             if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
               {
                   prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = TRUE;
                   STC_StopStc(prSwdmxInst->u1StcId);
                   // When there is video stream, stc value will set at vdec_flw.c
                   if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
                   {
                        u4Temp = STC_GetStcValue(prSwdmxInst->u1StcId);
                        STC_SetStcValue(prSwdmxInst->u1StcId, (UINT32)((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + MPG_STC_BASE));
                        u4Temp = STC_GetStcValue(prSwdmxInst->u1StcId);
        
                        LOG(3, "_SWDMX_MpgWatchAudioPTS u4DmxAvailSize STC_SetStcValue 0x%x\n",
                              ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + MPG_STC_BASE));
                        if (u4Temp != ((UINT32)((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + MPG_STC_BASE)))
                        {
                            LOG(3, "_SWDMX_MpgWatchAudioPTS STC_SetStcValue Fail\n");
                        }
                   }
               }
               if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
               {
                      //Check in HandleFifoFull
                      //AUD_MMAoutEnable(prSwdmxInst->u1AdecId, TRUE);
                      //STC_StartStc(prSwdmxInst->u1StcId);
               }
               else
               {
                      // if there is no audio PTS in till now,
                      // we use First video PTS as audio's PTS, but not the last one.
                      //VDP_TriggerAudReceive(prSwdmxInst->u1B2rId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS);
              #ifdef TIME_SHIFT_SUPPORT
                      if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
              #endif
                      {
                          VDP_TriggerAudReceive(prSwdmxInst->u1B2rId, MPG_STC_BASE);
                          // do on vdec_flw.c
                          //STC_StartStc(prSwdmxInst->u1StcId);
                      }
               }
        
                LOG(0, "_SWDMX_MpgWatchAudioPTS VDP_TriggerAudReceive due to audio pts check fail\n");
          }

        // DTV00447900 for MHEG5, when scramble video + normal audio, it need play quickly.
        if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type == MM_SRC_TYPE_NETWORK_MHEG5) &&
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoScramble) && 
            (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudioScramble) && 
            (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetKey))
        {
            if (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio)
            {
                AUD_MMAoutEnable(prSwdmxInst->u1AdecId, TRUE);
                STC_StartStc(prSwdmxInst->u1StcId);
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = TRUE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio = TRUE;
                LOG(3,"_swdmx_mpgAudioCallback video scramble & audio not scramble, quick start!\n");
            }
        }
        //DTV00146545, for audio only ts file, if we have get 8sec audio data but still can't get video data, we
        // should set fgGotVideo TRUE, and let audio start
        else if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)&&
            (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo)&&
            (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgHaveVideoData)&&
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS>prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4GetFirstAudioPTS)&&
            ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS-prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4GetFirstAudioPTS)>(90000*8))
#ifdef HANDLE_CODEC_PID_CHG
      && (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgDisableTriggerErrHdlr)
#endif
        )
        {
            VDEC_Notify(prSwdmxInst->u1VdecId,VDEC_DEC_DECODE_NO_DATA);
            //VDEC_Notify(prSwdmxInst->u1VdecId,VDEC_DEC_DECODE_CODEC_NOT_SUPPORT);
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo=TRUE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS=prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SecondVideoPTS=prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS;

            LOG(2,"_swdmx_mpgAudioCallback no video data and set fgGotVideo=TRUE \n");
        }

        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo && (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio))
        {
            BOOL fgEnableAudio = FALSE;
            
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X) &&
               // delay 0.3 second to output audio in time-shfit
               (((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT) &&
                 (u4PTS >= (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS + (30000)))) ||
                ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT) &&
                 (u4PTS >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS) &&
                 (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSeekaud)))
               &&
               // For 2x->1x, we must send audio data after the last PTS
               ((u4PTS >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS)
                ||
                // Error handle for we can't find target the PTS
                ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS - u4PTS) > (90000*10)))
                &&
                // For AD 
                ((prPes->u1DeviceId == AUD_DEC_MAIN) ||(prPes->u1DeviceId == AUD_DEC_AUX)))

            {
                    fgEnableAudio = TRUE;
            }
            else if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT) &&
                     (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSeekaud)&&
                     (u4PTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SeekAudPTS)) // last memory
            {
                fgEnableAudio = TRUE;
            }
            // This is orginal code for trigger audio.
            //if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X) &&
            //    (u4PTS >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS))
            if (fgEnableAudio)        
            {
                BOOL fgOK = TRUE;
        
        if (!NEED_QUICK_START(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type))
        {
                  if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo)
                  {
                      // DTV00140198 [MM]Can't play the video file smoothly after select it to play
                      // when fifo full and video are playing, we have to check current playback time
                      fgOK = FALSE;
                      if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SecondVideoPTS == 0xFFFFFFFF)
                      {
                          prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SecondVideoPTS = (STC_GetStcValue(prSwdmxInst->u1StcId) + 90000 + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS);
                          LOG(3, "_SWDMX_MpgWatchAudioPTS u4SecondVideoPTS 0x%x, Current time 0x%x\n",
                              prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SecondVideoPTS, STC_GetStcValue(prSwdmxInst->u1StcId));
                      }
                      if(u4PTS > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SecondVideoPTS)
                      {
                          fgOK = TRUE;
                      }
                      // DTV00141121, [DLNA] After repeatedly change audio stream, audio doesn't output.
                      // error handle, u4SecondVideoPTS is far from the u4Pts value
                      else if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SecondVideoPTS - u4PTS) > (UINT32)(2*90000))
                      {
                          fgOK = TRUE;
                          LOG(3, "_SWDMX_MpgWatchAudioPTS error handle, ignore u4SecondVideoPTS 0x%x\n",
                              prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SecondVideoPTS);
                      }
                  }         
        }

                if(fgOK && (u4PTS>=prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS ||
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192))
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = TRUE;                    
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCleanAudio = FALSE;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = 0;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X = 0;

                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS =
                        ((u4PTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + (MPG_STC_BASE));
                    #ifdef TIME_SHIFT_SUPPORT
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
                    #endif
                    {
                        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS != 0xFFFFFFFF)
                        {
                            VDP_TriggerAudReceive(prSwdmxInst->u1B2rId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS);
                            UNUSED(AUD_SetStartPts(prSwdmxInst->u1AdecId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS));
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS = 0xFFFFFFFF;
                        }                        

                        LOG(1, "_SWDMX_MpgWatchAudioPTS AUD_SetStartPts 1 pts 0x%x pos 0x%llx\n",
                            ((u4PTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + (MPG_STC_BASE)),
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize);
                            
                        LOG(0, "_SWDMX_MpgWatchAudioPTS AUD_SetStartPts 1 cur pts 0x%x firstpts 0x%x u4FirstVideoPTS 0x%x u4LastVideoPTS 0x%x\n",
                            (u4PTS),prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS);
                    }

                    /*
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = TRUE;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = 0;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X = 0;
                    */
               }
            }
        }
        else if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
        {
            if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = TRUE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS =
                    ((u4PTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + (MPG_STC_BASE));
                #ifdef TIME_SHIFT_SUPPORT
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
                #endif
                {
                    UNUSED(AUD_SetStartPts(prSwdmxInst->u1AdecId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS));
                    //AUD_MMAoutEnable(prSwdmxInst->u1AdecId, TRUE);
                    LOG(3, "_SWDMX_MpgWatchAudioPTS STC_SetStcValue 0x%x\n",
                        ((u4PTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + (MPG_STC_BASE)));

                    //STC_StartStc(prSwdmxInst->u1StcId);
                    LOG(3, "_SWDMX_MpgWatchAudioPTS AUD_SetStartPts 2 pts 0x%x pos 0x%llx\n",
                        ((u4PTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + (MPG_STC_BASE)), prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize);
                }
                //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = TRUE;
            }
        }

        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT) && 
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_ENCRYPT_192))
        {
            // DTV00210035, two wrong audio PTS. We should not update duration
            //firstPTS=0x8ca9,LastPTS=0xcb139
            //audio PTS=0x3e4cc936
            //audio PTS=0x3e4cc936
            if(((u4PTS > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS) && ((u4PTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS) < (600*90000)))||
               ((u4PTS < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS) && ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - u4PTS) < (600*90000))))
            {
                UNUSED(_SWDMX_MpgWatchDuration(u1SrcId, u4PTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS));
            }
        }

        #if 1
        {
            static UINT32 u4Cnt = 0;
            if(((u4Cnt++)%15) == 0)
            {
                LOG(6, "audio u4Pts 0x%x, pos 0x%x\n",
                    ((u4PTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + MPG_STC_BASE),
                    (UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize);
            }
        }
        #else
        LOG(6, "_SWDMX_MpgWatchAudioPTS u4Pts 0x%x\n",
            (u4PTS-prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS));
        #endif
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS = u4PTS;
    }

    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo) && (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio))
    {
        // could be video fifo size

        if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetInfo)
        {
            u4DmxAvailSize = (1024*1024);
            // playbacking, check AV size
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
            {
                #ifdef SWDMX_MPG_DMX_20
                u4DmxAvailSize = DMX_MUL_GetEmptySize(prSwdmxInst->u1DmxId,
                    DMX_PID_TYPE_ES_VIDEO,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo);
                #else
#ifdef CC_DMX_PURE_AUDIO
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
                {
                    u4DmxAvailSize = DMX_MM_GetBufEmptySize(
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo);
                   }
                else
#endif
                {
                    u4DmxAvailSize = DMX_GetMinFreeBufferSize(DMX_PID_TYPE_ES_VIDEO);
                }
                #endif
            }
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio && prPes->u1DeviceId == AUD_DEC_MAIN)
            {
                #ifdef SWDMX_MPG_DMX_20
                u4Temp = DMX_MUL_GetEmptySize(prSwdmxInst->u1DmxId,
                    DMX_PID_TYPE_ES_AUDIO,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio);
                #else
#ifdef CC_DMX_PURE_AUDIO
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
                {
                    u4Temp = DMX_MM_GetBufEmptySize(
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio);
                   }
                else
#endif
                {
                    u4Temp = DMX_GetMinFreeBufferSize(DMX_PID_TYPE_ES_AUDIO);
                }
                #endif

                if(u4DmxAvailSize > u4Temp)
                {
                    u4DmxAvailSize = u4Temp;
                }
            }
            else if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio2 && prPes->u1DeviceId == AUD_DEC_AUX)
            {
                #ifdef SWDMX_MPG_DMX_20
                u4Temp = DMX_MUL_GetEmptySize(prSwdmxInst->u1DmxId,
                    DMX_PID_TYPE_ES_AUDIO,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2);
                #else
#ifdef CC_DMX_PURE_AUDIO
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
                {
                    u4Temp = DMX_MM_GetBufEmptySize(
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2);
                }
                else
#endif
                {
                    u4Temp = DMX_GetMinFreeBufferSize(DMX_PID_TYPE_ES_AUDIO);
                }
                #endif

                if(u4DmxAvailSize > u4Temp)
                {
                    u4DmxAvailSize = u4Temp;
                }    
            }
            else if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio3 && prPes->u1DeviceId == AUD_DEC_THIRD)
            {
                #ifdef SWDMX_MPG_DMX_20
                u4Temp = DMX_MUL_GetEmptySize(prSwdmxInst->u1DmxId,
                    DMX_PID_TYPE_ES_AUDIO,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3);
                #else
#ifdef CC_DMX_PURE_AUDIO
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
                {
                    u4Temp = DMX_MM_GetBufEmptySize(
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3);
                }
                else
#endif
                {
                    u4Temp = DMX_GetMinFreeBufferSize(DMX_PID_TYPE_ES_AUDIO);
                }
                #endif

                if(u4DmxAvailSize > u4Temp)
                {
                    u4DmxAvailSize = u4Temp;
                }    
            }   
            
            // 0831 ?? here is what condition ??            
            if(u4DmxAvailSize < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = TRUE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = TRUE;

                // if there is no audio PTS in till now,
                // we use First video PTS as audio's PTS, but not the last one.
                //AUD_SetStartPts(prSwdmxInst->u1AdecId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS);
                //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS =
                //    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS + (MPG_STC_BASE));
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS = (MPG_STC_BASE);
                #ifdef TIME_SHIFT_SUPPORT
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
                #endif
                {
                    UNUSED(AUD_SetStartPts(prSwdmxInst->u1AdecId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS));
                    LOG(0,"AUD_SetStartPts 1\n");
                }

                if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc) &&
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = TRUE;

                    STC_StopStc(prSwdmxInst->u1StcId);
                    // When there is video stream, stc value will set at vdec_flw.c
                    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
                    {
                        u4Temp = STC_GetStcValue(prSwdmxInst->u1StcId);
                        STC_SetStcValue(prSwdmxInst->u1StcId, (UINT32)((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + MPG_STC_BASE));
                        u4Temp = STC_GetStcValue(prSwdmxInst->u1StcId);

                        LOG(3, "_SWDMX_MpgWatchAudioPTS u4DmxAvailSize STC_SetStcValue 0x%x\n",
                            ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + MPG_STC_BASE));
                        if (u4Temp != ((UINT32)((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + MPG_STC_BASE)))
                        {
                            LOG(3, "_SWDMX_MpgWatchAudioPTS STC_SetStcValue Fail\n");
                        }
                    }
                }
                if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
                {
                    //Check in HandleFifoFull
                    //AUD_MMAoutEnable(prSwdmxInst->u1AdecId, TRUE);
                    //STC_StartStc(prSwdmxInst->u1StcId);
                }
                else
                {
                    // if there is no audio PTS in till now,
                    // we use First video PTS as audio's PTS, but not the last one.
                    //VDP_TriggerAudReceive(prSwdmxInst->u1B2rId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS);
                    #ifdef TIME_SHIFT_SUPPORT
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
                    #endif
                    {
                        VDP_TriggerAudReceive(prSwdmxInst->u1B2rId, MPG_STC_BASE);
                        
                        LOG(0,"trigger audio pts %d\n",MPG_STC_BASE);
                        
                        // do on vdec_flw.c
                        //STC_StartStc(prSwdmxInst->u1StcId);
                    }
                }

                /*
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = TRUE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = TRUE;
                */
                //ASSERT(0);
                LOG(0, "_SWDMX_MpgWatchAudioPTS VDP_TriggerAudReceive due to fifo full");
            }
        }
    }
    else if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
    {
        if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio)
        {
            BOOL fgCheckAudFull=FALSE;
            if (IS_TS_FILE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG1_DAT) ||                 // [DTV00211805]
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_PS) ||                 // for PS, TS file
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192))
                //|| (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES))   //DTV00086567, the first second audio can't output

            {
                u4DmxAvailSize = (1024*1024);
                // playbacking, check AV size
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
                {
                    #ifdef SWDMX_MPG_DMX_20
                    u4DmxAvailSizeAudio = DMX_MUL_GetEmptySize(prSwdmxInst->u1DmxId,
                        DMX_PID_TYPE_ES_AUDIO,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio);
                    #else
#ifdef CC_DMX_PURE_AUDIO
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
                    {
                        u4DmxAvailSizeAudio = DMX_MM_GetBufEmptySize(
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio);
                       }
                    else
#endif
                    {
                        u4DmxAvailSizeAudio = DMX_GetMinFreeBufferSize(DMX_PID_TYPE_ES_AUDIO);
                    }
                    #endif
                    if(u4DmxAvailSize > u4DmxAvailSizeAudio)
                    {
                        u4DmxAvailSize = u4DmxAvailSizeAudio;
                    }
                }
                if(u4DmxAvailSize < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize)         //DTV00212016 check audio fifo is full or not
                {
                    fgCheckAudFull=TRUE;
                }
            }
            else
            {
                fgCheckAudFull=TRUE;          // DTV00140422 audio ES file no needed to check is audio fifo full or not
            }

            if(fgCheckAudFull == TRUE)         //
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = TRUE;

                // if there is no audio PTS in till now,
                // we use First video PTS as audio's PTS, but not the last one.
                //AUD_SetStartPts(prSwdmxInst->u1AdecId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS);
                //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS =
                //    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS + (MPG_STC_BASE));
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS = (MPG_STC_BASE);
                #ifdef TIME_SHIFT_SUPPORT
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
                #endif
                {
                    UNUSED(AUD_SetStartPts(prSwdmxInst->u1AdecId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS));
                    //AUD_MMAoutEnable(prSwdmxInst->u1AdecId, TRUE);
                    LOG(3, "_SWDMX_MpgWatchAudioPTS no V AUD_SetStartPts pts 0x%x pos 0x%llx\n",
                           ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + (MPG_STC_BASE)), prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize);
                    //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = TRUE;
                }

                if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc) &&
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = TRUE;

                    //LOG(3, "_SWDMX_MpgWatchAudioPTS STC_SetStcValue 0x%x\n",
                        //(((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + (MPG_STC_BASE))));
                    LOG(3, "_SWDMX_MpgWatchAudioPTS STC_SetStcValue 0x%x\n",
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS);

                    STC_StopStc(prSwdmxInst->u1StcId);
                    u4Temp = STC_GetStcValue(prSwdmxInst->u1StcId);
                    STC_SetStcValue(prSwdmxInst->u1StcId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS);
                    u4Temp = STC_GetStcValue(prSwdmxInst->u1StcId);

                    if (u4Temp != prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS)
                    {
                        LOG(3, "_SWDMX_MpgWatchAudioPTS STC_SetStcValue Fail\n");
                        //return FALSE;
                    }
                }
            }
            //STC_StartStc(prSwdmxInst->u1StcId);
        }
    }

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgPesFound = TRUE;

    #if 0
    {
        static UINT32 u4Cnt = 0;
        if(((u4Cnt++)%60) == 0)
        {
            LOG(6, "_SWDMX_MpgWatchAudioPTS u4Cnt 60\n");
        }
    }
    #endif

    return TRUE;
}


BOOL _SWDMX_MpgAudioCb(UINT8 u1SrcId, ENUM_SWDMX_AUDIO_NOTIFY_TYPE_T eAudioNotifyType)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if(eAudioNotifyType == ENUM_SWDMX_AUDIO_NOTIFY_DECODE_DONE)
    {
           LOG(1, "audio is ready===========================\n");
           prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = TRUE;          

        #ifdef TIME_SHIFT_SUPPORT
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
        #endif
        {
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideoReady) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo))
            {
                // DTV00134760
                // In this case, because video fifo is full.
                // Video start to play without wait audio ready.
                // So after audio ready, notify aout in first audio PTS.                
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS != 0xFFFFFFFF)
                {
                LOG(3, "trigger audio PTS = 0x%x, STC = 0x%x\n",
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS, 
                    STC_GetStcValue(prSwdmxInst->u1StcId));
                    VDP_TriggerAudReceive(prSwdmxInst->u1B2rId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS);
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS = 0xFFFFFFFF;
                }
            }
            //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = TRUE;
        }
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio &&
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio
#ifdef IPTV_FAST_START
            ||
            (MM_SRC_TYPE_IPTV == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type)
#endif
            ))
        {
            LOG(3, "re-enable audio\n");
            AUD_MMAoutEnable(prSwdmxInst->u1AdecId, TRUE);
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio = TRUE;
        }

        // 0831  ??
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio2)
        {
            LOG(3, "re-enable audio2\n");
            AUD_MMAoutEnable(prSwdmxInst->u1Adec2Id, TRUE);
        }
        
        // 0831  ??
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio3)
        {
            LOG(3, "re-enable audio3\n");
            // now we can not do this, aud do not enable third decoder
            //AUD_MMAoutEnable(prSwdmxInst->u1Adec3Id, TRUE);
        }        
    }
    return TRUE;
}

BOOL _SWDMX_MpgPcrCallBack(UINT8 u1SrcId, UINT32 u4PcrBase)
{
    // because we only have one stc, find the one
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc) &&
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = TRUE;
        STC_StopStc(prSwdmxInst->u1StcId);
        LOG(3, "_SWDMX_MpgPcrCallBack STC_SetStcValue 0x%x\n", (u4PcrBase));
        STC_SetStcValue(prSwdmxInst->u1StcId, (UINT32)(u4PcrBase));
        STC_StartStc(prSwdmxInst->u1StcId);
    }
    return TRUE;
}

#ifdef SWDMX_RVU_PARSE_PTS

#if 0
#define MPG_GET_START_ADDR(x, y, z) ((x+y>=VIRTUAL(z->u4BufEnd)) ? (VIRTUAL(z->u4BufStart)+x+y-VIRTUAL(z->u4BufEnd)) : (x+y))
#else
static inline UINT32  MPG_GET_START_ADDR(UINT32 x, INT32 y, const DMX_PES_MSG_T *prPes)
{
    if (NULL == prPes)
    {
        return 0;
    }
    
    if (0 <= y)
    {
        return ((x+(UINT32)y>=VIRTUAL(prPes->u4BufEnd)) ? 
                (VIRTUAL(prPes->u4BufStart)+x+(UINT32)y-VIRTUAL(prPes->u4BufEnd)) : 
                (x+(UINT32)y));
    }
    else
    {
        UINT32 u4Tmp = -y;
        return ((x-u4Tmp>=VIRTUAL(prPes->u4BufEnd)) ? 
                (VIRTUAL(prPes->u4BufStart)+x-u4Tmp-VIRTUAL(prPes->u4BufEnd)) : 
                (x-u4Tmp));
    }

}
#endif

static VOID _SWDMX_MpgTs130Reset(UINT8 u1SrcId)
{
    if (SWDMX_SOURCE_MAX <= u1SrcId)
    {
        LOG(1, "%s:%u Error Source id(%u)\n", __FUNCTION__, __LINE__, u1SrcId);
        return ;
    }
    
    x_memset(&_arDmxPes[u1SrcId], 0, sizeof(DMX_PES_MSG_T));

    return ;
}

static inline UINT32 _SWDMX_MpgGetDatain(UINT32 u4StartAddr, const DMX_PES_MSG_T * prPes)
{
    UINT32 u4Datain = 0;
    UINT32 u4Cnt = 0;
    UCHAR *puData = (UCHAR *)u4StartAddr;

    // Data Align case
    u4Datain = (UINT32)(*puData);
    for (u4Cnt=1; u4Cnt<4; u4Cnt++)
    {
        puData = (UCHAR *)MPG_GET_START_ADDR(u4StartAddr, (INT32)u4Cnt, prPes);
        u4Datain = u4Datain << 8;
        u4Datain |= (UINT32)(*puData);
    }
    
    #if 0
    u4Datain |= (((UINT32)(*puData)) << 24);
    puData = (CHAR*)MPG_GET_START_ADDR(u4StartAddr, 1, prPes);
    u4Datain |= (((UINT32)(*puData)) << 16);
    puData = (CHAR*)MPG_GET_START_ADDR(u4StartAddr, 1, prPes);
    u4Datain |= (((UINT32)(*puData)) << 8);
    puData = (CHAR*)MPG_GET_START_ADDR(u4StartAddr, 1, prPes);
    u4Datain |= ((UINT32)(*puData));
    #endif
    
    return u4Datain;
}

static UINT32 _SWDMX_MpgSearchStartCode (   UINT16 u2CodeToFind, 
                                                        UINT32 u4StartAddr,      
                                                        const DMX_PES_MSG_T *prPes)
{
    UINT8 u1SrcId = 0;
    UINT32 u4CurAddr = u4StartAddr;
    SWDMX_INFO_T *prSwdmxInst = NULL;

    if (prPes == NULL)
    {
        return 0;
    }
    
    prSwdmxInst = (SWDMX_INFO_T*)(prPes->pvInstanceTag);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
    u1SrcId = prSwdmxInst->u1SwdmxId;

    if ((u4CurAddr<VIRTUAL(prPes->u4BufStart)) || (u4CurAddr>VIRTUAL(prPes->u4BufEnd)))
    {
        LOG(1, "%s(%u):%u Error Start addr.\n",
                __FUNCTION__, u1SrcId, __LINE__);
        return 0;
    }
    
#undef SWDMX_SEARCH_START_CODE_BY_SPEC

#if defined(SWDMX_SEARCH_START_CODE_BY_SPEC)
    ASSERT(0);
#else   // find start code by value
    while ( (MPG_GET_START_ADDR(u4CurAddr, (INT32)3, prPes) != VIRTUAL(prPes->u4FrameAddr)) &&
            (_SWDMX_MpgGetDatain(u4CurAddr++, prPes) != u2CodeToFind) ) 
    {
        // Nothing to do... ... 
    }

    if (_SWDMX_MpgGetDatain(MPG_GET_START_ADDR(u4CurAddr, (INT32)-1, prPes), prPes) == u2CodeToFind)
    {
        u4CurAddr = MPG_GET_START_ADDR(u4CurAddr, (INT32)-1, prPes);
    }
    else
    {
        u4CurAddr = 0;
    }
#endif

    return u4CurAddr;
}

#if defined(CC_TRUSTZONE_SUPPORT) && defined(CC_SVP_SUPPORT)
BOOL _SWDMX_MpgParsingPtsInTrustzone(SWDMX_INFO_T * prSwdmxInst, const DMX_PES_MSG_T * prPes)
{
    UINT8 u1SrcId = 0;
    DMX_PES_MSG_T *pes = NULL;
    SWDMX_TO_TZ_PES_MSG_T tz_pes;
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
    if (prPes == NULL)
    {
        return FALSE;
    }
    u1SrcId = prSwdmxInst->u1SwdmxId;
    
    // 3D or not
    if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
       (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
    {
        pes = &_arDmxPes[prPes->u1Channel];
    }
    else
    {
        pes = &_arDmxPes[0];
    }

    // if Eos flag, just return
    if (prPes->fgEOS)
    {
        pes->fgEOS = TRUE;
        return TRUE;
    }
    
    // first time, just record
    if(!(pes->u4Wp))
    {
        x_memcpy(pes, prPes, sizeof(DMX_PES_MSG_T));
        return FALSE;
    }

    pes->u4Dts = 0;
    pes->u4Pts = 0;
    
    x_memset(&tz_pes,0x0,sizeof(SWDMX_TO_TZ_PES_MSG_T));
    tz_pes.u4BufStart = prPes->u4BufStart;
    tz_pes.u4BufEnd   = prPes->u4BufEnd;
    tz_pes.u4FrameAddr = prPes->u4FrameAddr;  
    tz_pes.u4PrevFrameAddr = pes->u4FrameAddr;  
    tz_pes.u4PrevFrameType = pes->u4FrameType;
    tz_pes.u4Pts = pes->u4Pts;    
    tz_pes.u4Dts = pes->u4Dts;    
    
    TZ_SWDMX_MpgParsingPts((void*)&tz_pes);
    pes->u4Pts = tz_pes.u4Pts;
    pes->u4Dts = tz_pes.u4Dts;
    
    if (pes->u4Dts && pes->u4Pts)
    {
        pes->fgPtsDts = TRUE;
    }

    LOG(6, "TZ :VO(27M Based) PTS(0x%X) DTS(0x%X)\n", pes->u4Pts, pes->u4Dts);
    
    return TRUE;
}
#endif

BOOL _SWDMX_MpgParsingPts(SWDMX_INFO_T * prSwdmxInst, const DMX_PES_MSG_T * prPes)
{
    CHAR  ucType;
    UINT8 u1SrcId = 0;
    UINT8 u1Length = 0;    
    UINT32 u4SkipBits = 0;
    UINT32 u4StartAddr = 0;
    UINT32 u4Datain = 0;
    UINT32 u4Data = 0;
    DMX_PES_MSG_T *pes = NULL;
    
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
    if (prPes == NULL)
    {
        return FALSE;
    }
    
    u1SrcId = prSwdmxInst->u1SwdmxId;
    
    // 3D or not
    if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
       (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
    {
        pes = &_arDmxPes[prPes->u1Channel];
    }
    else
    {
        pes = &_arDmxPes[0];
    }

    // if Eos flag, just return
    if (prPes->fgEOS)
    {
        pes->fgEOS = TRUE;
        return TRUE;
    }
    
    // first time, just record
    if(!(pes->u4Wp))
    {
        x_memcpy(pes, prPes, sizeof(DMX_PES_MSG_T));
        return FALSE;
    }

    pes->u4Dts = 0;
    pes->u4Pts = 0;
    
    // find Pic hdr, skip seq hdr & grp hdr
    u4StartAddr = _SWDMX_MpgSearchStartCode(0x100, VIRTUAL(pes->u4FrameAddr), prPes);
    if (u4StartAddr == 0)
    {
        LOG(2, "%s(%u):%u No Pic start code found, Data may error.\n",
                __FUNCTION__, u1SrcId, __LINE__);
        goto EXIT_PORT;
    }
    
    u4Datain = _SWDMX_MpgGetDatain(u4StartAddr, prPes);
    
    // not picture header
    if (u4Datain != 0x100)
    {
        LOG(2, "%s(%u):%u Not Pic start code found.\n",
                __FUNCTION__, u1SrcId, __LINE__); 
        // ASSERT(0);
        goto EXIT_PORT;
    }
    
    // skip pic header--->begin
    u4SkipBits = 32 + 10 + 3 + 16;
    // pic type different, skip bits num different.
    switch(pes->u4FrameType)
    {
        case PIC_TYPE_I:
            // do nothing
            break;
        case PIC_TYPE_P:
            u4SkipBits += 4;
            break;
        case PIC_TYPE_B:
            u4SkipBits += 8;
            break;
        default:
            LOG(2, "Err Pic type.\n");
            goto EXIT_PORT;
    }
    u4StartAddr = MPG_GET_START_ADDR(u4StartAddr, (INT32)(u4SkipBits/8), prPes);
    u4SkipBits = u4SkipBits%8;
    
    // skip extra_info_pic
    while(((*((CHAR*)u4StartAddr)) << u4SkipBits) & 0x80)
    {
        u4SkipBits += 9;
        u4StartAddr = MPG_GET_START_ADDR(u4StartAddr, (INT32)(u4SkipBits/8), prPes);
        u4SkipBits = u4SkipBits%8;        
    }
    
    // skip extra_bit_pic
    u4SkipBits+=1;
    if(u4SkipBits%8)
    {
        u4StartAddr = MPG_GET_START_ADDR(u4StartAddr, (INT32)(u4SkipBits/8 + 1), prPes);
    }
    else
    {
        u4StartAddr = MPG_GET_START_ADDR(u4StartAddr, (INT32)(u4SkipBits/8), prPes);
        u4SkipBits = 0;
    }
    
    // skip pic header--->end 
    // skip pic_coding_extension--->begin
    u4Datain = _SWDMX_MpgGetDatain(u4StartAddr, prPes);
    if(u4Datain != 0x1B5 && u4Datain != 0x1B2)
    {
        LOG(2, "Expected start code not found.\n");
        goto EXIT_PORT;
    }
    
    if(u4Datain == 0x1B5)
    {
        u4StartAddr = MPG_GET_START_ADDR(u4StartAddr, (INT32)8, prPes);
        u4SkipBits = 2;
        // skip compsdite_display_flag content
        if(((*((CHAR*)u4StartAddr)) << 1) & 0x80)
        {
            u4SkipBits += 20;                      
        }
        u4StartAddr = MPG_GET_START_ADDR(u4StartAddr, (INT32)(u4SkipBits/8 + 1), prPes);
        u4SkipBits = 0;            
    }

    u4StartAddr = _SWDMX_MpgSearchStartCode(0x1B2, u4StartAddr, prPes);
    u4Datain = _SWDMX_MpgGetDatain(u4StartAddr, prPes);
    if(u4Datain != 0x1B2)
    {
        goto EXIT_PORT;
    }
    
    // skip start code
    u4StartAddr = MPG_GET_START_ADDR(u4StartAddr, (INT32)4, prPes);

    // parsing user data
    u4Datain = _SWDMX_MpgGetDatain(u4StartAddr, prPes);
    
    while ( (!(pes->u4Dts && pes->u4Pts)) || 
            (!((u4Datain & 0xFFFFFF00) == 0x0100)) )
    {
        // get length
        u1Length = (UINT8)(*((CHAR*)u4StartAddr));
        
        // skip length
        u4StartAddr = MPG_GET_START_ADDR(u4StartAddr, (INT32)1, prPes);
        
        if(u1Length == 0)
        {
            // parse next infomation
            u4Datain = _SWDMX_MpgGetDatain(u4StartAddr, prPes);
            continue;
        }
        
        // get type
        ucType = (*((CHAR*)u4StartAddr));
        // skip user data type
        u4StartAddr = MPG_GET_START_ADDR(u4StartAddr, (INT32)1, prPes);
        
        switch(ucType)
        {
        // pts
        case 0x2:
        {
            u4Data = 0;
            u4Datain = _SWDMX_MpgGetDatain(u4StartAddr, prPes);
            u4Data |= ((u4Datain & 0x3000000) << 6);
            u4Data |= ((u4Datain & 0x7FFF00) << 7);
            u4Data |= ((u4Datain & 0x7F) << 8);

            u4StartAddr = MPG_GET_START_ADDR(u4StartAddr, (INT32)4, prPes);
            u4Datain = _SWDMX_MpgGetDatain(u4StartAddr, prPes);
            u4Data |= ((u4Datain >> 24) & 0xFF);
            u4StartAddr = MPG_GET_START_ADDR(u4StartAddr, (INT32)1, prPes);

#if 0
            u4Data |= (((UINT32)(*((CHAR*)u4StartAddr)) & 0x3) << 30);
            u4StartAddr = MPG_GET_START_ADDR(u4StartAddr, 1, prPes);
            u4Data |= (((UINT32)(*((CHAR*)u4StartAddr)) & 0x7F) << 23);
            u4StartAddr = MPG_GET_START_ADDR(u4StartAddr, 1, prPes);
            u4Data |= ((UINT32)(*((CHAR*)u4StartAddr)) << 15);
            u4StartAddr = MPG_GET_START_ADDR(u4StartAddr, 1, prPes);
            u4Data |= (((UINT32)(*((CHAR*)u4StartAddr)) & 0x7F) << 8);
            u4StartAddr = MPG_GET_START_ADDR(u4StartAddr, 1, prPes);
            u4Data |= (UINT32)(*((CHAR*)u4StartAddr));
#endif
            pes->u4Pts = u4Data;
            
            break;
        }
            
        // dts
        case 0x4:
        {
            u4Data = 0;
            u4Datain = _SWDMX_MpgGetDatain(u4StartAddr, prPes);
            u4Data |= ((u4Datain & 0x3000000) << 6);
            u4Data |= ((u4Datain & 0x7FFF00) << 7);
            u4Data |= ((u4Datain & 0x7F) << 8);

            u4StartAddr = MPG_GET_START_ADDR(u4StartAddr, (INT32)4, prPes);
            u4Datain = _SWDMX_MpgGetDatain(u4StartAddr, prPes);
            u4Data |= ((u4Datain >> 24) & 0xFF);
            u4StartAddr = MPG_GET_START_ADDR(u4StartAddr, (INT32)1, prPes);
            
#if 0
            u4Data |= (((UINT32)(*((CHAR*)u4StartAddr)) & 0x3) << 30);
            u4StartAddr = MPG_GET_START_ADDR(u4StartAddr, 1, prPes);
            u4Data |= (((UINT32)(*((CHAR*)u4StartAddr)) & 0x7F) << 23);
            u4StartAddr = MPG_GET_START_ADDR(u4StartAddr, 1, prPes);
            u4Data |= ((UINT32)(*((CHAR*)u4StartAddr)) << 15);
            u4StartAddr = MPG_GET_START_ADDR(u4StartAddr, 1, prPes);
            u4Data |= (((UINT32)(*((CHAR*)u4StartAddr)) & 0x7F) << 8);
            u4StartAddr = MPG_GET_START_ADDR(u4StartAddr, 1, prPes);
            u4Data |= (UINT32)(*((CHAR*)u4StartAddr));
#endif
            pes->u4Dts = u4Data;
            
            break;
        }
        
        default:
        {
            if ( (ucType>10) || (u1Length>6) )
            {
                LOG(2, "Err T(%d) L(%d)\n", ucType, u1Length);
                goto EXIT_PORT;
            }
            
            u4StartAddr = MPG_GET_START_ADDR(u4StartAddr, (INT32)(u1Length - 1), prPes);
            break;
        }
        }     

        u4Datain = _SWDMX_MpgGetDatain(u4StartAddr, prPes);
    }
    
    if (pes->u4Dts && pes->u4Pts)
    {
        pes->fgPtsDts = TRUE;
    }

EXIT_PORT:
    LOG(6, "VO(27M Based) PTS(0x%X) DTS(0x%X)\n", pes->u4Pts, pes->u4Dts);

    return TRUE;
}
#endif

BOOL _SWDMX_MpgAudioCallback(const DMX_AUDIO_PES_T* prPes)
{
    BOOL fgRet;
    UINT8 u1SrcId;
    UINT32 u4Original90KBasePTS;
    DMX_AUDIO_PES_T rPes;
#ifdef SWDMX_MPG_CHECK_MP3_AUDIO
    UINT32 u4Tmp;
    SWDMX_MPG_MP3_HDR rMp3Hdr;
    UCHAR *pRptr;
    UINT32 au4BufStart[2] = {0,0};
  UINT32 au4BufEnd[2] = {0,0};
#endif
    UINT32 u4Temp = 0;
    SWDMX_INFO_T *prSwdmxInst;

    if(prPes == NULL)
    {
        LOG(1, "_SWDMX_MpgAudioCallback prPes NULL\n");
        return FALSE;
    }

    prSwdmxInst = (SWDMX_INFO_T*)(prPes->pvInstanceTag);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    u1SrcId = prSwdmxInst->u1SwdmxId;
    
    if(prSwdmxInst->u4LogFilter & check_original_audio_pts)
    {
        LOG(1, "AO PTS=0x%X RP=0x%X WP=0x%X u1DeviceId 0x%X Pos=0x%llX\n",
               prPes->u4Pts, prPes->u4PesRp, prPes->u4Wp,prPes->u1DeviceId,
               prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize);
    }

#ifdef HANDLE_CODEC_PID_CHG 
  if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192 &&
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgDisableStrm)
  {   
    LOG(5,"Codec or Pid change , drop audio data!\n");
    return TRUE;
  }
#endif
    
    x_memset(&rPes, 0, sizeof(rPes));

    #ifdef SWDMX_MPG_CHECK_MP3_AUDIO
    if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) &&
        ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_PS) ||
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG1_DAT) ||
        IS_TS_FILE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)) &&
        (prSwdmxInst->eAudioType == ENUM_SWDMX_ADEC_MPEG) &&
        (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady))
    {
#ifdef AUD_OLDFIFO_INTF
        VERIFY(AUD_GetAudFifo(&au4BufStart[0], &au4BufEnd[0],
                              &au4BufStart[1], &au4BufEnd[1]) == AUD_OK);
#else
        if(prPes->u1DeviceId == AUD_DEC_MAIN)
        {
            VERIFY(AUD_GetAudFifo(prSwdmxInst->u1AdecId, &au4BufStart[0], &au4BufEnd[0]) == AUD_OK);        
        }
        else if(prPes->u1DeviceId == AUD_DEC_AUX)
        {
            VERIFY(AUD_GetAudFifo(prSwdmxInst->u1Adec2Id, &au4BufStart[0], &au4BufEnd[0]) == AUD_OK);
        }
        else if(prPes->u1DeviceId == AUD_DEC_THIRD)
        {
            VERIFY(AUD_GetAudFifo(prSwdmxInst->u1Adec3Id, &au4BufStart[0], &au4BufEnd[0]) == AUD_OK);
        }

#endif
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioWptr && prPes->u1DeviceId == AUD_DEC_MAIN)
        {
            pRptr = (UCHAR*)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioWptr;
        }
        else if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio2Wptr && prPes->u1DeviceId == AUD_DEC_AUX)
        {
            pRptr = (UCHAR*)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio2Wptr;
        }        
        else
        {
            pRptr = (UCHAR*)au4BufStart[0];
        }
        
        if((au4BufEnd[0] > ((UINT32)pRptr)) &&
           ((au4BufEnd[0] - ((UINT32)pRptr)) > 4))
        {
            u4Tmp = (*(UCHAR*)VIRTUAL((UINT32)(pRptr)));
            u4Tmp <<= 8;
            u4Tmp += (*(UCHAR*)VIRTUAL((UINT32)(pRptr+1)));
            u4Tmp <<= 8;
            u4Tmp += (*(UCHAR*)VIRTUAL((UINT32)(pRptr+2)));
            u4Tmp <<= 8;
            u4Tmp += (*(UCHAR*)VIRTUAL((UINT32)(pRptr+3)));
        }
        else
        {
            u4Tmp = 0;
        }
        rMp3Hdr.au4Reg[0] = u4Tmp;
        if((rMp3Hdr.rField.u4FrameSync == 0x7FF) &&
           (rMp3Hdr.rField.u4Version != 0x1) && // reserved
           (rMp3Hdr.rField.u4Layer == 0x1) &&// layer 3
           //(rMp3Hdr.rField.u4BitateIdx != 0xF) &&// bad
           (rMp3Hdr.rField.u4SampleRate != 0x3)// reserved
          )
        {
            //AUD_DEC_DECODE_FMT_CONFLICT
            LOG(3, "_SWDMX_MpgAudioCallback MP3 audio\n");
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4Mp3Cnt ++;
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4Mp3Cnt >= MPG_MP3_CHECK_CNT)
            {
                // notify audio driver
                #ifdef SWDMX_MPG_CHECK_AUDIO_SCRAMBLE
                AUD_MM_Set_Dec_Fmt_Conflict(prPes->u1DeviceId, TRUE);
                #endif
            }
        }
    }
    #endif

    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo &&
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgResetPosAfterFoundSeq)
    {
        STC_StopStc(prSwdmxInst->u1StcId);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCleanAudio = TRUE;
        return TRUE;
    }
    
    x_memcpy(&rPes, prPes, sizeof(DMX_AUDIO_PES_T));
    
    // swtich PTS/DTS to 90K based value
    if ((SWDMX_FMT_MPEG2_TS_130 == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
        (SWDMX_FMT_MPEG2_TS_134 == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) )
    {
        // For RVU, the PTS&DTS is 27M based, align to 27K based value
        UNUSED(_SWDMX_MpgTo27KBasedTimestamp(u1SrcId, rPes.u4Dts, &rPes.u4Dts));
        UNUSED(_SWDMX_MpgTo27KBasedTimestamp(u1SrcId, rPes.u4Pts, &rPes.u4Pts));

        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
        {
            BOOL fgShake = FALSE;
            
            if ((SWDMX_RVU_SHAKE_START_PTS < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS) && 
                (SWDMX_RVU_SHAKE_END_PTS > rPes.u4Pts) && (0 != rPes.u4Pts))
            {
               LOG(5, "APTS Jump 0x%X-->0x%X Base(0x%X)\n",
                       prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS, 
                       rPes.u4Pts,
                       prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurABasePTS);
               fgShake = TRUE;
            }
            
            if ( fgShake )
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurABasePTS += SWDMX_RVU_30K_BASE_PTS_MAX;
            }

            if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurABasePTS != prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurVBasePTS) &&
                IN_NORMAL_STATE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS) &&
                IN_NORMAL_STATE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS) &&
                (0 == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ShakeTime) &&
                (20*90000 > SWDMX_PTS_GAP(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS)))
            {
                // LWB: Pre AV sync state may in free run.
                LOG(5, "%s Force BasePTS=0x%X\n", __FUNCTION__, 
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurABasePTS);
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurVBasePTS = 
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurABasePTS;
            }
            
            if (0 < rPes.u4Pts)
            {
                rPes.u4Pts += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurABasePTS;
            }

            if (0 < rPes.u4Dts)
            {
                rPes.u4Dts += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurABasePTS;
            }
        }
    }
#ifdef SUPPORT_CIPLUS_RECORD
        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt==SWDMX_FMT_MPEG2_TS_ENCRYPT_192 &&
            !prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio)
        {
            if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicStartPlayOrgPTS!=0 && prPes->u4Pts!=0)
            {
                if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicStartPlayOrgPTS > prPes->u4Pts)
                {
                    if (prSwdmxInst->u4LogFilter & check_rl)
					{
						LOG(1,"callback audio pts %u not exceed u4PicStartPlayOrgPTS %u\n",prPes->u4Pts, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicStartPlayOrgPTS);
					}                
                    return TRUE;
                }
                else
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicStartPlayOrgPTS = 0;
                }
            }
        }
#endif

    u4Original90KBasePTS = rPes.u4Pts;
    UNUSED(_SWDMX_MpgWatchAudioPTS(u1SrcId, prPes));
    
    /*if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioWptr && prPes->u1DeviceId == AUD_DEC_MAIN)
    {
        // for the first time, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioWptr = 0,
        // we use original write pointer.
        rPes.u4Wp = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioWptr;
    }
    else if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio2Wptr && prPes->u1DeviceId == AUD_DEC_AUX)
    {
        rPes.u4Wp = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio2Wptr;
    }
    else if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio3Wptr && prPes->u1DeviceId == AUD_DEC_THIRD)
    {
        rPes.u4Wp = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio3Wptr;
    }*/
    if((prPes->u1DeviceId == AUD_DEC_MAIN))
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioWptr = prPes->u4Wp;
    }
    else if((prPes->u1DeviceId == AUD_DEC_AUX))
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio2Wptr = prPes->u4Wp;
    }
    else if((prPes->u1DeviceId == AUD_DEC_THIRD))
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio3Wptr = prPes->u4Wp;
    }

    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSeekaud)
    {
        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SeekAudPTS > (u4Original90KBasePTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCleanAudio = TRUE;
            //LOG(4,"[audiocallback]%d\n",__LINE__);
            return TRUE;
        }
        else
        {
            LOG(0,"1111111111111111111111111111111send first audo pts == %x,audiosee =%x\n",rPes.u4Pts,prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SeekAudPTS);
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSeekaud = FALSE;
        }
    }
    
#ifdef HANDLE_PTS_SKIP
    if (prSwdmxInst->u4LogFilter & check_pts_skip)
    {
        LOG(1, "[audio]i4CurSpeed %d fgVideo %d fgGotAudio %d u4LastAudioPTS 0x%x u4Original90KBasePTS 0x%x u1SkipPts %d\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS,
            u4Original90KBasePTS,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1SkipPts);
    }
    
    if (!NEED_QUICK_START(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type) &&
        (1000==prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed) &&
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo &&
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio &&
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS &&
        u4Original90KBasePTS && (u4Original90KBasePTS + SKIP_PTS < 
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS) &&
        !(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1SkipPts & AUDIO_PTS_SKIP))
    {
        if ((prSwdmxInst->eSubVideoType != ENUM_SWDMX_VDEC_MVC) &&
            (prSwdmxInst->eSubVideoType != ENUM_SWDMX_VDEC_MULTITRACK))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1SkipPts |= AUDIO_PTS_SKIP;

            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4ABaseSkipPts += 
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS - u4Original90KBasePTS);
                
            if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1SkipPts & VIDEO_PTS_SKIP)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4ABaseSkipPts = 
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4VBaseSkipPts;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1SkipPts = NO_SKIP_PTS;
            }
            
            LOG(3, "found audio pts 0x%0x -> 0x%x, base pts 0x%x base skip pts 0x%x\n", 
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS,
                    rPes.u4Pts,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4ABaseSkipPts);   
        }               
    }
#endif

    if (0 != u4Original90KBasePTS)
    {
        HAL_TIME_T rCurTime, rDeltaTime;
            
        HAL_GetTime(&rCurTime);

        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rLastACBTime.u4Seconds ||
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rLastACBTime.u4Micros)
        {
            HAL_GetDeltaTime(&rDeltaTime,
                             &prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rLastACBTime,
                             &rCurTime);

            if ((rDeltaTime.u4Seconds > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rDeltaACBTime.u4Seconds) ||
                (rDeltaTime.u4Seconds == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rDeltaACBTime.u4Seconds &&
                rDeltaTime.u4Micros > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rDeltaACBTime.u4Micros))
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rDeltaACBTime = rDeltaTime;
            }
        }
                         
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rLastACBTime = rCurTime;
        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4DeltaAudioPTS =
            u4Original90KBasePTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS = u4Original90KBasePTS;
    }
    
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToADec)
    {
        //_SWDMX_MpgFlushAFifo();
        if(prSwdmxInst->fgEnablePrebuffer)
    	{
    		_SWDMX_MpgFlushAFifo(u1SrcId);
    	}
        LOG(4,"[audiocallback]%d\n",__LINE__);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCleanAudio = TRUE;
        return TRUE;
    }

    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToDecoder)
    {    	
        //_SWDMX_MpgFlushAFifo();
        if(prSwdmxInst->fgEnablePrebuffer)
    	{
    		_SWDMX_MpgFlushAFifo(u1SrcId);
    	}
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCleanAudio = TRUE;
        _SWDMX_MpgFlushVFifo(u1SrcId);
        if ((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
            (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
        {
            _SWDMX_MpgFlushVFifo2(u1SrcId);
        }

        LOG(4,"[audiocallback]%d\n",__LINE__);                
        return TRUE;
    }

    // DTV00348760, add control, after enable audio, not using video to filter audio
    if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo) && 
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) &&
        (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio) && 
        (!NEED_QUICK_START(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type))
        #ifdef MPG_PUSH_REAL 
        && ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type !=
                 MM_SRC_TYPE_NETWORK_MPEG_REAL_PUSH) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type !=
                 MM_SRC_TYPE_IPTV))
        #endif
        )
    {
        //_SWDMX_MpgFlushAFifo();
        //if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio != 0xFF)
        //{
        //    UNUSED(DMX_MM_FlushBuffer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio));
        //}
        if(prSwdmxInst->fgEnablePrebuffer)
    	{
    		_SWDMX_MpgFlushAudio(u1SrcId);
    	}
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCleanAudio = TRUE;
        LOG(4,"[audiocallback]%d\n",__LINE__);                
        
        return TRUE;
    }

    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio)
    {
        //_SWDMX_MpgFlushAFifo();
        //if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio != 0xFF)
        //{
        //    UNUSED(DMX_MM_FlushBuffer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio));
        //}
        if(prSwdmxInst->fgEnablePrebuffer)
    	{
    		_SWDMX_MpgFlushAudio(u1SrcId);
    	}
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCleanAudio = TRUE;
        LOG(4,"[audiocallback]%d\n",__LINE__);                
        
        return TRUE;
    }

    // On cleaning
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCleanAudio)
    {
        LOG(4,"[audiocallback]%d\n",__LINE__);                
            
        return TRUE;
    }

    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio && prPes->u1DeviceId == AUD_DEC_MAIN)
    {
        LOG(4,"[audiocallback]%d\n",__LINE__);                
            
        return TRUE;
    }
    // 0831 
    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio2 && prPes->u1DeviceId == AUD_DEC_AUX)
    {
        LOG(4,"[audiocallback]%d\n",__LINE__);                
    
        return TRUE;
    }
    
    // 0831 
    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio3 && prPes->u1DeviceId == AUD_DEC_THIRD)
    {
        LOG(4,"[audiocallback]%d\n",__LINE__);                
    
        return TRUE;
    }
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos)
    {
        LOG(4,"[audiocallback]%d\n",__LINE__);        
    
        return TRUE;
    }
    // 0831
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio2Eos)
    {
        LOG(4,"[audiocallback]%d\n",__LINE__);                
            
        return TRUE;
    }
    // 0831
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio3Eos)
    {
        LOG(4,"[audiocallback]%d\n",__LINE__);        
        
        return TRUE;
    }

    #ifdef TIME_SHIFT_SUPPORT
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        rPes.u4TickNum = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum;
    }
    #endif

    if (rPes.u4Dts > 0)
    {
        rPes.u4Dts -= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS;
        rPes.u4Dts += (MPG_STC_BASE);
#ifdef HANDLE_PTS_SKIP
        rPes.u4Dts += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4ABaseSkipPts;
#endif
        
    }
    
    if (rPes.u4Pts > 0)
    {
        rPes.u4Pts -= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS;
        rPes.u4Pts += (MPG_STC_BASE);
#ifdef HANDLE_PTS_SKIP
        rPes.u4Pts += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4ABaseSkipPts;            
#endif
    }
    else
    {
        // DTV00135223, audio driver will ignore zero pts now.
        // DTV00209856, audio PTS is zero sometimes. Send the last one.
        //if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS > 0)
        //{
        //    rPes.u4Pts = ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS -
        //        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + (MPG_STC_BASE));
        //}
        //LOG(6, "_SWDMX_MpgAudioCallback rPes.u4Pts = 0 -> %d\n", rPes.u4Pts);
    }
    rPes.fgForward = FALSE;
    
    if (prPes->fgEOS)
    {
        // DTV00065338, [Acceptance test] Playback Time length NOT equal in Playback Screen and File Information.
        // because audio driver does not get the lastest Wptr,
        // add this to set the last one.
        // Flag fgForward will be used for each fmt not just for SWDMX_FMT_RAW_AUDIO_ES now
        // if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
        {
            DMX_AUDIO_PES_T rPes1Last;
            x_memset(&rPes1Last, 0, sizeof(rPes1Last));
            if(prPes->u1DeviceId == AUD_DEC_MAIN)
            {
                rPes1Last.u1DeviceId = prSwdmxInst->u1AdecId;
            }
            else if(prPes->u1DeviceId == AUD_DEC_AUX)
            {
               rPes1Last.u1DeviceId = prSwdmxInst->u1Adec2Id;
            }
            else if(prPes->u1DeviceId == AUD_DEC_THIRD)
            {
               rPes1Last.u1DeviceId = prSwdmxInst->u1Adec3Id;
            }
            
            if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES) &&
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime))
            {
                rPes1Last.u4Dts =  prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime + (MPG_STC_BASE);
                rPes1Last.u4Pts =  prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime + (MPG_STC_BASE);
            }
            else
            {
                rPes1Last.u4Dts = rPes.u4Dts;
                rPes1Last.u4Pts = rPes.u4Pts;
            }
            rPes1Last.u4Wp =  rPes.u4Wp;
      
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed >0)
            {
                //rPes1Last.fgForward = TRUE;        //for trick mode 
                rPes.fgForward =TRUE;
            }
            else
            {
                //rPes1Last.fgForward = FALSE;
                rPes.fgForward =FALSE;
            }
            if (rPes.u4Wp != 0)
            {
                UNUSED(AUD_SendAudioPes(&rPes1Last));
            }
            /* WP==0 && EOS==TRUE && fgGotAudio==false */
            /* throw the api:_SWDMX_MpgHandleEOS() hanle the case */
            else 
            {
                LOG(5,"_SWDMX_MpgAudioCallback rPes.u4Wp %lu EOS %u fgGotAudio %u \n" ,
                rPes.u4Wp, prPes->fgEOS,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio);
               
                return TRUE;
            }
            
            if(prSwdmxInst->u4LogFilter & check_audio_pts)
            {
                LOG(1, "AC PTS=0x%X RP=0x%X WP=0x%X Pos=0x%llX (Last)\n",
                       rPes1Last.u4Pts, rPes1Last.u4PesRp, rPes1Last.u4Wp,
                       prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize);
            }
        }

        // for the first time, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioWptr = xx,
        // but we use original write pointer.
        LOG(0, "_SWDMX_MpgAudioCallback send EOS\n");
        rPes.u4Wp = prPes->u4Wp;
        if(prPes->u1DeviceId == AUD_DEC_MAIN)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = TRUE;
        }
        else if(prPes->u1DeviceId == AUD_DEC_AUX)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio2Eos = TRUE;
        }
        else if(prPes->u1DeviceId == AUD_DEC_THIRD)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio3Eos = TRUE;
        }
        
    }
#ifdef SWDMX_MPG_DEBUG_FIFO
#ifdef SWDMX_MPG_AFIFO_SIZE
    if((_fgAFifo) && (_fgAManual))
    {
        UINT32 u4Addr, u4Size;
        UINT32 u4AudioSize;
        UINT32 u4Tmp;

        if(_u4AudioLastWriter)
        {
            UNUSED(_SWDMX_GetAudioFifo(u1SrcId, &u4Addr, &u4Size));
            if(_u4AudioLastWriter > rPes.u4Wp)
            {
                u4AudioSize = ((rPes.u4Wp + u4Size) - _u4AudioLastWriter);
            }
            else
            {
                u4AudioSize = (rPes.u4Wp - _u4AudioLastWriter);
            }
            _SWDMX_COPY_RING_BUF(
                _u4AFifoStart,
                _u4AFifoEnd,
                &_u4AFifoCur,
                u4Addr,
                (u4Addr + u4Size),
                _u4AudioLastWriter,
                u4AudioSize);
        }
        _u4AudioLastWriter = rPes.u4Wp;
    }
#endif
#endif
if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4MvcSeekAudPTS)
    {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4MvcSeekAudPTS >rPes.u4Pts)
        {
            LOG(4,"[audiocallback]%d\n",__LINE__);        

            return TRUE;
        }
        else
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4MvcSeekAudPTS = 0;
        }
    }
if(ucCount)
{
    u4Temp = STC_GetStcValue(prSwdmxInst->u1StcId);
    LOG(1,"audio callback data,pts 0x%x,stc %x\n",rPes.u4Pts,u4Temp);
    ucCount--;
}

#ifdef SWDMX_DUMP_DATA
    _SWDMX_DumpAFifo(prSwdmxInst, rPes.u4Wp);
#endif
    fgRet = AUD_SendAudioPes(&rPes);
    
    if(prSwdmxInst->u4LogFilter & check_audio_pts)
    {
        LOG(1, "AC PTS=0x%X RP=0x%X WP=0x%X Pos=0x%llX\n",
               rPes.u4Pts, rPes.u4PesRp, rPes.u4Wp,
               prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize);
    }
    
    if(prPes->fgEOS)
    {
        AUD_MM_Set_Avsync_event(prSwdmxInst->u1AdecId);
    }
    return fgRet;
}

static BOOL _SWDMX_MpgHevcSendSeqHdr(UINT8 u1SrcId, const DMX_PES_MSG_T *prPes)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if (prPes == NULL)
    {
        LOG(0, "[%s] prPes == NULL!\n", __FUNCTION__);
        return FALSE;
    }

    {
        VDEC_PES_INFO_T rPesInfo;
        
        x_memset(&rPesInfo, 0, sizeof(rPesInfo));
        
        rPesInfo.u4VldReadPtr = prPes->u4FrameAddr + 3;
        if (rPesInfo.u4VldReadPtr >= prPes->u4BufEnd)
        {
            rPesInfo.u4VldReadPtr -= prPes->u4BufEnd - prPes->u4BufStart;
        }

        rPesInfo.ucPicType = (UCHAR)prPes->u4FrameType;
        rPesInfo.u4VideoType = (UINT32)DMX_VIDEO_H265;
        rPesInfo.ucMpvId = VLD0;
        rPesInfo.ucEsId = prSwdmxInst->u1VdecId;
        rPesInfo.u4FifoStart = prPes->u4BufStart;
        rPesInfo.u4FifoEnd = prPes->u4BufEnd;
        rPesInfo.fgSeqHdr = prPes->fgSeqHeader;
        rPesInfo.fgGop = prPes->fgGop;
        rPesInfo.u4PTS = prPes->u4Pts;
        rPesInfo.u4DTS = prPes->u4Dts;
        rPesInfo.fgDtsValid = FALSE;
        rPesInfo.fgEos = prPes->fgEOS;
        rPesInfo.u4TotalTimeOffset = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTimeOffset;
        rPesInfo.u8Offset = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize;
        rPesInfo.u8OffsetI = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8Previous2IPosWithPTSFound;
        rPesInfo.u2DecodingOrder = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2OrderFromIPos;
        rPesInfo.u4Timestap = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS;
#ifdef CC_VDEC_FMT_DETECT
        rPesInfo.u4DmxFrameType = prPes->u4FrameType;
#endif
        x_memcpy((void*)rPesInfo.au1PicInfo, (void*)prPes->au1PicInfo, DMX_PICINFO_SIZE);
        
        VDEC_SendEs((void*)&rPesInfo);
        
        LOG(1, "[%s] u4FrameType 0x%x u4VldReadPtr 0x%x\n", __FUNCTION__, 
            prPes->u4FrameType, rPesInfo.u4VldReadPtr);
    }
        
    if (prPes->u4FrameType == H265_PIC_TYPE_PPS)
    {
        return TRUE; 
    }
    return FALSE;
}

static BOOL _SWDMX_MpgSendSeqHdr(UINT8 u1SrcId, const DMX_PES_MSG_T *prPes)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    BOOL fgRet = TRUE;

    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    switch (prSwdmxInst->eVideoType)
    {
        case ENUM_SWDMX_VDEC_H265:
            fgRet = _SWDMX_MpgHevcSendSeqHdr(u1SrcId, prPes);
            break;
        default:
            break;
    }
    
    return fgRet;
}

BOOL _SWDMX_MpgVideoCallback(const DMX_PES_MSG_T* prDmxPes)
{
    VDEC_PES_INFO_T rPesInfo;
    UINT32 u4Addr;
    UINT32 u4Original90KBasePTS;
    UINT32 u4SwdmxPicType = SWDMX_PIC_TYPE_OTHER;
    UINT8 u1SrcId;
  UINT64 u8DataSize;
    UINT64 u8Numerator = 0, u8Denominator = 0, u8Remainder = 0;
    const DMX_PES_MSG_T *prPes = prDmxPes;
    SWDMX_INFO_T *prSwdmxInst;

    if(prPes == NULL)
    {
        LOG(1, "_SWDMX_MpgVideoCallback prPes NULL\n");
        return FALSE;
    }

    prSwdmxInst = (SWDMX_INFO_T*)(prDmxPes->pvInstanceTag);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    u1SrcId = prSwdmxInst->u1SwdmxId;

    if (u1SrcId >= SWDMX_SOURCE_MAX)
    {
        LOG(1, "_SWDMX_MpgVideoCallback (u1SrcId >= SWDMX_SOURCE_MAX)\n");
        return FALSE;
    }
    
    if (prSwdmxInst->u4LogFilter & check_original_video_pts)
    {
        LOG(1, "VO PTS=0x%X RP=0x%X WP=0x%X Pos=0x%llX channel %d\n",
                prPes->u4Pts, prPes->u4FrameAddr, prPes->u4Wp,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize,
                prPes->u1Channel);
    }

    // only for last memory to send video sps/pps
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgLastMemory &&
        (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendSeqHdr || 
         prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgResetPosAfterFoundSeq))
    {
        if (_SWDMX_MpgSendSeqHdr(u1SrcId, prPes))
        {
            LOG(1, "[%s] Seq hdr send done\n", __FUNCTION__);
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendSeqHdr = TRUE;
        }
        return TRUE;
    }
    
#ifdef SWDMX_RVU_PARSE_PTS
    if ( (SWDMX_FMT_MPEG2_TS_130 == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
         (SWDMX_FMT_MPEG2_TS_134 == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) )
    {
#if defined(CC_TRUSTZONE_SUPPORT) && defined(CC_SVP_SUPPORT)
        if (!_SWDMX_MpgParsingPtsInTrustzone(prSwdmxInst, prDmxPes))
        {
            return TRUE;
        }
#else   
        if (!_SWDMX_MpgParsingPts(prSwdmxInst, prDmxPes))
        {
            return TRUE;
        }
#endif 
        // 3D or not
        if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
           (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
        {
            prPes = &_arDmxPes[prPes->u1Channel];
        }
        else
        {
            prPes = &_arDmxPes[0];
        }
    }
#endif

    x_memset(&rPesInfo, 0, sizeof(VDEC_PES_INFO_T));
    
#ifdef TIME_MEASUREMENT
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCbPrintTMS)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCbPrintTMS = FALSE;
        TMS_DIFF_EX(TMS_FLAG_WFD_LATENCY,"WFD_DATA:","Dmx video callback");
        rPesInfo.fgWFDTMSLogEnable = TRUE;
    }
    else
    {
        rPesInfo.fgWFDTMSLogEnable = FALSE;
    }
#endif

    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CbPrintPTS)
    {
    LOG(11, "%s target pts(0x%llX), now pts(0x%X)\n", __FUNCTION__, 
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CbPrintPTS, prPes->u4Pts);
        if ((UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CbPrintPTS == prPes->u4Pts)
        {
#ifdef __KERNEL__
            {
                UINT64 u8CurTime = 0;
                struct timeval tv = {0};
                
                do_gettimeofday(&tv);
                
                u8CurTime = (UINT64)tv.tv_sec * 1000000;                
                u8CurTime = u8CurTime + (UINT64)tv.tv_usec;
                u8CurTime = u8Div6432(u8CurTime, 1000, &u8Remainder);
                
                LOG(11, "%s meet target pts(0x%llX), cur_time(%lld), push_time(%lld), spend %lld us\n", __FUNCTION__,
                   prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CbPrintPTS,
                   u8CurTime,
                   prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PushDataTime,
                   u8CurTime - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PushDataTime);
            }
#endif
      rPesInfo.u8_vid_pts = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CbPrintPTS;
      rPesInfo.u8_push_time = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PushDataTime;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CbPrintPTS = 0;
        }
        else if ((UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CbPrintPTS < prPes->u4Pts)
        {
            LOG(11, "%s cannot meet target pts(0x%llX), now pts(0x%X)\n", __FUNCTION__, 
                   prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CbPrintPTS, prPes->u4Pts);
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CbPrintPTS = 0;
        }
    }

    // change PTS & DTS to 90K based value
    {
        rPesInfo.u4PTS = prPes->u4Pts;
        rPesInfo.u4DTS = prPes->u4Dts;
        
        if ((SWDMX_FMT_MPEG2_TS_130 == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
            (SWDMX_FMT_MPEG2_TS_134 == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) )
        {            
            // For RVU, the PTS&DTS is 27M based, align to 27K based value
            // change PTS & DTS to 90K based value
            UNUSED (_SWDMX_MpgTo27KBasedTimestamp(u1SrcId, prPes->u4Pts, &rPesInfo.u4PTS));
            UNUSED (_SWDMX_MpgTo27KBasedTimestamp(u1SrcId, prPes->u4Dts, &rPesInfo.u4DTS));

            // If Audio Stream is open, We must take AV Sync case in condition
            if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
            {
                BOOL fgShake = FALSE;
                
                // In PTS shake case
                if (((SWDMX_RVU_SHAKE_START_PTS < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS) && 
                    (SWDMX_RVU_SHAKE_END_PTS > rPesInfo.u4PTS) && (0 != rPesInfo.u4PTS) &&
                    (0 == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ShakeTime)))
                {
                   LOG(5, "VPTS Jump 0x%X-->0x%X Base(0x%X)\n",
                          prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS,
                          rPesInfo.u4PTS, 
                          prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurVBasePTS);
                   fgShake = TRUE;
                   prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ShakeTime = SWDMX_RVU_VIDEO_SHAKE_TIME;
                }
                
                if ( fgShake )
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurVBasePTS += SWDMX_RVU_30K_BASE_PTS_MAX;
                }
                
                if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurABasePTS != prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurVBasePTS) &&
                    IN_NORMAL_STATE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS) &&
                    IN_NORMAL_STATE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS) &&
                    (0 == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ShakeTime) &&
                    (10*90000 > SWDMX_PTS_GAP(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS)))
                {
                    // LWB: Pre AV sync state may in free run. 
                    LOG(5, "VideoCallback: Force BasePTS=0x%X\n", 
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurABasePTS);
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurVBasePTS = 
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurABasePTS;
                }
            
                if (0 < rPesInfo.u4PTS)
                {
                    rPesInfo.u4PTS += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurVBasePTS;
                }

                if (0 < rPesInfo.u4DTS)
                {
                    rPesInfo.u4DTS += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurVBasePTS;
                }

                if ((0 != prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ShakeTime) && 
                    (SWDMX_RVU_SHAKE_START_PTS < prPes->u4Pts/300))
                {
                    if (0 < rPesInfo.u4PTS) // Maybe SWDMX_RVU_30K_BASE_PTS_MAX
                    {
                        rPesInfo.u4PTS -= SWDMX_RVU_30K_BASE_PTS_MAX;
                    }

                    if (0 < rPesInfo.u4DTS)
                    {
                        rPesInfo.u4DTS -= SWDMX_RVU_30K_BASE_PTS_MAX;
                    }
                }

                if (0 != prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ShakeTime)
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ShakeTime--;
                }
            }
        }
    }

    // Cur value used to keep the original 90K based value without u4FirstPts align
    u4Original90KBasePTS = rPesInfo.u4PTS;
    
    UNUSED (_SWDMX_MpgWatchVideoPTS(u1SrcId, prPes));

#ifdef HANDLE_CODEC_PID_CHG 
  if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192 &&
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFlushVidData)
  {
    //DTV00566445 make sure the u4VideoPTSKeeper >=0
    if(prPes->u4Pts >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS)
    {
      LOG(1, "set keep pts ,1st pts %lu\n",prPes->u4Pts - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS);
      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4VideoPTSKeeper = 
        prPes->u4Pts - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS;
    }
    else if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS)
    {
      LOG(1,"flush video data pts < first pts\n");
      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4VideoPTSKeeper = 
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS;
    }
    else
    {
      LOG(1,"flush last video data pts < first pts!\n");
      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4VideoPTSKeeper = 1;
    }
    LOG(6,"Codec or Pid change , drop video data!\n");
    return TRUE;
  }
#endif
    
#ifdef HANDLE_PTS_SKIP
    if(prSwdmxInst->u4LogFilter & check_pts_skip)
    {
        LOG(1, "[video]i4CurSpeed %d fgAudio %d fgGotVideo %d u4LastVideoPTS 0x%x u4Original90KBasePTS 0x%x u1SkipPts %d\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS,
            u4Original90KBasePTS,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1SkipPts);
    }

    if (!NEED_QUICK_START(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type) &&
        (1000==prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed) &&
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio &&
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo &&
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS &&
        u4Original90KBasePTS && (u4Original90KBasePTS + SKIP_PTS < 
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS) &&
        !(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1SkipPts & VIDEO_PTS_SKIP))
    {
        if((prSwdmxInst->eSubVideoType != ENUM_SWDMX_VDEC_MVC) &&
            (prSwdmxInst->eSubVideoType != ENUM_SWDMX_VDEC_MULTITRACK))
        {        
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1SkipPts |= VIDEO_PTS_SKIP;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1VSkipLittlePts = 
            u4Original90KBasePTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS + MPG_STC_BASE;
            
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4VBaseSkipPts += 
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS - u4Original90KBasePTS);

            if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1SkipPts & AUDIO_PTS_SKIP)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4VBaseSkipPts = 
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4ABaseSkipPts;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1SkipPts = NO_SKIP_PTS;
            }
            LOG(3, "found video pts 0x%0x -> 0x%x, base pts 0x%x skip base pts 0x%x eSubVideoType %d\n", 
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS,
                u4Original90KBasePTS,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4VBaseSkipPts,
                prSwdmxInst->eSubVideoType);
        }
            
    }
#endif

    if (0 != u4Original90KBasePTS)
    {
        HAL_TIME_T rCurTime, rDeltaTime;
            
        HAL_GetTime(&rCurTime);

        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rLastVCBTime.u4Seconds ||
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rLastVCBTime.u4Micros)
        {
            HAL_GetDeltaTime(&rDeltaTime,
                             &prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rLastVCBTime,
                             &rCurTime);

            if ((rDeltaTime.u4Seconds > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rDeltaVCBTime.u4Seconds) ||
                (rDeltaTime.u4Seconds == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rDeltaVCBTime.u4Seconds &&
                rDeltaTime.u4Micros > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rDeltaVCBTime.u4Micros))
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rDeltaVCBTime = rDeltaTime;
            }
            
            LOG(11, "rLastVCBTime(%06u.%06u)\n", 
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rLastVCBTime.u4Seconds,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rLastVCBTime.u4Micros);
            
            LOG(11, "rDeltaVCBTime(%06u.%06u)\n", 
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rDeltaVCBTime.u4Seconds,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rDeltaVCBTime.u4Micros);
        }
                         
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rLastVCBTime = rCurTime;
        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4DeltaVideoPTS = 
            u4Original90KBasePTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS = u4Original90KBasePTS;  // DTV00139313  record last video pts
    }
    
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToADec)
    {
        _SWDMX_MpgFlushAFifo(u1SrcId);
    }

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToDecoder)
    {
        _SWDMX_MpgFlushAFifo(u1SrcId);
        _SWDMX_MpgFlushVFifo(u1SrcId);
        if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
            (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
        {
            _SWDMX_MpgFlushVFifo2(u1SrcId);
        }
        return TRUE;
    }

    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
    {
        return TRUE;
    }

    if(((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
        (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK)) &&
       (prPes->u1Channel == prSwdmxInst->u1Vdec2Id))
    {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos)
        {
            return TRUE;
        }
    }
    else if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos)
    {
        return TRUE;
    }
    
#ifdef SUPPORT_CIPLUS_RECORD
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt==SWDMX_FMT_MPEG2_TS_ENCRYPT_192 &&
        !prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo)
    {
        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicStartPlayOrgPTS!=0 && prPes->u4Pts!=0)
        {
            if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicStartPlayOrgPTS > prPes->u4Pts+4*90000)
            {
                if (prSwdmxInst->u4LogFilter & check_rl)
                {
                   LOG(1,"callback video pts %u not exceed 4s over u4PicStartPlayOrgPTS %u\n",prPes->u4Pts, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicStartPlayOrgPTS);
                }  
                return TRUE;
            }
            else
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicStartPlayOrgPTS = 0;
            }
        }
    }
#endif

    // ilii, markout
    /*
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause && (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio || (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio))
        && prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady)
    {
        LOG(5, "_SWDMX_MpgVideoCallback fgVideoPause VDEC_Play\n");
        if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_MPEG1_MPEG2)
        {
            VDEC_Play(u1SrcId, VDEC_FMT_MPV);
        }
        else if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_H264)
        {
            VDEC_Play(u1SrcId, VDEC_FMT_H264);
        }
        else if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_VC1)
        {
            VDEC_Play(u1SrcId, VDEC_FMT_WMV);
        }
        else
        {
            ASSERT(0);
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause = FALSE;
    }
    */

   //  x_memset(&rPesInfo, 0, sizeof(VDEC_PES_INFO_T));

    /*
    if((prSwdmxInst->i4PlaySpeed > 0)
        && (prSwdmxInst->i4PlaySpeed < 4000))
    {
        if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo)
        {
            if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_MPEG1_MPEG2)
            {
                if(prPes->u4FrameType != PIC_TYPE_I)
                {
                    _SWDMX_MpgFlushVFifo();
                    return TRUE;
                }
            }
        }
    }

    if((prSwdmxInst->i4PlaySpeed < 1000)
        || (prSwdmxInst->i4PlaySpeed >= 4000))
    {
        if(prPes->u4FrameType == PIC_TYPE_B)
        {
            return TRUE;
        }
    }   */

    // rPesInfo.u4PTS = prPes->u4Pts;
    // rPesInfo.u4DTS = prPes->u4Dts;
    //  This part of code has been move down ,  DTV00079400  there is a case  in the 00:00:55, pts=0, and fgPtsDts=true,
    // when jumping to the point , pts will wrong,
    //DTV00139582.. if (fgPtsDts) ,PTS=0 is also valid used as  first video PTS.
    #if 0
    if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo)&&(prPes->u4Pts==0)&&(prPes->fgPtsDts))
    {
        rPesInfo.u4PTS= (MPG_STC_BASE);
    }
    #endif

    if (rPesInfo.u4PTS > 0)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPTSFound = TRUE;
        //LOG(5, "_SWDMX_MpgVideoCallback Org PTS %d\n", rPesInfo.u4PTS);
        rPesInfo.u4PTS -= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS;
        rPesInfo.u4PTS += (MPG_STC_BASE);
    #ifdef HANDLE_PTS_SKIP     
        rPesInfo.u4PTS +=  prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4VBaseSkipPts;
    #endif
    
        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS != (UINT32)0xFFFFFFFF)
        {
            if ((u4Original90KBasePTS < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS) &&
                ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS - u4Original90KBasePTS) > (10000)) &&
                (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgLastMemory) &&
                (prSwdmxInst->rCurRangeReq.prDmxRangeInfo->e_mm_src_type != MM_SRC_TYPE_NETWORK_RVU)) // 1 sec
            {
                // DTV00209729, first video pts is a fake one.
                // we would not send audio data with PTS small than this first fake video pts.

                // u4FirstVideoPTS is used to output audio after this video pts
                // even we assign a smaller PTS that actually is a fake one,
                // we would also not affect the time after we start to output audio
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS = u4Original90KBasePTS;
            }
        }
    }
    if(rPesInfo.u4DTS > 0)
    {
        rPesInfo.u4DTS -= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS;
        rPesInfo.u4DTS += (MPG_STC_BASE);
    #ifdef HANDLE_PTS_SKIP     
        rPesInfo.u4DTS +=  prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4VBaseSkipPts;
    #endif
        
    }

    //DTV00139582.. if (fgPtsDts) ,PTS=0 is also valid used as  first video PTS.
    if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo)&&(u4Original90KBasePTS==0)&&(prPes->fgPtsDts))
    {
        if(prSwdmxInst->u4SeekTime >= 90000*2) // protect 2 seconds 
        {
            return TRUE;
        }

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPTSFound = TRUE;
        rPesInfo.u4PTS = (MPG_STC_BASE);
        rPesInfo.u4DTS = (MPG_STC_BASE);

    }

    rPesInfo.ucEsId = prPes->u1Channel;
    
    if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
       (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
    {
        rPesInfo.ucEsId        = (prPes->u1Channel);
        //for mvc hd seek, we will skip the base  view data before we found the depend view data
        //after we find the depend view data ,we will record the first depend view video pts, and skip
        //the audio data that it is pts less that the first depend view  pts.
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSeek)
        {
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgHdMvc)
            {
                if((rPesInfo.ucEsId == 0)&&(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4MvcSeekVidPTS == 0xFFFFFFFF))
                {
                    return TRUE;
                }
                else if((rPesInfo.ucEsId == 1)&&(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4MvcSeekVidPTS == 0xFFFFFFFF))
                {
                    printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
                    printf("start to send video data after seek\n");
                    printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
                    //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSeek = FALSE;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4MvcSeekVidPTS = rPesInfo.u4PTS;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4MvcSeekAudPTS = rPesInfo.u4PTS;
                }
                else if(rPesInfo.ucEsId == 0)
                {
                    if(rPesInfo.u4PTS >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4MvcSeekVidPTS)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSeek = FALSE;
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4MvcSeekVidPTS = 0xFFFFFFFF;
                    }
                    else
                    {
                        return TRUE;
                    }
                }
            }
            else
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSeek = FALSE;
            }
        }
    }
    rPesInfo.ucMpvId = VLD0; // video format all use VLD expect jpeg
    rPesInfo.u4FifoStart = prPes->u4BufStart;
    rPesInfo.u4FifoEnd = prPes->u4BufEnd;
    rPesInfo.u4VldReadPtr = prPes->u4FrameAddr;
    rPesInfo.fgDtsValid = prPes->fgPtsDts;
    rPesInfo.fgSeqHdr = prPes->fgSeqHeader;
    rPesInfo.fgGop = prPes->fgGop;
    rPesInfo.fgEos = prPes->fgEOS;
    //rPesInfo.fgNotDisplay = u4Pts < u4SeekTime;
    rPesInfo.u4TotalTimeOffset = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTimeOffset;
    rPesInfo.u8Offset = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize;
    rPesInfo.u8OffsetI = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8Previous2IPosWithPTSFound;
    rPesInfo.u2DecodingOrder = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2OrderFromIPos;
    #ifdef CC_VDEC_FMT_DETECT
    rPesInfo.u4DmxFrameType = prPes->u4FrameType;
    #endif

    #ifdef TIME_SHIFT_SUPPORT
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        rPesInfo.u4TickNum = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum;
    }
    #endif

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2OrderFromIPos++;

    // in es file, we never get pts.
    // so assume we already found pts.
    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_VIDEO_ES) ||
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_H264_VIDEO_ES) ||
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG4_VIDEO_ES) ||
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_AVS_VIDEO_ES) ||
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_VC1_ES) ||
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_H265_VIDEO_ES))
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPTSFound = TRUE;
        if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = TRUE;
            STC_StopStc(prSwdmxInst->u1StcId);
            // When there is video stream, stc value will set at vdec_flw.c

        }
    }

#ifdef SWDMX_MPG_MPEG2_SUPPORT
    /* for support kr3d file ,need judge two video type */
    if (((rPesInfo.ucEsId == prSwdmxInst->u1VdecId)&&
        (prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_MPEG1_MPEG2)) ||
        ((rPesInfo.ucEsId == prSwdmxInst->u1Vdec2Id) &&
        (prSwdmxInst->eVideo2Type == ENUM_SWDMX_VDEC_MPEG1_MPEG2)))
    {
        rPesInfo.u4VideoType = (UINT32)DMX_VIDEO_MPEG;

        switch (prPes->u4FrameType)
        {
        case PIC_TYPE_I:
            rPesInfo.ucPicType = MPV_I_TYPE;
            u4SwdmxPicType = SWDMX_PIC_TYPE_I;
            //add pts info for DTV00332611
            LOG(6, "_SWDMX_MpgVideoCallback u8PreviousIPos 0x%llx, now pts:0x%llx\n",
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos, u4Original90KBasePTS);
            break;

        case PIC_TYPE_P:
            rPesInfo.ucPicType = MPV_P_TYPE;
            u4SwdmxPicType = SWDMX_PIC_TYPE_P;
            break;

        case PIC_TYPE_B:
            rPesInfo.ucPicType = MPV_B_TYPE;
            break;

        case PIC_TYPE_SEQ_END:
            rPesInfo.ucPicType = MPV_I_TYPE;
            rPesInfo.fgSeqEnd = TRUE;
            break;

        default:
            rPesInfo.ucPicType = 0;
            #ifndef CC_VDEC_FMT_DETECT
            //ASSERT(0);
            break;
            #else
            return TRUE;
            #endif
        }
        if((prPes->u4FrameType == PIC_TYPE_P) ||
           (prPes->u4FrameType == PIC_TYPE_B))
        {
            // Sample a key frame is there is no IDR
            // Currently, key is 3 second
            UINT32 u4Tmp;
            UINT64 u8Size;
            UINT64 u8Remainder;
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime) > 90000)
            {
                u4Tmp = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime / 90000); // total frames
                //u4Tmp *= 3;  wrong -> u8Size *= 3;
                u8Size = _SWDMX_Div6464((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset), (UINT64)u4Tmp, &u8Remainder);
                u8Size *= 3;
            }
            else
            {
                u8Size = (UINT64)VDEC_GetAvgPicSize(prSwdmxInst->u1VdecId);
                u8Size *= 90;
            }
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize
                - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos) > u8Size)
            {
                u4SwdmxPicType = SWDMX_PIC_TYPE_NO_I;
            }
        }
    }
    else
#endif
#ifdef SWDMX_MPG_VC1_SUPPORT
    if (prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_VC1)
    {
        rPesInfo.u4VideoType = (UINT32)DMX_VIDEO_VC1;
        rPesInfo.ucPicType = (UCHAR)prPes->u4FrameType;
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSeekvid)
        {
            if(prPes->u4FrameType != VC1_PIC_TYPE_I)
            {
                return TRUE;
            }
        }

        switch (prPes->u4FrameType)
        {
        case VC1_PIC_TYPE_I:
            u4SwdmxPicType = SWDMX_PIC_TYPE_I;
            LOG(6, "_SWDMX_MpgVideoCallback u8PreviousIPos 0x%llx\n",
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos);
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSeekvid = FALSE;
            break;

        case VC1_PIC_TYPE_P:
            u4SwdmxPicType = SWDMX_PIC_TYPE_P;
            break;

        /*case PIC_TYPE_B:
            break;*/

        default:
            break;
        }
    }
    else
#endif
#ifdef SWDMX_MPG_H264_SUPPORT
    if(((rPesInfo.ucEsId == prSwdmxInst->u1VdecId)&&
        (prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_H264)) ||
        ((rPesInfo.ucEsId == prSwdmxInst->u1Vdec2Id) &&
        (prSwdmxInst->eVideo2Type == ENUM_SWDMX_VDEC_H264)) ||
        ((rPesInfo.ucEsId == prSwdmxInst->u1Vdec2Id) &&
        (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC)))
        {
            rPesInfo.u4VideoType = (UINT32)DMX_VIDEO_H264;

#if 1 //defined(CC_TRUSTZONE_SUPPORT)
        rPesInfo.ucPicType = prPes->au1PicInfo[0];        
#else
        u4Addr = prPes->u4FrameAddr + 3;
        if(u4Addr >= prPes->u4BufEnd)
        {
            u4Addr -= (prPes->u4BufEnd - prPes->u4BufStart);
        }
        rPesInfo.ucPicType = *(UINT8*)VIRTUAL(u4Addr);
#endif


        u4Addr = prPes->u4FrameAddr + 4;
        if(u4Addr >= prPes->u4BufEnd)
        {
            u4Addr -= (prPes->u4BufEnd - prPes->u4BufStart);
        }
        rPesInfo.u4VldReadPtr = u4Addr;
        
        if (rPesInfo.fgEos && prPes->u4FrameAddr == 0)
        {
            rPesInfo.u4VldReadPtr = prPes->u4FrameAddr;    
            LOG(5,"Video Callback EOS,do not need align\n");
        }
    
    u8DataSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset;
    u8Numerator = u8DataSize*DEMUX_MPG_AV_PERIOD;
    u8Denominator = (UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime;
    if(u8Denominator != 0)
    {
      rPesInfo.u4BitRate = _SWDMX_Div6464(u8Numerator, u8Denominator,&u8Remainder);
      rPesInfo.u4BitRate = rPesInfo.u4BitRate*8;
    }
    
        if(((rPesInfo.ucPicType & 0x1F) == 0x5) ||
            ((rPesInfo.ucPicType & 0x1F) == 0x7)) // IDR_NALU
        {
            LOG(6,"_SWDMX_MpgVideoCallback get I Frame pictype 0x%x\n",rPesInfo.ucPicType);
            u4SwdmxPicType = SWDMX_PIC_TYPE_I;
        }
        else if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type != MM_SRC_TYPE_NETWORK_VUDU)
        {
            // Sample a key frame is there is no IDR
            // Currently, key is 3 second
            UINT32 u4Tmp;
            UINT64 u8Size;
            UINT64 u8Remainder;
            if(((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime) != (UINT32)0xFFFFFFFF) &&
               ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime) > 90000))
            {
                u4Tmp = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime / 90000); // total frames
                u4Tmp *= 3;
                u8Size = _SWDMX_Div6464((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset), (UINT64)u4Tmp, &u8Remainder);
            }
            else
            {
                u8Size = (UINT64)VDEC_GetAvgPicSize(prSwdmxInst->u1VdecId);
                u8Size *= 90;
            }
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize > \
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos) && \
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize
                - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos) > u8Size)
            {                   
                LOG(6,"_SWDMX_MpgVideoCallback no I Frame \n");
                u4SwdmxPicType = SWDMX_PIC_TYPE_NO_I;
            }
        }

        LOG(6, "_SWDMX_MpgVideoCallback u8PreviousIPos 0x%llx\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos);
    }
    else
#endif
#ifdef SWDMX_MPG_MPEG4_SUPPORT
    if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_MPEG4)
    {
        UCHAR *pucBuf;
        
        rPesInfo.u4VideoType = (UINT32)DMX_VIDEO_MPEG4;        
                
#if 1 //defined(CC_TRUSTZONE_SUPPORT)
        pucBuf = (UCHAR*)&prPes->au1PicInfo[0];        
#else
        u4Addr = prPes->u4FrameAddr + 3;
        if(u4Addr >= prPes->u4BufEnd)
        {
            u4Addr -= (prPes->u4BufEnd - prPes->u4BufStart);
        }
        pucBuf = (UCHAR*)VIRTUAL(u4Addr);
#endif

        if (pucBuf[0] == 0xB6)
        {
#if 1 //defined(CC_TRUSTZONE_SUPPORT)
            pucBuf = (UCHAR*)&prPes->au1PicInfo[1];
            
#else
            u4Addr = prPes->u4FrameAddr + 4;
            if(u4Addr >= prPes->u4BufEnd)
            {
                u4Addr -= (prPes->u4BufEnd - prPes->u4BufStart);
            }
            pucBuf = (UCHAR*)VIRTUAL(u4Addr);
#endif

            switch (pucBuf[0] >> 6)
            {
                case 0:
                    rPesInfo.ucPicType  = I_TYPE;
                    u4SwdmxPicType = SWDMX_PIC_TYPE_I;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSeekvid = FALSE;
                    LOG(6, "_SWDMX_MpgVideoCallback u8PreviousIPos 0x%llx\n",
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos);
                    break;

                case 1: case 3:
                    rPesInfo.ucPicType  = P_TYPE;
                    u4SwdmxPicType = SWDMX_PIC_TYPE_P;
                    break;

                case 2:
                    rPesInfo.ucPicType = B_TYPE;
                    break;

                default:
                    rPesInfo.ucPicType = UNKNOWN_TYPE;
                    break;
            }
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSeekvid)
            {
                if(rPesInfo.ucPicType != VC1_PIC_TYPE_I)
                {
                    return TRUE;
                }
            }
        }
        else if ((pucBuf[0] & 0x20) == 0x20)
        {
            rPesInfo.fgSeqHdr = TRUE;
        }
    }
    else
#endif
#ifdef SWDMX_MPG_AVS_SUPPORT
    if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_AVS)
    {
        rPesInfo.u4VideoType = (UINT32)DMX_VIDEO_AVS;
#if 1 // defined(CC_TRUSTZONE_SUPPORT)
        rPesInfo.ucPicType = prPes->au1PicInfo[0];        
#else
        u4Addr = prPes->u4FrameAddr + 3;
        if(u4Addr >= prPes->u4BufEnd)
        {
            u4Addr -= (prPes->u4BufEnd - prPes->u4BufStart);
        }
        rPesInfo.ucPicType = *(UINT8*)VIRTUAL(u4Addr);        
#endif
     
        if (rPesInfo.ucPicType == 0xB3)
        {
            u4SwdmxPicType = SWDMX_PIC_TYPE_I;
            LOG(6, "_SWDMX_MpgVideoCallback u8PreviousIPos 0x%llx\n",
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos);
        }
        else if (rPesInfo.ucPicType == 0xB0)
        {
            rPesInfo.fgSeqHdr = TRUE;
        }
    }
    else
#endif
  if (prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_H265)
  { 
    rPesInfo.u4VideoType = (UINT32)DMX_VIDEO_H265;
    rPesInfo.ucPicType = (UCHAR)prPes->u4FrameType;

      u4Addr = prPes->u4FrameAddr + 3;
        if(u4Addr >= prPes->u4BufEnd)
        {
            u4Addr -= (prPes->u4BufEnd - prPes->u4BufStart);
        }
        rPesInfo.u4VldReadPtr = u4Addr;
      
      if (rPesInfo.fgEos && prPes->u4FrameAddr == 0)
      {
          rPesInfo.u4VldReadPtr = prPes->u4FrameAddr;    
          LOG(5,"Video Callback EOS,do not need align\n");
      }        
    
    switch (prPes->u4FrameType)
        {
      case H265_SLICE_BLA_W_LP:       
      case H265_SLICE_BLA_W_RADL:       
      case H265_SLICE_BLA_N_LP:         
      case H265_SLICE_IDR_W_RADL:       
      case H265_SLICE_IDR_N_LP:         
      case H265_SLICE_TRAIL_CRA:        
      u4SwdmxPicType = SWDMX_PIC_TYPE_I;
      LOG(6, "_SWDMX_MpgVideoCallback u8PreviousIPos 0x%llx\n",
          prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos);
      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSeekvid = FALSE;
      break;

      /* case H265_PIC_TYPE_P:
      u4SwdmxPicType = SWDMX_PIC_TYPE_P;
      break;*/

      /*case PIC_TYPE_B:
      break;*/

      default:
      break;
        }
    
  }
  else
    {
        LOG(1, "_SWDMX_MpgVideoCallback unknown video\n");
    }
    if (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgHaveVideoData)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgHaveVideoData = TRUE;                   
        LOG(6, "_SWDMX_MpgVideoCallback fgHaveVideoData = TRUE \n");       
    }

    if((u4SwdmxPicType == SWDMX_PIC_TYPE_I)
       ||
       // in order to have u4FirstVideoPTS, reuse this code
        (((u4SwdmxPicType == SWDMX_PIC_TYPE_NO_I)
       #ifdef IPTV_FAST_START
       || 
       (MM_SRC_TYPE_IPTV == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type)
       #endif
       )       
       &&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS == (UINT32)0xFFFFFFFF)))
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8Previous2IPosWithPTSFound =
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPosWithPTSFound;
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPTSFound && !prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos)
        {
            //if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo) && (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio))
            if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo) &&
#ifdef VDEC_TIME_SHIFT_2X_I_MODE
               (
                ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT) &&
                 (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed >= 0) &&
                 (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed <= 1500)
                )
                ||
                ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)&&
                 (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed >= 0) &&
                 (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed < 4000)
                )
               )
#else
               ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed >= 0) &&
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed < 4000))
#endif
              )
            {
                // In time-shift, we only pause vdp, but not vdec
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
                {
                    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause &&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type != MM_SRC_TYPE_NETWORK_VUDU ||
                        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type == MM_SRC_TYPE_NETWORK_VUDU &&
                         !prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo)))
                    {
                        UNUSED(VDP_SetPauseMm(prSwdmxInst->u1B2rId, TRUE));
                        VDEC_Pause(prSwdmxInst->u1VdecId);
                        if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                           (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                        {
                            VDEC_Pause(prSwdmxInst->u1Vdec2Id);
                        }
                        LOG(0, "_SWDMX_MpgVideoCallback VDEC_Pause line %d\n", __LINE__);
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause = TRUE;
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideoReady = TRUE;
                    }
                }
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS == (UINT32)0xFFFFFFFF)
                {
                    if(u4Original90KBasePTS==0)          //DTV00139313
                    {   
                        if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastMemoryPTS) && \
                            (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS))
                        {
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastMemoryPTS;
                            LOG(5,"set FirstVideoPTS= Last memry pts=0x%x STC(0x%x)\n",
                                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastMemoryPTS,
                                STC_GetStcValue(prSwdmxInst->u1StcId));
                        }
                        else
                        {
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS=prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS;
                            LOG(5,"set FirstVideoPTS=u4LastPTS=0x%x STC(0x%x)\n",
                                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS, STC_GetStcValue(prSwdmxInst->u1StcId));
                            
                        }
                    }
                    else
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS = (u4Original90KBasePTS);
                        LOG(5, "set FirstVideoPTS= First I pic Pts=0x%x STC(0x%x)\n",
                                u4Original90KBasePTS, STC_GetStcValue(prSwdmxInst->u1StcId));
                    }
                }
                LOG(0, "_SWDMX_MpgVideoCallback fgGotVideo %s\n",
                    (u4SwdmxPicType == SWDMX_PIC_TYPE_I) ? "SWDMX_PIC_TYPE_I" : "SWDMX_PIC_TYPE_NO_I");
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo = TRUE;
                UNUSED(VDEC_SetTotalTime(prSwdmxInst->u1VdecId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime));
                UNUSED(VDEC_SetFileSize(prSwdmxInst->u1VdecId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
                if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_VIDEO_ES) ||
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG4_VIDEO_ES) ||
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_H264_VIDEO_ES) ||
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_VC1_ES) ||
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_AVS_VIDEO_ES) ||
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_H265_VIDEO_ES))
                {
                    UNUSED(VDEC_SetLastTime(prSwdmxInst->u1VdecId, MPG_STC_BASE));
                }
            }
            else if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo)
            {
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS == (UINT32)0xFFFFFFFF)
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS = u4Original90KBasePTS;
                }
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo = TRUE;
                UNUSED(VDEC_SetTotalTime(prSwdmxInst->u1VdecId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime));
                UNUSED(VDEC_SetFileSize(prSwdmxInst->u1VdecId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
                if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_VIDEO_ES) ||
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG4_VIDEO_ES) ||
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_H264_VIDEO_ES) ||
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_VC1_ES) ||
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_AVS_VIDEO_ES) ||
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_H265_VIDEO_ES))
                {
                    UNUSED(VDEC_SetLastTime(prSwdmxInst->u1VdecId, MPG_STC_BASE));
                }
            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPTSFound = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPosWithPTSFound = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2OrderFromIPos = 0;
            LOG(6, "_SWDMX_MpgVideoCallback u8PreviousIPosWithPTSFound 0x%llx\n",
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPosWithPTSFound);

            #ifdef SWDMX_MPG_USE_INDEX
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgUseIdx)
            {
                UNUSED(_SWDMX_MpgIdxUpdate(u1SrcId, rPesInfo.u4PTS,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8Previous2IPosWithPTSFound));
            }
            #endif
        }
    }
    else if(u4SwdmxPicType == SWDMX_PIC_TYPE_P)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8Previous2IPosWithPTSFound =
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPosWithPTSFound;
    }

    if(u4SwdmxPicType == SWDMX_PIC_TYPE_NO_I)
    {
        LOG(7, "_SWDMX_MpgVideoCallback No I case\n");
        rPesInfo.u8OffsetI = 0xFFFFFFFF;
        rPesInfo.u8OffsetI <<= 32;
        rPesInfo.u8OffsetI += 0xFFFFFFFF;
    }

    // For first video frame is not I frame clip,
    // we may send this pes to vdec. We have to pause vdec,
    // or we may start stc too earlier.
    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos)
    {
        //if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo) && (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio))
        // In time-shift, we only pause vdp, but not vdec
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
        {
            if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo) &&
               (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause) &&
                ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed >= 0)
                   && (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed < 4000)))
            {
                VDEC_HDR_INFO_T rHdrInfo;
                x_memset(&rHdrInfo, 0, sizeof(rHdrInfo));
                UNUSED(VDEC_QueryInfo(prSwdmxInst->u1VdecId, &rHdrInfo));
                if(rHdrInfo.u4DisplayQPicCnt > 0)
                {
                    // DTV00136474 [MM]No audio ouput when play the special ts file.
                    // When all picture is P/B frame, we have to know this information from vdec
                    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed > 0)
                       &&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed < 4000))
                    {
                        // In time-shift, we only pause vdp, but not vdec
                        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
                        {
                            if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause)
                            {
                                UNUSED(VDP_SetPauseMm(prSwdmxInst->u1B2rId, TRUE));
                                VDEC_Pause(prSwdmxInst->u1VdecId);
                                if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                                   (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                                {
                                    VDEC_Pause(prSwdmxInst->u1Vdec2Id);
                                }
                                LOG(5, "_SWDMX_MpgVideoCallback VDEC_Pause\n");
                                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause = TRUE;
                                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideoReady = TRUE;
                            }
                        }
                        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS == (UINT32)0xFFFFFFFF)
                        {
                            if (u4Original90KBasePTS==0)          //DTV00139313
                            {
                                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS=prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS;
                                LOG(5,"set FirstVideoPTS=u4LastPTS=0x%x\n",
                                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS);

                            }
                            else
                            {
                                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS = u4Original90KBasePTS;
                                LOG(5,"set FirstVideoPTS= First I pic Pts=0x%x\n", u4Original90KBasePTS);
                            }
                        }
                        
                        LOG(5, "_SWDMX_MpgVideoCallback fgGotVideo\n");
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo = TRUE;
                        UNUSED(VDEC_SetTotalTime(prSwdmxInst->u1VdecId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime));
                        UNUSED(VDEC_SetFileSize(prSwdmxInst->u1VdecId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
                        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_VIDEO_ES) ||
                           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG4_VIDEO_ES) ||
                           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_H264_VIDEO_ES) ||
                           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_VC1_ES) ||
                           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_AVS_VIDEO_ES) ||
                           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_H265_VIDEO_ES))
                        {
                            UNUSED(VDEC_SetLastTime(prSwdmxInst->u1VdecId, MPG_STC_BASE));
                        }
                    }
                    else //if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo)
                    {
                        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS == (UINT32)0xFFFFFFFF)
                        {
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS = u4Original90KBasePTS;
                        }
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo = TRUE;
                        UNUSED(VDEC_SetTotalTime(prSwdmxInst->u1VdecId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime));
                        UNUSED(VDEC_SetFileSize(prSwdmxInst->u1VdecId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
                        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_VIDEO_ES) ||
                           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG4_VIDEO_ES) ||
                           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_H264_VIDEO_ES) ||
                           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_VC1_ES) ||
                           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_AVS_VIDEO_ES) ||
                           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_H265_VIDEO_ES))
                        {
                            UNUSED(VDEC_SetLastTime(prSwdmxInst->u1VdecId, MPG_STC_BASE));
                        }
                    }
                }
                else
                {
                    UNUSED(VDP_SetPauseMm(prSwdmxInst->u1B2rId, TRUE));
                    VDEC_Pause(prSwdmxInst->u1VdecId);
                    if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                       (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                    {
                        VDEC_Pause(prSwdmxInst->u1Vdec2Id);
                    }
                    LOG(5, "_SWDMX_MpgVideoCallback VDEC_Pause\n");
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause = TRUE;
                }
            }
        }
    }

    // in es file, we never get pts.
    // so assume we already found pts.
    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_VIDEO_ES) ||
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG4_VIDEO_ES) ||
        ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_AVS_VIDEO_ES) &&
         ((rPesInfo.ucPicType == 0xB6) || (rPesInfo.ucPicType == 0xB3))) ||
        ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_H264_VIDEO_ES) &&
         ((rPesInfo.ucPicType & 0x1F) <= 0x5)) ||
         (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_H265_VIDEO_ES)
#ifdef SWDMX_MPG_VC1_SUPPORT
        ||
        ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_VC1_ES) &&
         (rPesInfo.ucPicType >= VC1_PIC_TYPE_I) &&
         (rPesInfo.ucPicType <= VC1_PIC_TYPE_SKIP))
#endif
      )
    {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS == 0)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS = MPG_STC_BASE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS = MPG_STC_BASE;
            rPesInfo.fgDtsValid = TRUE;
            rPesInfo.u4DTS = MPG_STC_BASE;
            rPesInfo.u4PTS = MPG_STC_BASE;

            LOG(5, "_SWDMX_MpgVideoCallback u4FirstPTS 0x%x\n",
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS);
        }

        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpping)
        {
            UINT32 u4PTS;
            UINT64 u8Tmp;
            UINT64 u8Remainder;

            // to make PTS increament, use file position to calculate a fake one
            u8Tmp = VDEC_GetAvgPicSize(prSwdmxInst->u1VdecId);
            // 90000 / 30 fps = 3000
            u4PTS = (UINT32)_SWDMX_Div6464((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize * (UINT64)3000), u8Tmp, &u8Remainder);

            if(!rPesInfo.fgDtsValid)
            {
                rPesInfo.fgDtsValid = TRUE;
                rPesInfo.u4DTS = (u4PTS + MPG_STC_BASE);
                rPesInfo.u4PTS = rPesInfo.u4DTS;
            }
        }
    }
    else
    {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpping)
        {
            if(!rPesInfo.fgDtsValid)
            {
                rPesInfo.fgDtsValid = TRUE;
                rPesInfo.u4DTS = ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS)
                                  + (MPG_STC_BASE));
                rPesInfo.u4PTS = rPesInfo.u4DTS;
            }
        }
    }

    if(prPes->fgEOS)
    {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed < 0)
        {
            rPesInfo.fgBackward = TRUE;
        }
        
        if(((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
            (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK)) &&
           (prPes->u1Channel == prSwdmxInst->u1Vdec2Id))
        {
            LOG(0, "_SWDMX_MpgVideoCallback send 2 EOS\n");
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = TRUE;
        }
        else //(prPes->u1Channel == ES0)
        {
            LOG(0, "_SWDMX_MpgVideoCallback send EOS\n");
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = TRUE;
        }
    }
    rPesInfo.u4Timestap = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS;
#if 1 // defined(CC_TRUSTZONE_SUPPORT)
    x_memcpy((void*)rPesInfo.au1PicInfo, (void*)prPes->au1PicInfo, DMX_PICINFO_SIZE);
#endif

#ifdef SWDMX_DUMP_DATA
    _SWDMX_DumpVFifo(prSwdmxInst, rPesInfo.u4VldReadPtr);
#endif
  if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.fgBandWidthChg) && ((rPesInfo.ucPicType & 0x1f) <= 0x5))
  {
    rPesInfo.fgBandwidthChanged = TRUE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.fgBandWidthChg = FALSE;
  }
  
    UNUSED(VDEC_SendEs((void*)&rPesInfo));
    
#ifdef SWDMX_RVU_PARSE_PTS
    x_memcpy((VOID*)prPes, (VOID*)prDmxPes, sizeof(DMX_PES_MSG_T));
#endif

    /*--------- */
    if(((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
        (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK)) &&
       (prPes->u1Channel == prSwdmxInst->u1VdecId))
    {
        if(prPes->fgEOS)
        {
            LOG(3,"_SWDMX_MpgVideoCallback set eos done to vdec\n ");
            VDEC_SetMMParam(prSwdmxInst->u1VdecId, VDEC_MM_SWDMX_SEND_EOS_DONE, TRUE, 0, 0);        
        }
    }    
    
    
    if (prSwdmxInst->u4LogFilter & check_video_pts)
    {
        LOG(1, "VC PTS=0x%X RP=0x%X PicType(0x%x) u4BitRate=0x%X fgBandwidthChanged=0x%X Pos=0x%llX\n",
               rPesInfo.u4PTS, rPesInfo.u4VldReadPtr, rPesInfo.ucPicType,rPesInfo.u4BitRate,rPesInfo.fgBandwidthChanged,
               prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize);
    }
    
/*
    if(prPes->fgEOS)
    {
        if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
           (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
        {
            LOG(3, "_SWDMX_MpgVideoCallback send 2nd EOS\n");
            if(rPesInfo.ucEsId == prSwdmxInst->u1VdecId)
            {
                rPesInfo.ucEsId = prSwdmxInst->u1Vdec2Id;
            }
            else
            {
                rPesInfo.ucEsId = prSwdmxInst->u1VdecId;
            }
            UNUSED(VDEC_SendEs((void*)&rPesInfo));
        }
    }
*/
    UNUSED(u4Addr);
    return TRUE;
}


VOID _SWDMX_MpgSeekFinNotify(UINT8 u1SrcId, UINT32 u4PTS, BOOL fgAgain)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);    
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);
	if(prSwdmxInst->u4LogFilter & check_handle_seek)
	{
		LOG(2,"%s: _SWDMX_MpgSeekFinNotify again %d u2JumpAgainCount %u\n",__FUNCTION__, fgAgain, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2JumpAgainCount + 1);
	}
    //VERIFY (x_sema_unlock(_hPlayMgrSemaFinSeek) == OSR_OK);
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext = TRUE;
    /* just use ts dash function */
    if(prSwdmxInst->rCurRangeReq.prDmxRangeInfo->e_mm_src_type == MM_SRC_TYPE_NETWORK_DASH)
    {
       /* temp no req data mw set pause until recieve MW notify */
        
        _SWDMX_RANGE_CALLBACK(
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
            MM_RANGE_GET_IFRAME,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
            0xFFFFFFFF,
            (UINT32)u1SrcId);
            
        LOG(5,"Swdmx notify MW recieve I Frame\n");        
    }
    
    if(fgAgain)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2JumpAgainCount++;
    }
    else
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2JumpAgainCount = 0;
    }
    UNUSED(u4PTS);
}

VOID _SWDMX_MpgTimeSeekFinNotify(UINT32 u4Pts,UINT8 u1AttachedSrcId)
{
      
    LOG(5,"_SWDMX_MpgTimeSeekFinNotify pts 0x%x \n",u4Pts);
}

BOOL _SWDMX_MpgResetFeeder(UINT8 u1SrcId)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);

    UINT32 u4ReqCnt;
    INT32 i4Ret;
    UINT32 u4AlignSize;
    FEEDER_TRANSMIT_COND rFeederCond;

    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if (FeederGetBufferInfo(prSwdmxInst->eFeederSrc, &prSwdmxInst->rFeederInfo) !=
      FEEDER_E_OK)
    {
        LOG(1, "Feeder input buffer error.\n");
        return FALSE;
    }

    #ifdef SWDMX_MPG_DEBUG_BUFFER
    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt > 0) || (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes > 0))
    {
        LOG(7, "Mpg Fd Flh UB %d BT %d RT %d BWI %d BRI %d BAC %d RWI %d RRI %d RT %d UAdr %d\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufTotalSize,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufWriteIdx,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingStartAddr);
    }
    #endif

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqID += SWDMX_FEEDER_ID_GAP; // always a even value
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqIBCID = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufWriteIdx = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufTotalSize = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimeoutCount = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqBufFullCount = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;

    for(u4ReqCnt = 0;u4ReqCnt < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum;u4ReqCnt++)
    {
        // make it invalid, not a even value
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqId[u4ReqCnt] = 1;
#ifdef SWDMX_MPG_DEBUG_INPUT_DATA
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqDup[u4ReqCnt] = 0;
#endif
    }

    #if 1//def CC_DLNA_SUPPORT
    FeederSetReadyThreshold(prSwdmxInst->eFeederSrc, MPG_DLNA_FEEDER_UNREACH);
    FeederSetUnderFlowThreshold(prSwdmxInst->eFeederSrc, MPG_DLNA_FEEDER_UNREACH);
    FeederSetInfo(prSwdmxInst->eFeederSrc, FEEDER_SWDMX_THRESHOLD, FALSE);
    #endif
    // Update read ptr to feeder
    if(IS_PUSH_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type))
    {
    }
    else
    {
        if(prSwdmxInst->rFeederInfo.u4WriteAddr)
        {
            if(FeederUpdateReadPointer(prSwdmxInst->eFeederSrc, prSwdmxInst->rFeederInfo.u4WriteAddr) != FEEDER_E_OK)
            {
                LOG(1, "_SWDMX_MpgResetFeeder FeederUpdateReadPointer fail\n");
            }
        }
    }
    
    if ( !IS_PUSH_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type) &&
        (prSwdmxInst->eSeekType !=  eSWDMX_TYPE_TIME_SEEK))
    {
        // DDI is 4 byte alignment
        if ( !IS_PUSH_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type) )
        {
            u4AlignSize = (prSwdmxInst->rFeederInfo.u4WriteAddr % 4);
            if(u4AlignSize > 0)
            {
                LOG(5, "Mpg Fd align u4WriteAddr %d\n",
                    prSwdmxInst->rFeederInfo.u4WriteAddr);
                i4Ret = FeederSetRequest(prSwdmxInst->eFeederSrc,
                        (4-u4AlignSize),
                        (UINT64)(0),
                        &rFeederCond,
                        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqID-25)); // 25 is a past requestID
                if(i4Ret != FEEDER_E_OK)
                {
                    LOG(1, "Mpg Fd align FeederSetRequest Fail\n");
                    /* not necessary
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = TRUE;
                    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetInfo)
                    {
                        _SWDMX_MpgHandleEOS(i4PlaySpeed);
                    }
                    if(prRangeList)
                    {
                        prRangeList->eRangeStats = eSWDMX_RANGE_STATE_PENDING;
                    }
                    */
                    return FALSE;
                }
            }
        }
    }
    
    return TRUE;
}

VOID _SWDMX_MpgResetInputData(UINT8 u1SrcId)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    _SWDMX_FlushReqMsgQ(u1SrcId);
    UNUSED(_SWDMX_MpgResetFeeder(u1SrcId));

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize = 0;

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->eRangeStats = eSWDMX_RANGE_STATE_NOT_FINISHED;
    }
}

VOID _SWDMX_MpgResetData(UINT8 u1SrcId)
{
    BOOL fgRet;
    UINT32 i;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    _SWDMX_MpgFlushAFifo(u1SrcId);
    _SWDMX_MpgFlushVFifo(u1SrcId);
    _SWDMX_MpgFlushPreBuffer(u1SrcId);
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio != 0xFF)
    {
        UNUSED(DMX_MM_FlushBuffer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio));
    }
    // 0831
    if(prSwdmxInst->fgEnAudio2Dmx)
    {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2 != 0xFF)
        {
            _SWDMX_MpgFlushAFifo2(u1SrcId);
            UNUSED(DMX_MM_FlushBuffer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2));
        }
    }
    // 0831
    if(prSwdmxInst->fgEnAudio3Dmx)
    {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3 != 0xFF)
        {
            _SWDMX_MpgFlushAFifo3(u1SrcId);
            UNUSED(DMX_MM_FlushBuffer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3));
        }
    }    
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo != 0xFF)
    {
        UNUSED(DMX_MM_FlushBuffer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo));
    }
    if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
        (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
    {
        _SWDMX_MpgFlushVFifo2(u1SrcId);
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo2 != 0xFF)
        {
            UNUSED(DMX_MM_FlushBuffer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo2));
        }
    }
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFirst = TRUE;
    //if(prSwdmxInst->fgEnVideoDmx)
    //{
    //    SWDMX_SetInfo((UINT8)eSWDMX_DISABLE_STREAM, (UINT32)eSWDMX_STRM_TYPE_VID, 0, 0);
    //    SWDMX_SetInfo((UINT8)eSWDMX_ENABLE_STREAM, (UINT32)eSWDMX_STRM_TYPE_VID, 0, 0);
    //}
    //_u4BufStart = 0;
    _SWDMX_FlushReqMsgQ(u1SrcId);
    UNUSED(_SWDMX_MpgResetFeeder(u1SrcId));
    // This might put before _SWDMX_MpgFlushAFifo, DMX_MM_FlushBuffer
    // because write might meet read pointer, and DDI is in full status,
    // then _SWDMX_DMX_Reset will cause DMX in strange status.
    // so DMX_DDI_MoveData can't return when next call DMX_DDI_MoveData.
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_RAW_AUDIO_ES)
    {
        fgRet = _SWDMX_DMX_Reset(u1SrcId);//DMX_DDI_RequestReset();
        if(!fgRet)
        {
            LOG(3, "_SWDMX_MpgResetData _SWDMX_DMX_Reset Fail\n");
        }
    }
    //#define DMXCMD_READ321(offset)            IO_READ32((IO_VIRT + 0x17000), ((offset) * 4))
    //LOG(3, "_SWDMX_MpgResetData DMXCMD 0x%x\n", DMXCMD_READ321(26));

    // For es file, DMX_DDI_RequestReset will reset the value set
    // by DMX_ES_SetFileLength. So set it again.
    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_VIDEO_ES) ||
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_H264_VIDEO_ES) ||
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG4_VIDEO_ES) ||
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_VC1_ES) ||
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_AVS_VIDEO_ES) ||
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_H265_VIDEO_ES))
    {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo != 0xFF)
        {
            fgRet = DMX_ES_SetFileLength(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo,(UINT32)0xFFFFFFFF);
            if(!fgRet)
            {
                LOG(3, "_SWDMX_MpgResetData _DMX_ES_SetFileLength Fail\n");
            }
        }
    }


    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize = 0;
    // DTV00211818, mp3 audio es
    // pause and seek, then play
    // we will have fgSendEOF = 1, clean it.
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio2Eos = 0;    
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio3Eos = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = FALSE;
#if 1//def CC_DLNA_SUPPORT
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.fgGetEof = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.fgLastData = FALSE;
#endif
    //_u4AvailSize = 0;

    // DTV00212560, [5387-FLIP][MM]Total time change after time search to the beginning with special file
    // when change position, we should clean LastPTS data.
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTSCnt = 0;
    for(i=0;i<MPG_PTS_CHECK_NUM;i++)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.au4LastPTS[i] = 0;
    }

#ifdef TIME_SHIFT_SUPPORT
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4QueueTickNum = 0xFFFFFFFF;
    for(i=0;i<MPG_TIME_SHIFT_ADDRESS_CHECK_NUMBER;i++)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8QueueStartAddr[i] = (0);
    }
#endif

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSystemB)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SystemBPacketSize = 0x100000;
    }

    //DTV00135555 [MM]TV stop at current video file after excute play and FF
    //DTV00210492 when do seek or trick after sended EOS, RangeStatus should set NOT_FINISHED
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->eRangeStats = eSWDMX_RANGE_STATE_NOT_FINISHED;
    }

#ifdef SWDMX_MPG_DEBUG_FIFO
#ifdef SWDMX_MPG_AFIFO_SIZE
    _u4AFifoCur = _u4AFifoStart;
    _u4AudioLastWriter = 0;
#endif
#ifdef SWDMX_MPG_DMXFIFO_SIZE
    _u4DmxFifoCur = _u4DmxFifoStart;
#endif
#endif
}
/*---------------------------------------------*/
/*  this api use time-based seek & FF FR case  */
/*---------------------------------------------*/
VOID _SWDMX_MpgResetTimeVariable(UINT8 u1SrcId)
{
     SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
     SWDMX_MPG_VERIFY_NULL(prSwdmxInst);
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSeekvid = TRUE;

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS = 0xFFFFFFFF;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SecondVideoPTS = 0xFFFFFFFF;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS = 0xFFFFFFFF;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastMemoryPTS = 0;
#ifdef HANDLE_CODEC_PID_CHG 
  prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4VideoPTSKeeper = 0;  
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgDisableStrm = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgDisableTriggerErrHdlr = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFlushAudData = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFlushVidData = FALSE;
#endif
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgLastMemory = FALSE;        
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgHaveVideoData = FALSE;                
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidPidChg = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudPidChg = FALSE;         
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdVidId  = 0xFFFF;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdAudId  = 0xFFFF; 
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidCodecChg = FALSE; 
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudCodecChg = FALSE; 
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4DmxPreviousAvailSizeVideo = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4DmxPreviousAvailSizeAudio = 0;                
    prSwdmxInst->eUpdVideoType = ENUM_SWDMX_VDEC_UNKNOWN;
    prSwdmxInst->eUpdAudioType = ENUM_SWDMX_ADEC_UNKNOWN;        
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideoReady = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetFirstAudPts = FALSE;  //DTV00093908     
#ifdef SWDMX_MPG_CHECK_MP3_AUDIO
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4Mp3Cnt = 0;
#endif
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgChangeVideo = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicCnt = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPTSFound = FALSE;    
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos ;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPosWithPTSFound = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8Previous2IPosWithPTSFound = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = 0;

    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousUIPos = 
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = TRUE;
    }
    else
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = FALSE; // PTS reset
    }
}

VOID _SWDMX_MpgResetVariable(UINT8 u1SrcId)
{
    UINT32 i;
     SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
     SWDMX_MPG_VERIFY_NULL(prSwdmxInst);
     _SWDMX_MpgResetData(u1SrcId);
    //_SWDMX_FlushDataMsgQ();

    #if 0 // move to ResetData
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = FALSE;
    #endif
#if 1//def CC_DLNA_SUPPORT
    FeederSetInfo(prSwdmxInst->eFeederSrc, FEEDER_SWDMX_EOS, FALSE);
#endif
    // for step lose audio
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpping = FALSE;
    //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFirst = TRUE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToDecoder = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToADec = FALSE;

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTSCnt = 0;
    for(i=0;i<MPG_PTS_CHECK_NUM;i++)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.au4LastPTS[i] = 0;
    }
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS = 0xFFFFFFFF;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SecondVideoPTS = 0xFFFFFFFF;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS = 0xFFFFFFFF;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4GetFirstAudioPTS    = 0;    //DTV00093908    
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS = 0;                          //DTV00139313
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4DeltaAudioPTS = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4DeltaVideoPTS = 0;
    x_memset(&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rLastACBTime, 0, sizeof(HAL_TIME_T));
    x_memset(&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rLastVCBTime, 0, sizeof(HAL_TIME_T));
    x_memset(&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rDeltaACBTime, 0, sizeof(HAL_TIME_T));
    x_memset(&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rDeltaVCBTime, 0, sizeof(HAL_TIME_T));
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurABasePTS = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurVBasePTS = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ShakeTime = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastMemoryPTS = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgLastMemory = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgHaveVideoData = FALSE;    
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidPidChg = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudPidChg = FALSE; 
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdVidId  = 0xFFFF;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdAudId  = 0xFFFF;       
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidCodecChg = FALSE; 
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudCodecChg = FALSE; 
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4DmxPreviousAvailSizeVideo = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4DmxPreviousAvailSizeAudio = 0;        
    prSwdmxInst->eUpdVideoType = ENUM_SWDMX_VDEC_UNKNOWN;
    prSwdmxInst->eUpdAudioType = ENUM_SWDMX_ADEC_UNKNOWN;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideoReady = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetFirstAudPts = FALSE;    //DTV00093908
#ifdef TIME_SHIFT_SUPPORT
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage = MPG_TSS_NORMAL;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1NumNoSignal = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNeedAdjust = FALSE;
#endif
#ifdef SWDMX_MPG_CHECK_MP3_AUDIO
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4Mp3Cnt = 0;
#endif
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio2 = FALSE; // 0831    
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio3 = FALSE; // 0831    
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgChangeVideo = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgResetPosAfterFoundSeq = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicCnt = 0;
    //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTimeOffset = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurIndexNum = 0;

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoWptr = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideo2Wptr = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioWptr = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio2Wptr = 0; // 0831    
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio3Wptr = 0; // 0831    
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioFifoDataSize = 0;

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPTSFound = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPosWithPTSFound = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8Previous2IPosWithPTSFound = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SeqHdrChk=0;

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8OffsetKeep = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8OffsetIKeep = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4TempRefKeep = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2DecodingOrderKeep = 0;

    #if 1//def CC_DLNA_SUPPORT
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.fgGetEof = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.fgLastData = FALSE;
    #endif
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetKey = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoScramble = FALSE; 
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudioScramble = FALSE;

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotStartToPlay = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicStartPlayOrgPTS = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AudStartPlayOrgPTS = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AudStartPlayPTS = 0;

#ifdef TIME_MEASUREMENT
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.fgUsingPrintTMS = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCbPrintTMS = FALSE;
#endif
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CbPrintPTS = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PushDataTime = 0;

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FakeTime = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPauseMoving = TRUE;
    
    return ;
}

VOID _SWDMX_MpgJumpToNormal(UINT8 u1SrcId, BOOL fgSeek, BOOL fgSeekOffset, BOOL fgJumpping, INT32 i4Speed)
{
    BOOL fgRet;
    UINT16 u2DecodingOrder;
    INT32 i4TempRef;
    UINT64 u8Offset, u8OffsetI;
    VDP_PIC_INFO_T rPicInfo;
    BOOL fgNoI;

    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    x_memset(&rPicInfo, 0, sizeof(VDP_PIC_INFO_T));
    if(fgJumpping || fgSeek)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS = 0xFFFFFFFF;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SecondVideoPTS = 0xFFFFFFFF;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS = 0xFFFFFFFF;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4DeltaAudioPTS = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastMemoryPTS = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgLastMemory = FALSE;
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
        {
            if(!fgSeek)
            {
                u8Offset = 0;
                u8OffsetI = 0;
                u2DecodingOrder = 0;
                i4TempRef = 0;
                fgNoI = FALSE;
                #ifdef TIME_SHIFT_SUPPORT
                if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT) &&
                   ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage == MPG_TSS_UNDER_NO_SIGNAL) ||
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage == MPG_TSS_UNDER_BAD_STORAGE)))
                {
                    // Do not change corrent position when we are no signal/bad now.
                    u8Offset = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                    u8OffsetI = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                }
                else
                #endif
                {
                    // from now, we use file position of last displayed picture.
                    fgRet = (VDP_GetFilePosition(prSwdmxInst->u1B2rId, &i4TempRef, &u2DecodingOrder, &u8Offset, &u8OffsetI));

                    if(fgRet)
                    {
                        if(((UINT32)(u8OffsetI>>32) == (UINT32)0xFFFFFFFF)
                            && ((UINT32)(u8OffsetI) == (UINT32)0xFFFFFFFF))
                        {
                            u8OffsetI = u8Offset;
                            LOG(3, "_SWDMX_MpgJumpToNormal No I, start from 0x%llx\n",
                                u8OffsetI);
                            fgNoI = TRUE;
                        }
                        if((u8Offset == 0) &&(u8OffsetI == 0)&&(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
                        {
                            u8Offset = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                            u8OffsetI = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                            LOG(3,"_SWDMX_MpgJumpToNormal u8Offset is 0,u8OffsetI is 0!\n");
                        }
                    }
                    else
                    {
                        u8Offset = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                        u8OffsetI = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                        fgNoI = TRUE;
                        LOG(5, "_SWDMX_MpgJumpToNormal VDP_GetFilePosition fail\n");
                    }

                    if(u8OffsetI > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize)
                    {
                        LOG(3, "_SWDMX_MpgJumpToNormal VDP_GetFilePosition u8OffsetI 0x%llx > u8FileSize 0x%llx\n",
                            u8OffsetI,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize);
                        u8Offset = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize;
                        u8OffsetI = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize;
                    }

                    fgRet = (VDP_GetPicInfo(prSwdmxInst->u1B2rId, &rPicInfo));
                    if(fgRet)
                    {
                        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
                        {
                            LOG(3,"_SWDMX_MpgJumpToNormal pic info : 0x%x!\n",rPicInfo.u4TickNum);
                            if(rPicInfo.u4TickNum != 0)
                            {
                                #ifdef TIME_SHIFT_SUPPORT
                                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum = rPicInfo.u4TickNum;
                                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ReadTickNum = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum;
                                #endif                        
                                // DTV00352271, reset the pts if can get form vdp.
                                //if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed == 1)
                                {
                                    STC_SetStcValue(prSwdmxInst->u1StcId, rPicInfo.u4Pts);
                                    LOG(5, "the reset stc after step is 0x%x!\n", rPicInfo.u4Pts);
                                }
                            }
                        }
                        else
                        {
                            STC_SetStcValue(prSwdmxInst->u1StcId, rPicInfo.u4Pts);
                            LOG(5, "the reset stc after step is 0x%x!\n", rPicInfo.u4Pts);
                        }
                    }
                    else
                    {
                        #ifdef TIME_SHIFT_SUPPORT
                        //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum = rPicInfo.u4TickNum;
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ReadTickNum = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum;
                        #endif
                        LOG(5, "_SWDMX_MpgJumpToNormal VDP_GetPicInfo fail\n");
                    }
                }
                
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X = u8Offset;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPTSFound = FALSE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = u8OffsetI;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = u8OffsetI;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = u8OffsetI;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = u8OffsetI;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize = 0;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos = u8OffsetI;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPosWithPTSFound = u8OffsetI;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8Previous2IPosWithPTSFound = u8OffsetI;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize = u8OffsetI;
                
                if (fgNoI || (MM_SRC_TYPE_IPTV == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type))
                {
                    UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
                    UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1VdecId, TRUE, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
                    if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                       (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                    {
                        UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                        UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1Vdec2Id, TRUE, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
                    }
                    LOG(5, "_SWDMX_MpgJumpToNormal VDEC_SetRenderFromFirstPic from 0x%llx\n", u8OffsetI);
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = 0;
                }
                else
                {
                    UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1VdecId, TRUE, u8Offset, i4TempRef, u2DecodingOrder));
                    LOG(5, "_SWDMX_MpgJumpToNormal VDEC_SetRenderFromPos I:0x%llx, 0x%llx, PTS:0x%x, i4TempRef: %d\n",
                        u8OffsetI, u8Offset, rPicInfo.u4Pts, i4TempRef);
                    UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1VdecId, FALSE, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
                    if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                       (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                    {
                        UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1Vdec2Id, TRUE, u8Offset, i4TempRef, u2DecodingOrder));
                        UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1Vdec2Id, FALSE, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
                    }
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = ((rPicInfo.u4Pts - (MPG_STC_BASE))+ prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS);
                }
                
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS = 0xFFFFFFFF;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SecondVideoPTS = 0xFFFFFFFF;
                UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
                if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                   (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                {
                    UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                }
            }
            else if(fgSeekOffset)
            {
                LOG(5, "_SWDMX_MpgJumpToNormal fgSeek fgSeekOffset\n");
            }
            else
            {
                UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
                UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
                UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1VdecId, TRUE, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
                if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                   (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                {
                    UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                    UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                    UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1Vdec2Id, TRUE, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
                }                
                LOG(5, "_SWDMX_MpgJumpToNormal fgSeek\n");
            }
            //STC_StopStc(prSwdmxInst->u1StcId);
            //STC_SetStcValue(prSwdmxInst->u1StcId, 0);
            MPV_FlushEsmQ(prSwdmxInst->u1VdecId, FALSE);
            UNUSED(VDEC_ReleaseDispQ(prSwdmxInst->u1VdecId));
            if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
               (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
            {
                MPV_FlushEsmQ(prSwdmxInst->u1Vdec2Id, FALSE);
                UNUSED(VDEC_ReleaseDispQ(prSwdmxInst->u1Vdec2Id));
            }
            VDP_ResetPts(prSwdmxInst->u1B2rId);
            UNUSED(VDEC_RegTrickPtsCb(prSwdmxInst->u1VdecId,
                        NULL, u1SrcId));

            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)||
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192)) // set the flag for TS H.264 wait IDR frame
            {
               VDEC_SetWaitPvrSps(prSwdmxInst->u1VdecId,1);
                if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                   (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                {
                    VDEC_SetWaitPvrSps(prSwdmxInst->u1Vdec2Id,1);
                }
            }            
            if(fgSeek)
            {
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
                {
                    VDP_SetSeek(prSwdmxInst->u1B2rId, 
                                1,
                                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed >= 0) ? 0 : (UINT32)-1);
                    LOG(5,"Set to B2r seek \n");
                }
            }
        }
        else
        {
            #ifdef TIME_SHIFT_SUPPORT
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
            {
                BOOL fgRet;
                u8Offset = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                fgRet = _SWDMX_MpgGetPosByTickNum(u1SrcId,
                    TRUE,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum,
                    &u8Offset);
                if(fgRet)
                {
#if 1
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ReadTickNum =
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum;
#endif
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = u8Offset;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = u8Offset;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = u8Offset;
                }
                else
                {
                    LOG(5, "_SWDMX_MpgJumpToNormal: CurTickNum %d fail\n",
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum);
                }
            }
            #endif
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPTSFound = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPosWithPTSFound = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8Previous2IPosWithPTSFound = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        }

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio2Eos = FALSE; // 0831        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio3Eos = FALSE; // 0831        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = FALSE;
#if 1//def CC_DLNA_SUPPORT
        FeederSetInfo(prSwdmxInst->eFeederSrc, FEEDER_SWDMX_EOS, FALSE);
#endif
        //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFirst = TRUE;

        _SWDMX_MpgResetData(u1SrcId);

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = FALSE; // PTS reset
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgHaveVideoData = FALSE;     
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidPidChg = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudPidChg = FALSE;   
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdVidId  = 0xFFFF;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdAudId  = 0xFFFF;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidCodecChg = FALSE; 
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudCodecChg = FALSE; 
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4DmxPreviousAvailSizeVideo = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4DmxPreviousAvailSizeAudio = 0;        
        prSwdmxInst->eUpdVideoType = ENUM_SWDMX_VDEC_UNKNOWN;
        prSwdmxInst->eUpdAudioType = ENUM_SWDMX_ADEC_UNKNOWN;        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideoReady = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = FALSE;
#ifdef TIME_SHIFT_SUPPORT
        // Don't need to change it when chagne speed.
        //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage = MPG_TSS_NORMAL;
#endif
#ifdef SWDMX_MPG_CHECK_MP3_AUDIO
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4Mp3Cnt = 0;
#endif
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio2 = FALSE; // 0831        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio3 = FALSE; // 0831        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio2Eos = FALSE; // 0831        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio3Eos = FALSE; // 0831        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgChangeVideo = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicCnt = 0;
        //_fgSetAudioStartTime = FALSE;

        LOG(5, "_SWDMX_MpgJumpToNormal Jump\n");
    }
    else
    {   
        //DTV00320791, when change from "step" to "normal play" we should set STC value agian.
        fgRet = (VDP_GetPicInfo(prSwdmxInst->u1B2rId, &rPicInfo));
        if (fgRet)
        {
            
            STC_SetStcValue(prSwdmxInst->u1StcId, rPicInfo.u4Pts);
            STC_StartStc(prSwdmxInst->u1StcId);

            LOG(5, "_SWDMX_MpgJumpToNormal set STC value (0x%x)\n",rPicInfo.u4Pts);
        }

        if (prSwdmxInst->rCurRangeReq.prDmxRangeInfo->e_mm_src_type == MM_SRC_TYPE_NETWORK_RVU) /* for RVU step  operation */
        {
            UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1VdecId, TRUE, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
            LOG(5, "_SWDMX_MpgJumpToNormal VDEC_SetRenderFromFirstPic\n");
        }
        
        LOG(5, "_SWDMX_MpgJumpToNormal\n");
    }
    
    /* due to add prebuffer ,so jump to normal case need flush hard buffer */
  if(prSwdmxInst->fgEnablePrebuffer)
  {
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
    {
      UINT32 u4CurPts;
      UINT32 u4APts;
      SWDMX_AUDIO_STREAM_T *pt_audio_stream = NULL;
    
      LOG(5,"flush audio hard buffer \n");
      
      u4CurPts = VDP_GetPts(prSwdmxInst->u1B2rId);
      LOG(5,"Source cur pts 0x%x\n",u4CurPts);
      
      u4CurPts += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS;
      
      pt_audio_stream = &prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.t_audio_stream_info;
      
      if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio != 0xFF)
      {
         DMX_MM_FlushBuffer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio);
      }
    
      fgRet = DMX_AudHandler_SeekAndUpdate(pt_audio_stream->t_audio_stream[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1CurATrackIdx].u1Pidx,
                         (u4CurPts + 6000), &u4APts);
    
      if (fgRet)
      {
        u4APts -= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS;
        LOG(5, "Find audio in the pre-buffer u4APts 0x%x\n",u4APts);
        AUD_SetStartPts(prSwdmxInst->u1AdecId, u4APts);
      }
      else
      { 
        /* due to pts jump,may be can not found audio pts with > u4CurPts */
        /* swdmx reenable condition : cur audio pts > cur video pts */
        LOG(5, "Can't find audio in the pre-buffer\n");
      } 

	  prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToADec = FALSE;
      DMX_AudHandler_SetActivePidx(pt_audio_stream->t_audio_stream[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1CurATrackIdx].u1Pidx); 
      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSetActivePid = TRUE;
      
      
      }
  }
    
    UNUSED(i4Speed);
}

VOID _SWDMX_MpgHandleSeekAudio(UINT8 u1SrcId, INT32 i4PlaySpeed, BOOL fgSeek)
{
    UINT32 u4Speed;
    UINT64 u8Tmp;
    UINT64 u8Remainder;

    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    if(i4PlaySpeed >= 0)
    {
        LOG(3, "_SWDMX_MpgHandleSeekAudio i4PlaySpeed >= 0\n");
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpping = FALSE;
        return;
    }
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime == 0)
    {
        LOG(3, "_SWDMX_MpgHandleSeekAudio u4TotalTime == 0\n");
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpping = FALSE;
        return;
    }

    u4Speed = (i4PlaySpeed > 0) ? i4PlaySpeed : -i4PlaySpeed;
    u4Speed /= 1000;
    u8Tmp = _SWDMX_Div6464(((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset)*MPG_AUDIO_ES_SKIP_TIME), (UINT64)(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime), &u8Remainder);
    u8Tmp *= u4Speed;
    UNUSED(u8Remainder);
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos > u8Tmp)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos -= u8Tmp;

        {
            UINT64 u8Remainder;
            UNUSED(_SWDMX_Div6464((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset), (UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase, &u8Remainder));
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos -= u8Remainder;
        }

        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst->u.pt_pb_idx_tbl_entry)
          )
        {
            MM_RANGE_ELEMT_IDXTBL_PB_ENTRY_T* prTblEntry = NULL;
            MM_RANGE_ELMT_IDXTBL_T* prIdxTbl = NULL;
            {
                UINT64 u8IdxBaseAddr;
                UINT64 u8IdxStartAddr;
                UINT64 u8IdxEndAddr;
                u8IdxBaseAddr =
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst->ui8_base_offset;
                prIdxTbl = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst;
                prTblEntry = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst->u.pt_pb_idx_tbl_entry;
                if((prTblEntry) && (prIdxTbl))
                {
                    if(prIdxTbl->ui4_number_of_entry > 0)
                    {
                        u8IdxEndAddr = u8IdxBaseAddr +
                            (UINT64)prTblEntry[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurIndexNum].ui4_relative_offset +
                            (UINT64)prTblEntry[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurIndexNum].ui4_size;

                        if(((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos) >=
                            (u8IdxEndAddr)
                           )
                           ||
                           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurIndexNum >= prIdxTbl->ui4_number_of_entry)
                          )
                        {
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurIndexNum = (prIdxTbl->ui4_number_of_entry-1);
                        }
                        while(1)
                        {
                            u8IdxEndAddr = u8IdxBaseAddr +
                                (UINT64)prTblEntry[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurIndexNum].ui4_relative_offset +
                                (UINT64)prTblEntry[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurIndexNum].ui4_size;

                            if(((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos) >=
                                (u8IdxBaseAddr +
                                 prTblEntry[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurIndexNum].ui4_relative_offset
                                )
                               )
                               &&
                               ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos) <
                                (u8IdxEndAddr)
                               )
                              )
                            {
                                break;
                            }
                            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurIndexNum == 0)
                            {
                                break;
                            }
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurIndexNum--;
                        }
                        u8IdxStartAddr = u8IdxBaseAddr +
                            prTblEntry[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurIndexNum].ui4_relative_offset;
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = u8IdxStartAddr;
                    }
                    else
                    {
                        LOG(3, "_SWDMX_MpgHandleSeekAudio ui4_number_of_entry 0\n");
                    }
                }
                else
                {
                    LOG(3, "_SWDMX_MpgHandleSeekAudio prTblEntry NULL\n");
                }
            }

        }

        LOG(5, "_SWDMX_MpgHandleSeekAudio new pos 0x%llx\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos);
    }
    else
    {
        // end seek
        //change for DTV00098584
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset;
        
        LOG(5, "_SWDMX_MpgHandleSeekAudio end seek\n");
    }

    // can't flush audio data, or we can't play audio
    //_SWDMX_MpgResetData(u1SrcId);
    if (i4PlaySpeed < 0)
    {
        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousUIPos)
        {
           LOG(1,"_SWDMX_MpgHandleSeekAudio current UI pos[0x%llx] < u8PlayPos[0x%llx] ,should reset u8PlayPos \n",
               prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousUIPos,
               prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos);
           prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousUIPos;
        }    
    }      
    _SWDMX_FlushReqMsgQ(u1SrcId);
    UNUSED(_SWDMX_MpgResetFeeder(u1SrcId));
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize = 0;
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->eRangeStats = eSWDMX_RANGE_STATE_NOT_FINISHED;
    }

    _SWDMX_MpgModifyPlayPos(u1SrcId);
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio2 = FALSE; // 0831    
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio3 = FALSE; // 0831    
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
}

static UINT64 _SWDMX_MpgGetAvgBitRate(UINT8 u1SrcId)
{
    UINT64 u8AvgSize = 0x7800 * 30;      // Set default AvgSize
    SWDMX_INFO_T *prSwdmxInst = NULL;
    VDP_PIC_INFO_T rPicInfo;

    prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    if (!prSwdmxInst)
    {
        LOG(1, "Get Inst Failed. Inst(%d)\n", u1SrcId);
        goto EXIT_POINT;
    }
    
    UNUSED(rPicInfo);
    
#ifdef TIME_SHIFT_SUPPORT
    if (SWDMX_FMT_MPEG2_TS_TIME_SHIFT == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt)
    {
        UINT32 u4TickStart, u4TickEnd, u4Tmp, u4TickNum, u4Time;
        UINT64 u8StartPos, u8EndPos, u8Remainder;

        if (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgValidRange)
        {
            LOG(3, "_SWDMX_MpgGetAvgBitRate valid range is not set\n");
            goto EXIT_POINT;
        }
        
        _SWDMX_LockRangeSema(u1SrcId);
        
        // Calc current startTick
        {
            if (VDP_SET_OK == VDP_GetPicInfo(prSwdmxInst->u1B2rId, &rPicInfo))
            {
                u4TickStart = rPicInfo.u4TickNum;
            }
            else
            {
                u4TickStart = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum;
            }
        }
        
        // Get the End Tick num, 4s
        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TickBase>0 &&
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TickBase<1000)
        {
            u4TickEnd = u4TickStart + 4*(1000/prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TickBase);
        }
        else
        {
            LOG(3, "Src[%d] Error u4TickBase(%d)... ...\n", u1SrcId, 
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TickBase);
            _SWDMX_UnlockRangeSema(u1SrcId);
            goto EXIT_POINT;
        }

        // Modify Tick number to Safe range
        {
            if (u4TickEnd > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeEndTick)
            {
                u4Tmp = 0;
                u4Tmp = u4TickEnd - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeEndTick;
                u4TickEnd = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeEndTick;

                if (u4TickStart > u4Tmp)
                {
                    u4TickStart -= u4Tmp;
                }
                else
                {
                    u4TickStart = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeStartTick;
                }
            }
        } 
        
        if ( u4TickEnd<prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeStartTick ||
             u4TickEnd>prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeEndTick )
        {
            _SWDMX_UnlockRangeSema(u1SrcId);
            goto EXIT_POINT;
        }
        
        if ( u4TickStart<prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeStartTick ||
             u4TickStart>prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeEndTick )
        {
            _SWDMX_UnlockRangeSema(u1SrcId);
            goto EXIT_POINT;
        }

        /*if (0 == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ValidStartTick)
        {
            _SWDMX_UnlockRangeSema(u1SrcId);
            goto EXIT_POINT;
        }*/
        
        if (u4TickEnd <= u4TickStart)
        {
            LOG(3, "Src[%d] End<Start u8AvgSize(0x%llX)\n", u1SrcId, u8AvgSize);
            _SWDMX_UnlockRangeSema(u1SrcId);
            goto EXIT_POINT;
        }

        _SWDMX_UnlockRangeSema(u1SrcId);
        
        // Get position
        if (!_SWDMX_MpgGetPosByTickNum(u1SrcId, FALSE, u4TickStart, &u8StartPos))
        {
            LOG(3, "_SWDMX_MpgGetAvgBitRate Error, u4TickStart(%d) u8AvgSize(0x%llX)\n",
                   u4TickStart, u8AvgSize);
            goto EXIT_POINT;
        }

        if (!_SWDMX_MpgGetPosByTickNum(u1SrcId, FALSE, u4TickEnd, &u8EndPos))
        {
            LOG(3, "_SWDMX_MpgGetAvgBitRate Error, u4TickEnd(%d) u8AvgSize(0x%llX)\n",
                   u4TickEnd,  u8AvgSize);
            goto EXIT_POINT;
        }

        if (0 == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoSize)
        {
            LOG(3, "Src[%d] No Data info... ...\n", u1SrcId);
            goto EXIT_POINT;
        }
                
        u4TickNum = u4TickEnd - u4TickStart;
        // Calc AvgSize
        UNUSED(_SWDMX_Div6464((u8EndPos + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoSize - u8StartPos), 
                               prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoSize, &u8Remainder));
        u4Time = u4TickNum*10 / (1000/prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TickBase);

        u8AvgSize = _SWDMX_Div6464(u8Remainder*10, u4Time, &u8Remainder);

        if (u8AvgSize < 0xE000)     // We assume the low bitrate (in Byte) should larger than 0xE000 and high bitrate should less than 0xA000000 
        {
            u8AvgSize = 0xE000;
        }
        else if (u8AvgSize > 0xA000000)
        {
            u8AvgSize = 0xA000000;
        }
        
        LOG(5, "S(%d) E(%d) Range(0x%llX-0x%llX) AS(0x%llX)\n",
                u4TickStart, u4TickEnd, u8EndPos, u8StartPos, u8AvgSize);
    }
    else
#endif
    {
        // u8AvgSize = (UINT64)VDEC_GetAvgPicSize(prSwdmxInst->u1VdecId);
        LOG(3, "Src[%d] _SWDMX_MpgGetAvgBitRate Only used for Timeshift... ...\n", u1SrcId);
        goto EXIT_POINT;
    }
    
EXIT_POINT:
    return u8AvgSize;
}
VOID _SWDMX_MpgTimeJumpToNormal(UINT8 u1SrcId,BOOL fgFlush)
{
    BOOL fgRet;
    VDP_PIC_INFO_T rPicInfo;    
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);
    fgRet = (VDP_GetPicInfo(prSwdmxInst->u1B2rId, &rPicInfo));
    if (fgRet)
    {        
        STC_SetStcValue(prSwdmxInst->u1StcId, rPicInfo.u4Pts);
        STC_StartStc(prSwdmxInst->u1StcId);

        LOG(5, "_SWDMX_MpgTimeJumpToNormal set STC value (0x%x)\n",rPicInfo.u4Pts);
    }
    
    LOG(5, "_SWDMX_MpgTimeJumpToNormal\n");
    
    if (fgFlush)
    {
        _SWDMX_MpgResetTimeVariable(u1SrcId);
        _SWDMX_MpgResetData(u1SrcId);
        MPV_FlushEsmQ(prSwdmxInst->u1VdecId, FALSE);
        UNUSED(VDEC_ReleaseDispQ(prSwdmxInst->u1VdecId));
        if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
           (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
        {
            MPV_FlushEsmQ(prSwdmxInst->u1Vdec2Id, FALSE);
            UNUSED(VDEC_ReleaseDispQ(prSwdmxInst->u1Vdec2Id));
        }
        VDP_ResetPts(prSwdmxInst->u1B2rId);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartTime = rPicInfo.u4Pts;        
        VDEC_SetRenderFromPts(prSwdmxInst->u1VdecId,rPicInfo.u4Pts);
        if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
           (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
        {
            VDEC_SetRenderFromPts(prSwdmxInst->u1VdecId,rPicInfo.u4Pts);
        }   
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgStartJumpping = TRUE;
        
    }

}
VOID _SWDMX_MpgPlayOneFrame(UINT8 u1SrcId)
{
    ENUM_VDEC_FMT_T eVdecFmt = VDEC_FMT_MPV;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);
    UNUSED(VDP_SetPauseMm(prSwdmxInst->u1B2rId, FALSE));
    if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_MPEG1_MPEG2)
    {
        eVdecFmt = VDEC_FMT_MPV;
        if(!VDEC_PlayOneFrm(prSwdmxInst->u1VdecId, VDEC_FMT_MPV))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext = TRUE;
            LOG(3, "_SWDMX_MpgHandleSeek VDEC_PlayOneFrm VDEC_FMT_MPV fail\n");
        }
    }
    else if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_H264)
    {
        eVdecFmt = VDEC_FMT_H264;
        if(!VDEC_PlayOneFrm(prSwdmxInst->u1VdecId, VDEC_FMT_H264))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext = TRUE;
            LOG(3, "_SWDMX_MpgHandleSeek VDEC_PlayOneFrm VDEC_FMT_H264 fail\n");
        }
    }
    else if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_VC1)
    {
        eVdecFmt = VDEC_FMT_WMV;
        if(!VDEC_PlayOneFrm(prSwdmxInst->u1VdecId, VDEC_FMT_WMV))
        {
          prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext = TRUE;
            LOG(3, "_SWDMX_MpgHandleSeek VDEC_PlayOneFrm ENUM_SWDMX_VDEC_VC1 fail\n");
        }
    }
    else if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_AVS)
    {
        eVdecFmt = VDEC_FMT_AVS;
        if(!VDEC_PlayOneFrm(prSwdmxInst->u1VdecId, VDEC_FMT_AVS))
        {
          prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext = TRUE;
            LOG(3, "_SWDMX_MpgHandleSeek VDEC_PlayOneFrm ENUM_SWDMX_VDEC_AVS fail\n");
        }
    }
    else if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_MPEG4)
    {
        eVdecFmt = VDEC_FMT_MP4;
        if(!VDEC_PlayOneFrm(prSwdmxInst->u1VdecId, VDEC_FMT_MP4))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext = TRUE;
            LOG(3, "_SWDMX_MpgHandleSeek VDEC_PlayOneFrm ENUM_SWDMX_VDEC_MPEG4 fail\n");
        }
    }
    else if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_H265)
    {
        eVdecFmt = VDEC_FMT_H265;
        if(!VDEC_PlayOneFrm(prSwdmxInst->u1VdecId, VDEC_FMT_H265))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext = TRUE;
            LOG(3, "_SWDMX_MpgHandleSeek VDEC_PlayOneFrm ENUM_SWDMX_VDEC_H265 fail\n");
        }
    } 
    else
    {
        ASSERT(0);
    }
    if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
       (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
    {
        if(!VDEC_PlayOneFrm(prSwdmxInst->u1Vdec2Id, eVdecFmt))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext = TRUE;
            LOG(3, "_SWDMX_MpgHandleSeek VDEC_PlayOneFrm 2 VDEC_FMT_H264 fail\n");
        }
    }
    
}
VOID _SWDMX_MpgVdecPlay(UINT8 u1SrcId)
{
    ENUM_VDEC_FMT_T eVdecFmt = VDEC_FMT_MPV;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);
    
    if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_MPEG1_MPEG2)
    {
        eVdecFmt = VDEC_FMT_MPV;
        if(!VDEC_Play(prSwdmxInst->u1VdecId, VDEC_FMT_MPV))
        {
            LOG(3, "_SWDMX_MpgHandleFifoFull VDEC_Play VDEC_FMT_MPV fail\n");
        }
    }
    else if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_H264)
    {
        eVdecFmt = VDEC_FMT_H264;
        if(!VDEC_Play(prSwdmxInst->u1VdecId, VDEC_FMT_H264))
        {
            LOG(3, "_SWDMX_MpgHandleFifoFull VDEC_Play VDEC_FMT_H264 fail\n");
        }
    }
    else if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_VC1)
    {
        eVdecFmt = VDEC_FMT_WMV;
        if(!VDEC_Play(prSwdmxInst->u1VdecId, VDEC_FMT_WMV))
        {
            LOG(3, "_SWDMX_MpgHandleFifoFull VDEC_Play VDEC_FMT_WMV fail\n");
        }
    }
    else if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_AVS)
    {
        eVdecFmt = VDEC_FMT_AVS;
        if(!VDEC_Play(prSwdmxInst->u1VdecId, VDEC_FMT_AVS))
        {
            LOG(3, "_SWDMX_MpgHandleFifoFull VDEC_Play VDEC_FMT_AVS fail\n");
        }
    }
    else if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_MPEG4)
    {
        eVdecFmt = VDEC_FMT_MP4;
        if(!VDEC_Play(prSwdmxInst->u1VdecId, VDEC_FMT_MP4))
        {
            LOG(3, "_SWDMX_MpgHandleFifoFull VDEC_Play ENUM_SWDMX_VDEC_MPEG4 fail\n");
        }
    }
  else if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_H265)
  {
    eVdecFmt = VDEC_FMT_H265;
        if(!VDEC_Play(prSwdmxInst->u1VdecId, VDEC_FMT_H265))
        {
            LOG(3, "_SWDMX_MpgHandleFifoFull VDEC_Play ENUM_SWDMX_VDEC_H265 fail\n");
        }
  }
    else
    {
        ASSERT(0);
    }
    if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
       (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
    {
        if(!VDEC_Play(prSwdmxInst->u1Vdec2Id, eVdecFmt))
        {
            LOG(3, "_SWDMX_MpgHandleFifoFull VDEC_Play 2 eVdecFmt fail\n");
        }
    }    
}

VOID _SWDMX_MpgHandleTimeNextTrick(UINT8 u1SrcId,INT32 i4PlaySpeed)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);
    LOG(5,"Hanlde Next Trick\n");
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)    
    {
        MPV_FlushEsmQ(prSwdmxInst->u1VdecId, FALSE);
        _SWDMX_MpgResetData(u1SrcId);
        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = 0 ;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPosWithPTSFound = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8Previous2IPosWithPTSFound = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize = 0;
      VDEC_RegRenderPtsCb(prSwdmxInst->u1VdecId,_SWDMX_MpgTimeSeekFinNotify, u1SrcId);  
        _SWDMX_MpgCalcNextTime(u1SrcId,i4PlaySpeed);
      VDEC_SetRenderFromPtsAutoPause(prSwdmxInst->u1VdecId,prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartTime,TRUE);
        if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
           (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
        {
        VDEC_SetRenderFromPtsAutoPause(prSwdmxInst->u1VdecId,prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartTime,TRUE);
        }     
        
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
        {
            _SWDMX_MpgPlayOneFrame(u1SrcId);
        }
        
    }
    else
    {
        // audio es add info
    }
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgStartJumpping = TRUE;
    
}
INT32 _SWDMX_MpgHandleNextTrick(UINT8 u1SrcId,INT32 i4PlaySpeed)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
    if (prSwdmxInst->eSeekType ==  eSWDMX_TYPE_BYTE_SEEK)
    {
        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext)
        {
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2JumpAgainCount == 0)
            {
                // it's nice to have this. it could improve the trick speed.
                UINT64 u8Offset = 0;
                UINT64 u8OffsetI = 0;
                UINT16 u2DecodingOrder = 0;
                INT32 i4TempRef = 0;
                UINT32 u4WaitCnt;
                u4WaitCnt = 3;
                while(u4WaitCnt--)
                {
                    if(VDP_GetFilePosition(prSwdmxInst->u1B2rId, &i4TempRef, &u2DecodingOrder, &u8Offset, &u8OffsetI))
                    {
                    }
                    // to check vdp have change frame, so we could leave earlier.
                    if(((u8Offset != prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8OffsetKeep) &&
                        (u8OffsetI != prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8OffsetIKeep) &&
                        (i4TempRef != prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4TempRefKeep) &&
                        (u2DecodingOrder != prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2DecodingOrderKeep))
                       ||
                       (_SWDMX_GetNumOfCmd(u1SrcId) > 0))
                    {
                        // no wait display, when we have new command
                        u4WaitCnt = 0;
                    }
                    else
                    {
                        // at least we will delay 60 ms.
                        x_thread_delay(20);
                    }
                }
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8OffsetKeep = u8Offset;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8OffsetIKeep = u8OffsetI;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4TempRefKeep = i4TempRef;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2DecodingOrderKeep = u2DecodingOrder;
            }

            _SWDMX_MpgHandleSeek(u1SrcId, i4PlaySpeed, FALSE); 
                  
        }
        else if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
        {
            // this  part need modify it.
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime > 0)
            {
                UINT64 u8Tmp;
                UINT64 u8Remainder;
                u8Tmp = _SWDMX_Div6464(((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset)*MPG_AUDIO_ES_SKIP_TIME), (UINT64)(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime), &u8Remainder);
                UNUSED(u8Remainder);
                if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr) >= u8Tmp)
                {
                    {
                        UINT32 u4DmxAvailSizeAudio;
                        UINT32 u4Addr, u4Size;
                        UINT32 u4BufSize;
                        u4DmxAvailSizeAudio = DMX_MUL_GetEmptySize(prSwdmxInst->u1DmxId,
                            DMX_PID_TYPE_ES_AUDIO,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio);
                        if(!_SWDMX_GetAudioFifo(u1SrcId, &u4Addr, &u4Size))
                        {
                            LOG(3, "_SWDMX_GetAudioFifo Fail\n");
                            return MPG_SEND_FAIL;
                        }
                        u4BufSize          = u4Size;
                        if(((u4BufSize - u4DmxAvailSizeAudio) < 100000)
                           &&
                           ((u4BufSize - u4DmxAvailSizeAudio) ==
                             prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioFifoDataSize)
                          )
                        {
                            _SWDMX_MpgHandleSeekAudio(u1SrcId, i4PlaySpeed, FALSE);
                            return MPG_SEND_SKIP;
                        }
                        else
                        {
                            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady) &&
                               (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio))
                            {
                                AUD_MMAoutEnable(prSwdmxInst->u1AdecId, TRUE);
                                STC_StartStc(prSwdmxInst->u1StcId);
                                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio = TRUE;
                            }

                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioFifoDataSize =
                                (u4BufSize - u4DmxAvailSizeAudio);
                            // wait audio consume
                            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos < u8Tmp*20)  // DTV00089946 for too low bitrate file, 
                            {                                                                  // last 20 second 
                                x_thread_delay(200);
                            }
                            else
                            {
                                x_thread_delay(100);
                            }

                            return MPG_SEND_SKIP;
                        }
                    }
                }
            }            
        }
        
    }
    else if (prSwdmxInst->eSeekType ==  eSWDMX_TYPE_TIME_SEEK)
    {
        HAL_TIME_T rDelta;
        HAL_GetTime(&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpEndTime);
        HAL_GetDeltaTime(&rDelta, &prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpStartTime, &prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpEndTime);
        
        if((rDelta.u4Seconds >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpWaitTime.u4Seconds) &&
           (rDelta.u4Micros >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpWaitTime.u4Micros))
        {
            _SWDMX_MpgHandleTimeNextTrick(u1SrcId,i4PlaySpeed);     
      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpStartTime.u4Micros = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpEndTime.u4Micros;
      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpStartTime.u4Seconds = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpEndTime.u4Seconds;    
      
        } 
    }
    else
    {
        LOG(0,"this case exception,pls check it.");
        ASSERT(0);
    }
    return MPG_SEND_OK;
    
}
VOID _SWDMX_MpgHandleSeek(UINT8 u1SrcId, INT32 i4PlaySpeed, BOOL fgSeek)
{
    UINT32 u4Speed;
    UINT32 u4Tmp;
    UINT32 u4SkipTime;
    UINT64 u8Tmp;
    UINT64 u8Size;
    UINT64 u8SizeWithoutSkipTime;
    UINT64 u8Remainder;
    HAL_TIME_T rDelta;
    UINT16 u2DecodingOrder;
    INT32 i4TempRef;
    UINT64 u8Offset, u8OffsetI;
    UINT64 u8SendSizeWOIdx; // withoud index
    VDP_PIC_INFO_T rPicInfo;
    BOOL fgNoI;
    UINT32 u8SizeCompare;
    BOOL fgTotalTimeOffsetFake=FALSE;
    UINT32 u4FrameRate = 30;
    UINT32 u4PreFrameTime = 3000;
    BOOL   b_enable_log = FALSE;
    
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    b_enable_log = ((prSwdmxInst->u4LogFilter & check_handle_seek) != 0)? TRUE : FALSE;

    MPV_FlushEsmQ(prSwdmxInst->u1VdecId, FALSE);
    _SWDMX_MpgResetData(u1SrcId);

    u8SendSizeWOIdx = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;

    x_memset(&rPicInfo, 0, sizeof(rPicInfo));
    HAL_GetTime(&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpEndTime);
    HAL_GetDeltaTime(&rDelta, &prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpStartTime, &prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpEndTime);
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpStartTime.u4Micros = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpEndTime.u4Micros;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpStartTime.u4Seconds = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpEndTime.u4Seconds;
    if(rDelta.u4Seconds > 3)
    {
        rDelta.u4Seconds = 3;
    }
    u4SkipTime = ((rDelta.u4Seconds*1000000) + rDelta.u4Micros);

    // Get Frame Rate from VDEC
    {
        VDEC_HDR_INFO_T rHdrInfo;
                
        x_memset(&rHdrInfo, 0, sizeof(VDEC_HDR_INFO_T));
        if (VDEC_QueryInfo(prSwdmxInst->u1VdecId, &rHdrInfo))
        {
            u4FrameRate = (rHdrInfo.u2FrmRate + 99) / 100;
        }

        if ((0==u4FrameRate) || (300<u4FrameRate))
        {
            LOG(1, "Error Frame rate, set to 30fps.\n");
            u4FrameRate = 30;
        }

        ASSERT(u4FrameRate);
        u4PreFrameTime = 90000/u4FrameRate;
        ASSERT(u4PreFrameTime);
    }
    
    // from now, we use file position of last displayed picture.
    /*
    u8Offset = u8OffsetI = 0;
    u2DecodingOrder = 0;
    i4TempRef = 0;
    VDP_GetFilePosition(prSwdmxInst->u1B2rId, &i4TempRef, &u2DecodingOrder, &u8Offset, &u8OffsetI);
    if(u8OffsetI > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize)
    {
        LOG(3, "_SWDMX_MpgHandleSeek VDP_GetFilePosition u8OffsetI %d > u8FileSize %d\n",
            (UINT32)u8OffsetI, (UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize);
        u8OffsetI = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize;
    }*/
    u8Offset = 0;
    u8OffsetI = 0;
    u2DecodingOrder = 0;
    i4TempRef = 0;
    fgNoI = FALSE;

#ifdef TIME_SHIFT_SUPPORT
    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT) &&
       (DMX_GetScrambleState(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo) == DMX_SCRAMBLE_STATE_SCRAMBLED))
    {
        u8Offset = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        u8OffsetI = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        u2DecodingOrder = 0;
        i4TempRef = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        LOG(5, "_SWDMX_MpgHandleSeek Scramble  u8SendedSize 0x%llx\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize);
    }
    else
#endif
    {
        UNUSED(VDP_GetFilePosition(prSwdmxInst->u1B2rId, &i4TempRef, &u2DecodingOrder, &u8Offset, &u8OffsetI));
        UNUSED(VDP_GetPicInfo(prSwdmxInst->u1B2rId, &rPicInfo));
        LOG(5, "HandleSeek Position i4TempRef %d u2DecodingOrder %d I:0x%llx 0x%llx rPicInfo.u4Pts 0x%x\n",
            i4TempRef, u2DecodingOrder, u8OffsetI, u8Offset,rPicInfo.u4Pts);
    if ((i4PlaySpeed < 0) && (u8Offset == 0))
    {            
      
      u8Offset = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;            
      u8OffsetI = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;            
      u2DecodingOrder = 0;
      i4TempRef = 0;
      
          LOG(5, "[PMT Changed] HandleSeek Position i4TempRef %d u2DecodingOrder %d I:0x%llx 0x%llx\n",
              i4TempRef, u2DecodingOrder, u8OffsetI, u8Offset);     
    }

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS =
            ((rPicInfo.u4Pts - (MPG_STC_BASE)) + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS);
    }

    if(((UINT32)(u8OffsetI>>32) == (UINT32)0xFFFFFFFF)
        && ((UINT32)(u8OffsetI) == (UINT32)0xFFFFFFFF))
    {
        u8OffsetI = u8Offset;
        LOG(3, "_SWDMX_MpgHandleSeek No I, start from 0x%llx\n",
            u8OffsetI);
        fgNoI = TRUE;
    }

    if(u8OffsetI > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize)
    {
        LOG(3, "_SWDMX_MpgHandleSeek VDP_GetFilePosition u8OffsetI 0x%llx > u8FileSize 0x%llx\n",
            u8OffsetI, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize);
        u8OffsetI = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize;
        u2DecodingOrder = 0;
        i4TempRef = 0;
    }

    /*
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS =
        ((rPicInfo.u4Pts - (MPG_STC_BASE)) + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS);

#ifdef TIME_SHIFT_SUPPORT
    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT) &&
       (DMX_GetScrambleState(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo) == DMX_SCRAMBLE_STATE_SCRAMBLED))
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = 0;
        // no need this
        //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    }
#endif
    */

    if(i4PlaySpeed == -1)
    {

        //u8Offset = u8OffsetI = 0;
        //u2DecodingOrder = 0;
        //i4TempRef = 0;
        // from now, we use file position of last displayed picture.
        /*VDP_GetFilePosition(prSwdmxInst->u1B2rId, &i4TempRef, &u2DecodingOrder, &u8Offset, &u8OffsetI);
        if(u8OffsetI > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize)
        {
            LOG(3, "_SWDMX_MpgHandleSeek VDP_GetFilePosition u8OffsetI %d > u8FileSize %d\n",
                (UINT32)u8OffsetI, (UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize);
            u8OffsetI = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize;
            u2DecodingOrder = 0;
            i4TempRef = 0;
        }
        LOG(5, "_SWDMX_MpgHandleSeek VDP_GetFilePosition i4TempRef %d u2DecodingOrder %d u8Offset %d\n",
            i4TempRef, u2DecodingOrder, (UINT32)u8Offset, (UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize);
        */
        //if(u8OffsetI == u8Offset)
        {
            if((u8OffsetI == u8Offset) &&
               (u8Offset == 0) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2JumpAgainCount))
            {
                // end seek
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToADec = TRUE; // FixMe, should be FALSE
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPTSFound = FALSE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = FALSE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = FALSE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = FALSE;
#if 1//def CC_DLNA_SUPPORT
                FeederSetInfo(prSwdmxInst->eFeederSrc, FEEDER_SWDMX_EOS, FALSE);
#endif
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize;
                #ifdef TIME_SHIFT_SUPPORT
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
                {
                    UINT32 u4Ret;
                    UINT32 u4OutReadSize;
                    UINT64 u8OutReadAddr;

                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum = 0;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ReadTickNum = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum;

                    u4Ret = _SWDMX_MpgHandleRing(
                           u1SrcId,
                        0, // begining of file. prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize,
                        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize * MPG_BATCH_READ_SIZE * _u4DoubleDataSize),
                        &u8OutReadAddr, &u4OutReadSize, i4PlaySpeed);
                    UNUSED(u4Ret);
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr;
                }
                else
                #endif
                {
                    LOG(5, "_SWDMX_MpgHandleSeek end seek\n");
                }
                u8SendSizeWOIdx = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X = 0;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = 0;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPosWithPTSFound = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8Previous2IPosWithPTSFound = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
                {
                    UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
                    UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1VdecId, FALSE, (UINT64)0));
                    UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
                    if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                       (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                    {
                        UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                        UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1Vdec2Id, FALSE, (UINT64)0));
                        UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                    }
                }
            }
            else
            {
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2JumpAgainCount)
                {
                    // GOP boundry is there. Back a GOP.
                    // prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime unit is 90000
                    //u4Tmp = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime/90000)*30; // total frames
                    //u8Size = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize/u4Tmp); // avg size/frame
                    //u8Size *= (u4Speed/1000);
                    u4Tmp = ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTimeOffset) / u4PreFrameTime); // total frames
                    u8Size = _SWDMX_Div6464((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset), (UINT64)u4Tmp, &u8Remainder);

                    //DTV00212070  check  is prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTimeOffset  normal ?
                    u8SizeCompare = (UINT64)VDEC_GetAvgPicSize(prSwdmxInst->u1VdecId);
                    if(u8SizeCompare>6*u8Size)
                    {
                         u8Size= u8SizeCompare;
                         fgTotalTimeOffsetFake=TRUE;
                         LOG(5,"SWDMX_HandleSeek TotalTimeOffset is Wrong\n");
                    }
                    u8Size *= u4FrameRate; // 1 sec
                    //ASSERT(u8Size < (UINT64)0xFFFFFFFF);
                    //u4Tmp = (UINT32)u8Size;
                    //u4Tmp = (u4Tmp%(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase));
                    //u8Size -= (UINT64)u4Tmp;
                    // error handleing for (u8Size >= (UINT64)0xFFFFFFFF)
                    UNUSED(_SWDMX_Div6464((u8Size - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset), (UINT64)(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase), &u8Remainder));
                    u8Size -= u8Remainder;
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2JumpAgainCount)
                    {
                        u8Size *= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2JumpAgainCount;
                    }
                    if(u8OffsetI <= u8Size)
                    {
                        u8OffsetI = 0;
                    }
                    else
                    {
                        u8OffsetI -= u8Size;
                    }
                }

                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPTSFound = FALSE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = u8OffsetI;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = u8OffsetI;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = u8OffsetI;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = u8OffsetI;
                u8SendSizeWOIdx = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize = 0;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos = u8OffsetI;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPosWithPTSFound = u8OffsetI;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8Previous2IPosWithPTSFound = u8OffsetI;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize = u8OffsetI;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X = 0;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = 0;
                if(fgNoI)
                {
                    UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1VdecId, TRUE, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
                    UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
                    LOG(5, "HandleSeek FromFirstPic from 0x%llx\n", u8OffsetI);
                    if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                       (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                    {
                        UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1Vdec2Id, TRUE, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
                        UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                    }
                }
                else
                {
                    UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1VdecId, FALSE, (UINT64)0));
                    UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1VdecId, TRUE, u8Offset, i4TempRef, u2DecodingOrder));
                    UNUSED(VDP_GetPicInfo(prSwdmxInst->u1B2rId, &rPicInfo));
                    LOG(5, "HandleSeek BackStep I:0x%llx, 0x%llx, PTS:%d, i4TempRef:%d, u2DecodingOrder:%d\n", u8OffsetI,
                        u8Offset, rPicInfo.u4Pts, i4TempRef, (UINT32)u2DecodingOrder);
                    if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                       (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                    {
                        UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1Vdec2Id, FALSE, (UINT64)0));
                        UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1Vdec2Id, TRUE, u8Offset, i4TempRef, u2DecodingOrder));
                    }
                }
                UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
                if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                   (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                {
                    UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                }
            }
        }
    }
    else
    {
        u4Speed = (i4PlaySpeed < 0) ? ((UINT32)-i4PlaySpeed) : ((UINT32)i4PlaySpeed);

        // remove prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTimeOffset
        // when totaltime is 0, we use average frame size from vdec.
        if(((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime) > u4PreFrameTime) && 
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize > 0))
        {
            // prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime unit is 90000
            //u4Tmp = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime/90000)*30; // total frames
            //u8Size = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize/u4Tmp); // avg size/frame
            //u8Size *= (u4Speed/1000);
            u4Tmp = ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTimeOffset) / u4PreFrameTime); // total frames
            if(u4Tmp > 0) // prevent div zero
            {
                u8Size = _SWDMX_Div6464((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset), (UINT64)u4Tmp, &u8Remainder);
            }
            else
            {
                u8Size = 1;
            }
			
			#if 0
            //this api VDEC_GetAvgPicSize is not accuracy ,specially trick mode.so mark this part.
            //DTV00212070  check  is prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTimeOffset  normal ?
            u8SizeCompare=(UINT64)VDEC_GetAvgPicSize(prSwdmxInst->u1VdecId);
            if(u8SizeCompare>6*u8Size)
            {
                 u8Size = u8SizeCompare;
                 fgTotalTimeOffsetFake=TRUE;
                 LOG(5,"SWDMX_HandleSeek TotalTimeOffset is Wrong\n");
            }
			#endif
			
            u8Tmp = u8Size;
            u8Size *= u4Speed;
            //if(i4PlaySpeed < 0) //DTV00212070
            {
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2JumpAgainCount)
                {
                    u8Size += (u8Tmp * prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2JumpAgainCount);
                }
            }
            u8SizeWithoutSkipTime = u8Size;			

            // This is the time we spent on the sending I frame
            if(u4SkipTime > 3000000) // 3 sec
            {
                LOG(5, "_SWDMX_MpgHandleSeek u4SkipTime %d\n", (UINT32)u4SkipTime);
                u4SkipTime = 3000000;
            }
            if(u4SkipTime > 10000) // 10 ms
            {
              if(fgTotalTimeOffsetFake==TRUE) //DTV00212070
              {

                u8Tmp = (UINT64)VDEC_GetAvgPicSize(prSwdmxInst->u1VdecId);
                u8Tmp *= u4FrameRate;
                u8Tmp *= u4SkipTime;
                u8Tmp = _SWDMX_Div6464(u8Tmp, (UINT64)1000000, &u8Remainder);
                u8Tmp *= u4Speed; // we should also consider the speed.
                u8Size += u8Tmp;
               }
              else
              {
                // a = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize / u4TotalTime -> 90K base
                // b = (u4SkipTIme / 1000000) * (a/90K)
                // b = (u4SkipTIme / 1000000) * ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize / u4TotalTime)/90000)
                // b = (u4SkipTIme / 100) * ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize / u4TotalTime)/9)
                u8Tmp = (u4SkipTime/100);
                u8Tmp *= 9;
                u8Tmp = (u8Tmp * (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset)); //1000000 / 90000 -> 100/9
                u8Tmp = _SWDMX_Div6464(u8Tmp,
                    ((UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime + (UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTimeOffset),
                    &u8Remainder);
                u8Tmp *= u4Speed; // we should also consider the speed.
                u8Size += u8Tmp;
              }
            }
            if(b_enable_log)
            {
               LOG(1, "handle seek skipSize %llu, speed %u\n", _SWDMX_Div6464(u8Size, 1000, NULL), u4Speed);
			   LOG(1, "totalTime %u, totalTimeOffset %u, fileSize %llu, startFileOffset %llu\n",
			   	prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime,
			   	prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTimeOffset,
			   	prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize,
			   	prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset);
			   LOG(1, "preFrameTime %u skipTime %u\n", u4PreFrameTime,u4SkipTime);
            }
		}
        else
        {
            UINT64 u8AvgSize = 0;

            if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
            {
                u8AvgSize = _SWDMX_MpgGetAvgBitRate(u1SrcId);
                u8AvgSize = _SWDMX_Div6464(u8AvgSize, u4FrameRate, &u8Remainder);
            }
            else
            {
                u8AvgSize = (UINT64)VDEC_GetAvgPicSize(prSwdmxInst->u1VdecId);
            }

            u8Size = u8AvgSize; // (UINT64)VDEC_GetAvgPicSize(prSwdmxInst->u1VdecId);
            u8Tmp = u8Size;
            u8Size *= (UINT64)u4Speed;
            //if(i4PlaySpeed < 0)       //DTV00212070
            {
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2JumpAgainCount)
                {
                    u8Size += (u8Tmp * prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2JumpAgainCount);
                }
            }
            u8SizeWithoutSkipTime = u8Size;            

            // This is the time we spent on the sending I frame
            if(u4SkipTime > 3000000) // 3 sec
            {
                LOG(5, "_SWDMX_MpgHandleSeek u4SkipTime %d\n", (UINT32)u4SkipTime);
                u4SkipTime = 3000000;
            }
            if(u4SkipTime > 10000) // 10 ms
            {
                u8Tmp = u8AvgSize; // (UINT64)VDEC_GetAvgPicSize(prSwdmxInst->u1VdecId);
                u8Tmp *= u4FrameRate;
                u8Tmp *= u4SkipTime;
                u8Tmp = _SWDMX_Div6464(u8Tmp, (UINT64)1000000, &u8Remainder);
                u8Tmp *= u4Speed; // we should also consider the speed.
                u8Size += u8Tmp;
            }
            if(b_enable_log)
            {
               LOG(1,"handle seek skipSize %llu, speed %u,u8AvgSize %llu,skipTime %u\n",
			   	_SWDMX_Div6464(u8Size, 1000, NULL),
			   	u4Speed,u8AvgSize, u4SkipTime);
			}
        }
        //need consider slow backward speed less than 1000
        u8Size = _SWDMX_Div6464(u8Size, (UINT64)1000, NULL);
    {
            UINT64 u8Remainder;
            UNUSED(_SWDMX_Div6464(u8SizeWithoutSkipTime, (UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase, &u8Remainder));
            u8SizeWithoutSkipTime -= u8Remainder;
        }
    u8SizeWithoutSkipTime = _SWDMX_Div6464(u8SizeWithoutSkipTime, (UINT64)1000, NULL);
        if (u8Size < (UINT64)1000)
        {
            u8Size = (UINT64)1000;//avoid u8Size==0
        }

        //ASSERT(u8Size < (UINT64)0xFFFFFFFF);
        // error handling no need now.
        {
            UINT64 u8Remainder;
            UNUSED(_SWDMX_Div6464(u8Size, (UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase, &u8Remainder));
            u8Size -= u8Remainder;
        }

        if(b_enable_log)
        {
           LOG(1,"%s: Cur Pos %llu jump size %llu\n",__FUNCTION__,prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr,u8Size);
        }        

        if(i4PlaySpeed < 0)
        {
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr > u8Size)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPTSFound = FALSE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = FALSE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = FALSE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = FALSE;
#if 1//def CC_DLNA_SUPPORT
                FeederSetInfo(prSwdmxInst->eFeederSrc, FEEDER_SWDMX_EOS, FALSE);
#endif
                // DTV00136835 [MM]Video auto resume when time seek to end in fr mode.
                if(fgSeek)
                {
                    // When we are seek, make the first file position const.
                    // Not affected by skip time.
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr > (u8SizeWithoutSkipTime * 2))
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize =
                            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr - (u8SizeWithoutSkipTime * 2));
                    }
                    else
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = 0;
                    }
                }
                else
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr - u8Size);
					if(b_enable_log)
					{
						LOG(2,"%s:take down new sended size %llu rewindjumpsize %llu\n",__FUNCTION__,prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8RewindSendedSize,u8SizeWithoutSkipTime);
					}
					prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8RewindJumpSize = u8SizeWithoutSkipTime;
					prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8RewindSendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                }
                /*if(u8OffsetI > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr)
                {
                    u4Tmp = (UINT32)(u8OffsetI - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr);
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize -= (u4Tmp/2);
                }*/
                u8SendSizeWOIdx = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                #ifdef TIME_SHIFT_SUPPORT
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
                {
                    UINT32 u4Ret;
                    UINT32 u4OutReadSize;
                    UINT64 u8OutReadAddr;

                    u4SkipTime += (u4Speed * u4FrameRate); // 30 fps
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum >=
                        (u4SkipTime / prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.ui4_tick_period))
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum -=
                            (u4SkipTime / prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.ui4_tick_period);
                    }
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ReadTickNum = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum;

                    u4OutReadSize = 0;
                    u4Ret = _SWDMX_MpgHandleRing(u1SrcId,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize,
                        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize * MPG_BATCH_READ_SIZE * _u4DoubleDataSize),
                        &u8OutReadAddr, &u4OutReadSize, i4PlaySpeed);
                    if(u4Ret == MPG_RING_END_MEET)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                    }
                    else if(u4Ret != MPG_RING_OK)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr;
                    }
                    else
                    {
                        if(_SWDMX_MpgGetIPosByTickNum(u1SrcId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize,
                             (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ReadTickNum),
                             &u8OutReadAddr))
                        {
                            // change I frame start position
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = u8OutReadAddr;
                        }
                    }
                }
                #endif
                #if 0 // move up
                u8SendSizeWOIdx = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                #endif
                #ifdef SWDMX_MPG_USE_INDEX
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgUseIdx)
                {
                    UINT64 u8RetPos;
                    if(!_SWDMX_MpgIdxGetPosByPos(u1SrcId, TRUE, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize, &u8RetPos))
                    {
                        LOG(3, "_SWDMX_MpgHandleSeek _SWDMX_MpgIdxGetPosByPos fail\n");
                    }
                    LOG(5, "_SWDMX_MpgHandleSeek ff GetPosByPos 0x%llx -> 0x%llx\n",
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize, u8RetPos);
                    // if previous jump get a initial value in index table
                    // this time we might get a correct one, but that is a bigger one.
                    // avoid this case
                    if(u8RetPos <= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = u8RetPos;
                    }
                }
                #endif
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X = 0;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = 0;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPosWithPTSFound = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8Previous2IPosWithPTSFound = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
                {
                    UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
                    UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
                    if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                       (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                    {
                        UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                        UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                    }
                    if(fgSeek)
                    {
                        // alwasy render it.
                        UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1VdecId, TRUE, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
                        if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                           (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                        {
                            UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1Vdec2Id, TRUE, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
                        }
                    }
                    else
                    {
                        // only render it before u8Offset.
                        UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1VdecId, TRUE, u8Offset));
                        if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                           (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                        {
                            UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1Vdec2Id, TRUE, u8Offset));
                        }
                    }
                }
            }
            else
            {
                // end seek
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToADec = TRUE; // FixMe, should be FALSE
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPTSFound = FALSE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = FALSE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = FALSE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = FALSE;
#if 1//def CC_DLNA_SUPPORT
                FeederSetInfo(prSwdmxInst->eFeederSrc, FEEDER_SWDMX_EOS, FALSE);
#endif
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize;
                #ifdef TIME_SHIFT_SUPPORT
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
                {
                    UINT32 u4Ret;
                    UINT32 u4OutReadSize;
                    UINT64 u8OutReadAddr;

                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum = 0;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ReadTickNum = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum;

                    u4Ret = _SWDMX_MpgHandleRing(u1SrcId,
                        0, // begining of file. prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize,
                        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize * MPG_BATCH_READ_SIZE * _u4DoubleDataSize),
                        &u8OutReadAddr, &u4OutReadSize, i4PlaySpeed);
                    UNUSED(u4Ret);
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr;
                }
                else
                #endif
                {
                    LOG(5, "_SWDMX_MpgHandleSeek end seek\n");
                }
                u8SendSizeWOIdx = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X = 0;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = 0;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPosWithPTSFound = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8Previous2IPosWithPTSFound = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
                {
                    UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
                    UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1VdecId, FALSE, (UINT64)0));
                    UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
                    if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                       (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                    {
                        UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                        UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1Vdec2Id, FALSE, (UINT64)0));
                        UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                    }
                }
            }
        }
        else // i4PlaySpeed > 0
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPTSFound = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = FALSE;
#if 1//def CC_DLNA_SUPPORT
            FeederSetInfo(prSwdmxInst->eFeederSrc, FEEDER_SWDMX_EOS, FALSE);
#endif
            // DTV00136835 [MM]Video auto resume when time seek to end in fr mode.
            if(fgSeek)
            {
                // When we are seek, make the first file position const.
                // Not affected by skip time.
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize =
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr + (u8SizeWithoutSkipTime * 2));
            }
            else
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr + u8Size);
            }
            u8SendSizeWOIdx = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
            #ifdef TIME_SHIFT_SUPPORT
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
            {
                UINT32 u4Ret;
                UINT32 u4OutReadSize;
                UINT64 u8OutReadAddr;

                u4SkipTime += (u4Speed * u4FrameRate); // 30 fps
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum +=
                    (u4SkipTime / prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.ui4_tick_period);
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ReadTickNum = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum;

                u4Ret = _SWDMX_MpgHandleRing(u1SrcId,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize,
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize * MPG_BATCH_READ_SIZE * _u4DoubleDataSize),
                    &u8OutReadAddr, &u4OutReadSize, i4PlaySpeed);
                if(u4Ret != MPG_RING_OK)
                {
                    // this is end of current range case
                    // do not move send position.
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ValidEndAddr)
                    {
                        u8SendSizeWOIdx = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr;
                        LOG(6, "_SWDMX_MpgHandleSeek u8SendedSize(0x%llx) >= u8ValidEndAddr(0x%llx)\n",
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ValidEndAddr);
                    }
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr;
                }
                else
                {
                    if(_SWDMX_MpgGetIPosByTickNum(u1SrcId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize,
                         (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ReadTickNum),
                         &u8OutReadAddr))
                    {
                        // change I frame start position
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = u8OutReadAddr;
                    }
                }
            }
            #endif
            #if 0 // move up
            u8SendSizeWOIdx = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
            #endif
            /*if(u8OffsetI > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr)
            {
                u4Tmp = (UINT32)(u8OffsetI - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr);
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize += (u4Tmp/2);
            }*/
            #ifdef SWDMX_MPG_USE_INDEX
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgUseIdx)
            {
                UINT64 u8RetPos;
                if(!_SWDMX_MpgIdxGetPosByPos(u1SrcId, FALSE, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize, &u8RetPos))
                {
                    LOG(3, "_SWDMX_MpgHandleSeek _SWDMX_MpgIdxGetPosByPos fail\n");
                }
                LOG(5, "_SWDMX_MpgHandleSeek fb GetPosByPos 0x%llx -> 0x%llx\n",
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize, u8RetPos);
                // if previous jump get a initial value in index table
                // this time we might get a correct one, but that is a small one.
                // avoid this case
                if(u8RetPos >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr)
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = u8RetPos;
                }
            }
            #endif
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPosWithPTSFound = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8Previous2IPosWithPTSFound = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
            {
                UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
                UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
                if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                   (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                {
                    UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                    UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                }
                if(fgSeek)
                {
                    // alwasy render it.
                    UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1VdecId, TRUE, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
                    if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                       (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                    {
                        UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1Vdec2Id, TRUE, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
                    }
                }
                else
                {
                    // only render it after u8Offset + onetimesize.
                    UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1VdecId, TRUE,
                            (u8Offset + (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize))));
                    if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                       (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                    {
                        UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1Vdec2Id, TRUE,
                                (u8Offset + (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize))));
                    }
                }
            }
        }
    }
    
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext = FALSE;

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
    {
        _SWDMX_MpgPlayOneFrame(u1SrcId);
    }

    LOG(6, "_SWDMX_MpgHandleSeek new addr 0x%llx (WO Idx 0x%llx)\n",
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize, u8SendSizeWOIdx);

    // reset jump
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = u8SendSizeWOIdx;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicCnt = 0;
}

BOOL _SWDMX_MpgHandleFlushFeeder(UINT8 u1SrcId, UINT8 u1Type, VOID* pvMMFlushInfo, UINT32 u4Para2, UINT32 u4Para3)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
    
    LOG(5,"_SWDMX_MpgHandleFlushFeeder \n");

    MPV_FlushEsmQ(prSwdmxInst->u1VdecId, FALSE);
    UNUSED(VDEC_ReleaseDispQ(prSwdmxInst->u1VdecId));
    UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
    UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1VdecId, TRUE, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
    
    if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
       (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
    {
        MPV_FlushEsmQ(prSwdmxInst->u1Vdec2Id, FALSE);
        UNUSED(VDEC_ReleaseDispQ(prSwdmxInst->u1Vdec2Id));
        UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
        UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1Vdec2Id, TRUE, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
        
    }
    
    VDP_ResetPts(prSwdmxInst->u1B2rId);
    _SWDMX_MpgResetData(u1SrcId);
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpping = TRUE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2JumpAgainCount = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToADec = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = FALSE;
    FeederSetInfo(prSwdmxInst->eFeederSrc, FEEDER_SWDMX_EOS, FALSE);
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS = 0xFFFFFFFF;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SecondVideoPTS = 0xFFFFFFFF;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS = 0xFFFFFFFF;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4DeltaAudioPTS = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = FALSE; // PTS reset
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideoReady = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgChangeVideo = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPTSFound = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = 0;

    return TRUE;
}
VOID _SWDMX_MpgHandleTimeSeek(UINT8 u1SrcId)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);
        
    LOG(5, "_SWDMX_MpgHandleTimeSeek change time: %d \n",prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartTime);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)    
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSeek = TRUE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgStartTimeSeek = TRUE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4MvcSeekVidPTS = 0xFFFFFFFF;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4MvcSeekAudPTS = 0;

        _SWDMX_MpgResetTimeVariable(u1SrcId);
        _SWDMX_MpgResetData(u1SrcId);
        STC_StopStc(prSwdmxInst->u1StcId);
        
        VDEC_SetRenderFromPts(prSwdmxInst->u1VdecId,(UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartTime);
        
        if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
           (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
        {
            VDEC_SetRenderFromPts(prSwdmxInst->u1VdecId,(UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartTime);    
        }            

        MPV_FlushEsmQ(prSwdmxInst->u1VdecId, FALSE);
        UNUSED(VDEC_ReleaseDispQ(prSwdmxInst->u1VdecId));
        if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
           (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
        {
            MPV_FlushEsmQ(prSwdmxInst->u1Vdec2Id, FALSE);
            UNUSED(VDEC_ReleaseDispQ(prSwdmxInst->u1Vdec2Id));
        }
        VDP_ResetPts(prSwdmxInst->u1B2rId);
        
        VDP_SetSeek(prSwdmxInst->u1B2rId,
                    1,
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed >= 0) ?
                     (UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartTime : (UINT32)-1);
        LOG(5,"Set to B2r seek %d\n",(UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartTime);
    }
    else 
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgStartTimeSeek = TRUE;
        _SWDMX_MpgResetTimeVariable(u1SrcId);
        _SWDMX_MpgResetData(u1SrcId);
    }

    
}
VOID _SWDMX_MpgCalcNextTime(UINT8 u1SrcId,INT32 i4PlaySpeed)
{
    UINT32 u4Speed;
    UINT64 u8JumpCnt;
    UINT64 u8Remainder;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);
        
    u4Speed = (i4PlaySpeed < 0) ? ((UINT32)-i4PlaySpeed) : ((UINT32)i4PlaySpeed);
  /* calculate jump method */
  /* -----------------------
      frequency:1/wait time (jump counts in one speed)
      step:     speed/frequency
     -----------------------
  */
  if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpWaitTime.u4Seconds == 0)
  {
      u8JumpCnt = _SWDMX_Div6464((UINT64)1000000, (UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpWaitTime.u4Micros, &u8Remainder);
  }
  else
  {
      u8JumpCnt = 1;
  }
  if (u8JumpCnt > 0)
  {
      u4Speed = u4Speed / (UINT32)u8JumpCnt;
  }
    
    if (i4PlaySpeed < 0)
    {
        /* driver not support float operation,
        so  90* u4Speed replace (u4Speed / 1000 ) * 90000 */                
        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartTime > u4Speed * 90) 
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartTime -= (u4Speed * 90); 
        }
        else
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartTime = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime;      
        }
    }
    else
    {
        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartTime + u4Speed * 90 < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartTime += u4Speed * 90;                    
        }
        else
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartTime= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime;   
        }
    }
    LOG(5,"next jump time is 0x%llx\n",prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartTime );
    
}
VOID _SWDMX_MpgHandleTimeTrick(UINT8 u1SrcId,INT32 i4PlaySpeed)
{
    UINT32 u4CurPts = 0;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
    {
      LOG(5,"Trigger Tirck\n");
        /*normal play -> 2X or 1/2X  ... slow forward */
        if (!SKIP_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed) && !SKIP_MODE(i4PlaySpeed))
        {
            _SWDMX_MpgTimeJumpToNormal(u1SrcId, FALSE);
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpping = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToADec = FALSE;                        
        }
        /*normal play ->FF 4X 8X ... or FR 2X 4X 8X */    
        else if ((!SKIP_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed) && SKIP_MODE(i4PlaySpeed)) ||
                 (SKIP_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed) && SKIP_MODE(i4PlaySpeed)))
        {
            _SWDMX_MpgResetTimeVariable(u1SrcId);
            _SWDMX_MpgResetData(u1SrcId);
            MPV_FlushEsmQ(prSwdmxInst->u1VdecId, FALSE);
            UNUSED(VDEC_ReleaseDispQ(prSwdmxInst->u1VdecId));
            if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
               (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
            {
                MPV_FlushEsmQ(prSwdmxInst->u1Vdec2Id, FALSE);
                UNUSED(VDEC_ReleaseDispQ(prSwdmxInst->u1Vdec2Id));
            }
            VDP_ResetPts(prSwdmxInst->u1B2rId);

            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
            {
                u4CurPts = VDP_GetPts(prSwdmxInst->u1B2rId);
            }
            else if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
            {
                u4CurPts = STC_GetStcValue(prSwdmxInst->u1StcId);
            }            
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpping = TRUE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgStartJumpping = TRUE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2JumpAgainCount = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToADec = TRUE;            
            VDEC_RegRenderPtsCb(prSwdmxInst->u1VdecId,_SWDMX_MpgTimeSeekFinNotify, u1SrcId);
            HAL_GetTime(&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpStartTime);
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartTime = u4CurPts;
            
            LOG(5,"Jump start time 0x%llx\n",prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartTime);
            
            _SWDMX_MpgCalcNextTime(u1SrcId,i4PlaySpeed);
            
            VDEC_SetRenderFromPtsAutoPause(prSwdmxInst->u1VdecId,prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartTime,TRUE);
            if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
               (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
            {
                VDEC_SetRenderFromPtsAutoPause(prSwdmxInst->u1VdecId,prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartTime,TRUE);
            }   
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
            {
                _SWDMX_MpgPlayOneFrame(u1SrcId);
            }
            
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgStartJumpping = TRUE;

        }
        /* FF or FR -> normal play */
        else if (SKIP_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed) && !SKIP_MODE(i4PlaySpeed))
        {
            _SWDMX_MpgTimeJumpToNormal(u1SrcId, TRUE);
      
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpping = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToADec = FALSE;                        
      
            
        }            
    }
    

    
}
VOID _SWDMX_MpgHandleTimeChange(UINT8 u1SrcId, SWDMX_CUR_CMD_T* prCmd)
{
    INT32 i4PlaySpeed;

    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);
    if(!prCmd)
    {
        LOG(1, "_SWDMX_MpgHandleChange prCmd null\n");
        return;
    }
    i4PlaySpeed = prCmd->i4PlaySpeed;
    
    LOG(5,"_SWDMX_MpgHandleTimeChange CurSpeed %d ChangeSpeed %d fgSeek %d\n",
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed,
        i4PlaySpeed,
        prCmd->fgSeek);    

    if ((((UINT32)(prCmd->u8SeekTime>>32) != (UINT32)0xFFFFFFFF)
        || ((UINT32)(prCmd->u8SeekTime) != (UINT32)0xFFFFFFFF))
        && (prCmd->u4SeekMode == SWDMX_CUR_CMD_SEEK_TIME))  
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartTime = prCmd->u8SeekTime;
        _SWDMX_MpgHandleTimeSeek(u1SrcId);

        LOG(1,"fgAudio %d\n",prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio);
        
                
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
        {
            #ifdef CC_AUD_SUPPORT_DUAL_DSP
            AUD_DSPCmdStop(AUD_DSP0, prSwdmxInst->u1AdecId);
            AUD_DSPCmdPlay(AUD_DSP0, prSwdmxInst->u1AdecId);
            #else
            AUD_DSPCmdStop(prSwdmxInst->u1AdecId);
            AUD_DSPCmdPlay(prSwdmxInst->u1AdecId);
            #endif
            LOG(1,"Time-based Seek ,Stop/play audio dsp\n");
        }   
        if (i4PlaySpeed != prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed)
        {
            _SWDMX_MpgHandleTimeTrick(u1SrcId,i4PlaySpeed);        
            LOG(0,"Seek and trick change i4PlaySpeed= %d ori i4PlaySpeed = %d\n",i4PlaySpeed,prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed);
        }
        
    }
    else if((prCmd->fgSeek) &&
            (prCmd->u4SeekMode == SWDMX_CUR_CMD_SEEK_OFFSET))
    {
        //_SWDMX_MpgHandleTimeABRepeat(u1SrcId,prCmd);
    }
    else
    {
        _SWDMX_MpgHandleTimeTrick(u1SrcId,i4PlaySpeed);
    }
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed = i4PlaySpeed;    
    return;
}
VOID _SWDMX_MpgSetActivePix(UINT8 u1SrcId)
{
    BOOL fgRet = FALSE;
    UINT32 u4CurPts = 0;
    UINT32 u4APts = 0;
    SWDMX_MPG_INFO_T* prSwdmxMpgInfo = NULL;    
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);
    prSwdmxMpgInfo = &prSwdmxInst->rFmtInfo.rSwdmxMpgInfo;

  if(prSwdmxInst->fgEnablePrebuffer)
    {
        if (prSwdmxMpgInfo->rVar.u1PidxAudio != 0xFF)
        {
            DMX_MM_FlushBuffer(prSwdmxMpgInfo->rVar.u1PidxAudio);
        }    
        
        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
        {
            u4CurPts = VDP_GetPts(prSwdmxInst->u1B2rId);
        }
        else if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
        {
            u4CurPts = STC_GetStcValue(prSwdmxInst->u1StcId);
        }
        
        LOG(5,"Change video Cur Pts 0x%x\n",u4CurPts);
        
        u4CurPts += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS;

        if (prSwdmxMpgInfo->rFmt.u1CurATrackIdx < prSwdmxMpgInfo->rFmt.t_audio_stream_info.u4_audio_pid_num)
        {
            fgRet = DMX_AudHandler_SeekAndUpdate(prSwdmxMpgInfo->rFmt.t_audio_stream_info.t_audio_stream[prSwdmxMpgInfo->rFmt.u1CurATrackIdx].u1Pidx,
                                                 (u4CurPts + 6000), &u4APts);
        }

        if (fgRet)
        {
            u4APts -= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS;
            LOG(5, "Find audio in the pre-buffer u4APts 0x%x\n",u4APts);
            AUD_SetStartPts(prSwdmxInst->u1AdecId, u4APts);
        }
        else
        {   
            /* due to pts jump,may be can not found audio pts with > u4CurPts */
            /* swdmx reenable condition : cur audio pts > cur video pts */
            LOG(5, "Can't find audio in the pre-buffer\n");
        } 

		prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToADec = FALSE;
        DMX_AudHandler_SetActivePidx(prSwdmxMpgInfo->rFmt.t_audio_stream_info.t_audio_stream[prSwdmxMpgInfo->rFmt.u1CurATrackIdx].u1Pidx);         
    }
    
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSetActivePid = TRUE;
    
}
VOID _SWDMX_MpgHandleLastMemory(UINT8 u1SrcId,SWDMX_RANGE_LIST_T* prRangeList)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_INFO_T* prMpgInfo = NULL;

    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);
    prMpgInfo = &(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo);   
    
    if((prRangeList) &&
       (prRangeList->fgSetRenderPosition) &&
       (((UINT32)((prRangeList->u8Offset) >> 32) != (UINT32)0xFFFFFFFF) ||
       ((UINT32)(prRangeList->u8Offset) != (UINT32)0xFFFFFFFF)) &&
       (((UINT32)((prRangeList->u8Offset) >> 32) != (UINT32)0x0) ||
       ((UINT32)(prRangeList->u8Offset) != (UINT32)0x0)))
    {
        if (!prMpgInfo->rVar.fgSendSeqHdr && !prMpgInfo->rVar.fgResetPosAfterFoundSeq)
        {
            prMpgInfo->rVar.fgLastMemory = TRUE; 
            prMpgInfo->rVar.u8OrgSendedSize = prMpgInfo->rVar.u8SendedSize;
            prMpgInfo->rVar.fgResetPosAfterFoundSeq = TRUE;
            prMpgInfo->rVar.u8SendedSize = 0;
            prMpgInfo->rVar.u8ReadedPos = 0;
            prMpgInfo->rVar.u8PlayPos = 0;
#if 1//def CC_DLNA_SUPPORT
            FeederSetReadyThreshold(prSwdmxInst->eFeederSrc, MPG_DLNA_FEEDER_UNREACH);
            FeederSetUnderFlowThreshold(prSwdmxInst->eFeederSrc, MPG_DLNA_FEEDER_UNREACH);
            FeederSetInfo(prSwdmxInst->eFeederSrc, FEEDER_SWDMX_THRESHOLD, FALSE);
#endif
            _SWDMX_MpgResetData(u1SrcId);
            LOG(1, "[%s] start to find sequence\n", __FUNCTION__); 
        }
        else if (!prMpgInfo->rVar.fgSendSeqHdr)
        {
            LOG(1, "[%s] finding seq header...\n", __FUNCTION__);
        }
        else if (prMpgInfo->rVar.fgResetPosAfterFoundSeq)
        {
            UINT64 u8FilePos = prRangeList->u8OffsetI;
            
            LOG(1, "[%s] sended seq header\n", __FUNCTION__);
            LOG(0, "[%s] prRangeList->u4Timestap 0x%x\n", __FUNCTION__, prRangeList->u4Timestap);
            if (!prRangeList->u4Timestap)
            {
                prMpgInfo->rVar.u4FirstPTS = MPG_STC_BASE;
            }
            else
            {
                prMpgInfo->rVar.u4FirstPTS = prRangeList->u4Timestap;
            }
            
            prMpgInfo->rFmt.fgSeekaud = TRUE;
            prMpgInfo->rFmt.fgSeekvid = TRUE;
            prMpgInfo->rVar.u4SeekAudPTS = prRangeList->u8StartPts;
            if ((((UINT32)(u8FilePos >> 32) == (UINT32)0xFFFFFFFF) &&
                 ((UINT32)(u8FilePos) == (UINT32)0xFFFFFFFF)) ||
                 (prRangeList->u8OffsetI > prRangeList->u8Offset))
            {
                UINT64 u8FrameSize = DEFAULT_FRAME_SIZE;
                _SWDMX_MpgGetFrameSize(u1SrcId, &u8FrameSize);

                if(prRangeList->u8Offset > u8FrameSize * 30)
                {
                    u8FilePos = (prRangeList->u8Offset - u8FrameSize * 30);
                }
                else
                {
                    u8FilePos = 0x0;
                }
                if(u8FilePos < prMpgInfo->rVar.u8StartFileOffset)
                {
                    u8FilePos = prMpgInfo->rVar.u8StartFileOffset;
                }
            }
            if (prMpgInfo->rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
            {
                if(_SWDMX_MpgGetPosByTime(u1SrcId, TRUE, prRangeList->u8StartPts, &u8FilePos))
                {
                }
                else
                {
                    u8FilePos = prRangeList->u8OffsetI;
                }
                STC_StopStc(prSwdmxInst->u1StcId);
                STC_SetStcValue(prSwdmxInst->u1StcId, prRangeList->u8StartPts);
            }

            /* DTV00325451, some video es file cannot be decoded if not from file start. If render pos < 10M,
               send data from file start, just a temp solution. */
            if((u8FilePos < 0xA00000) &&
                    (prMpgInfo->rFmt.eFmt >= SWDMX_FMT_VC1_ES) &&
                    (prMpgInfo->rFmt.eFmt <= SWDMX_FMT_AVS_VIDEO_ES))
            {
                u8FilePos = prMpgInfo->rVar.u8StartFileOffset;
            }

            prRangeList->fgSetRenderPosition = FALSE;
            UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1VdecId, TRUE,
                        prRangeList->u8Offset,
                        prRangeList->i4TempRef,
                        prRangeList->u2DecodingOrder));
            prMpgInfo->rVar.u8OrgSendedSize = u8FilePos;
            prMpgInfo->rVar.u8SendedSize = prMpgInfo->rVar.u8OrgSendedSize;
            prMpgInfo->rVar.u8ReadedPos = prMpgInfo->rVar.u8OrgSendedSize;
            prMpgInfo->rVar.u8PlayPos = prMpgInfo->rVar.u8OrgSendedSize;
            prMpgInfo->rVar.u4PreviousPTS = prRangeList->u8StartPts;
            prMpgInfo->rVar.u4LastMemoryPTS = prRangeList->u8StartPts;

            _SWDMX_MpgModifyPlayPos(u1SrcId);
            prMpgInfo->rVar.u8OrgSendedSize = prMpgInfo->rVar.u8PlayPos;
            prMpgInfo->rVar.u8SendedSize = prMpgInfo->rVar.u8PlayPos;
            prMpgInfo->rVar.u8ReadedPos = prMpgInfo->rVar.u8PlayPos;

            if(prMpgInfo->rVar.prCurRangeReq)
            {
                LOG(5, "SendData Position RenderFromPos I:0x%llx, 0x%llx, PTS:0x%x, i4TempRef: %d,u4FirstPTS:%lu.\n",
                        prMpgInfo->rVar.u8PlayPos, prRangeList->u8Offset, prMpgInfo->rVar.u4PreviousPTS, 
                        prRangeList->i4TempRef, prMpgInfo->rVar.u4FirstPTS);
            }
            UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
            UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1VdecId, FALSE, prMpgInfo->rVar.u8FileSize));

            _SWDMX_MpgResetData(u1SrcId);
            MPV_FlushEsmQ(prSwdmxInst->u1VdecId, FALSE);
            if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                    (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
            {
                UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1Vdec2Id, TRUE,
                            prRangeList->u8Offset,
                            prRangeList->i4TempRef,
                            prRangeList->u2DecodingOrder));
                UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1Vdec2Id, FALSE, prMpgInfo->rVar.u8FileSize));
                MPV_FlushEsmQ(prSwdmxInst->u1Vdec2Id, FALSE);
            }
            prMpgInfo->rVar.fgResetPosAfterFoundSeq = FALSE;
        }
    }
}


VOID _SWDMX_MpgHandleChange(UINT8 u1SrcId, SWDMX_CUR_CMD_T* prCmd)
{
    BOOL fgRet;
    BOOL fgSeek;
    UINT32 u4Count;
    UINT16 u2DecodingOrder;
    INT32 i4TempRef;
    UINT64 u8Offset, u8OffsetI;
    INT32 i4PlaySpeed;
    UINT64 u8SeekPos;

    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    if(!prCmd)
    {
        LOG(1, "_SWDMX_MpgHandleChange prCmd null\n");
        return;
    }
    i4PlaySpeed = prCmd->i4PlaySpeed;
    u8SeekPos = prCmd->u8SeekPos;
    fgSeek = FALSE;
    if(((UINT32)(u8SeekPos>>32) != (UINT32)0xFFFFFFFF)
        || ((UINT32)(u8SeekPos) != (UINT32)0xFFFFFFFF))
    {
        LOG(5, "_SWDMX_MpgHandleChange change pos: 0x%llx -> 0x%llx ================\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize, u8SeekPos);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSeek = TRUE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4MvcSeekVidPTS = 0xFFFFFFFF;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4MvcSeekAudPTS = 0;

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio2Eos = FALSE; // 0831        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio3Eos = FALSE; // 0831        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSeekvid = TRUE;

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS = 0xFFFFFFFF;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SecondVideoPTS = 0xFFFFFFFF;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS = 0xFFFFFFFF;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4DeltaAudioPTS = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastMemoryPTS = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgLastMemory = FALSE;        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = FALSE; // PTS reset
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgHaveVideoData = FALSE;                
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidPidChg = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudPidChg = FALSE;         
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdVidId  = 0xFFFF;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdAudId  = 0xFFFF; 
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidCodecChg = FALSE; 
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudCodecChg = FALSE; 
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4DmxPreviousAvailSizeVideo = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4DmxPreviousAvailSizeAudio = 0;                
        prSwdmxInst->eUpdVideoType = ENUM_SWDMX_VDEC_UNKNOWN;
        prSwdmxInst->eUpdAudioType = ENUM_SWDMX_ADEC_UNKNOWN;        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideoReady = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetFirstAudPts = FALSE;  //DTV00093908
#ifdef TIME_SHIFT_SUPPORT
   #if 0 // DTV00077914 remove it  when in no signal status ,FW to end and speed change to 1x, will send a wrong "  MM_SIGNAL_N_TO_Y" to mw
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage == MPG_TSS_UNDER_NO_SIGNAL)
        {
            LOG(3, "_SWDMX_MpgHandleChange: MM_SIGNAL_N_TO_Y u4NoSignalStage 0\n");
            if((prSwdmxInst) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
            {
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
                {
                    _SWDMX_RANGE_CALLBACK(
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                        MM_SIGNAL_N_TO_Y,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                        0xFFFFFFFF,
                        (UINT32)u1SrcId);
                }
            }
        }
        else if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage == MPG_TSS_UNDER_BAD_STORAGE)
        {
            LOG(3, "_SWDMX_MpgHandleChange: MM_BAD_TICK_Y_TO_N u4NoSignalStage 0\n");
            if((prSwdmxInst) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
            {
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
                {
                    _SWDMX_RANGE_CALLBACK(
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                        MM_BAD_TICK_Y_TO_N,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                        0xFFFFFFFF,
                        (UINT32)u1SrcId);
                }
            }
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage = MPG_TSS_NORMAL;
  #endif
//#if 1
#if 0
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex = NULL;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex = NULL;

        {
            BOOL fgRet;
            UINT32 u4Temp;
            fgRet = _SWDMX_MpgGetTickByPos(u1SrcId,
                TRUE,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize,
                i4PlaySpeed,
                &u4Temp);
            if(fgRet)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum = u4Temp;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ReadTickNum =
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum;
                LOG(5, "_SWDMX_MpgHandleChange tick num: %d\n",
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum);
            }
            else
            {
                // give a initial value
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum =
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeStartTick;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ReadTickNum =
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum;
                LOG(5, "_SWDMX_MpgHandleChange, NG, use safe start tick num: %d\n",
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum);
            }
        }
#endif
#endif
#ifdef SWDMX_MPG_CHECK_MP3_AUDIO
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4Mp3Cnt = 0;
#endif
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio2 = FALSE;  // 0831
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio3 = FALSE;  // 0831
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgChangeVideo = FALSE;
        //_fgSetAudioStartTime = FALSE;
        //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFirst = TRUE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicCnt = 0;
        u4Count = (UINT32)u8SeekPos;
        UNUSED(u4Count);
        if(u8SeekPos < (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset;            
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        }
        else
        {
#ifdef TIME_SHIFT_SUPPORT
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos =
                    _SWDMX_MpgTSAlignDown(u1SrcId, u8SeekPos);
                LOG(0,"%s:tshift seek pos %llu\n",__FUNCTION__,prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos);
            }
            else
#endif
            {
                {
                    //UINT64 u8Remainder;
                    if (u8SeekPos < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos =
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset;
                        LOG(0, "Seek position < StartFileOffset, use StartFileOffset 0x%llx\n",
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset);
                    }
                    else if (u8SeekPos > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos =
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize;
                        LOG(0, "Seek position > FileSize, use FileSize 0x%llx\n",
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize);
                    }
                    else
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = u8SeekPos;
                    }
                    //UNUSED(_SWDMX_Div6464((u8SeekPos + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset), (UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase, &u8Remainder));
                    //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos -= u8Remainder;
                    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES) ||
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS) ||
			           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_204) ||
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_192) ||
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ZERO_192) ||
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192))
                    {
                        _SWDMX_MpgModifyPlayPos(u1SrcId);
                    }
					LOG(0,"%s:seek pos %llu\n",__FUNCTION__,prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos);
                }                
            }
            
            LOG(5, "_SWDMX_MpgHandleChange modify change pos : 0x%llx \n",
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos);            
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPTSFound = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPosWithPTSFound = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8Previous2IPosWithPTSFound = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousUIPos = 
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = 0;

        //  DTV00211793 only audio, no video ,do seek when have send EOF, need clear the flags
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio2Eos = FALSE; // 0831
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio3Eos = FALSE; // 0831        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = FALSE;

#ifdef TIME_SHIFT_SUPPORT           //DTV00077914
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
        {
            UINT32 u4Temp;

            fgRet = _SWDMX_MpgGetTickByPos(u1SrcId,
                        FALSE,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize,
                        i4PlaySpeed,
                        &u4Temp);
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex) &&
                                       (fgRet))
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum = u4Temp;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ReadTickNum = u4Temp;
                //LOG(5, "Trace u4CurTickNum(%d) _u8SendedSize(0x%llx)\n", prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum, _u8SendedSize);
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime =
                (UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex->ui4_tick_num;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime *=
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TickBase;
            }
            else
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum = 0;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ReadTickNum = 0;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime = 0;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage = MPG_TSS_NORMAL;
            }
        }
#endif

        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
        { 
            _SWDMX_MpgResetData(u1SrcId);
        }
        
        // DTV00132905, should stop timer bar
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
        {
            STC_StopStc(prSwdmxInst->u1StcId);
        }
        fgSeek = TRUE;
    }
    else if((prCmd->fgSeek) &&
            (prCmd->u4SeekMode == SWDMX_CUR_CMD_SEEK_OFFSET))
    {
        BOOL fgNoI = FALSE;
        LOG(5, "_SWDMX_MpgSendData fgPlayChangeOffset RenderFromPos I:0x%llx, 0x%llx, PTS:0x%x, i4TempRef: %d\n",
            prSwdmxInst->rSeekOffset.ui8_i_frame_position,
            prSwdmxInst->rSeekOffset.ui8_frame_position,
            prSwdmxInst->rSeekOffset.ui8_pts_info,
            prSwdmxInst->rSeekOffset.i4_temporal_reference);

        u8SeekPos = prCmd->rSeekOffset.ui8_frame_position;

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio2Eos = FALSE;  // 0831
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio3Eos = FALSE;  // 0831        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = FALSE;

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS = 0xFFFFFFFF;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SecondVideoPTS = 0xFFFFFFFF;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS = 0xFFFFFFFF;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4DeltaAudioPTS = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastMemoryPTS = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgLastMemory = FALSE;        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = FALSE; // PTS reset
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgHaveVideoData = FALSE;        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideoReady = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = FALSE;

#ifdef SWDMX_MPG_CHECK_MP3_AUDIO
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4Mp3Cnt = 0;
#endif
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio2 = FALSE; // 0831
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio3 = FALSE; // 0831         
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgChangeVideo = FALSE;
        //_fgSetAudioStartTime = FALSE;
        //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFirst = TRUE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgChangeVideo = FALSE;
        //_fgSetAudioStartTime = FALSE;
        //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFirst = TRUE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicCnt = 0;

        MPV_FlushEsmQ(prSwdmxInst->u1VdecId, FALSE);

        if((((UINT32)(prCmd->rSeekOffset.ui8_i_frame_position>>32) == (UINT32)0xFFFFFFFF)
            && ((UINT32)(prCmd->rSeekOffset.ui8_i_frame_position) == (UINT32)0xFFFFFFFF)))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8OrgSendedSize =
                prCmd->rSeekOffset.ui8_frame_position;
            fgNoI = TRUE;
        }
        else
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8OrgSendedSize =
                prCmd->rSeekOffset.ui8_i_frame_position;
            fgNoI = FALSE;
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize =
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8OrgSendedSize;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos =
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8OrgSendedSize;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos =
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8OrgSendedSize;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr =
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS =
            prCmd->rSeekOffset.ui8_pts_info;

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPTSFound = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos =
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPosWithPTSFound =
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8Previous2IPosWithPTSFound =
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize =
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = 0;
        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousUIPos = 
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        }
        
        //  DTV00211793 only audio, no video ,do seek when have send EOF, need clear the flags
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio2Eos = FALSE; // 0831        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio3Eos = FALSE; // 0831        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = FALSE;
#ifdef TIME_SHIFT_SUPPORT           //DTV00077914
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
        {
            UINT32 u4Temp;
            fgRet = _SWDMX_MpgGetTickByPos(u1SrcId,
                                FALSE,
                                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize,
                                i4PlaySpeed,
                                &u4Temp);
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex) &&
                               (fgRet))
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum = u4Temp;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ReadTickNum = u4Temp;
                //LOG(5, "Trace u4CurTickNum(%d) _u8SendedSize(0x%llx)\n", prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum, _u8SendedSize);
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime =
                (UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex->ui4_tick_num;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime *=
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TickBase;
            }
            else
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum = 0;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ReadTickNum = 0;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime = 0;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage = MPG_TSS_NORMAL;
            }
        }
#endif

        if(fgNoI)
        {
            UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
            UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
            UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1VdecId, TRUE,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
            LOG(5, "SEEK_OFFSET VDEC_SetRenderFromFirstPic from 0x%llx\n",
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize);
            if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
               (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
            {
                UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1Vdec2Id, TRUE,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
            }
        }
        else
        {
            UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1VdecId, TRUE,
                prCmd->rSeekOffset.ui8_frame_position,
                prCmd->rSeekOffset.i4_temporal_reference,
                prCmd->rSeekOffset.ui2_decoding_order));
            UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
            UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1VdecId, FALSE,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
            if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
               (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
            {
                UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1Vdec2Id, TRUE,
                    prCmd->rSeekOffset.ui8_frame_position,
                    prCmd->rSeekOffset.i4_temporal_reference,
                    prCmd->rSeekOffset.ui2_decoding_order));
                UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1Vdec2Id, FALSE,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
            }
            LOG(5, "SEEK_OFFSET VDEC_SetRenderFromPos I:0x%llx, 0x%llx, PTS:0x%x, i4TempRef: %d\n",
                prCmd->rSeekOffset.ui8_i_frame_position,
                prCmd->rSeekOffset.ui8_frame_position,
                prCmd->rSeekOffset.ui8_pts_info,
                prCmd->rSeekOffset.i4_temporal_reference);
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS =
                ((prCmd->rSeekOffset.ui8_pts_info - (MPG_STC_BASE))+ prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS);
        }

        _SWDMX_MpgResetData(u1SrcId);
        // DTV00132905, should stop timer bar
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
        {
            STC_StopStc(prSwdmxInst->u1StcId);
        }
        fgSeek = TRUE;
    }

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
    {
        LOG(5, "_SWDMX_MpgHandleChange change speed: %d ====================\n", i4PlaySpeed);
#ifdef TIME_SHIFT_SUPPORT
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
        {
            if(!_SWDMX_PVR_SetDataMode(u1SrcId, i4PlaySpeed))
            {
                LOG(3, "_SWDMX_MpgHandleChange _SWDMX_PVR_SetDataMode fail\n");
            }
        }
#endif
		if(i4PlaySpeed > 0)
		{
			prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8RewindSendedSize = 0;
			prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8RewindMaxSendedSize = 0;
			prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8RewindJumpSize = 0;
			prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4RewindJumpCnt = 0;
		}
        if(i4PlaySpeed == 1000)
        {
            // always do start to play behavior
            //_SWDMX_MpgJumpToNormal(fgSeek,
            //    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpping,
            //    i4PlaySpeed);
            //_SWDMX_MpgJumpToNormal(u1SrcId, fgSeek, TRUE,
            //    i4PlaySpeed);
            //DTV00078801  for H264 video ES  flush will cause H.264 decdode can't found PPS.
            //DTV00086507  for video es 2x-->1x no needed to do flush
            if( (MM_SRC_TYPE_IPTV != prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type) &&
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed >= 1) &&
#ifdef VDEC_TIME_SHIFT_2X_I_MODE
                (((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed <= 1500) &&
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)) ||
                ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed <= 2000) &&
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)))
#else
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed <= 2000)
#endif
#if defined(SUPPORT_CIPLUS_RECORD)
                &&
                ( (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_ENCRYPT_192) ||
                  ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192) &&
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed != 1000)) )     // start play, rVar.fgFirst
#endif
                )
            {
                _SWDMX_MpgJumpToNormal(u1SrcId, fgSeek,
                    ((prCmd->fgSeek) &&
                     (prCmd->u4SeekMode == SWDMX_CUR_CMD_SEEK_OFFSET)),
                      FALSE,
                      i4PlaySpeed);
            }
            else
            {
                _SWDMX_MpgJumpToNormal(u1SrcId, fgSeek,
                    ((prCmd->fgSeek) &&
                     (prCmd->u4SeekMode == SWDMX_CUR_CMD_SEEK_OFFSET)),
                     TRUE,
                     i4PlaySpeed);
            }

            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpping = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2JumpAgainCount = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToADec = FALSE;

        }
        else if (
            (((i4PlaySpeed > 1000) && (i4PlaySpeed <= 1500))
#ifdef VDEC_TIME_SHIFT_2X_I_MODE
            ||
             // when play time-shift, usb performace is not good enough
             // use jump mode to play 2x speed.
            (((i4PlaySpeed > 1500) && (i4PlaySpeed < 4000))
             &&
             (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
#endif
            ||
            ((i4PlaySpeed >= 1) && (i4PlaySpeed < 1000))) &&
            (MM_SRC_TYPE_IPTV != prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type))
        {
            BOOL fgStartToPlay = FALSE;
            // DTV00211049 [MM Compatibility]No audio output when play after FF & FB with special file
            // If previous speed == step and now != step, do a start to play behavior
            if (((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed == 1) &&
                 (i4PlaySpeed != 1))
                ||
                // even we are in 1x speed,
                // vdec will fail to get a frame vdp are pause
                // so if we change to step, we will lose one frame to display
                // add the condition to avoid it
                ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed != 1) &&
                 (i4PlaySpeed == 1))
                ||
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpping)
            {
                fgStartToPlay = TRUE;
            }

            // DTV00078801  for H264 video ES  flush will cause H.264 decdode can't found PPS.
           if (( prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed ==1000)&&
               (i4PlaySpeed >= 1)&& (i4PlaySpeed < 1000))
           {
                fgStartToPlay = FALSE;
           }

            _SWDMX_MpgJumpToNormal(u1SrcId, fgSeek,
                ((prCmd->fgSeek) &&
                 (prCmd->u4SeekMode == SWDMX_CUR_CMD_SEEK_OFFSET)),
                fgStartToPlay,
                i4PlaySpeed);

            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpping = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2JumpAgainCount = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToADec = TRUE;
        }
        else
        {
            if(prSwdmxInst->rCurRangeReq.prDmxRangeInfo->e_mm_src_type != MM_SRC_TYPE_NETWORK_DASH)
            {
                MPV_FlushEsmQ(prSwdmxInst->u1VdecId, FALSE);
                UNUSED(VDEC_ReleaseDispQ(prSwdmxInst->u1VdecId));
                if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                   (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                {
                    MPV_FlushEsmQ(prSwdmxInst->u1Vdec2Id, FALSE);
                    UNUSED(VDEC_ReleaseDispQ(prSwdmxInst->u1Vdec2Id));
                }
                VDP_ResetPts(prSwdmxInst->u1B2rId);

                _SWDMX_MpgResetData(u1SrcId);
            }
        
            if (MM_SRC_TYPE_IPTV != prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpping = TRUE;
            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2JumpAgainCount = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToADec = TRUE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio2Eos = FALSE; // 0831
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio3Eos = FALSE; // 0831            
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = FALSE;
#if 1//def CC_DLNA_SUPPORT
            FeederSetInfo(prSwdmxInst->eFeederSrc, FEEDER_SWDMX_EOS, FALSE);
#endif
            //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFirst = TRUE;

            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS = 0xFFFFFFFF;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SecondVideoPTS = 0xFFFFFFFF;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS = 0xFFFFFFFF;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4DeltaAudioPTS = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastMemoryPTS = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgLastMemory = FALSE;            
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = FALSE; // PTS reset
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgHaveVideoData = FALSE;            
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidPidChg = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudPidChg = FALSE;                     
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdVidId  = 0xFFFF;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdAudId  = 0xFFFF; 
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidCodecChg = FALSE; 
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudCodecChg = FALSE; 
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4DmxPreviousAvailSizeVideo = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4DmxPreviousAvailSizeAudio = 0;                
            prSwdmxInst->eUpdVideoType = ENUM_SWDMX_VDEC_UNKNOWN;
            prSwdmxInst->eUpdAudioType = ENUM_SWDMX_ADEC_UNKNOWN;           
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideoReady = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = FALSE;
#ifdef TIME_SHIFT_SUPPORT
            // Don't need to change it when chagne speed.
            //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage = MPG_TSS_NORMAL;
#endif
#ifdef SWDMX_MPG_CHECK_MP3_AUDIO
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4Mp3Cnt = 0;
#endif
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio2 = FALSE;            
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgChangeVideo = FALSE;
            //_fgSetAudioStartTime = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicCnt = 0;
            // from now, we use file position of last displayed picture.
            u8OffsetI = 0;
            u8Offset = u8OffsetI;
            u2DecodingOrder = 0;
            i4TempRef = 0;
            if(!fgSeek)
            {
                // if seek and trick, we might get the older position before seek.
                // we have to ignore the older position when seek.
                fgRet = VDP_GetFilePosition(prSwdmxInst->u1B2rId, &i4TempRef, &u2DecodingOrder, &u8Offset, &u8OffsetI);
                if(fgRet)
                {
                    if(i4PlaySpeed > 0)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = u8Offset;
                        LOG(5, "HandleChange Jumpping 1 u8SendedSize 0x%llx u8JumpStartAddr 0x%llx\n",
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr);
                    }
                    else
                    {
                        if((((UINT32)(u8OffsetI>>32) == (UINT32)0xFFFFFFFF)
                            && ((UINT32)(u8OffsetI) == (UINT32)0xFFFFFFFF)))
                        {
                            u8OffsetI = u8Offset;
                            LOG(3, "_SWDMX_MpgHandleChange No I, start from 0x%llx\n",
                                u8OffsetI);
                        }
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = u8OffsetI;
                        LOG(5, "HandleChange Jumpping 2 u8SendedSize 0x%llx u8JumpStartAddr 0x%llx\n",
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr);
                    }
                }
                else
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = u8Offset;
                    LOG(5, "_SWDMX_MpgHandleChange VDP_GetFilePosition fail\n");
                }
            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPTSFound = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPosWithPTSFound = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8Previous2IPosWithPTSFound = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = 0;
            
            if (MM_SRC_TYPE_IPTV != prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type)
            {
                LOG(5, "_SWDMX_MpgHandleChange VDEC_GetAvgPicSize %d\n",
                    VDEC_GetAvgPicSize(prSwdmxInst->u1VdecId));

                HAL_GetTime(&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpStartTime);
                UNUSED(VDEC_RegTrickPtsCb(prSwdmxInst->u1VdecId, _SWDMX_MpgSeekFinNotify, u1SrcId));
                
#ifdef TIME_SHIFT_SUPPORT
                if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
                {
                    // LWB: For other stage, SWDMX will not enter into HandleSeek anymore. This is abmormal. UI show 2X/4X, but in fact, driver play by 1X
                    // if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage == MPG_TSS_NORMAL)
                    {
                        _SWDMX_MpgHandleSeek(u1SrcId, i4PlaySpeed, fgSeek);
                    }
                }
                else
#endif
                {
                    _SWDMX_MpgHandleSeek(u1SrcId, i4PlaySpeed, fgSeek);
                }
            }
            else
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize = 0;
    }
        }
    }
    else if(((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) &&
             // when RAW_AUDIO_ES, we support -?x speed in driver build
             (((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime > 0) &&
               (i4PlaySpeed < 0))
              ||
              (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_RAW_AUDIO_ES)
             )
            )
            ||
            // we should reset variable in audio only stream
            // (might not set audio yet)
            (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
           )
    {
        LOG(5, "_SWDMX_MpgHandleChange no video change speed: %d ====================\n", i4PlaySpeed);

        _SWDMX_MpgResetData(u1SrcId);
        if(i4PlaySpeed < 0)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpping = TRUE;
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u2JumpAgainCount = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToADec = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio2Eos = FALSE; // 0831        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio3Eos = FALSE; // 0831        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = FALSE;
#if 1//def CC_DLNA_SUPPORT
        FeederSetInfo(prSwdmxInst->eFeederSrc, FEEDER_SWDMX_EOS, FALSE);
#endif

        // when audio es change speed or change position,
        // we should send data begining at the position which pts>0(begining of each index entry)
         // so there will be a jumpping, after do seek, or change speed  _u8SendedSize = _u8PlayPos;
        // reuse this code for tick mode -->normal mode, there is a jummping
#if 1
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = 
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset;
            LOG(5,"_swdmx_mpgHandleChange set u8PlayPos >= u8StartFileOffset (0x%x)\n",
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset);
        }
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)&&
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)&&
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime > 0)&&
            (i4PlaySpeed < 0))
        {
            UINT32 u4Speed;
            UINT64 u8Tmp;
            UINT64 u8Remainder;

           u4Speed = (i4PlaySpeed > 0) ? i4PlaySpeed : -i4PlaySpeed;
           u4Speed /= 1000;
           u8Tmp = _SWDMX_Div6464(((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset)*MPG_AUDIO_ES_SKIP_TIME), (UINT64)(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime), &u8Remainder);
           u8Tmp *= u4Speed;

           // change for DTV00098584
           if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos > u8Tmp + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset)
           {
               prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos -= u8Tmp;
           }
           else
           {
               prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset;
           }           
           if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos > u8Tmp + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset)
           {
               prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos - u8Tmp;
               if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousUIPos)
               {
                   LOG(1,"_swdmx_mpgHandleChange current UI pos[0x%llx] < u8JumpStartAddr[0x%llx] ,should reset u8JumpStartAddr \n",
                           prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousUIPos,
                           prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr);
                   prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousUIPos;
                   prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos       = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousUIPos;
                   
               }
           }
           else
           {
               prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset;
           }                
           _SWDMX_MpgModifyPlayPos(u1SrcId);
           prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
           prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;

        }
        else
        {
           if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
           {
               _SWDMX_MpgModifyPlayPos(u1SrcId);
           }      
           prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
           prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
           prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
        }

#else
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos;
#endif
        //_SWDMX_MpgHandleSeekAudio(i4PlaySpeed, fgSeek);

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS = 0xFFFFFFFF;
         prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SecondVideoPTS = 0xFFFFFFFF;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS = 0xFFFFFFFF;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastMemoryPTS = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgLastMemory = FALSE;        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = FALSE; // PTS reset
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgHaveVideoData = FALSE;                    
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideoReady = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = FALSE;
#ifdef TIME_SHIFT_SUPPORT
            // Don't need to change it when chagne speed.
            //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage = MPG_TSS_NORMAL;
#endif
#ifdef SWDMX_MPG_CHECK_MP3_AUDIO
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4Mp3Cnt = 0;
#endif
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio2 = FALSE;        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgChangeVideo = FALSE;
        //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicCnt = 0;

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPTSFound = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPosWithPTSFound = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8Previous2IPosWithPTSFound = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = 0;
    }
    //DTV00081416 trick mode to normal mode. we should start trigger audio again.
    else if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) &&
             (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES) &&
               (((i4PlaySpeed == 1000)&&
                 (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed != 1000)&&
                 ((UINT32)(u8SeekPos>>32) == (UINT32)0xFFFFFFFF)&&((UINT32)(u8SeekPos) == (UINT32)0xFFFFFFFF))))
    {
           // DTV00091732 , when use  DMX_MM_GetBufEmptySize() to calculate play position is not so exactly,
        // so we do a error handle, check is playPos  < u8StartFileOffset
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = 
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset;
            LOG(5,"_swdmx_mpgHandleChange set u8PlayPos >= u8StartFileOffset (0x%x)\n",
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset);
        } 

        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed < 0)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpping = FALSE;
        }
    }
    //DTV00094813, when FR to the file start, u8SendedSize will be set to fileSize, so we need to flush Afifo, and set 
    // u8SendedSize and u8ReadedPos to u8PlayPos.
    else if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) &&
             (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES) &&
               (i4PlaySpeed >= 2000)&&(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed < 0)&&
               prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF)
    {
        LOG(5, "_SWDMX_MpgHandleChange no video change speed from %d to %d====================\n", 
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed, i4PlaySpeed);
        _SWDMX_MpgResetData(u1SrcId);
        //DTV00314077, play pos can not be smaller than u8StartFileOffset
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = 
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset;
        } 
        _SWDMX_MpgModifyPlayPos(u1SrcId);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = FALSE;
    }

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed = i4PlaySpeed;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPauseMoving = TRUE; 
    
    if (MM_SRC_TYPE_IPTV == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type)
    {
       VDEC_SetMMParam( prSwdmxInst->u1VdecId, VDEC_MM_DROP_TIMEOUTFRAME, 
                        (i4PlaySpeed==2000)?(UINT32)TRUE:(UINT32)FALSE, 0, 0);
    }

    return ;
}

static VOID _SWDMX_MpgPauseRecordingPlayback(UINT8 u1SrcId)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);

    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);
    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq) && !prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgRequestPause)
    {
        _SWDMX_RANGE_CALLBACK(
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
            MM_FILE_WAIT_PLAY,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
            0xFFFFFFFF,
            (UINT32)u1SrcId);          
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgRequestPause = TRUE;
        LOG(1,"SWDMX data request coming border , wait to MW pause!\n");
    }
    else
    {
        LOG(3, "pfnSwdmxRangeCb null\n");
    }
}

VOID _SWDMX_MpgHandleEOS(UINT8 u1SrcId, INT32 i4PlaySpeed)
{
    UINT32 au4BufStart[2], au4BufEnd[2];

    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);


    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed >= 1000) &&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192) && 
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgDynamicDuration))
    {
        LOG(3,"chasing playback should not send EOS!\n");
        
        _SWDMX_MpgPauseRecordingPlayback(u1SrcId);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgPauseMoving = TRUE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = FALSE;
        return;        
    }

    #if 1//def CC_DLNA_SUPPORT
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type !=
        MM_SRC_TYPE_HIGH_SPEED_STORAGE)
    {
        FeederSetInfo(prSwdmxInst->eFeederSrc, FEEDER_SWDMX_EOS, TRUE);
    }
    #endif

    // if i4PlaySpeed = 1x or 2x, fgVideoPause = TRUE
    // then got EOS and VDec in pause.
    //if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF)
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        if((((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) && (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady))
            ||
            (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)) &&
            ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) && (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause)))
        {
            VDP_SetPauseMm(prSwdmxInst->u1B2rId, FALSE);
            _SWDMX_MpgVdecPlay(u1SrcId);
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideoReady = TRUE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo = TRUE;
        }
    }

    // DTV00132905, seek to end without sending any a/v data.
    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = TRUE;
        STC_StopStc(prSwdmxInst->u1StcId);
        STC_SetStcValue(prSwdmxInst->u1StcId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTimeOffset);
        LOG(3, "_SWDMX_MpgHandleEOS STC_SetStcValue 0x%x\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTimeOffset);
    }

    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) && (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos))
    {
        DMX_AUDIO_PES_T rPes;
        x_memset(&rPes, 0, sizeof(rPes));
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioWptr != 0)
        {
            rPes.u4Wp = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioWptr;
        }
        else
        {
#ifdef AUD_OLDFIFO_INTF
            VERIFY(AUD_GetAudFifo(&au4BufStart[0], &au4BufEnd[0],
                &au4BufStart[1], &au4BufEnd[1]) == AUD_OK);
#else
            VERIFY(AUD_GetAudFifo(prSwdmxInst->u1AdecId, &au4BufStart[0], &au4BufEnd[0]) == AUD_OK);
#endif
            rPes.u4Wp = (au4BufStart[0] + 4); // Jessica.
        }
        rPes.u1DeviceId = AUD_DEC_MAIN; // 0831        
        //UNUSED(AUD_SendAudioPes(&rPes)); // audio driver said they need this one.
        rPes.fgEOS = TRUE;
        
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed >0)
        {
           rPes.fgForward = TRUE;          //for trick mode 
        }
        else
        {
            rPes.fgForward = FALSE;
        }

        //_SWDMX_MpgAudioCallback(&rPes);
        UNUSED(AUD_SendAudioPes(&rPes));
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = TRUE;
        if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = TRUE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = TRUE;

            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS =
                ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + (MPG_STC_BASE));
            #ifdef TIME_SHIFT_SUPPORT
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
            #endif
            {
                UNUSED(AUD_SetStartPts(prSwdmxInst->u1AdecId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS));
                //AUD_MMAoutEnable(prSwdmxInst->u1AdecId, TRUE);
                /*
                if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc)
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = TRUE;
                    STC_StopStc(prSwdmxInst->u1StcId);
                    STC_SetStcValue(prSwdmxInst->u1StcId, (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS));
                    LOG(3, "_SWDMX_MpgHandleEOS AUD_SetStartPts 4 pts 0x%x pos %d\n",
                        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS), (UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize);
                }
                */
                //STC_StartStc(prSwdmxInst->u1StcId);
            }

            //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = TRUE;
            //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = TRUE;
        }
        LOG(0, "_SWDMX_MpgHandleEOS send dummy EOS to Adec line %d\n", __LINE__);
    }
    
    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio2) && (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio2Eos))
    {
            DMX_AUDIO_PES_T rPes;
            x_memset(&rPes, 0, sizeof(rPes));
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio2Wptr != 0)
            {
                rPes.u4Wp = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio2Wptr;
            }
            else
            {
#ifdef AUD_OLDFIFO_INTF
                VERIFY(AUD_GetAudFifo(&au4BufStart[0], &au4BufEnd[0],
                    &au4BufStart[1], &au4BufEnd[1]) == AUD_OK);
#else
                VERIFY(AUD_GetAudFifo(prSwdmxInst->u1Adec2Id, &au4BufStart[0], &au4BufEnd[0]) == AUD_OK);
#endif
                rPes.u4Wp = (au4BufStart[0] + 4); // Jessica.
            }
            
            rPes.u1DeviceId = AUD_DEC_AUX; // 0831
            //UNUSED(AUD_SendAudioPes(&rPes)); // audio driver said they need this one.
            rPes.fgEOS = TRUE;
            
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed >0)
            {
               rPes.fgForward = TRUE;         //for trick mode 
            }
            else
            {
                rPes.fgForward = FALSE;
            }
    
            //_SWDMX_MpgAudioCallback(&rPes);
            UNUSED(AUD_SendAudioPes(&rPes));
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio2Eos = TRUE;
            if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = TRUE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = TRUE;
    
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS =
                    ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + (MPG_STC_BASE));
            #ifdef TIME_SHIFT_SUPPORT
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
            #endif
                {
                    UNUSED(AUD_SetStartPts(prSwdmxInst->u1Adec2Id, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS));
                    //AUD_MMAoutEnable(prSwdmxInst->u1AdecId, TRUE);
                    /*
                    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = TRUE;
                        STC_StopStc(prSwdmxInst->u1StcId);
                        STC_SetStcValue(prSwdmxInst->u1StcId, (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS));
                        LOG(3, "_SWDMX_MpgHandleEOS AUD_SetStartPts 4 pts 0x%x pos %d\n",
                            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS), (UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize);
                    }
                    */
                    //STC_StartStc(prSwdmxInst->u1StcId);
                }
    
                //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = TRUE;
                //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = TRUE;
            }
            LOG(0, "_SWDMX_MpgHandleEOS send dummy EOS to Adec line %d\n", __LINE__);
        }

      if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio3) && (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio3Eos))
        {
                DMX_AUDIO_PES_T rPes;
                x_memset(&rPes, 0, sizeof(rPes));
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio3Wptr != 0)
                {
                    rPes.u4Wp = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio3Wptr;
                }
                else
                {
#ifdef AUD_OLDFIFO_INTF
                    VERIFY(AUD_GetAudFifo(&au4BufStart[0], &au4BufEnd[0],
                        &au4BufStart[1], &au4BufEnd[1]) == AUD_OK);
#else
                    VERIFY(AUD_GetAudFifo(prSwdmxInst->u1Adec3Id, &au4BufStart[0], &au4BufEnd[0]) == AUD_OK);
#endif
                    rPes.u4Wp = (au4BufStart[0] + 4); // Jessica.
                }
                
                rPes.u1DeviceId = AUD_DEC_THIRD; // 0831
                //UNUSED(AUD_SendAudioPes(&rPes)); // audio driver said they need this one.
                rPes.fgEOS = TRUE;
                
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed >0)
                {
                   rPes.fgForward = TRUE;         //for trick mode 
                }
                else
                {
                    rPes.fgForward = FALSE;
                }
        
                //_SWDMX_MpgAudioCallback(&rPes);
                UNUSED(AUD_SendAudioPes(&rPes));
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio3Eos = TRUE;
                if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio)
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = TRUE;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = TRUE;
        
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS =
                        ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + (MPG_STC_BASE));
            #ifdef TIME_SHIFT_SUPPORT
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
            #endif
                    {
                        UNUSED(AUD_SetStartPts(prSwdmxInst->u1Adec3Id, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS));
                        //AUD_MMAoutEnable(prSwdmxInst->u1AdecId, TRUE);
                        /*
                        if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc)
                        {
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = TRUE;
                            STC_StopStc(prSwdmxInst->u1StcId);
                            STC_SetStcValue(prSwdmxInst->u1StcId, (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS));
                            LOG(3, "_SWDMX_MpgHandleEOS AUD_SetStartPts 4 pts 0x%x pos %d\n",
                                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS), (UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize);
                        }
                        */
                        //STC_StartStc(prSwdmxInst->u1StcId);
                    }
        
                    //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = TRUE;
                    //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = TRUE;
                }
                LOG(0, "_SWDMX_MpgHandleEOS send dummy EOS to Adec line %d\n", __LINE__);
     }    

    if(((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
           (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK)) &&
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) &&
       (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos))
    {
        DMX_PES_MSG_T rPes;
        x_memset(&rPes, 0, sizeof(rPes));
        rPes.fgEOS = TRUE;
        rPes.u4FrameType = PIC_TYPE_I;
        rPes.fgSeqHeader = TRUE;
        rPes.fgGop = TRUE;
        rPes.u1Channel = prSwdmxInst->u1Vdec2Id;
        rPes.pvInstanceTag=(void*)prSwdmxInst;                 //surpport mult instance
        if(!_SWDMX_MpgVideoCallback(&rPes))
        {
            LOG(3, "_SWDMX_MpgHandleSeek _SWDMX_MpgVideoCallback fail\n");
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = TRUE;
        LOG(0, "_SWDMX_MpgHandleEOS send dummy EOS to Vdec2 line %d\n", __LINE__);
    }
    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) &&
        (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos))
    {
        DMX_PES_MSG_T rPes;
        x_memset(&rPes, 0, sizeof(rPes));
        rPes.fgEOS = TRUE;
        rPes.u4FrameType = PIC_TYPE_I;
        rPes.fgSeqHeader = TRUE;
        rPes.fgGop = TRUE;
        rPes.pvInstanceTag=(void*)prSwdmxInst;                 //surpport mult instance
        if(!_SWDMX_MpgVideoCallback(&rPes))
        {
            LOG(3, "_SWDMX_MpgHandleSeek _SWDMX_MpgVideoCallback fail\n");
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = TRUE;
        // i4PlaySpeed = 4x or up.
        // if now in VDEC_PlayOneFrm, VDec might in pause status.
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
        {
            if((i4PlaySpeed < 1)
                || (i4PlaySpeed >= 4000)
                || (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause))
            {
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
                {
                    VDP_SetPauseMm(prSwdmxInst->u1B2rId, FALSE);
                    _SWDMX_MpgVdecPlay(u1SrcId);
                }
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause = FALSE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideoReady = TRUE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo = TRUE;
            }
        }
        LOG(0, "_SWDMX_MpgHandleEOS send dummy EOS to Vdec line %d\n", __LINE__);
    }
    if(prSwdmxInst->rCurRangeReq.prDmxRangeInfo &&
         IS_NETWORK_SOURCE(prSwdmxInst->rCurRangeReq.prDmxRangeInfo->e_mm_src_type))
    {
       prSwdmxInst->fgRcvEOS = TRUE;
    }
}

VOID _SWDMX_MpgGetAVThreshold(UINT8 u1SrcId, UINT16 * p2VideoThreshold, 
    UINT32 * p4AudioThreshold)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_INFO_T* prMpgInfo = NULL;
    UINT16 u2VideoThreshold = 0;
    UINT32 u4AudioThreshold = 0;
    UINT64 u8Remainder = 0;
    static UINT32 resetstc = 5;
	
	UINT32	u4AudioTmpThreshold = AVG_BIT_RATE_THRESHOLD;
	
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);
    prMpgInfo = &(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo);   
    
    if(prMpgInfo->rFmt.fgAudio        
        &&(prMpgInfo->rVar.e_mm_src_type != MM_SRC_TYPE_NETWORK_MPEG_REAL_PUSH)
        )
    {
        if(prMpgInfo->rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
        {
            u4AudioThreshold = MAX_AUDIO_DATA_SIZE;
            if(90000 <= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime )
            {
                u4AudioThreshold = _SWDMX_Div6464(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize, 
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime/90000, &u8Remainder);
                u4AudioThreshold *= 15;
                // Notes: the size must larger than FIFO_EMPTY_THRESHOLD  (UINT32)(3300)  or underflow may be occur 
                if(MIN_AUDIO_DATA_SIZE > u4AudioThreshold)
                {
                    u4AudioThreshold = MIN_AUDIO_DATA_SIZE;
                }
                else if (MAX_AUDIO_DATA_SIZE < u4AudioThreshold)
                {
                    u4AudioThreshold = MAX_AUDIO_DATA_SIZE;
                }
            }          
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type == MM_SRC_TYPE_NETWORK_DLNA)
            {
                if(!prMpgInfo->rVar.fgEnableAudio)
                {
                   u4AudioThreshold = MIN_AUDIO_DATA_SIZE;
                }
            }
        }
        else if(((prMpgInfo->rFmt.eFmt == SWDMX_FMT_MPEG2_PS) ||
                (prMpgInfo->rFmt.eFmt == SWDMX_FMT_MPEG1_DAT)) &&
                (prMpgInfo->rFmt.u2AudioSubId != 0xBD))
        {
            u4AudioThreshold = 14 * 1024;
        }
        else
        {
			if (prSwdmxInst->fgEnablePrebuffer)
			{
				u4AudioThreshold = 150 * 1024;			
			}
			else
			{
				u4AudioThreshold = 70 * 1024;
			}
			
            if(90000 <= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime )
            {				
                u4AudioTmpThreshold = _SWDMX_Div6464(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize, 
                                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime/90000, &u8Remainder);
                
    			if((USB_SOURCE(prMpgInfo->rVar.e_mm_src_type)) &&
    			    (u4AudioTmpThreshold < AVG_BIT_RATE_THRESHOLD) &&
    			    (!prSwdmxInst->fgEnablePrebuffer))
    			{
                    u4AudioThreshold = 15 * 1024;
    			}  
				else if ((prMpgInfo->rVar.e_mm_src_type == MM_SRC_TYPE_NETWORK_CMPB) &&
					     (u4AudioTmpThreshold < AVG_BIT_RATE_THRESHOLD))					
				{
                    u4AudioThreshold = 15 * 1024;
    			}                
            }
			
        }
    }

    if (prMpgInfo->rFmt.fgVideo)
    {
        if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
           (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
        {
            if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_H264)
            {
                u2VideoThreshold = MAX_AVC_EMSG_NUM;
            }
            else
            {
                u2VideoThreshold = MAX_EMSG_NUM;
            }
        }
        else if(MM_SRC_TYPE_NETWORK_MPEG_REAL_PUSH == prMpgInfo->rVar.e_mm_src_type)
        {
           if(prMpgInfo->rVar.fgEnableVideo)
                    {
                        u2VideoThreshold = 600;
                        if(prMpgInfo->rVar.u4LastPTS > 
                            STC_GetStcValue(prSwdmxInst->u1StcId) + 90000)
                        {
                            if((prMpgInfo->rVar.u4LastPTS > 45000) && resetstc)
                            {
                                STC_SetStcValue(prSwdmxInst->u1StcId, 
                                prMpgInfo->rVar.u4LastPTS - 45000);
                                resetstc--;
                                LOG(1, "still can reset stc %d times\n", resetstc);
                            }                            
                        }
                    }
                    else
                    {
                        resetstc = 5;
                        u2VideoThreshold = 18;
                    }     
                    if(prMpgInfo->rFmt.fgAudio &&
                        prMpgInfo->rVar.fgGotAudioReady &&
                        !prMpgInfo->rVar.fgEnableAudio)
                    {
                        LOG(1, "enable audio out\n");
                        AUD_MMAoutEnable(prSwdmxInst->u1AdecId, TRUE);
                        prMpgInfo->rVar.fgEnableAudio = TRUE;
                    }
                    if(prMpgInfo->rFmt.fgAudio)
                    {
                        u4AudioThreshold = 0;
                    }
                    LOG(4, "ev(%d), ga(%d), gar(%d), ea(%d)\n",                        
                        prMpgInfo->rVar.fgEnableVideo,
                        prMpgInfo->rVar.fgGotAudio,
                        prMpgInfo->rVar.fgGotAudioReady,
                        prMpgInfo->rVar.fgEnableAudio);
                   
        }
        else if(NEED_QUICK_START(prMpgInfo->rVar.e_mm_src_type))
        {
            if (MM_SRC_TYPE_IPTV == prMpgInfo->rVar.e_mm_src_type)
            {
                if(prMpgInfo->rVar.fgEnableVideo &&
                    !prMpgInfo->rVar.fgVideoPause)
                {
                    u2VideoThreshold = 180;
                }
                else
                {
                    u2VideoThreshold = 18;
                    if(prMpgInfo->rFmt.fgAudio)
                    {
                        u4AudioThreshold = 0;  /*10k*/
                    }
                }
            }
            else
            {
                if(!prMpgInfo->rVar.fgEnableVideo)
                {
                    u2VideoThreshold = MAX_QUICK_START_NUM;
                    u4AudioThreshold = 0;
                    // for wifi display quick start
                    if (prMpgInfo->rVar.e_mm_src_type == MM_SRC_TYPE_WIFI_DISPLAY)
                    {
                        u2VideoThreshold = 0;
                    }
                }
                else
                {
                    u2VideoThreshold = MAX_EMSG_NUM;
                }
            }
        }
        else if(USB_SOURCE(prMpgInfo->rVar.e_mm_src_type))
        {
            u2VideoThreshold = MAX_USB_EMSG_NUM;

            // LWB: For timeshit, Data parse speed was controled by DMX, we need not care much about it
            // LWB: if the threshold is too low, for some special TS, if video PTS - PCR > 1s, AV sync case will appear
            if (SWDMX_FMT_MPEG2_TS_TIME_SHIFT == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt)
            {
                u2VideoThreshold = MAX_EMSG_NUM;
            }
        }
        else if(IS_LOCAL_NET(prMpgInfo->rVar.e_mm_src_type))
        {
            u2VideoThreshold = MAX_LOCAL_NET_EMSG_NUM;
        }
        else
        {
            u2VideoThreshold = MAX_NET_EMSG_NUM;
        }
    }
    
    *p2VideoThreshold = u2VideoThreshold;
    *p4AudioThreshold = u4AudioThreshold;
}
VOID _SWDMX_MpgHandleScrambleState(UINT8 u1SrcId,UINT8 u1StrmType,UINT8 u1Pidx)
{
    SWDMX_SCRAMBLE_STATE_T eScrambleState = SWDMX_SCRAMBLE_STATE_CLEAR;        

    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);    
    eScrambleState = (SWDMX_SCRAMBLE_STATE_T)DMX_GetScrambleState(u1Pidx);
    
    switch(u1StrmType)
    {
        case eSWDMX_STRM_TYPE_VID:
        {
            if( eScrambleState == SWDMX_SCRAMBLE_STATE_SCRAMBLED)
            {
                if(IS_PUSH_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type) ||
          prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192)
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoScramble = TRUE;
                }
                else
                {
                    //VDEC_Notify(prSwdmxInst->u1VdecId,VDEC_DEC_DECODE_CODEC_NOT_SUPPORT);
                }
                // VDEC_DEC_DECODE_NO_DATA
                //eScrambleState = SWDMX_SCRAMBLE_STATE_SCRAMBLED;
            }

      else if( eScrambleState == SWDMX_SCRAMBLE_STATE_CLEAR)
      {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192)
        {
          prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoScramble = FALSE;
        }
      }
      
            /* scrame state change and notify MW */
            if (prSwdmxInst->eVidScrambleState != eScrambleState)
            {
                /* clear -> scrame and notify mw*/
                if ((prSwdmxInst->eVidScrambleState == SWDMX_SCRAMBLE_STATE_CLEAR) &&
                    (eScrambleState == SWDMX_SCRAMBLE_STATE_SCRAMBLED))
                {
                    if (prSwdmxInst->pfnSwdmxVidSramebleCb != NULL)
                    {
                        prSwdmxInst->pfnSwdmxVidSramebleCb(prSwdmxInst->u1VidScramblePidx,
                            DMX_NOTIFY_CODE_SCRAMBLE_STATE,
                            SWDMX_SCRAMBLE_STATE_SCRAMBLED,
                            0);
                        LOG(1,"notify video scramble u1VidScramblePidx %d\n",prSwdmxInst->u1VidScramblePidx);
                    }   
                    prSwdmxInst->eVidScrambleState = SWDMX_SCRAMBLE_STATE_SCRAMBLED;
                }
                else if ((prSwdmxInst->eVidScrambleState == SWDMX_SCRAMBLE_STATE_SCRAMBLED) &&
                         (eScrambleState == SWDMX_SCRAMBLE_STATE_CLEAR))
                {
                    if (prSwdmxInst->pfnSwdmxVidSramebleCb != NULL)
                    {
                        prSwdmxInst->pfnSwdmxVidSramebleCb(prSwdmxInst->u1VidScramblePidx,
                            DMX_NOTIFY_CODE_SCRAMBLE_STATE,
                            SWDMX_SCRAMBLE_STATE_CLEAR,
                            0);
                        LOG(1,"notify video clear u1VidScramblePidx %d\n",prSwdmxInst->u1VidScramblePidx);
                    }   
                    prSwdmxInst->eVidScrambleState = SWDMX_SCRAMBLE_STATE_CLEAR;                                        
                }
            }        
            
            break;
        }
        case eSWDMX_STRM_TYPE_AUD:
        {
            if( eScrambleState == SWDMX_SCRAMBLE_STATE_SCRAMBLED)
            {
                if(IS_PUSH_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type))
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudioScramble = TRUE;
                }
                else
                {
#ifdef SWDMX_MPG_CHECK_AUDIO_SCRAMBLE
                    AUD_MM_Set_Dec_Fmt_Scramble(prSwdmxInst->u1AdecId, TRUE);
                    // 0831 ??
                    //AUD_MM_Set_Dec_Fmt_Scramble(prSwdmxInst->u1Adec2Id, TRUE);
                    //AUD_MM_Set_Dec_Fmt_Scramble(prSwdmxInst->u1Adec3Id, TRUE);                        
#endif
                }
                //eScrambleState = SWDMX_SCRAMBLE_STATE_SCRAMBLED;
            }
            /* scrame state change and notify MW */
            if (prSwdmxInst->eAudScrambleState != eScrambleState)
            {
                /* clear -> scrame and notify mw*/
                if ((prSwdmxInst->eAudScrambleState == SWDMX_SCRAMBLE_STATE_CLEAR) &&
                    (eScrambleState == SWDMX_SCRAMBLE_STATE_SCRAMBLED))
                {
                    if (prSwdmxInst->pfnSwdmxAudSramebleCb != NULL)
                    {
                        prSwdmxInst->pfnSwdmxAudSramebleCb(prSwdmxInst->u1AudScramblePidx,
                            DMX_NOTIFY_CODE_SCRAMBLE_STATE,
                            DMX_SCRAMBLE_STATE_SCRAMBLED,
                            0);
                        LOG(1,"notify audio scramble u1AudScramblePidx %d\n",prSwdmxInst->u1AudScramblePidx);
                    }   
                    prSwdmxInst->eAudScrambleState = SWDMX_SCRAMBLE_STATE_SCRAMBLED;
                }
                else if ((prSwdmxInst->eAudScrambleState == SWDMX_SCRAMBLE_STATE_SCRAMBLED) &&
                         (eScrambleState == SWDMX_SCRAMBLE_STATE_CLEAR))
                {
                    if (prSwdmxInst->pfnSwdmxAudSramebleCb != NULL)
                    {
                        prSwdmxInst->pfnSwdmxAudSramebleCb(prSwdmxInst->u1AudScramblePidx,
                            DMX_NOTIFY_CODE_SCRAMBLE_STATE,
                            SWDMX_SCRAMBLE_STATE_CLEAR,
                            0);
                        LOG(1,"notify audio clear u1AudScramblePidx %d\n",prSwdmxInst->u1AudScramblePidx);
                    }   
                    prSwdmxInst->eAudScrambleState = SWDMX_SCRAMBLE_STATE_CLEAR;                                        
                }
            }                 
            break;
        }
        default:
        ASSERT(0);
        break;
    }

}

static void _SWDMX_MpgFlushAudio(UINT8 u1SrcId)
{
	SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);
	_SWDMX_MpgFlushAFifo(u1SrcId);
    _SWDMX_MpgFlushAFifo2(u1SrcId);
    _SWDMX_MpgFlushAFifo3(u1SrcId);
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio != 0xFF)
    {
        UNUSED(DMX_MM_FlushBuffer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio));
    }
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2 != 0xFF)
    {
        UNUSED(DMX_MM_FlushBuffer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2));
    }        
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3 != 0xFF)
    {
        UNUSED(DMX_MM_FlushBuffer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3));
    }        
}



INT32 _SWDMX_MpgHandleFifoFull(UINT8 u1SrcId, INT32 i4PlaySpeed, BOOL fgLast)
{
    BOOL fgRet;
    BOOL fgFull;
    BOOL fgForcePlay;
    BOOL fgAudioSmaller;
    DMX_DDI_T rDDI;
    UINT32 u4DmxAvailSizeMin = 0;
    UINT32 u4DmxAvailSizeVideo = 0;
    UINT32 u4DmxAvailSizeAudio = 0;
    UINT16 u2QueueSize, u2MaxQueueSize;
    UINT16 u2DmxPictureQSize,u2DmxMaxQSize;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    fgFull = FALSE;
    fgForcePlay = FALSE;
    fgAudioSmaller = FALSE;

    x_memset(&rDDI, 0, sizeof(rDDI));
    fgRet = DMX_DDI_Get(DMX_DDI_FLAG_DATA_SIZE, &rDDI);
    rDDI.u4DataSize += (10*MPG_ALIGN_SIZE_TS_192); // max is 192
    if(!fgRet)
    {
        LOG(3, "_SWDMX_MpgHandleFifoFull DMX_DDI_Get fail.\n");
        return MPG_SEND_FAIL;
    }

    u4DmxAvailSizeMin = (1024*1024); // ToDo: 3M?
    u4DmxAvailSizeAudio = (1024*1024);
    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetInfo)
    {
        // playbacking, check AV size
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
        {
            // DTV00139611, [MM]Only flash progress bar after select current video file to play
            // notify not support when this clip is ts file with scramble data
            if(((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo)||
        ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192) &&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoScramble == TRUE)))  &&
                IS_TS_FILE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) &&
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1VideoKeyIndex == 0 &&
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u4VideoDescMode == 0)
            {
                _SWDMX_MpgHandleScrambleState(u1SrcId,eSWDMX_STRM_TYPE_VID,prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo);
            }

            u4DmxAvailSizeVideo = DMX_MUL_GetEmptySize(prSwdmxInst->u1DmxId,
                            DMX_PID_TYPE_ES_VIDEO,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo);

			u4DmxAvailSizeMin = u4DmxAvailSizeVideo;
			
            if(prSwdmxInst->u4LogFilter & check_fifo_full)
        	{
				LOG(2,"_SWDMX_MpgHandleFifoFull video avail size 0x%x\n",u4DmxAvailSizeVideo);
        	}
                            
            if(u4DmxAvailSizeVideo <=
                (1024*1024))
            {
                u2QueueSize = 0;
                u2MaxQueueSize = 0;
                VDEC_GetQueueInfo(prSwdmxInst->u1VdecId, &u2QueueSize, &u2MaxQueueSize);
                if(u2QueueSize < 2)
                {
                    // we have two choices.
                    // 1. notfiy video not exist.
                    // 2. just flush fifo data
                    #if 0
                    // 1.
                    VDEC_Notify(prSwdmxInst->u1VdecId,VDEC_DEC_DECODE_CODEC_NOT_SUPPORT);
                    // We don't know where to jump to.
                    //if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
                    //{
                    //    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgResetPosAfterFoundSeq = TRUE;
                    //}
                    LOG(3,"there is no video frame in queue, disable it\n");
                    #else
                    // 2.
                    _SWDMX_MpgFlushVFifo(u1SrcId);
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo != 0xFF)
                    {
                        UNUSED(DMX_MM_FlushBuffer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo));
                    }
                    if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                        (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                    {
                        _SWDMX_MpgFlushVFifo2(u1SrcId);
                        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo2 != 0xFF)
                        {
                            UNUSED(DMX_MM_FlushBuffer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo2));
                        }
                    }
                    LOG(3,"there is no video frame in queue, flush it\n");
                    #endif
                    return TRUE;
                }
            }
        }
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
        {
            // DTV00139611, [MM]Only flash progress bar after select current video file to play
            // notify not support when this clip is ts file with scramble data
            if ((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio) &&
                 IS_TS_FILE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) &&
                 prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1AudioKeyIndex == 0 &&
                 prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u4AudioDescMode == 0)
            {
                _SWDMX_MpgHandleScrambleState(u1SrcId,eSWDMX_STRM_TYPE_AUD,prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio);

            }

            u4DmxAvailSizeAudio = DMX_MUL_GetEmptySize(prSwdmxInst->u1DmxId,
                                    DMX_PID_TYPE_ES_AUDIO,
                                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio);

            if(prSwdmxInst->u4LogFilter & check_fifo_full)
        	{
				LOG(2,"_SWDMX_MpgHandleFifoFull audio avail size 0x%x\n",u4DmxAvailSizeAudio);        		
        	}
            
            if(u4DmxAvailSizeMin > u4DmxAvailSizeAudio)
            {
                u4DmxAvailSizeMin = u4DmxAvailSizeAudio;
                fgAudioSmaller = TRUE;
            }
        }
        
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio2)
        {
            u4DmxAvailSizeAudio = DMX_MUL_GetEmptySize(prSwdmxInst->u1DmxId,
                                    DMX_PID_TYPE_ES_AUDIO,
                                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2);
            if(u4DmxAvailSizeMin > u4DmxAvailSizeAudio)
            {
                u4DmxAvailSizeMin = u4DmxAvailSizeAudio;
                fgAudioSmaller = TRUE;
            }                    
        }

        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio3)
        {
            u4DmxAvailSizeAudio = DMX_MUL_GetEmptySize(prSwdmxInst->u1DmxId,
                                    DMX_PID_TYPE_ES_AUDIO,
                                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3);
            
            if(u4DmxAvailSizeMin > u4DmxAvailSizeAudio)
            {
                u4DmxAvailSizeMin = u4DmxAvailSizeAudio;
                fgAudioSmaller = TRUE;
            }
        }
        /* need to complete audio2
        // DTV00139611, [MM]Only flash progress bar after select current video file to play
        // notify not support when this clip is ts file with scramble data
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio2)
        {
            if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio)
            {
                if(DMX_GetScrambleState(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio) == DMX_SCRAMBLE_STATE_SCRAMBLED)
                {
#ifdef SWDMX_MPG_CHECK_AUDIO_SCRAMBLE
                    AUD_MM_Set_Dec_Fmt_Scramble(prSwdmxInst->u1AdecId, TRUE);
#endif
                    LOG(3,"video scramble\n");
                }
            }

            u4DmxAvailSizeAudio = DMX_GetMinFreeBufferSize(DMX_PID_TYPE_ES_AUDIO);
            if(u4DmxAvailSize > u4DmxAvailSizeAudio)
            {
                u4DmxAvailSize = u4DmxAvailSizeAudio;
                fgAudioSmaller = TRUE;
            }
        }
        */
        if (rDDI.u4DataSize >= u4DmxAvailSizeMin)
        {
            u4DmxAvailSizeMin = 0;
        }
        else
        {
            u4DmxAvailSizeMin -= rDDI.u4DataSize;
        }
        if (MPG_DMX_RESERVED_SIZE >= u4DmxAvailSizeMin)
        {
            u4DmxAvailSizeMin = 0;
        }
        else
        {
            u4DmxAvailSizeMin -= MPG_DMX_RESERVED_SIZE;
        }
    }

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPSISize)
    {
        static UINT32 u4BufferUnderRunCnt = 0;
        UINT32 u4DmxPSIAvailSize = 0;        
        // parsing, check psi buffer size
        #ifdef SWDMX_MPG_DMX_20
        u4DmxPSIAvailSize = DMX_MUL_GetEmptySize(prSwdmxInst->u1DmxId,
            DMX_PID_TYPE_PSI, 0xFF);
        #else
        u4DmxPSIAvailSize = DMX_GetMinFreeBufferSize(DMX_PID_TYPE_PSI);
        #endif
		if(prSwdmxInst->u4LogFilter & check_fifo_full)
		{
			LOG(2,"_SWDMX_MpgHandleFifoFull PSI avail size 0x%x\n",u4DmxPSIAvailSize);
		}
		
        if (rDDI.u4DataSize >= u4DmxPSIAvailSize)
        {
            u4DmxPSIAvailSize = 0;
            u4BufferUnderRunCnt++;
            if(u4BufferUnderRunCnt > 90)
            {
                DMX_PID_T rPidStruct;
                UINT32 u4Idx;

                for(u4Idx = 0;u4Idx < DMX_NUM_PID_INDEX;u4Idx++)
                {
                    x_memset(&rPidStruct, 0, sizeof(rPidStruct));
                    DMX_GetPid(u4Idx, DMX_PID_FLAG_BUFFER, &rPidStruct);
                    if(rPidStruct.ePidType == DMX_PID_TYPE_PSI)
                    {
                        if(rPidStruct.u4BufSize < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize)
                        {
                            LOG(0, "Please enlarge Pidx Buffer to 40K in sys_start.h\n");
                            LOG(0, "#define PSI_ENG_PAT_BUFF_SIZE    ((SIZE_T) 40960)\n");
                            break;
                        }
                    }
                }

                u4BufferUnderRunCnt = 0;
            }
        }
        else
        {
            u4BufferUnderRunCnt = 0;
            u4DmxPSIAvailSize -= rDDI.u4DataSize;
        }
        if ( u4DmxPSIAvailSize < u4DmxAvailSizeMin )
        {
            u4DmxAvailSizeMin = u4DmxPSIAvailSize;
        }        
    }

    if(u4DmxAvailSizeMin < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize)
    {
        BOOL bIsBadInterlive = FALSE;

		if(prSwdmxInst->u4LogFilter & check_fifo_full)
		{
			if ((u4DmxAvailSizeVideo < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize) &&
			    (u4DmxAvailSizeAudio > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize)
			    )
			{
			    bIsBadInterlive = TRUE;
			}
			else if ((u4DmxAvailSizeVideo > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize) &&
    			    (u4DmxAvailSizeAudio < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize))
			{
			    bIsBadInterlive = TRUE;
			}
			if (bIsBadInterlive)
			{
			    LOG(1,"this special file is bad interlive \n");
			}
		}
		
        LOG(7, "_SWDMX_MpgHandleFifoFull SWDMX Demuxer Buffer is not enough u4DmxAvailSizeMin (0x%x).\n",u4DmxAvailSizeMin);
		
        fgForcePlay = TRUE;
        fgFull = TRUE;
    }    
    
    if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetInfo) && (!fgFull))
    {
        if( prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo ||
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
        {
            BOOL fgVideoFull = TRUE;
            u2QueueSize = 0;
            u2MaxQueueSize = 0;
            
            if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) ||
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio))
            {
                _SWDMX_MpgGetAVThreshold(u1SrcId, &prSwdmxInst->u2VideoThreshold, &prSwdmxInst->u4AudioThreshold);
                LOG(9, "Threshold: A(0x%X) V(0x%X)\n", prSwdmxInst->u4AudioThreshold, prSwdmxInst->u2VideoThreshold);
            }
            
            if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
            {
                VDEC_GetQueueInfo(prSwdmxInst->u1VdecId, &u2QueueSize, &u2MaxQueueSize);
                DMX_GetPicQSize(&u2DmxPictureQSize, &u2DmxMaxQSize);
            
                fgVideoFull = FALSE;
                if(((u2DmxPictureQSize > 0) && (u2DmxMaxQSize > 384)) &&
                    (u2DmxPictureQSize > (u2DmxMaxQSize - 384)))
                {
          LOG(7,"vnum = %d %d\n",u2QueueSize,__LINE__);
                
                    fgFull = TRUE;
                }
                else if((u2DmxPictureQSize + u2QueueSize) >= u2MaxQueueSize) 
                {
                    /*
                            protect ESMQ overflow by the interrupt from dmx picture Q
                            when os scheduled to dmx, it will dump all in hands picture Q to Vdec ESMQ
                           */
          LOG(7,"vnum = %d %d\n",u2QueueSize,__LINE__);
                           
                    fgFull = TRUE;
                }
                else if(u2QueueSize >= prSwdmxInst->u2VideoThreshold)
                {
                    if (!prSwdmxInst->fgCheckUnderFlow)
                    {
                        prSwdmxInst->fgCheckUnderFlow = TRUE;                        
                    }
                    
                    if((u2QueueSize >= MAX_EMSG_NUM && prSwdmxInst->eVideoType != ENUM_SWDMX_VDEC_H264) ||
                         (u2QueueSize >= MAX_AVC_EMSG_NUM)
                        #ifdef IPTV_FAST_START
                        ||
                        ((MM_SRC_TYPE_IPTV == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type) &&
                        (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo))
                        #endif
                        )
                    {
            LOG(7,"vnum = %d %d\n",u2QueueSize,__LINE__);
                    
                        /****video max, no need to check audio****/
                        fgForcePlay = TRUE;
                        fgFull = TRUE;

                        // For IPTV, we set u2VideoThreshold to a little value, but fgaudioReady may still fasle. (We do not send data any more)
                        if ((MM_SRC_TYPE_IPTV == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type) &&
                            (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo))
                        {
                            fgForcePlay = TRUE;
                        }
                    }
                    else if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo)
                    {
                       /****video full****/
             LOG(7,"vnum = %d %d\n",u2QueueSize,__LINE__);
             
                       fgVideoFull = TRUE;
                    }
                }
                else if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause) &&
                         (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo) &&
                          NEED_QUICK_START(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type))
                {
                    if (prSwdmxInst->fgCheckUnderFlow)
                    {
                        prSwdmxInst->fgCheckUnderFlow = FALSE;
                    }
                    
                    if (u2QueueSize > MAX_QUICK_START_NUM)
                    {
            LOG(7,"vnum = %d %d\n",u2QueueSize,__LINE__);
                    
                        fgVideoFull = TRUE;
                    }
                }
                /****ap control network****/
                else if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo) 
                    &&
                    ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type ==
                    MM_SRC_TYPE_NETWORK_VUDU) ||
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type ==
                    MM_SRC_TYPE_PUSH) ||
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type ==
                    MM_SRC_TYPE_NETWORK_CMPB)) 
                    &&
                    (((prSwdmxInst->ePlaybackBufType == eSWDMX_BUF_MODE_TIME) &&
                    /**** ms -> frame (fps = 30)****/
                    (u2QueueSize >= (prSwdmxInst->u4PlaybackBufThreshold / 33))) ||
                    ((prSwdmxInst->ePlaybackBufType == eSWDMX_BUF_MODE_BYTE) &&
                    ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize -
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset) >=
                    prSwdmxInst->u4PlaybackBufThreshold))))
                    {
            LOG(7,"vnum = %d %d\n",u2QueueSize,__LINE__);
                    
                        fgVideoFull = TRUE;
                    }
            }                        

            if (!fgFull && fgVideoFull)
            {
                if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
                {
                    UINT32 u4Addr, u4Size;
                    if(!_SWDMX_GetAudioFifo(u1SrcId, &u4Addr, &u4Size))
                    {
                        LOG(3, "_SWDMX_GetAudioFifo Fail\n");
                        return FALSE;
                    }
                    #if 0
                    if(u4Size - u4DmxAvailSizeAudio > MAX_AUDIO_DATA_SIZE)
                    {
                        /****audio max, no need check video****/
                        fgFull = TRUE;
                    }
                    else
                    #endif
                    if( prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio &&
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady)
                    {
                        if ((u4Size - u4DmxAvailSizeAudio >= prSwdmxInst->u4AudioThreshold) ||
                            ((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio) &&
                            NEED_QUICK_START(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type)))
                        {
                            fgFull = TRUE;
                            LOG(7, "vnum = %d, asize = 0x%x\n", u2QueueSize, u4Size - u4DmxAvailSizeAudio);
                        }
                    }
                    else
                    {
                        // For pc->tv quick play, audio not ready but we have accumulated too much ES data, force VDEC play
                        if ( NEED_QUICK_START(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type) &&
                             (u2QueueSize > 3*prSwdmxInst->u2VideoThreshold) &&
                             (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio) )
                        {   
                          LOG(7,"vnum = %d %d\n",u2QueueSize,__LINE__);
                            fgFull = TRUE;
                        }
                        else
                        {
                            // Is not Full, Continue send Data
                        }
                    }
                }
                else if (fgVideoFull)
                {
                    fgFull = TRUE;
                    fgForcePlay = TRUE;
                    LOG(7, "vnum = %dn", u2QueueSize);
                }
            }
        }
    }

    // Handle dmx might use old read/write point when we update this on
    // _SWDMX_MpgAudioCallback. So do it again.
    if(((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio) ||
    // time-shift will set fgGotAudio but fgCleanAudio is on.
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCleanAudio)) &&
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo))
    {
        _SWDMX_MpgFlushAudio(u1SrcId);    
    }
    // ~handle dmx

#ifdef TIME_SHIFT_SUPPORT
    // To handle:
    // 1. pause vdp
    // 2. move data with block mode
    // 3. check display queue have video frame. If no, go to 2.
    // 4. keep move data with block mode
    // 5. if STC equals to first vdp's PTS,
    //    change move data method to tick mode
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause) &&
           (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo) &&
           (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideoReady) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) &&
           (i4PlaySpeed >= 0) &&
#ifdef VDEC_TIME_SHIFT_2X_I_MODE
           (i4PlaySpeed <= 1500)
#else
           (i4PlaySpeed < 4000)
#endif
          )
        {
            // pause video
            //UNUSED(VDP_SetPauseMm(prSwdmxInst->u1B2rId, TRUE));
            //STC_StopStc(prSwdmxInst->u1StcId);           //DTV00144863 When time shift for audio only file ,can't stop STC

            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause = TRUE;
            //LOG(3, "video pause  ==============\n");

            // 4x -> 1x, vdec might in pause status. play it.
            _SWDMX_MpgVdecPlay(u1SrcId);
        }

        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo))
        {
            if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause = FALSE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideoReady = TRUE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo = TRUE;
            }
        }
    }
    // ~To handle
#endif

    
#ifdef HANDLE_CHANGE_AUDIO_TYPE
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1WaitAudio &&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1WaitAudio != AUDIO_TYPE_HANDLE_END))
    { 
		if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type == MM_SRC_TYPE_PUSH ||
			prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type == MM_SRC_TYPE_NETWORK_VUDU)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1WaitAudio = AUDIO_TYPE_HANDLE_END;
            LOG(0, "push, end handle audio\n");
            return MPG_SEND_FULL;
        }
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1WaitAudio == AUDIO_TYPE_FOUND)
        {
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
            {
                prSwdmxInst->fgPlayChange = TRUE;
                prSwdmxInst->u8SeekPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1WaitAudio = AUDIO_TYPE_HANDLE_END;
                LOG(1, " seek after re-enable\n");
            }
            return MPG_SEND_FULL;
        }
        if(fgFull)
        {
            if((++(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1WaitAudio)) == AUDIO_TYPE_FOUND)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1WaitAudio = AUDIO_TYPE_HANDLE_END;
                LOG(1, "re-enable timeout\n");
            }
            else
            {
                LOG(3, "wait audio ready, fifo full\n");
                x_thread_delay(ONCE_DEALY_TIME);
                return MPG_SEND_FULL;
            }
        }
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio &&
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1WaitAudio = AUDIO_TYPE_HANDLE_END;
            LOG(1, "audio ready, end HANDLE_CHANGE_AUDIO_TYPE");
        }
    }  
#endif

    // [DTV00132776] The video stopped and the position-duration indicator in the status bar is null after input the current playing time.
    // When seek to near file end, we might send to vdec then vdec_pause,
    // nobody will call vdec_play.
    // Check this status here.
    if((fgFull) ||
        //(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize == (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufTotalSize)))
        // DTV00211080 [MM Compatibility]Progress bar doesn't start from the beginning when play special file
        // we should check start to play after we have send almost all data,
        // but not read all data.
       (fgLast) ||
       // when rendering thumbnail, not wait fifo full to start playback.
       ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) &&
        (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) &&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq) &&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo) &&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_vid_render_counts > 0)
       ) ||
       // DTV00447900 for MHEG5, when scramble video + normal audio, vdec play quickly.
       ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type == MM_SRC_TYPE_NETWORK_MHEG5) &&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoScramble) && 
        (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudioScramble) && 
        (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetKey) &&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo)) ||
       ((MM_SRC_TYPE_IPTV == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type) &&
        (2000 == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed))
      )
    {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
        {
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
            {
                BOOL fgAudioReady;
                BOOL fgFeederReady;
                if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
                {
                    fgAudioReady = TRUE;
                }
                else
                {
                    fgAudioReady =
                          ((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio) || // error handle, can't fuind audio
                            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio &&
                             prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady));

          LOG(7,"fgGotAudio %d fgGotAudioReady %d\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio,
             prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady);
                }

                fgFeederReady = FALSE;
                #ifdef CC_DLNA_SUPPORT
                if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type ==
                        MM_SRC_TYPE_NETWORK_DLNA)
                {
                    if (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendSeqHdr &&
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgResetPosAfterFoundSeq)
                    {
                        FeederSetReadyThreshold(prSwdmxInst->eFeederSrc, MPG_DLNA_FEEDER_UNREACH);
                        FeederSetUnderFlowThreshold(prSwdmxInst->eFeederSrc, MPG_DLNA_FEEDER_UNREACH);
                        FeederSetInfo(prSwdmxInst->eFeederSrc, FEEDER_SWDMX_THRESHOLD, FALSE);
                    }
                    else
                    {
                        UINT32 u4FeederReadySize = (MPG_DLNA_FEEDER_READY_SIZE);
                        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum*(MPG_BATCH_SIZE*MPG_BATCH_READ_SIZE))
                            > (u4FeederReadySize))
                        {
                            FeederSetReadyThreshold(prSwdmxInst->eFeederSrc, u4FeederReadySize);
                        }
                        else
                        {
                            u4FeederReadySize = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum*(MPG_BATCH_SIZE*MPG_BATCH_READ_SIZE));
                            FeederSetReadyThreshold(prSwdmxInst->eFeederSrc, u4FeederReadySize);
                        }
                        //FeederSetUnderFlowThreshold(MPG_DLNA_FEEDER_UNDERFLOW_SIZE);
                        FeederSetUnderFlowThreshold(prSwdmxInst->eFeederSrc, u4FeederReadySize/8);
                        FeederSetInfo(prSwdmxInst->eFeederSrc, FEEDER_SWDMX_THRESHOLD, TRUE);
                    }

                    if(FeederIsReady(prSwdmxInst->eFeederSrc))
                    {
                        fgFeederReady = TRUE;
                    }
                }
                else
                #endif
                if(IS_PUSH_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type))
                {
                    fgFeederReady = TRUE;
                }
                else
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type == MM_SRC_TYPE_NETWORK_VUDU)
                {
                    fgFeederReady = TRUE;
                }
                else
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type == MM_SRC_TYPE_NETWORK_RHAPSODY)
                {
                    fgFeederReady = TRUE;
                }
                else
                //if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type == MM_SRC_TYPE_HIGH_SPEED_STORAGE)
                {
                    // when audio buffer is 512K
                    // only could only have 1 buffer data (one is u4UsingBufSize)
                    //if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt >= 2)
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt >= 1)
                    {
                        fgFeederReady = TRUE;
                    }
                }

                if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize ==
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos +
                     prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize +
                     prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufTotalSize)) ||
                   // while vdec is pause then we got eof with vfifo full
                   // we will block here. Add this condition.
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.fgGetEof))
                {
                    // File end
                    fgFeederReady = TRUE;
                }

                if(((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause) && (fgAudioReady) && (fgFeederReady)) ||
                    ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause) && (fgForcePlay)))
                {
                    // DTV00136461 [MM]Can't full display the special ts file.
                    // if there is no video PTS
                    if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo) &&
                       (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPTSFound))
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPTSFound = TRUE;
                        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS)
                        {
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS;
                        }
                        else
                        {
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS = MPG_STC_BASE;
                        }
                        if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc) &&
                           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
                        {
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = TRUE;
                            STC_StopStc(prSwdmxInst->u1StcId);
                            // When there is video stream, stc value will set at vdec_flw.c
                        }
                    }
                    
                    LOG(0, "_SWDMX_MpgHandleFifoFull full -> VDEC_Play \n");
                    VDP_SetPauseMm(prSwdmxInst->u1B2rId, FALSE);                    
                    _SWDMX_MpgVdecPlay(u1SrcId);

                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideoReady = TRUE;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo = TRUE;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause = FALSE;
          /* This part will be done when vdp display first video frame.
          AUD_MMAoutEnable(prSwdmxInst->u1AdecId, TRUE);
          prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio = TRUE;
          */
                }

                  // DTV00136461 [MM]Can't full display the special ts file.
                  // audio full without triger again
                if((fgFull) && (fgAudioSmaller))
                  {
                      VDEC_GetQueueInfo(prSwdmxInst->u1VdecId, &u2QueueSize, &u2MaxQueueSize);
                      if(u2QueueSize == 0)
                      {
                    if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc) &&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT) &&
                       (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgHaveVideoData))
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = TRUE;

                        STC_StopStc(prSwdmxInst->u1StcId);              
                        STC_SetStcValue(prSwdmxInst->u1StcId, (UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS);
                STC_StartStc(prSwdmxInst->u1StcId);   
                LOG(3,"this stream not video ,swdmx start stc %x\n",prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS);
                    }
              
                          AUD_MMAoutEnable(prSwdmxInst->u1AdecId, TRUE);
                          prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio = TRUE;
                          // 0831 ??
                          if(prSwdmxInst->fgEnAudio2Dmx)
                          {
                              AUD_MMAoutEnable(prSwdmxInst->u1Adec2Id, TRUE);
                              prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio2 = TRUE;
                          }
                          else if(prSwdmxInst->fgEnAudio3Dmx)
                          {
                              // now can not do this...
                              //AUD_MMAoutEnable(prSwdmxInst->u1Adec3Id, TRUE);
                              prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio3 = TRUE;
                          }             
          
                          LOG(3, "_SWDMX_MpgHandleFifoFull AUD_MMAoutEnable video empty\n");
                    }

                }
            }
            else if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) &&
                    (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio) &&
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady))// audio only
            {
                #ifdef CC_DLNA_SUPPORT
                // DTV00212740, audio notify no data
                // audio should be pause when data underflow
                if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type == MM_SRC_TYPE_NETWORK_DLNA)
                {

                    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq) &&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo) &&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst)&&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst->u.pt_pb_idx_tbl_entry))
                    {
                        // we can't generate audio index size, we will block in
                        // buf count is full but data is still not full enough
                        FeederSetReadyThreshold(prSwdmxInst->eFeederSrc, MPG_DLNA_INDEX_FEEDER_READY_SIZE);
                        FeederSetUnderFlowThreshold(prSwdmxInst->eFeederSrc, MPG_DLNA_INDEX_FEEDER_UNDERFLOW_SIZE);
                    }
                    else
                    {
                        UINT32 u4FeederReadySize = (MPG_DLNA_FEEDER_READY_SIZE);
                        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum*(MPG_BATCH_SIZE*MPG_BATCH_READ_SIZE))
                            > (u4FeederReadySize))
                        {
                            FeederSetReadyThreshold(prSwdmxInst->eFeederSrc, u4FeederReadySize);
                        }
                        else
                        {
                            u4FeederReadySize = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum*(MPG_BATCH_SIZE*MPG_BATCH_READ_SIZE));
                            FeederSetReadyThreshold(prSwdmxInst->eFeederSrc, u4FeederReadySize);
                        }
                        //FeederSetUnderFlowThreshold(MPG_DLNA_FEEDER_UNDERFLOW_SIZE);
                        FeederSetUnderFlowThreshold(prSwdmxInst->eFeederSrc, u4FeederReadySize/8);
                    }
                    FeederSetInfo(prSwdmxInst->eFeederSrc, FEEDER_SWDMX_THRESHOLD, TRUE);
                }
                #endif
                LOG(0, "_SWDMX_MpgHandleFifoFull AUD_MMAoutEnable\n");
                AUD_MMAoutEnable(prSwdmxInst->u1AdecId, TRUE);
                STC_StartStc(prSwdmxInst->u1StcId);
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio = TRUE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudioPlayed = TRUE;        
                //0831
                if(prSwdmxInst->fgEnAudio2Dmx && !prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio2)
                {
                    AUD_MMAoutEnable(prSwdmxInst->u1Adec2Id, TRUE);
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio2 = TRUE;
                }
                if(prSwdmxInst->fgEnAudio3Dmx && !prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio3)
                {
                    //AUD_MMAoutEnable(prSwdmxInst->u1Adec3Id, TRUE);
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio3 = TRUE;
                }
            }
        }

        if(fgFull)
        {
            return MPG_SEND_FULL;
        }
    }

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo &&
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio &&
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio &&
        (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio) &&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS != 0xFFFFFFFF)
#ifdef TIME_SHIFT_SUPPORT
        && (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
#endif
       )
    {
        VDP_TriggerAudReceive(prSwdmxInst->u1B2rId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS = 0xFFFFFFFF;
    }
    
    return MPG_SEND_OK;
}


BOOL _SWDMX_MpgHandleMoveDataSysB(UINT8 u1SrcId, DMX_MM_DATA_T* prDmxMMData, INT32 i4PlaySpeed)
{
    BOOL fgRet = TRUE;
    UINT64 u8SkipStartpos;
    UINT64 u8SkipEndpos;
    UINT64 u8Remainder;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if(prDmxMMData->u4FrameSize >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SystemBPacketSize)
    {
        return _SWDMX_MoveData(u1SrcId, prDmxMMData);         
    }

    // confirm systemBPacketSize
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize == 0)
    {
        UINT64 u8Size = 0;
        UINT32 i = 0;
        UINT32 u4Addr = prDmxMMData->u4StartAddr;
        for(;i<14;i++)
        {
            u8Size <<= 8;
            u8Size +=  (UINT64)(*(CHAR*)u4Addr);
            u4Addr ++;
            if(u4Addr > prDmxMMData->u4BufEnd)
            {
                u4Addr -=
                    (prDmxMMData->u4BufEnd - prDmxMMData->u4BufEnd);
            }
        }
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SystemBPacketSize != 
            u8Size)
        {
            if(u8Size < 0xFFFFFFFF)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SystemBPacketSize = 
                    u8Size;
            }
            LOG(3, "u4SystemBPacketSize(%d)\n", (UINT32)u8Size);
        }
    }

    u8SkipStartpos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize +
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SystemBPacketSize + 14) - 1;
    u8SkipStartpos = _SWDMX_Div6464(u8SkipStartpos,
        (UINT64)(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SystemBPacketSize + 14),
        &u8Remainder);
    u8SkipStartpos *= (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SystemBPacketSize + 14);

    u8SkipEndpos = u8SkipStartpos + 14;
    
    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize +
        prDmxMMData->u4FrameSize) > u8SkipStartpos)
    {
        DMX_MM_DATA_T rDmxMMDataTmp;
        
        rDmxMMDataTmp = *prDmxMMData;
        rDmxMMDataTmp.u4FrameSize = 
            u8SkipStartpos - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize + prDmxMMData->u4FrameSize >
            u8SkipEndpos)
        {
            // will have second move
            rDmxMMDataTmp.fgEOS = FALSE;
        }
        if(rDmxMMDataTmp.u4FrameSize > 0)
        {
            fgRet = _SWDMX_MoveData(u1SrcId, &rDmxMMDataTmp);
            if(!fgRet)
            {
                LOG(3, "_SWDMX_MpgHandleMoveDataSysB 1 MoveData Fail.\n");
            }
            rDmxMMDataTmp.fgFrameHead = 0;
        }
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize + prDmxMMData->u4FrameSize >
            u8SkipEndpos)
        {
            rDmxMMDataTmp.u4StartAddr +=
                (u8SkipEndpos - 
                 prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize);
            if(rDmxMMDataTmp.u4StartAddr > rDmxMMDataTmp.u4BufEnd)
            {
                rDmxMMDataTmp.u4StartAddr -=
                    (rDmxMMDataTmp.u4BufEnd - rDmxMMDataTmp.u4BufStart);
            }
            ASSERT(u8SkipEndpos > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize);
            rDmxMMDataTmp.u4FrameSize = 
                prDmxMMData->u4FrameSize - 
                (u8SkipEndpos - 
                 prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize);                    
            rDmxMMDataTmp.fgEOS = prDmxMMData->fgEOS;
            fgRet = _SWDMX_MoveData(u1SrcId, &rDmxMMDataTmp);
            if(!fgRet)
            {
                LOG(3, "_SWDMX_MpgHandleMoveDataSysB 2 MoveData Fail.\n");
            }
        }
    }
    else
    {
        fgRet = _SWDMX_MoveData(u1SrcId, prDmxMMData);
    }
    return fgRet;
}
INT32 _SWDMX_MpgHandleMoveData(UINT8 u1SrcId, DMX_MM_DATA_T* prDmxMMData, INT32 i4PlaySpeed)
{
    BOOL fgRet;
    INT32 i4Ret;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
#ifdef TIME_SHIFT_SUPPORT
    UINT32 i;
    SWDMX_PVR_SENDDATA_RET_T ePVRRet;
    UINT32 u4MinSize = 0;
    UINT32 u4Temp = 0;
#endif
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
    if(!prDmxMMData)
    {
        LOG(1, "prDmxMMData null\n");
        return MPG_SEND_FAIL;
    }
#ifdef SWDMX_MPG_DEBUG_FIFO
#ifdef SWDMX_MPG_DMXFIFO_SIZE
    if((_fgDmxFifo) && (_fgDmxManual))
    {
        UINT32 u4Tmp;

        _SWDMX_COPY_RING_BUF(
            _u4DmxFifoStart,
            _u4DmxFifoEnd,
            &_u4DmxFifoCur,
            prDmxMMData->u4BufStart,
            prDmxMMData->u4BufEnd,
            prDmxMMData->u4StartAddr,
            prDmxMMData->u4FrameSize);
    }
#endif
#endif


    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCleanAudio = FALSE;
    i4Ret = MPG_SEND_OK;
    UNUSED(fgRet);

#ifdef TIME_SHIFT_SUPPORT
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        // ToDo: Handle 0x47 sync byte
        #if 1
        if((*(UCHAR*)VIRTUAL(prDmxMMData->u4StartAddr+4)) != 0x47)
        {
            LOG(3, "Move !0x47\n");
            ASSERT(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoSize);
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoSize)
            {
                UINT64 u8Tmp;
                UINT64 u8Remainder;
                u8Tmp = _SWDMX_Div6464((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset), (UINT64)192, &u8Remainder);
                UNUSED(_SWDMX_Div6464((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset), prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoSize, &u8Remainder));

                LOG(3, "!0x47, FileOffset 0x%llx, LBA 0x%llx, FilePos 0x%llx\n",
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset,
                    (UINT64)u8Tmp,
                    (UINT64)(u8Remainder + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset)
                    );
                UNUSED(u8Tmp);
                UNUSED(u8Remainder);
            }
            //ASSERT(0);
        }
        #endif

        // [DTV00141987] After fast rewind,the fast forward to right boundary ,audio isn't smooth
        // We should not use fast mode when out of safe range
        // mw safe range is small, we might switch fast/normal during safe-valid range
        // enlarge safe range in driver to prevent this switch.
        /*
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ValidEndTick >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum) &&
           ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ValidEndTick - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum) <=
             MPG_TIME_SHIFT_SAFE_RANGE_END_THRESHOLD))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgOutOfSafeRange = TRUE;
        }
        */

        for(i=0;i<(MPG_TIME_SHIFT_ADDRESS_CHECK_NUMBER-1);i++)
        {
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8QueueStartAddr[i] == 0) ||
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8QueueStartAddr[i+1] == 0))
            {
                break;
            }
            else
            {
                u4Temp = (UINT32)(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8QueueStartAddr[i+1] -
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8QueueStartAddr[i]);
                if(u4Temp <
                   (prDmxMMData->u4BufEnd - prDmxMMData->u4BufStart))
                {
                    u4MinSize += u4Temp;
                }
                else
                {
                    u4MinSize += (120*1024);
                }
            }
        }
        if(i < (MPG_TIME_SHIFT_ADDRESS_CHECK_NUMBER-1))
        {
            u4MinSize = (1024*1024);
        }

        // 1x senddata
        if((i4PlaySpeed == 1000)
           && // have at least one video or one audio
           // change to audio only not use fast mode
           // or swdmx speed is too fast
           ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) ||
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio))
            #if 0
           &&
            // can't use fast move when audio only, swdmx speed is too fast
           (
            // video with audio also have this problem
            //(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
            //||
            // can't use fast move when out of safe range
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgOutOfSafeRange)
             #if 1 // enable this to speed up Nx -> 1x speed
           )
             #endif
             #endif
          )
        {
            //LOG(3, "_SWDMX_PVR_SendData normal u8SendedSize(0x%llx)\n",
            //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize);
            /*
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgOutOfSafeRange)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgOutOfSafeRange = FALSE;
            }*/
            _SWDMX_LockMoveMutex(u1SrcId);
            ePVRRet = _SWDMX_PVR_SendData(u1SrcId, prDmxMMData, u4MinSize, FALSE);
            _SWDMX_UnlockMoveMutex(u1SrcId);
            if(ePVRRet == SWDMX_PVR_SENDDATA_FULL)
            {
                return MPG_SEND_FULL;
            }
            if(ePVRRet != SWDMX_PVR_SENDDATA_OK)
            {
                return MPG_SEND_FAIL;
            }
        }
        else
        {
            //LOG(3, "_SWDMX_PVR_SendData fast u8SendedSize(0x%llx)\n",
            //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize);
            _SWDMX_LockMoveMutex(u1SrcId);
            ePVRRet = _SWDMX_PVR_SendData(u1SrcId, prDmxMMData, u4MinSize, TRUE);
            _SWDMX_UnlockMoveMutex(u1SrcId);
            if(ePVRRet != SWDMX_PVR_SENDDATA_OK)
            {
                return MPG_SEND_FAIL;
            }

        }
        // this is tick size < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4QueueTickNum !=
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4QueueTickNum = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum;
            for(i=0;i<(MPG_TIME_SHIFT_ADDRESS_CHECK_NUMBER-1);i++)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8QueueStartAddr[i] =
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8QueueStartAddr[i+1];
            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8QueueStartAddr[(MPG_TIME_SHIFT_ADDRESS_CHECK_NUMBER-1)] =
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        }
    }
    else
#endif
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
    {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
        {
            #ifdef SWDMX_MPG_DMX_20
            prDmxMMData->u1Idx =
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio;
            fgRet = _SWDMX_MoveData(u1SrcId, prDmxMMData);
            #else
            fgRet = DMX_MM_MoveData(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio, prDmxMMData, 1000);
            #endif
            LOG(7, "_SWDMX_MpgHandleMoveData(%d) MoveData 0x%x, S=%d.\n",
                u1SrcId,
                prDmxMMData->u4StartAddr, prDmxMMData->u4FrameSize);
            if(!fgRet)
            {
                LOG(5, "_SWDMX_MpgHandleMoveData DMX_MM_MoveData Fail.\n");
                i4Ret = MPG_SEND_FAIL;
            }
        }
        else//DTV00214170,  For ES audio only file swdmx can't send data before audio stream enable
        {
            LOG(5, "_SWDMX_MpgHandleMoveData(%d) DMX_MM_MoveData Fail audio didn't enable.\n",
                u1SrcId);
            i4Ret = MPG_SEND_FAIL;
        }
    }
    else
    {
        #ifdef SWDMX_MPG_DMX_20
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) &&
           ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_VC1_ES) ||
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_AVS_VIDEO_ES) ||
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_VIDEO_ES) ||
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG4_VIDEO_ES) ||
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_H264_VIDEO_ES) ||
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_H265_VIDEO_ES)))
        {
            prDmxMMData->u1Idx =
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo;
        }
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSystemB)
        {
            fgRet = _SWDMX_MpgHandleMoveDataSysB(u1SrcId, prDmxMMData, i4PlaySpeed);
        }
        else
        {
#ifdef TIME_MEASUREMENT
            if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.fgUsingPrintTMS)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.fgUsingPrintTMS = FALSE;
                TMS_DIFF_EX(TMS_FLAG_WFD_LATENCY,"WFD_DATA:","Swdmx call Dmx move data");
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCbPrintTMS = TRUE;
            }
#endif
            fgRet = _SWDMX_MoveData(u1SrcId, prDmxMMData);
        }
        #else
        fgRet = DMX_DDI_MoveData(prDmxMMData);
        #endif
        LOG(9, "_SWDMX_MpgHandleMoveData MoveData 0x%x, S=%d.\n",
            prDmxMMData->u4StartAddr, prDmxMMData->u4FrameSize);
        if(!fgRet)
        {
            LOG(5, "_SWDMX_MpgHandleMoveData MoveData Fail.\n");
            i4Ret = MPG_SEND_FAIL;
        }
    }
#if 0
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo &&
        DMX_HDCP_IsInvalidCtr(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo))
    {
         _SWDMX_RANGE_CALLBACK(
             prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
             MM_VIDEO_STREAM_CTR_NOT_SUPPORT,
             prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
             0xFFFFFFFF,
             (UINT32)u1SrcId);
    }
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio &&
        DMX_HDCP_IsInvalidCtr(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio))
    {
        _SWDMX_RANGE_CALLBACK(
             prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
             MM_AUDIO_STREAM_CTR_NOT_SUPPORT,
             prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
             0xFFFFFFFF,
             (UINT32)u1SrcId);
    }
#endif
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCleanAudio)
    {
        _SWDMX_MpgFlushAFifo(u1SrcId);
        _SWDMX_MpgFlushAFifo2(u1SrcId);
        _SWDMX_MpgFlushAFifo3(u1SrcId);
        
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio != 0xFF)
        {
            UNUSED(DMX_MM_FlushBuffer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio));
        }
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2 != 0xFF)
        {
            UNUSED(DMX_MM_FlushBuffer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2));
        }        
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3 != 0xFF)
        {
            UNUSED(DMX_MM_FlushBuffer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3));
        }        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCleanAudio = FALSE;                
    }

    UNUSED(i4PlaySpeed);
    return i4Ret;
}
static VOID _SWDMX_MpgGetFrameSize(UINT8 u1SrcId, UINT64 *u8Size)
{
    UINT32 u4FrameRate = 30;
    UINT32 u4PreFrameTime = 3000;
    UINT32 u4Tmp = 0;
    UINT64 u8Remainder = 0;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);    

    VDEC_HDR_INFO_T rHdrInfo;
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);
    x_memset(&rHdrInfo, 0, sizeof(VDEC_HDR_INFO_T));
    if (VDEC_QueryInfo(prSwdmxInst->u1VdecId, &rHdrInfo))
    {
        u4FrameRate = (rHdrInfo.u2FrmRate + 99) / 100;
    }

    if ((0==u4FrameRate) || (300<u4FrameRate))
    {
        LOG(1, "Error Frame rate, set to 30fps.\n");
        u4FrameRate = 30;
    }

    ASSERT(u4FrameRate);
    u4PreFrameTime = 90000/u4FrameRate;
    ASSERT(u4PreFrameTime);

    *u8Size = DEFAULT_FRAME_SIZE;
    
   if(((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime) > u4PreFrameTime) && 
    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize > 0))
    {
        // prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime unit is 90000
        //u4Tmp = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime/90000)*30; // total frames
        //u8Size = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize/u4Tmp); // avg size/frame
        //u8Size *= (u4Speed/1000);
        u4Tmp = ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTimeOffset) / u4PreFrameTime); // total frames
        if(u4Tmp > 0) // prevent div zero
        {
            *u8Size = _SWDMX_Div6464((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset), (UINT64)u4Tmp, &u8Remainder);
        }
    }

    return;
}

static VOID _SWDMX_MpgHandleRecordingFile(UINT8 u1SrcId, INT32 i4_curr_speed)
{
    BOOL fgRet = TRUE;
    BOOL fgNeedPause = FALSE;
    UINT64 u8FrameSize = DEFAULT_FRAME_SIZE;
    UINT64 u8TrickSize = 0;
    VDP_PIC_INFO_T rPicInfo;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);

    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);
    x_memset(&rPicInfo, 0, sizeof(VDP_PIC_INFO_T));

    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPauseMoving ||!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgRequestPause)
    {
        _SWDMX_MpgGetFrameSize(u1SrcId, &u8FrameSize) ;
    }

    if (i4_curr_speed > 1)
    {
        u8TrickSize = u8FrameSize * i4_curr_speed * FILE_SIZE_PACKET_RESERVE;
    }
         
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPauseMoving)
    {
        if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeReadSize + 
             prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufTotalSize + u8TrickSize +
             prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize) ||
             prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize == (UINT64)(-1))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgPauseMoving = TRUE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPauseMoving = FALSE;
            if (i4_curr_speed > 1)
            {
                fgNeedPause = TRUE;
            }
        } else
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgPauseMoving = FALSE;
        }
    }

    if (i4_curr_speed == 1 && !prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgRequestPause) 
    {
        fgRet = (VDP_GetPicInfo(prSwdmxInst->u1B2rId, &rPicInfo));

        if (fgRet) //  OK = 1 for VDP_GetPicInfo
        {
            if (rPicInfo.u8Offset != 0 && rPicInfo.u8Offset + THRESHOLD_FRAME_COUNT * u8FrameSize >=
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize)
            {
                  fgNeedPause = TRUE;
            }
        }        
    }           

    if(fgNeedPause && !prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgRequestPause)
    {
        _SWDMX_MpgPauseRecordingPlayback(u1SrcId);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgRequestPause = TRUE;
    }

    return;
}

//#define TickMethod
UINT32 _SWDMX_MpgHandleAudioIndex(UINT8 u1SrcId, UINT64 u8StartAddr, UINT32 u4ReadSize,
    UINT64 *pu8OutStartAddr, UINT32 *pu4OutReadSize, UINT32 *pu4OutReadPTS, INT32 i4PlaySpeed)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);

    *pu8OutStartAddr = u8StartAddr;
    *pu4OutReadSize = u4ReadSize;
    *pu4OutReadPTS = 0;

    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_RAW_AUDIO_ES)
    {
        return MPG_AUDIO_INDEX_OK;
    }
    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq) &&
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo) &&
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst)&&
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst->u.pt_pb_idx_tbl_entry)
      )
    {
        MM_RANGE_ELEMT_IDXTBL_PB_ENTRY_T* prTblEntry = NULL;
        MM_RANGE_ELMT_IDXTBL_T* prIdxTbl = NULL;
        {
            UINT64 u8IdxBaseAddr;
            UINT64 u8IdxStartAddr;
            UINT64 u8IdxEndAddr;
            u8IdxBaseAddr =
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst->ui8_base_offset;
            prIdxTbl = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst;
            prTblEntry = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst->u.pt_pb_idx_tbl_entry;
            if((prTblEntry) && (prIdxTbl))
            {
                UINT32 u4Cnt = 0;
                if(prIdxTbl->ui4_number_of_entry == 0)
                {
                    LOG(3, "_SWDMX_MpgHandleAudioIndex ui4_number_of_entry 0\n");
                    return MPG_AUDIO_INDEX_OK;
                }
                while(u4Cnt < prIdxTbl->ui4_number_of_entry)
                {
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurIndexNum >= prIdxTbl->ui4_number_of_entry)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurIndexNum = 0;
                    }

                    u8IdxEndAddr = u8IdxBaseAddr +
                        (UINT64)prTblEntry[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurIndexNum].ui4_relative_offset +
                        (UINT64)prTblEntry[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurIndexNum].ui4_size;

                    if(((u8StartAddr) >=
                        (u8IdxBaseAddr +
                         prTblEntry[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurIndexNum].ui4_relative_offset
                        )
                       )
                       &&
                       ((u8StartAddr) <
                        (u8IdxEndAddr)
                       )
                      )
                    {
                        break;
                    }
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurIndexNum++;
                    u4Cnt++;
                }
                if(u4Cnt >= prIdxTbl->ui4_number_of_entry)
                {
                    *pu4OutReadSize = 0;
                    LOG(3, "_SWDMX_MpgHandleAudioIndex Read Address(0x%x)out of index num (from %d)\n",
                        u8StartAddr,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurIndexNum);
                    return MPG_AUDIO_INDEX_OK;
                }
                u8IdxStartAddr = u8IdxBaseAddr +
                    (UINT64)prTblEntry[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurIndexNum].ui4_relative_offset;

                u8IdxEndAddr = u8IdxStartAddr + (UINT64)prTblEntry[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurIndexNum].ui4_size;

                //if(u8IdxStartAddr == u8StartAddr)
                if(u8IdxStartAddr <= u8StartAddr)  //for handle jumpping to normal get  pts =0
                {
                    *pu4OutReadPTS = prTblEntry[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurIndexNum].ui4_pts;
                }
                if((u8StartAddr + (UINT64)u4ReadSize) > u8IdxEndAddr)
                {
                    *pu4OutReadSize = (UINT32)(u8IdxEndAddr - u8StartAddr);
                    if((u8IdxEndAddr - u8StartAddr) > 0xFFFFFFF)
                    {
                        LOG(3, "Too big, u8StartAddr %lld -- u8IdxEndAddr %lld\n",
                            u8StartAddr, u8IdxEndAddr);
                        *pu4OutReadSize = 0;
                    }
                    if(u8StartAddr > u8IdxEndAddr)
                    {
                        LOG(3, "u8StartAddr %lld > u8IdxEndAddr %lld\n",
                            u8StartAddr, u8IdxEndAddr);
                        *pu4OutReadSize = 0;
                    }
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurIndexNum++;
                }
            }
            else
            {
                //LOG(3, "_SWDMX_MpgHandleAudioIndex prTblEntry NULL\n");
            }
        }

    }
    else
    {
        UINT32 u4Time = 0;
        if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime > 0) &&
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize > 0) &&
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize != INVALID_FILESIZE))
        {
            UINT64 u8Tmp;
            UINT64 u8SendPos;
            UINT64 u8Remainder;
            // 90000 -> 90000
            u8Tmp = _SWDMX_Div6464((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset) * (UINT64)90000,
                              prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime,
                              &u8Remainder);
            if(u8Tmp > 0)
            {
                //DTV00141518, [MM]Can not display current time when play special .mp3 file.
                // This is call from handlefeeder, we should consider buffer status
                // Or the position is updated late.
                u8SendPos = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize + (UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufTotalSize
                    + (UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize + (UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize);
                if(u8SendPos >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset)
                {
                    u4Time = (UINT32)_SWDMX_Div6464((UINT64)(u8SendPos - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset) * (UINT64)90000,
                                               (UINT32)u8Tmp, &u8Remainder);
                }
            }
        }

        *pu8OutStartAddr = u8StartAddr;
        *pu4OutReadSize = u4ReadSize;
        *pu4OutReadPTS = u4Time;
    }
    return MPG_AUDIO_INDEX_OK;
}

//#define TickMethod
UINT32 _SWDMX_MpgHandleRing(UINT8 u1SrcId, UINT64 u8StartAddr, UINT32 u4ReadSize,
    UINT64 *pu8OutStartAddr, UINT32 *pu4OutReadSize, INT32 i4PlaySpeed)
{
    UINT32 u4Ret = MPG_RING_OK;
#ifdef TIME_SHIFT_SUPPORT
    BOOL fgRet;
    UINT64 u8Remainder;
#ifdef TickMethod
    UINT32 u4ReadTick;
#endif
    UINT64 u8Temp;
    UINT64 u8EndAddr;

    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if((pu8OutStartAddr == NULL) || (pu4OutReadSize == NULL))
    {
        return MPG_RING_FAIL;
    }

#ifdef TickMethod
    u4ReadTick = 0;
#endif
    fgRet = TRUE;
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        *pu8OutStartAddr = u8StartAddr;
        *pu4OutReadSize = u4ReadSize;
        return MPG_RING_OK;
    }
    else//if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgValidRange)
        {
            // valid range is not set
            *pu8OutStartAddr = u8StartAddr;
            *pu4OutReadSize = 0;
            LOG(9, "_SWDMX_MpgHandleRing valid range is not set\n");
            return MPG_RING_FAIL;
        }

        u8EndAddr = u8StartAddr + (UINT64)u4ReadSize;

        ASSERT(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoSize);
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoSize == 0)
        {
            // valid range is not set
            *pu8OutStartAddr = u8StartAddr;
            *pu4OutReadSize = 0;
            return MPG_RING_FAIL;
        }

        if(i4PlaySpeed >= 0)
        {
            fgRet = _SWDMX_MpgGetPosByTickNum(u1SrcId,
                FALSE,
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ReadTickNum),
                &u8Temp);

            if(fgRet)
            {
                if(u8EndAddr > u8Temp)
                {
                    u8EndAddr = _SWDMX_MpgTSAlignDown(u1SrcId, u8Temp);
                    if(u8EndAddr < u8StartAddr)
                    {
                        u8EndAddr = u8StartAddr;
                    }
                    else if((u8EndAddr - u8StartAddr) > u4ReadSize)
                    {
                        u8EndAddr = u8StartAddr + (UINT64)u4ReadSize;
                    }
                    u4ReadSize = (UINT32)(u8EndAddr - u8StartAddr);
                    if(u4ReadSize == 0)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ReadTickNum++;
                        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ReadTickNum + 200) <
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum)
                        {
                            LOG(3, "u4ReadTickNum + 200 < u4CurTickNum\n");
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ReadTickNum += 100;
                        }
                    }
                }
            }
        }

#ifdef TickMethod
        fgRet = _SWDMX_MpgGetTickByPos(u1SrcId,
                    FALSE,
                    u8StartAddr,
                    i4PlaySpeed,
                    &u4ReadTick);
        if(fgRet)
        {
            if(i4PlaySpeed >= 0)
            {
                fgRet = _SWDMX_MpgGetPosByTickNum(
                    FALSE,
                    (u4ReadTick + 1),
                    &u8Temp);

                if(fgRet)
                {
                    if(u8EndAddr > u8Temp)
                    {
                        u8EndAddr = _SWDMX_MpgTSAlignDown(u1SrcId, u8Temp);
                        if(u8EndAddr < u8StartAddr)
                        {
                            u8EndAddr = u8StartAddr;
                        }
                        else if((u8EndAddr - u8StartAddr) > u4ReadSize)
                        {
                            u8EndAddr = u8StartAddr + (UINT64)u4ReadSize;
                        }
                        u4ReadSize = (UINT32)(u8EndAddr - u8StartAddr);
                    }
                }
                /*
                else
                {
                    // out of range
                    *pu8OutStartAddr = u8StartAddr;
                    *pu4OutReadSize = 0;
                    return MPG_RING_END_MEET;
                }
                */
            }
        }
        //else
        {
            u4ReadTick = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum;
        }
#endif

        u8Temp = _SWDMX_Div6464((u8StartAddr - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset), (UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoSize, &u8Remainder);
        u8EndAddr = _SWDMX_Div6464((u8EndAddr - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset), (UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoSize, &u8Remainder);
        if(u8EndAddr == u8Temp)
        {
            u8EndAddr = u8StartAddr + (UINT64)u4ReadSize;
        }
        else
        {
            u8EndAddr = (u8EndAddr * prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoSize) +
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset;
            u4ReadSize = (u8EndAddr - u8StartAddr);
        }

        if(prSwdmxInst)
        {
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorLBA)
                &&
               // while we are change, mw will set new monitor addr
               // but we are still in old speed
               // we should make sure the speed information is synced.
               (!prSwdmxInst->fgPlayChange) // not changing speed
                &&
               (
                ((i4PlaySpeed >= 0) &&
                 (u8EndAddr >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8MonitorAddr))
                ||
                ((i4PlaySpeed < 0) &&
                 (u8StartAddr < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8MonitorAddr))
               )
              )
            {
                VDP_PIC_INFO_T rVdpPicInfo;
                UINT64 u8DispOffset = 0;
                x_memset(&rVdpPicInfo, 0, sizeof(VDP_PIC_INFO_T));
                if(i4PlaySpeed > 0)
                {
                    u8DispOffset = (UINT64)-1;
                }
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
                {
                    if (VDP_GetPicInfo(prSwdmxInst->u1B2rId, &rVdpPicInfo) == VDP_SET_OK)
                    {
                        u8DispOffset = rVdpPicInfo.u8OffsetDisp;
                    }
                }

                if(
                   (
                    ((i4PlaySpeed >= 0) &&
                     (u8DispOffset >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8MonitorAddr))
                    ||
                    ((i4PlaySpeed < 0) &&
                     (u8DispOffset < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8MonitorAddr))
                   )
                  )
                {
                    LOG(3, "fgMonitorLBA addr 0x%llx, start addr 0x%llx end addr 0x%llx, u8DispOffset 0x%llx\n",
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8MonitorAddr,
                        u8StartAddr,
                        u8EndAddr,
                        u8DispOffset);
                    if((prSwdmxInst) &&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
                    {
                        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
                        {
                            _SWDMX_RANGE_CALLBACK(
                                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                                MM_MONITOR_LBA_ARRIVAL,
                                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                                0xFFFFFFFF,
                                (UINT32)u1SrcId);
                        }
                    }
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorLBA = FALSE;
                }
            }
        }
        else
        {
            LOG(3, "_SWDMX_MpgHandleRing prSwdmxInst null\n");
            return MPG_RING_FAIL;
            
        }
#ifdef TickMethod
        if((u4ReadTick + 1) >=
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeEndTick)
#else
        if(u8EndAddr >=
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SafeEndAddr))
#endif
        {
#ifdef TV_PAUSE_SUPPORT
        // for tv pause , not allow this position      
        *pu8OutStartAddr = u8StartAddr;
        *pu4OutReadSize = 0;
        u4ReadSize = 0;
#endif

            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeEnd) &&
               (i4PlaySpeed >= 0))
               //&&
               // codition is _u8SendedSize, not _u8ReadPos
               // Then we will notify on playback to this position.
               // -> rollback to original method
               //(_u8SendedSize >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SafeEndAddr))
            {
#ifdef TickMethod
                LOG(3, "fgMonitorSafeEnd tick + 1 %d safe end tick %d\n",
                    (u4ReadTick + 1),
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeEndTick);
#else
                LOG(3, "fgMonitorSafeEnd addr 0x%llx safe end addr 0x%llx\n",
                    u8EndAddr,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SafeEndAddr);
#endif
                if((prSwdmxInst) &&
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
                {
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
                    {
                        _SWDMX_RANGE_CALLBACK(
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                            MM_OUT_OF_SAFE_RANGE_END,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                            0xFFFFFFFF,
                            (UINT32)u1SrcId);
                    }
                }
#ifndef TV_PAUSE_SUPPORT
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeEnd = FALSE;
#endif
            }
            // allow this position
            //if(i4PlaySpeed > 0)
            //{
            //    u4Ret = MPG_RING_FAIL;
            //}
        }
        else if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeEnd)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeEnd = TRUE;
        }

#ifdef TickMethod
        if((u4ReadTick) <
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeStartTick)
#else
        if((u8StartAddr) <
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SafeStartAddr))
#endif
        {
            *pu8OutStartAddr = u8StartAddr;
            *pu4OutReadSize = 0;
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeStart) &&
               (i4PlaySpeed < 0))
            {
#ifdef TickMethod
                LOG(3, "fgMonitorSafeStart tick %d safe end tick %d\n",
                    (u4ReadTick),
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeStartTick);
#else
                LOG(3, "fgMonitorSafeStart addr 0x%llx safe start addr 0x%llx\n",
                    u8StartAddr,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SafeStartAddr);
#endif
                if((prSwdmxInst) &&
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
                {
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
                    {
                        _SWDMX_RANGE_CALLBACK(
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                            MM_OUT_OF_SAFE_RANGE_START,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                            0xFFFFFFFF,
                            (UINT32)u1SrcId);
                    }
                }
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeStart = FALSE;
            }
            if(i4PlaySpeed < 0)
            {
                u4Ret = MPG_RING_FAIL;
            }
        }
        else if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeStart)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeStart = TRUE;
        }

#ifdef TickMethod
        if((u4ReadTick + 1) >=
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ValidEndTick)
#else
        if(u8EndAddr >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ValidEndAddr)
#endif
        {
            *pu8OutStartAddr = u8StartAddr;
            *pu4OutReadSize = 0;
            u4ReadSize = 0;
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorValidEnd) &&
               (i4PlaySpeed >= 0))
               //&&
               // codition is _u8SendedSize, not _u8ReadPos
               // Then we will notify on playback to this position.
               //(_u8SendedSize >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ValidEndAddr))
               // we never out of valid range when we check with _u8SendedSize
               // -> rollback to original method
               //(_u8SendedSize >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SafeEndAddr))
            {
#ifdef TickMethod
                LOG(3, "fgMonitorValidEnd tick + 1 %d valid end tick %d\n",
                    (u4ReadTick + 1),
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ValidEndTick);
#else
                LOG(3, "fgMonitorValidEnd addr 0x%llx valid end addr 0x%llx\n",
                    u8EndAddr,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ValidEndAddr);
#endif
                if((prSwdmxInst) &&
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
                {
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
                    {
                        _SWDMX_RANGE_CALLBACK(
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                            MM_REACH_VALID_RANGE_END,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                            0xFFFFFFFF,
                            (UINT32)u1SrcId);
                    }
                }
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorValidEnd = FALSE;
            }

            u4Ret = MPG_RING_FAIL;

            // if we are doing backward
            //and there is no signal anymore (u8ValidEndAddr)
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorValidStart) &&
               (i4PlaySpeed < 0) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage == MPG_TSS_NORMAL))
            {
                u4Ret = MPG_RING_END_MEET;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext = TRUE;
            }
        }

#ifdef TickMethod
        if((u4ReadTick) <
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ValidStartTick)
#else
        if(u8StartAddr < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ValidStartAddr)
#endif
        {
            *pu8OutStartAddr = u8StartAddr;
            *pu4OutReadSize = 0;
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorValidStart) &&
               (i4PlaySpeed < 0))
            {
#ifdef TickMethod
                LOG(3, "fgMonitorValidStart tick %d valid start tick %d\n",
                    (u4ReadTick),
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ValidStartTick);
#else
                LOG(3, "fgMonitorValidStart addr 0xllx valid start addr 0x%llx\n",
                    u8StartAddr,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ValidStartAddr);
#endif
                if((prSwdmxInst) &&
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
                {
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
                    {
                        _SWDMX_RANGE_CALLBACK(
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                            MM_REACH_VALID_RANGE_START,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                            0xFFFFFFFF,
                            (UINT32)u1SrcId);
                    }
                }
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorValidStart = FALSE;
            }
            u4Ret = MPG_RING_FAIL;
        }

        if(u4ReadSize == 0)
        {
            //LOG(3, "_SWDMX_MpgHandleRing u4ReadSize 0\n");
            // out of range
            *pu8OutStartAddr = u8StartAddr;
            *pu4OutReadSize = 0;
            return MPG_RING_FAIL;
        }

        ASSERT(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoSize);
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoSize == 0)
        {
            // valid range is not set
            *pu8OutStartAddr = u8StartAddr;
            *pu4OutReadSize = 0;
            return MPG_RING_FAIL;
        }
        UNUSED(_SWDMX_Div6464((u8StartAddr - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset), (UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoSize, &u8Remainder));
        u8Temp = u8Remainder;

        *pu8OutStartAddr =
            u8Temp + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset;
        *pu4OutReadSize = u4ReadSize;

        if((u4Ret == MPG_RING_OK) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFirst) &&
           ((i4PlaySpeed >= 0) &&
#ifdef VDEC_TIME_SHIFT_2X_I_MODE
            (i4PlaySpeed <= 1500)
#else
            (i4PlaySpeed < 4000)
#endif
           ))
        {
            LOG(5, "First u8OutStartAddr 0x%llx, u4OutReadSize 0x%x\n",
                *pu8OutStartAddr, *pu4OutReadSize);
        }
    }
#endif
    return u4Ret;
}
INT32 _SWDMX_MpgHandleReq(UINT8 u1SrcId,UINT32 u4ReadSize,UINT64 u8ReadAddr )
{
    INT32 i4Ret;
    UINT64 u8ReqTime=0;
    UINT64 u8Remainder=0;
    FEEDER_TRANSMIT_COND rFeederCond;    
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
    
    x_memset((VOID*)&rFeederCond,0x0,sizeof(FEEDER_TRANSMIT_COND));
    
    if (prSwdmxInst->eSeekType ==  eSWDMX_TYPE_TIME_SEEK)
    {
        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgStartTimeSeek)
        {
            u8ReqTime = _SWDMX_Div6464(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartTime,(UINT64)90000,&u8Remainder);

            i4Ret = FeederSetRequest(prSwdmxInst->eFeederSrc,
                    u4ReadSize,
                    u8ReqTime, //dlna server unit s
                    &rFeederCond,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqID);
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgStartTimeSeek = FALSE;
        }
        else if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgStartJumpping)
        {
            u8ReqTime = _SWDMX_Div6464(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartTime,(UINT64)90000,&u8Remainder);
            i4Ret = FeederSetRequest(prSwdmxInst->eFeederSrc,
                    u4ReadSize,
                    u8ReqTime,
                    &rFeederCond,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqID);
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgStartJumpping = FALSE;               
        }
        else
        {
            i4Ret = FeederSetRequest(prSwdmxInst->eFeederSrc,
                    u4ReadSize,
                    (UINT64)DLNA_TIME_SEEK_INVALID_TIME,
                    &rFeederCond,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqID);
        }                
        
    }
    else
    {
        //LOG(3, "Mpg Fd 1 FeederSetRequest size(%d)\n", u4ReadSize);
        i4Ret = FeederSetRequest(prSwdmxInst->eFeederSrc,
                u4ReadSize,
                (UINT64)u8ReadAddr,
                &rFeederCond,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqID);
    }    
    return i4Ret;
    
}
INT32 _SWDMX_MpgHandleFeeder(UINT8 u1SrcId, SWDMX_RANGE_LIST_T* prRangeList, INT32 i4PlaySpeed)
{
    INT32 fgRet;
    BOOL fgBlockReq;
    BOOL fgIsReq = FALSE;
    INT32 i4Ret;
    UINT32 u4Count;
    UINT32 u4ReadSize;
    UINT32 u4ReadPTS;
    UINT32 u4Ptr;
    UINT64 u8ReadAddr;
    FEEDER_REQ_DATA_T rFeederReqData;
#ifdef SWDMX_MPG_ACCEPT_NON_SEQUENCE_ACK_ID
    UINT32 u4ReqCnt;
#endif

    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if (u1SrcId >= SWDMX_SOURCE_MAX)
    {
        LOG(1, "_SWDMX_MpgHandleFeeder (u1SrcId >= SWDMX_SOURCE_MAX)\n");
        return MPG_SEND_FAIL;
    }
    
    u8ReadAddr = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos+prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize+prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufTotalSize);
    u4ReadSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeReadSize;
    u4ReadPTS = 0;
	
	if (IS_LOCAL_NET(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type) &&
		(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed > 0) &&
		(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed < 1000) &&
		prSwdmxInst->fgSupportConnStalling)
		{			
			u4ReadSize *= prSwdmxInst->u4Multiple;
			LOG(6,"u4Multiple %d u4ReadSize 0x%x\n",prSwdmxInst->u4Multiple,u4ReadSize);
		}
	
#ifdef TIME_SHIFT_SUPPORT
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        UINT32 u4Ret;
        UINT32 u4OutReadSize;
        UINT64 u8OutReadAddr;
        u4Ret = _SWDMX_MpgHandleRing(u1SrcId, u8ReadAddr, u4ReadSize,
            &u8OutReadAddr, &u4OutReadSize, i4PlaySpeed);
        if(u4Ret == MPG_RING_OK)
        {
            u8ReadAddr = u8OutReadAddr;
            u4ReadSize = u4OutReadSize;
        }
        else
        {
            if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize == 0) &&
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes == 0) &&
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt == 0))
            {
                LOG(9, "Mpg Fd Ring Full.\n");
                return MPG_SEND_FULL;
            }
            else
            {
                u4ReadSize = 0;
            }
        }
    }
    else
#endif
#ifdef SUPPORT_CIPLUS_RECORD
    if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192) &&
        (u8ReadAddr < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset) )     // LWB: Let u4ReadSize to do adjusted in else case
    {
        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed <= 0)
        {
            // End Play, Do EOF, block case
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize =
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize;
            if (prSwdmxInst->u4LogFilter & check_rl)
            {
                LOG(1,"%s:rewind when expired, eof\n",__FUNCTION__);
            }
            u4ReadSize = 0; //  Do not Req Data from Feeder
        }
        else if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed >= 1000)
        {
            UINT32 u4PTS = 0;

			if (prSwdmxInst->u4LogFilter & check_rl)
            {
                LOG(1,"%s:adjust request addr %llu\n",__FUNCTION__,prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset);
            }
            
            u8ReadAddr = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset;
            if (u4ReadSize > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - u8ReadAddr)
            {
                u4ReadSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - u8ReadAddr;
            }

            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8OrgSendedSize = u8ReadAddr;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8OrgSendedSize;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8OrgSendedSize;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8OrgSendedSize;
            
            #if 1
            MPV_FlushEsmQ(prSwdmxInst->u1VdecId, FALSE);
            UNUSED(VDEC_ReleaseDispQ(prSwdmxInst->u1VdecId));
            if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
               (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
            {
                MPV_FlushEsmQ(prSwdmxInst->u1Vdec2Id, FALSE);
                UNUSED(VDEC_ReleaseDispQ(prSwdmxInst->u1Vdec2Id));
            }

            _SWDMX_MpgResetData(u1SrcId);

            // For we have many things should to do after decoder, so vdec should drop more pic.
            // when start play, Wait for NPTV stable need more time.
            if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicStartPlayOrgPTS > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS)
            {
                u4PTS = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicStartPlayOrgPTS - 
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS +
                        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotStartToPlay ? 45000 : 110000);
            } else{
                u4PTS = 0;
            }
            
            // Notes: It only be reset in resetSwdmxInfo
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotStartToPlay = TRUE;
            
            UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
            UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
            UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1VdecId, FALSE, 0));			
            UNUSED(VDEC_SetRenderFromPts(prSwdmxInst->u1VdecId, u4PTS));
            if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
               (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
            {
                UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1Vdec2Id, FALSE, 0));
                UNUSED(VDEC_SetRenderFromPts(prSwdmxInst->u1Vdec2Id, u4PTS));
            }
            
            // Notes: also, we need flush the audio data, or AV sync may apeear
            if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
            {
#ifdef CC_AUD_SUPPORT_DUAL_DSP
                AUD_DSPCmdStop(AUD_DSP0, prSwdmxInst->u1AdecId);
                AUD_DSPCmdPlay(AUD_DSP0, prSwdmxInst->u1AdecId);
#else
                AUD_DSPCmdStop(prSwdmxInst->u1AdecId);
                AUD_DSPCmdPlay(prSwdmxInst->u1AdecId);
#endif
                LOG(5, "[Info] %s(%d):%u LC: Tmp solution(Stop&Play) for Flush audio data.\n",
                        __FUNCTION__, prSwdmxInst->u1SwdmxId, __LINE__);
            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AudStartPlayPTS 
                = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicStartPlayOrgPTS + 4*90000;
             LOG(1, "[Info] %s(%d):%u LC: VDEC_SetRenderFromPts from 0x%X\n", 
                     __FUNCTION__, prSwdmxInst->u1SwdmxId, __LINE__, u4PTS);
            #endif
        }
        else //  ( may speed = (0, 1000) )
        {
            // Need Reset Data ??? 
            // if not flush data, may have garbage
            // prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = u8ReadAddr - 
            //    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufTotalSize);
        }
    }
    else
#endif // SUPPORT_CIPLUS_RECORD
    if(IS_PUSH_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type))
    {
        u8ReadAddr = 0;
        u4ReadSize = 1;
        u4ReadPTS = 0;
    }
    else
    {
        if((UINT64)u4ReadSize > ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos + 
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufTotalSize))) )
        {
            u4ReadSize = ((UINT32)(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - 
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize 
                + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufTotalSize)));
            #if 1//def CC_DLNA_SUPPORT
            if((u4ReadSize == 0) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type !=
                        MM_SRC_TYPE_HIGH_SPEED_STORAGE))
            {
                FeederSetInfo(prSwdmxInst->eFeederSrc, FEEDER_SWDMX_EOS, TRUE);
            }
            #endif
        }

        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgDynamicDuration && prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgPauseMoving)
        {
            u4ReadSize = 0;
        }
                
        if((u4ReadSize > 0) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES))
        {
            if(prSwdmxInst->eSeekType == eSWDMX_TYPE_BYTE_SEEK)
            {
                UINT32 u4Ret;
                UINT32 u4OutReadSize;
                UINT32 u4OutReadPTS;
                UINT64 u8OutReadAddr;
                
                u4Ret = _SWDMX_MpgHandleAudioIndex(u1SrcId, u8ReadAddr, u4ReadSize,
                    &u8OutReadAddr, &u4OutReadSize, &u4OutReadPTS, i4PlaySpeed);
                if(u4Ret == MPG_AUDIO_INDEX_OK)
                {
                    u8ReadAddr = u8OutReadAddr;
                    u4ReadSize = u4OutReadSize;
                    u4ReadPTS = u4OutReadPTS;
                }
            }
            else if((prSwdmxInst->eSeekType == eSWDMX_TYPE_TIME_SEEK) &&
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgStartTimeSeek))
            {
                u4ReadPTS = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartTime;
            }
        }
    }

    fgBlockReq = ((MM_SRC_TYPE_IPTV != prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type) &&
        ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetInfo) ||
        // for audio only file, we also could use multi-request
        ((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendSeqHdr) && 
         (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgResetPosAfterFoundSeq) &&
         (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)) ||
        ((i4PlaySpeed < 0) ||
#ifdef VDEC_TIME_SHIFT_2X_I_MODE
        ((i4PlaySpeed > 1500)
         &&
         (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
        ||
        ((i4PlaySpeed >= 4000)
        &&
         (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)) 
        ||
         ((i4PlaySpeed >= 2000)
         &&
         (MM_SRC_TYPE_IPTV == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type)))));
#else
        (i4PlaySpeed >= 4000)))); // 4x use BlockReq
#endif

    //fgBlockReq = ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetInfo) || (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendSeqHdr)); // 4x use multi request
    //fgBlockReq = TRUE; // request one and wait to got one.

#if 1//def CC_DLNA_SUPPORT                               //for DLNA handle EOF
   if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.fgGetEof)
   {
#endif
    if(fgBlockReq)
    {
        if ((u4ReadSize > 0) &&
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize == 0) &&
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes == 0) &&
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt == 0))
        {
#ifdef SWDMX_MPG_DEBUG_INPUT_DATA
            UINT32 u4i;
            for(u4i=0;u4i<2;u4i++)
            {
#endif
            i4Ret = _SWDMX_MpgHandleReq(u1SrcId,u4ReadSize,u8ReadAddr);
            
            if(i4Ret != FEEDER_E_OK)
            {
                if (prSwdmxInst->u4LogFilter & check_feeder_req)
	            {
	                LOG(1, "*******feeder block req id = %d failed! ret %d\n", (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqID - 2), i4Ret);
	            }
                                
                if(i4Ret == FEEDER_E_BUFFER_FULL)
                {
                    // workaround for buffer full                    
					if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
					{

	                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqBufFullCount++;
	                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqBufFullCount <= (UINT32)MPG_REQ_BUFFULL_NUM)
	                    {
	                        LOG(1, "Mpg Fd FeederSetRequest Buffer Full\n");
	                        return MPG_SEND_FULL;
	                    }					
					}
					else
					{
	                    LOG(1, "Mpg Fd FeederSetRequest Buffer Full\n");
	                    if (!IS_LOCAL_NET(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type))
	                    {
	                        return MPG_SEND_FULL;							
					    }
                    }
                }
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqBufFullCount = 0;

#ifdef TIME_SHIFT_SUPPORT
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
                {
                    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq) &&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo))
                    {
                        _SWDMX_RANGE_CALLBACK(
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                            MM_DATA_READ_ERROR,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                            0xFFFFFFFF,
                            (UINT32)u1SrcId);
                    }
                    LOG(1, "Mpg Fd FeederSetRequest Fail(%d)\n", (UINT32)i4Ret);
                    UNUSED(_SWDMX_MpgResetFeederReq(u1SrcId));
                    return MPG_SEND_FAIL;
                }
#endif

                LOG(1, "Mpg Fd FeederSetRequest Fail\n");
                if (!IS_LOCAL_NET(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type))
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = TRUE;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpping = FALSE;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext = FALSE;
        
                    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetInfo)
                    {
                        // _SWDMX_MpgHandleEOS(u1SrcId, i4PlaySpeed);
                    }
                    if(prRangeList)
                    {
                        prRangeList->eRangeStats = eSWDMX_RANGE_STATE_PENDING;
                    }
                    if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) &&
                       (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) &&
                       // DTV00211818
                       // when audio es playback.
                       // pause -> seek -> seek -> play
                       // we will send finish event. this is not correct.
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_RAW_AUDIO_ES)&&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_ENCRYPT_192)&&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS)&&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_204)&&
				               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_206)&&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_192))
                    {
                        if(prRangeList)
                        {
                            prRangeList->eRangeStats = eSWDMX_RANGE_STATE_FINISHED;
                        }
                    }
                    return MPG_SEND_FAIL;
                }
            }
            else // i4Ret == FEEDER_E_OK
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqID+=2;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqBufFullCount = 0;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqSize[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx] = u4ReadSize;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqPTS[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx] = u4ReadPTS;
#ifdef SWDMX_MPG_DEBUG_REQUEST_FILE_OFFSET
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au8ReqFileOffset[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx] = u8ReadAddr;
#endif
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqId[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx] = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqID-2);
#ifdef SWDMX_MPG_DEBUG_INPUT_DATA
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqDup[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx] =
                      u4i;
#endif
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes++;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize += u4ReadSize;
                if (prSwdmxInst->u4LogFilter & check_feeder_req)
                {
                    LOG(1, "*******feeder block req id = %d req size = %d, req addr %llu, sucess!\n", (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqID - 2),
                        u4ReadSize, u8ReadAddr);
                }
#ifdef SWDMX_MPG_DEBUG_BUFFER
                LOG(7, "Mpg Fd Set UB %d BT %d RT %d BWI %d BRI %d BAC %d RWI %d RRI %d RT %d RRS %d RPS 0x%llx RPTS %d Id %d\n",
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufTotalSize,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufWriteIdx,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes,
                    u4ReadSize,
                    u8ReadAddr,
                    u4ReadPTS,
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqID-2));
#endif
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx++;
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum)
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx = 0;
                }
#ifdef SWDMX_MPG_DEBUG_INPUT_DATA
                }
#endif
            }
        }
        else
        {
            if (prSwdmxInst->u4LogFilter & check_feeder_req)
            {
	            LOG(2, "can't block feed req Mpg Fd Use UB %d BT %d RT %d\n",
	                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize,
	                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufTotalSize,
	                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize);
            }
        }
    }
    else
    {
        if (FeederGetBufferInfo(prSwdmxInst->eFeederSrc, &prSwdmxInst->rFeederInfo) !=
          FEEDER_E_OK)
        {
            LOG(1, "Mpg Fd input buffer error.\n");
            return FALSE;
        }
        if ((u4ReadSize > 0) &&
            #ifdef SWDMX_MPG_DEBUG_INPUT_DATA
            ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes + 1) < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum) &&
            ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes + 1 + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt) < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum) &&
            #else
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes +1 < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum) &&
            ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes + 1 + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt) < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum) &&
            #endif
            //((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize +
            //  prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufTotalSize + u4ReadSize) <=
            // (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeReadSize*prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum)))
            // feeder now is 512 K in audio es case
            (IS_PUSH_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type) ||
            (prSwdmxInst->rFeederInfo.u4FreeSize >
             (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeReadSize +
              MPG_FEEDER_ALIGN))) &&
              ((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidPidChg) && 
               (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudPidChg) &&
               (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidCodecChg) &&
               (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudCodecChg)))
		{
			fgIsReq = TRUE;
		}
		if (IS_LOCAL_NET(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type) &&
			(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed > 0) &&
			(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed < 1000) &&
			prSwdmxInst->fgSupportConnStalling)
		{
                UINT16 u2QueueSize = 0, u2MaxQueueSize =0;		
                
                VDEC_GetQueueInfo(prSwdmxInst->u1VdecId, &u2QueueSize, &u2MaxQueueSize);
                
            if((prSwdmxInst->rFeederInfo.u4BytesInBuf > (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeReadSize/2)) ||
                (u2QueueSize > 2))
            {
                LOG(2,"Feeder still have data(0x%x) ,don't need request u2QueueSize (%d)\n",prSwdmxInst->rFeederInfo.u4BytesInBuf,u2QueueSize );

                fgIsReq = FALSE;
            }
		
		}
		
        if (fgIsReq)  /* if pid change or codec change then not again request data temperary.until change done finish,continue request data */
        {
#ifdef SWDMX_MPG_DEBUG_INPUT_DATA
            UINT32 u4i;
            for(u4i=0;u4i<2;u4i++)
            {
#endif
            //LOG(3, "Mpg Fd 2 FeederSetRequest size(%d)\n", u4ReadSize);
            
            i4Ret = _SWDMX_MpgHandleReq(u1SrcId,u4ReadSize,u8ReadAddr);
                      
            if(i4Ret != FEEDER_E_OK)
            {
            	if (prSwdmxInst->u4LogFilter & check_feeder_req)
	            {
	                LOG(1, "*******feeder req id = %d failed! ret %d\n", (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqID - 2), i4Ret);
	            }
                if(i4Ret == FEEDER_E_BUFFER_FULL)
                {
                    // workaround for buffer full
					if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
					{

	                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqBufFullCount++;
	                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqBufFullCount <= (UINT32)MPG_REQ_BUFFULL_NUM)
	                    {
	                        LOG(1, "Mpg Fd FeederSetRequest Buffer Full\n");
	                        return MPG_SEND_FULL;
	                    }					
					}
					else
					{
	                    LOG(1, "Mpg Fd FeederSetRequest Buffer Full\n");
	                    if (!IS_LOCAL_NET(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type))
	                    {
	                        return MPG_SEND_FULL;							
					    }
                    }
                }
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqBufFullCount = 0;

#ifdef TIME_SHIFT_SUPPORT
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
                {
                    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq) &&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo))
                    {
                        _SWDMX_RANGE_CALLBACK(
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                            MM_DATA_READ_ERROR,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                            0xFFFFFFFF,
                            (UINT32)u1SrcId);
                    }
                    LOG(1, "Mpg Fd FeederSetRequest Fail(%d)\n", (UINT32)i4Ret);
                    UNUSED(_SWDMX_MpgResetFeederReq(u1SrcId));
                    return MPG_SEND_FAIL;
                }
#endif

                LOG(1, "Mpg Fd FeederSetRequest Fail\n");
                if (!IS_LOCAL_NET(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type))
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = TRUE;
                    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetInfo)
                    {
                        //_SWDMX_MpgHandleEOS(u1SrcId, i4PlaySpeed);
                    }
                    if(prRangeList)
                    {
                        prRangeList->eRangeStats = eSWDMX_RANGE_STATE_PENDING;
                    }
                    if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) &&
                       (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) &&
                       // DTV00211818
                       // when audio es playback.
                       // pause -> seek -> seek -> play
                       // we will send finish event. this is not correct.
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_RAW_AUDIO_ES)&&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_ENCRYPT_192)&&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS)&&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_204)&&
     			   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_206)&&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_192))
                    {
                        if(prRangeList)
                        {
                            prRangeList->eRangeStats = eSWDMX_RANGE_STATE_FINISHED;
                        }
                    }
                    return MPG_SEND_FAIL;
                }
            }
            else // i4Ret == FEEDER_E_OK
            {
                if (prSwdmxInst->u4LogFilter & check_feeder_req)
                {
                    LOG(1, "*******feeder req id = %d req size = %d req addr %llu, sucess!\n", (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqID - 2),
                        u4ReadSize, u8ReadAddr);
                }
            
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqBufFullCount = 0;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqID+=2;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqSize[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx] = u4ReadSize;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqPTS[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx] = u4ReadPTS;
#ifdef SWDMX_MPG_DEBUG_REQUEST_FILE_OFFSET
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au8ReqFileOffset[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx] = u8ReadAddr;
#endif
#ifdef SWDMX_MPG_DEBUG_INPUT_DATA
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqDup[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx] =
                      u4i;
#endif
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqId[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx] = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqID-2);
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes++;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize += u4ReadSize;
#ifdef SWDMX_MPG_DEBUG_BUFFER
                LOG(7, "Mpg Fd Set UB %d BT %d RT %d BWI %d BRI %d BAC %d RWI %d RRI %d RT %d RRS %d RPS 0x%llx RPTS %d Id %d\n",
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufTotalSize,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufWriteIdx,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes,
                    u4ReadSize,
                    u8ReadAddr,
                    u4ReadPTS,
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqID-2));
#endif
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx++;
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum)
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx = 0;
                }
#ifdef SWDMX_MPG_DEBUG_INPUT_DATA
                }
#endif
            }
        }
        else
        {
            if (prSwdmxInst->u4LogFilter & check_feeder_req)
            {
	            LOG(9, "can't req feeder Mpg Fd Use UB %d BT %d RT %d\n",
	                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize,
	                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufTotalSize,
	                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize);
            }
        }
    }
#if 1//def CC_DLNA_SUPPORT                               //for DLNA handle EOF
   }
#endif
    #ifdef SWDMX_STATISTICS
    HAL_GetTime(&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rFeederReqStartTime);
    #endif

    if(((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes) ||
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt == 0) || (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize == 0))
        && (((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize != (UINT64)(-1)) && (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192))
        || (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_ENCRYPT_192)))
    {
        // when get eof from feeder, mean data all give to swdmx, no needer continue to ack
        // u4UsingBufSize = 0, u4BufAvailCnt = 0, fgGetEof = 1, will send eos in this function.
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes) && \
            (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.fgGetEof) && \
           (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidPidChg && \
                 !prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudPidChg && \
                 !prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidCodecChg && \
                 !prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudCodecChg))
        {
            u4Count = (5 + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum); // the times try to remove previous feeder's ack
            while(u4Count--)
            {
                x_memset(&rFeederReqData, 0, sizeof(FEEDER_REQ_DATA_T));
                if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt == 0) && (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize == 0))
                //if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize == 0)
                {
                    fgRet = _SWDMX_ReceiveFeederAck(u1SrcId, (VOID*)&rFeederReqData);
                }
                else
                {
                    fgRet = TRUE;
                    i4Ret = _SWDMX_ReceiveFeederAckNoWait(u1SrcId, (VOID*)&rFeederReqData);
                    if(i4Ret == OSR_NO_MSG)
                    {
                        break; //return MPG_SEND_OK;
                    }
                    else if(i4Ret != OSR_OK)
                    {
                        LOG(5, "Mpg Fd AckNoWait i4Ret %d\n", i4Ret);
                        fgRet = FALSE;
                    }
                }
                // check rFeederReqData.u4Id
                if(rFeederReqData.eDataType == FEEDER_SOURCE_INVALID)
                {
                    LOG(2, "Mpg Fd FEEDER_SOURCE_INVALID, ack id = %d\n", rFeederReqData.u4Id);
                    if(fgRet == TRUE)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimeoutCount++;
                        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimeoutCount > MPG_REQ_TIMEOUT_NUM)
                        {
                            LOG(1, "Mpg Fd Timeout %d(S)\n",
                                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimeoutCount);
                        }
                    }
                    return MPG_SEND_FULL;
                }
                // Feeder add error code for us. u4WriteAddr = 0 is error
                if((rFeederReqData.u4WriteAddr == 0) && (!rFeederReqData.fgEof))
                {
                    LOG(1, "Mpg Fd u4WriteAddr = 0. Reset request.\n");
                    UNUSED(_SWDMX_MpgResetFeederReq(u1SrcId));         //reset request CR [DTV00211387]
                    return MPG_SEND_FULL;
                }

                // CR Review action item , write address invalid
                if( ((rFeederReqData.u4WriteAddr < prSwdmxInst->rFeederInfo.u4StartAddr) ||
                     (rFeederReqData.u4WriteAddr >= prSwdmxInst->rFeederInfo.u4EndAddr)) &&
                     (rFeederReqData.eFeederIBC != FEEDER_IBC_DMX_VUDU_KEY) &&
                     (rFeederReqData.eFeederIBC != FEEDER_IBC_PARAM_STRM_INFO)&&
           (rFeederReqData.eFeederIBC != FEEDER_IBC_DASH_SET_INFO))
                {
                    LOG(0,"!!!!!!!!prFeederData->u4WriteAddr = %x\n",rFeederReqData.u4WriteAddr);
                    UNUSED(_SWDMX_MpgResetFeederReq(u1SrcId));
                    return MPG_SEND_FULL;
                }

                // Linux NetApp want to have eos
                #if 1//def CC_DLNA_SUPPORT                                 //for DLNA handle EOF
                if(rFeederReqData.fgEof)                                      // get EOF from feeder
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.fgGetEof=TRUE;
                    #if 1//def CC_DLNA_SUPPORT
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type !=
                        MM_SRC_TYPE_HIGH_SPEED_STORAGE)
                    {
                        FeederSetInfo(prSwdmxInst->eFeederSrc, FEEDER_SWDMX_EOS, TRUE);
                    }
                    #endif
                    LOG(1,"get Eof from feeder\n ");
                }
                #endif
                if(rFeederReqData.u4WriteAddr == 0)
                {
                    LOG(1, "Warnning~ Mpg Fd u4WriteAddr = 0. (!rFeederReqData.fgEof).\n");
                    return MPG_SEND_FULL;
                }

                if((!fgRet)
            #if 1//ndef CC_DLNA_SUPPORT                                  //for DLNA handle EOF
              || ((rFeederReqData.u4ReadSize == 0) &&                        // "EOF" has been got  from feeder with nomore  other data
                  (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type ==
                        MM_SRC_TYPE_HIGH_SPEED_STORAGE))
             #endif                                                                       // rFeederReqData.u4ReadSize =0
              )
                {
#ifdef TIME_SHIFT_SUPPORT
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
                    {
                        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq) &&
                           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo))
                        {
                            _SWDMX_RANGE_CALLBACK(
                                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                                MM_DATA_READ_ERROR,
                                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                                0xFFFFFFFF,
                                (UINT32)u1SrcId);
                        }
                        LOG(1, "Mpg Fd _SWDMX_ReceiveFeederAck Fail\n");
                        UNUSED(_SWDMX_MpgResetFeederReq(u1SrcId));
                        return MPG_SEND_FAIL;
                    }
#endif
                    LOG(1, "Mpg Fd _SWDMX_ReceiveFeederAck Fail, handle eos!\n");
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = TRUE;
                    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetInfo)
                    {
                        _SWDMX_MpgHandleEOS(u1SrcId, i4PlaySpeed);
                    }
                    if(prRangeList)
                    {
                        prRangeList->eRangeStats = eSWDMX_RANGE_STATE_PENDING;
                    }
                    if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) &&
                       (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) &&
                       // DTV00211818
                       // when audio es playback.
                       // pause -> seek -> seek -> play
                       // we will send finish event. this is not correct.
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_RAW_AUDIO_ES)&&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_ENCRYPT_192)&&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS)&&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_204)&&
					   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_206)&&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_192))
                    {
                        if(prRangeList)
                        {
                            prRangeList->eRangeStats = eSWDMX_RANGE_STATE_FINISHED;
                        }
                    }
                    return MPG_SEND_FAIL;
                }
#ifdef SWDMX_MPG_ACCEPT_NON_SEQUENCE_ACK_ID
                for(u4ReqCnt = 0;u4ReqCnt < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum;u4ReqCnt++)
                {
                    if(rFeederReqData.u4Id == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqId[u4ReqCnt])
                    {
                        break;
                    }
                }
                if(u4ReqCnt < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum)
#else
                #ifdef SWDMX_MPG_DEBUG_INPUT_DATA
                if(rFeederReqData.u4Id ==
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqId[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx])
                #else
                if(rFeederReqData.u4Id ==
                    ((UINT32)(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqID -
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes*2))))
                #endif
#endif
                {
                    BOOL fgPut2Buf = TRUE;
                    #ifdef SWDMX_MPG_DEBUG_INPUT_DATA
                    if(0 != prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqDup[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx])
                    {
                        // compare data
                        INT32 i4Ret;
                        UINT32 u4Size;
                        UINT32 u4SizeOrg;
                        UINT32 u4Size1;
                        UINT32 u4Size2;
                        UINT32 u4BufWriteIdx = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufWriteIdx;
                        if(u4BufWriteIdx == 0)
                        {
                            u4BufWriteIdx =
                                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum - 1);
                        }
                        else
                        {
                            u4BufWriteIdx--;
                        }
                        u4Size = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4BufSize[u4BufWriteIdx];
                        u4SizeOrg = u4Size;
                        u4Size1 = prSwdmxInst->rFeederInfo.u4EndAddr -
                            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4BufStartAddr[u4BufWriteIdx]);
                        if(u4Size > u4Size1)
                        {
                            u4Size = u4Size1;
                        }
                        u4Size2 = prSwdmxInst->rFeederInfo.u4EndAddr -
                            (rFeederReqData.u4WriteAddr + rFeederReqData.u4AlignOffset);
                        if(u4Size > u4Size2)
                        {
                            u4Size = u4Size2;
                        }
                        // compare data before wrap around
                        i4Ret = x_memcmp(
                            (VOID*)(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4BufStartAddr[u4BufWriteIdx]),
                            (VOID*)(rFeederReqData.u4WriteAddr + rFeederReqData.u4AlignOffset),
                            u4Size);
                        if((UINT32)i4Ret != (UINT32)0)
                        {
                            LOG(0, "Mpg Fd dup 1 compare fail\n");
                            ASSERT(0);
                        }
                        // compare data after wrap around
                        if(u4Size == u4Size1)
                        {
                            i4Ret = x_memcmp(
                                (VOID*)(prSwdmxInst->rFeederInfo.u4StartAddr),
                                (VOID*)(u4Size + rFeederReqData.u4WriteAddr + rFeederReqData.u4AlignOffset),
                                (u4SizeOrg - u4Size));
                            if((UINT32)i4Ret != (UINT32)0)
                            {
                                LOG(0, "Mpg Fd dup 2 compare fail\n");
                                ASSERT(0);
                            }
                        }
                        else if(u4Size == u4Size2)
                        {
                            i4Ret = x_memcmp(
                                (VOID*)(u4Size + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4BufStartAddr[u4BufWriteIdx]),
                                (VOID*)(prSwdmxInst->rFeederInfo.u4StartAddr),
                                (u4SizeOrg - u4Size));
                            if((UINT32)i4Ret != (UINT32)0)
                            {
                                LOG(0, "Mpg Fd dup 3 compare fail\n");
                                ASSERT(0);
                            }
                        }

                        fgPut2Buf = FALSE;

                        // eat feeder data
                        // don't care part.
                        /*
                        u4Ptr = rFeederReqData.u4WriteAddr + rFeederReqData.u4ReadSize;
                        if(u4Ptr >= prSwdmxInst->rFeederInfo.u4EndAddr)
                        {
                            u4Ptr -= (prSwdmxInst->rFeederInfo.u4EndAddr -
                                             prSwdmxInst->rFeederInfo.u4StartAddr);
                        }
                        if(FeederUpdateReadPointer(prSwdmxInst->eFeederSrc, u4Ptr) != FEEDER_E_OK)
                        {
                            LOG(1, "Mpg Fd FeederUpdateReadPointer fail\n");
                            //ASSERT(0);
                        }
                        */
                    }
                    #endif
                    if (prSwdmxInst->u4LogFilter & check_feeder_req)
                    {
                        LOG(2, "*******ack id = %d, size = %d sucess!\n", rFeederReqData.u4Id, rFeederReqData.u4ReadSize);
                    }
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes--;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize -= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqSize[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx];
                    if(rFeederReqData.u4ReadSize < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqSize[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx])
                    {
                        LOG(1, "Mpg Fd read size too small %d -> %d\n",
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqSize[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx], rFeederReqData.u4ReadSize);
              #if 1//def CC_DLNA_SUPPORT        //for DLNA handle eof
                        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type !=
                            MM_SRC_TYPE_HIGH_SPEED_STORAGE)
                        {
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqSize[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx] = rFeederReqData.u4ReadSize;
                        }
              #endif
                        //ASSERT(0);
                        //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx++;
                        //if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum)
                        //{
                        //    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx = 0;
                        //}
                        //return MPG_SEND_FAIL;
                    }

                    if(IS_PUSH_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type) || rFeederReqData.fgEof)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqSize[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx] = rFeederReqData.u4ReadSize;
                    }

                    if(fgPut2Buf)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4BufStartAddr[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufWriteIdx] =
                                rFeederReqData.u4WriteAddr +
                                rFeederReqData.u4AlignOffset;
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.afgBufFeederIBCType[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufWriteIdx] =
                            (UINT32)rFeederReqData.eFeederIBC;
//#ifdef CC_VUDU_SUPPORT
                        if(rFeederReqData.eFeederIBC == FEEDER_IBC_DMX_VUDU_KEY)
                        {
                            x_memcpy((VOID*)&_arVuduKey[u1SrcId][prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufWriteIdx],
                                (VOID*)rFeederReqData.u4WriteAddr,
                                sizeof(DMX_VUDU_KEY_T));
                            if(sizeof(DMX_VUDU_KEY_T) != rFeederReqData.u4ReadSize)
                            {
                                LOG(3, "(sizeof(DMX_VUDU_KEY_T)(%d) != rFeederReqData.u4ReadSize(%d))",
                                    sizeof(DMX_VUDU_KEY_T),
                                    rFeederReqData.u4ReadSize);
                            }
                        }
//#endif
                        if (rFeederReqData.eFeederIBC == FEEDER_IBC_PARAM_STRM_INFO)
                        {
                            UINT32 u4BufIndex;
                            SWDMX_BUF_AGT_CTRL_IBC_PARAM_STRM_INFO_T rTmpIBCStrmInfo;
                        
                            if(sizeof(SWDMX_BUF_AGT_CTRL_IBC_PARAM_STRM_INFO_T) != rFeederReqData.u4ReadSize)
                            {
                                LOG(0, "(sizeof(MTBUF_AGT_CTRL_IBC_PARAM_STRM_INFO_T)(%d) != rFeederReqData.u4ReadSize(%d))",
                                    sizeof(SWDMX_BUF_AGT_CTRL_IBC_PARAM_STRM_INFO_T),
                                    rFeederReqData.u4ReadSize);
                                return MPG_SEND_FAIL;                                     
                            }      
                            u4BufIndex = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufWriteIdx;
                            x_memcpy((VOID*)&_arIBCStrmInfo[u1SrcId][u4BufIndex],
                                (VOID*)rFeederReqData.u4WriteAddr,
                                sizeof(SWDMX_BUF_AGT_CTRL_IBC_PARAM_STRM_INFO_T));
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqIBCID = rFeederReqData.u4Id;
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4BufStartIBCAddr = rFeederReqData.u4WriteAddr;                                                        
                            x_memcpy((VOID*)&rTmpIBCStrmInfo,(VOID*)&_arIBCStrmInfo[u1SrcId][u4BufIndex],sizeof(SWDMX_BUF_AGT_CTRL_IBC_PARAM_STRM_INFO_T));
                            _SWDMX_MpgHandleStrmChg(u1SrcId,&rTmpIBCStrmInfo);
                            
                            LOG(2,"u4FeederReqIBCID %d u4BufIndex %d \n",rFeederReqData.u4Id, u4BufIndex);
                        }
            if (rFeederReqData.eFeederIBC == FEEDER_IBC_DASH_SET_INFO)
            {

                            x_memcpy((VOID*)&_arIBCDashSetInfo[u1SrcId][prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufWriteIdx],
                                (VOID*)rFeederReqData.u4WriteAddr,
                                sizeof(SWDMX_IBC_DASH_SET_INFO_T));
                            if(sizeof(SWDMX_IBC_DASH_SET_INFO_T) != rFeederReqData.u4ReadSize)
                            {
                                LOG(3, "(sizeof(SWDMX_IBC_DASH_SET_INFO_T)(%d) != rFeederReqData.u4ReadSize(%d))",
                                    sizeof(SWDMX_IBC_DASH_SET_INFO_T),
                                    rFeederReqData.u4ReadSize);
                            }             
            }           
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4BufSize[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufWriteIdx] = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqSize[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx];
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4BufPTS[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufWriteIdx] = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqPTS[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx];
#ifdef TIME_MEASUREMENT
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.fgPrintTMS[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufWriteIdx] = 
                            (rFeederReqData.eFeederPrintTMS == FEEDER_PRINT_TMS_PRINT) ? TRUE : FALSE;
#endif
                        if (rFeederReqData.ui8_vid_pts)
                        {
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CbPrintPTS = rFeederReqData.ui8_vid_pts;
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PushDataTime = rFeederReqData.ui8_push_time;
#ifdef __KERNEL__
                            {
                                UINT64 u8CurTime = 0;
                                struct timeval tv = {0};
                                UINT64 u8Remainder = 0;
                                
                                do_gettimeofday(&tv);
                                u8CurTime = (UINT64)tv.tv_sec * 1000000;                
                                u8CurTime = u8CurTime + (UINT64)tv.tv_usec;
                                u8CurTime = u8Div6432(u8CurTime, 1000, &u8Remainder);
                                
                                LOG(1, "SWDMX get target PTS(0x%llX), current_time(%lld), push_time(%lld), spend %lld us\n",
                                   prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CbPrintPTS,
                                   u8CurTime,
                                   prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PushDataTime,
                                   u8CurTime - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PushDataTime);
                            }
#endif
                        }

#ifdef SWDMX_MPG_DEBUG_REQUEST_FILE_OFFSET
                        #if 0
                        {
                            UCHAR *pucBuf = (UCHAR*)(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4BufStartAddr[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufWriteIdx]);
                            LOG(1, "FileOffset(0x%llx) size(0x%x) mem(0x%x) 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n",
                                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au8ReqFileOffset[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx],
                                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqSize[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx],
                                (UINT32)pucBuf,
                                *((UCHAR*)pucBuf + 0),
                                *((UCHAR*)pucBuf + 1),
                                *((UCHAR*)pucBuf + 2),
                                *((UCHAR*)pucBuf + 3),
                                *((UCHAR*)pucBuf + 4),
                                *((UCHAR*)pucBuf + 5),
                                *((UCHAR*)pucBuf + 6),
                                *((UCHAR*)pucBuf + 7));
                        }
                        #endif
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au8BufFileOffset[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufWriteIdx] = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au8ReqFileOffset[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx];
#endif
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufTotalSize += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqSize[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx];

                        // though ack size is 0, should also u4BufAvailCnt++, or the req num may not match
                        //if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqSize[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx])!=0)                        //for DLNA handle EOF
                        {
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt++;
                        }
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimeoutCount = 0;
                        #ifdef SWDMX_MPG_DEBUG_BUFFER
                        LOG(7, "Mpg Fd Get UB %d BT %d RT %d BWI %d BRI %d BAC %d RWI %d RRI %d RT %d RRS %d RPTS %d FId %d FAdr %d FOfs %d\n",
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufTotalSize,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufWriteIdx,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqSize[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx],
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqPTS[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx],
                            rFeederReqData.u4Id,
                            rFeederReqData.u4WriteAddr,
                            rFeederReqData.u4AlignOffset);
                        #endif
#ifdef SWDMX_DUMP_DATA
                        _SWDMX_DumpFeeder(prSwdmxInst, 
                            (INT8 *)(rFeederReqData.u4WriteAddr + rFeederReqData.u4AlignOffset),
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqSize[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx]);
#endif
                    }
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx++;
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx = 0;
                    }
                    if(fgPut2Buf)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufWriteIdx++;
                        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufWriteIdx >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum)
                        {
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufWriteIdx = 0;
                        }
                    }

                    if(fgPut2Buf)
                    {
#ifdef TIME_SHIFT_SUPPORT
                        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT) &&
                           ((*(UCHAR*)VIRTUAL((rFeederReqData.u4WriteAddr+rFeederReqData.u4AlignOffset)+4)) != 0x47))
                        {
                            UINT32 i;
                            LOG(3, "Mpg Fd !0x47\n");
                            ASSERT(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoSize);
                            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoSize)
                            {
                                UINT64 u8Tmp;
                                UINT64 u8Remainder;
                                u8Tmp = _SWDMX_Div6464((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize-prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset), (UINT64)192, &u8Remainder);
                                UNUSED(_SWDMX_Div6464((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize-prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset), prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoSize, &u8Remainder));
                                LOG(1, "!0x47, FileOffset 0x%llx, u8SendedSize 0x%llx, LBA 0x%llx, FilePos 0x%llx\n",
                                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset,
                                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize,
                                    (UINT64)u8Tmp,
                                    (UINT64)(u8Remainder + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset)
                                    );
                            }
                            //ASSERT(0);
                            for(i=5;i<196;i++)
                            {
                                if((*(UCHAR*)VIRTUAL((rFeederReqData.u4WriteAddr+rFeederReqData.u4AlignOffset)+i)) == 0x47)
                                {
                                    _SWDMX_MpgResetData(u1SrcId);
                                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize += (i - 4);
                                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                                    break;
                                }
                            }
                            return MPG_SEND_FULL;
                        }
#endif
// only enable this check on multiple instance
// in single instance, dmx could auto sync 0x47
#ifdef CC_FBM_TWO_FBP
                        if(((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192) ||
                            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ZERO_192) ||
                            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_192)) &&
                            ((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                            (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK)) &&
                           ((*(UCHAR*)VIRTUAL((rFeederReqData.u4WriteAddr+rFeederReqData.u4AlignOffset)+4)) != 0x47))
                        {
                            UINT32 i;
                            LOG(3, "Mpg Fd !0x47\n");
                            //ASSERT(0);
                            for(i=5;i<196;i++)
                            {
                                if((*(UCHAR*)VIRTUAL((rFeederReqData.u4WriteAddr+rFeederReqData.u4AlignOffset)+i)) == 0x47)
                                {
                                    //_SWDMX_MpgResetData(u1SrcId);
                                    //UNUSED(_SWDMX_MpgResetInputData);
                                    _SWDMX_MpgResetInputData(u1SrcId);
                                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize += (i - 4);
                                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
                                    break;
                                }
                            }
                            return MPG_SEND_FULL;
                        }
#endif
                    }

                    if(!fgPut2Buf)
                    {
                        return MPG_SEND_SKIP;
                    }

                    break;
                }
                else
                {
                    if(rFeederReqData.u4WriteAddr)
                    {
                        #ifdef SWDMX_MPG_DEBUG_BUFFER
                        LOG(7, "Mpg Fd Skp UB %d BT %d RT %d BWI %d BRI %d BAC %d RWI %d RRI %d RT %d RRS %d RPTS %d FId %d FAdr %d FRS %d\n",
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufTotalSize,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufWriteIdx,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqSize[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx],
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqPTS[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx],
                            rFeederReqData.u4Id,
                            rFeederReqData.u4WriteAddr,
                            rFeederReqData.u4ReadSize);
                        #endif
                        u4Ptr = rFeederReqData.u4WriteAddr + rFeederReqData.u4ReadSize;
                        if(u4Ptr >= prSwdmxInst->rFeederInfo.u4EndAddr)
                        {
                            u4Ptr -= (prSwdmxInst->rFeederInfo.u4EndAddr - prSwdmxInst->rFeederInfo.u4StartAddr);
                        }
                        if(IS_PUSH_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type))
                        {
                            u4Ptr = 0;
                        }
                        #if 0
                        if(FeederUpdateReadPointer(prSwdmxInst->eFeederSrc, u4Ptr) != FEEDER_E_OK)
                        {
                            LOG(1, "Mpg Fd FeederUpdateReadPointer fail\n");
                            //ASSERT(0);
                        }
                        #else
                        {
                            UINT32 u4ReqID = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqID;
                            UINT32 u4RegIDSize = 0;
                            if(u4ReqID >= rFeederReqData.u4Id)
                            {
                                u4RegIDSize = (u4ReqID - rFeederReqData.u4Id);
                            }
                            else
                            {
                                u4RegIDSize = ((0xFFFFFFFF - rFeederReqData.u4Id) + u4ReqID);
                            }
                            if(u4RegIDSize < (SWDMX_FEEDER_ID_GAP/2))
                            {
                                if(FeederUpdateReadPointer(prSwdmxInst->eFeederSrc, u4Ptr) != FEEDER_E_OK)
                                {
                                    LOG(1, "Mpg Fd FeederUpdateReadPointer fail\n");
                                    //ASSERT ;
                                }
                                //LOG(3, "Mpg Fd FeederUpdateReadPointer %d\n", u4Ptr);
                            }
                            // else case means this updated address is belong to
                            // previous request. If we update this one, it might
                            // cause feeder internal buffer full and can't accept
                            // request anymore.
                        }
            
                        LOG(3, "Mpg Fd FeederUpdateReadPointer 0x%x u4FeederReqID %d ack id %d \n",
              u4Ptr,prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqID,rFeederReqData.u4Id);            
                        #endif
                    }
                    // DTV00140229, [DLNA] When play attached mp3 file,repeatedly Fast Backward, system hangs up.
                    // when we are skip the first ack from feeder, it should be a correct one.
                    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize == 0) &&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt == 0))
                    {
                        LOG(3, "Mpg Fd Skp u4BufAvailCnt 0 u4UsingBufSize 0\n");
                        return MPG_SEND_FAIL;
                    }
                }
            }
            if(u4Count == 0)
            {
                LOG(0, "Mpg Fd _SWDMX_ReceiveFeederAck id is not correct\n");
                //ASSERT(u4Count > 0);
                return MPG_SEND_FAIL;
            }
        }
		else
		{
			if (prSwdmxInst->u4LogFilter & check_feeder_req)
			{
				LOG(1,"%s:not ack feeder pid/codecchg (%d,%d,%d,%d) reqtimes %u\n",__FUNCTION__,
					prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidPidChg,
					prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudPidChg,
					prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidCodecChg,
					prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudCodecChg,
					prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes);
			}			
		}
        // u4UsingBufSize = 0, u4BufAvailCnt = 0, fgGetEof = 1, will send eos in this function.
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize == 0)
        {   

            UINT32 u4BufReadIdx = 0;
            BOOL   bIsModedata = FALSE;
      
            u4BufReadIdx = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx;

            if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt > 0)            
            {
                if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidPidChg) && 
                   (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudPidChg) &&
                   (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidCodecChg) &&
                   (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudCodecChg))
                {
                    bIsModedata = TRUE;
                }
                else if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidPidChg ||
                         prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudPidChg ||
                         prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidCodecChg ||
                         prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudCodecChg)
                {
                    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4BufStartIBCAddr != prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4BufStartAddr[u4BufReadIdx])
                    {   
                        bIsModedata = TRUE;
                    }
                    else
                    {
                        bIsModedata = FALSE;                        
                        LOG(2,"IBC addr 0x%x temp not move data plse waiting \n",prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4BufStartIBCAddr);
                    }
                }
            }
            if(bIsModedata)
            {
                BOOL fgSkip = FALSE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4BufSize[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx];
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingPTS = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4BufPTS[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx];
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4BufSize[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx];
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingStartAddr = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4BufStartAddr[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx];
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufTotalSize -= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4BufSize[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx];

                if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_206)
                {
					prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize += 14;
					if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize >= 14)
					{
						prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize -= 14;
					}
					else
					{
						prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize = 0 ;						
					}
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingStartAddr += 14; 
					
				    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingStartAddr >= prSwdmxInst->rFeederInfo.u4EndAddr)
				    {
				        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingStartAddr -= (prSwdmxInst->rFeederInfo.u4EndAddr - prSwdmxInst->rFeederInfo.u4StartAddr);
				    }					
                }
#ifdef TIME_MEASUREMENT
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.fgUsingPrintTMS = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.fgPrintTMS[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx];
#endif
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt--;

                if(prSwdmxInst->u4LogFilter & check_move_data)
                {
					UCHAR *pucBuf = (UCHAR*)(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingStartAddr);
					
                    LOG(1," au4BufStartAddr[%d] 0x%x UsingBufSize %d u4BufAvailCnt %d changed [%d %d %d %d] \n",
                        u4BufReadIdx, 
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingStartAddr,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt, 
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidPidChg,   
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudPidChg,  
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidCodecChg,                    
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudCodecChg);

                        LOG(2, "mem(0x%x) 0x%02x%02x%02x%02x%02x%02x%02x%02x\n",                               
                             (UINT32)pucBuf,
                            *((UCHAR*)pucBuf + 0),
                            *((UCHAR*)pucBuf + 1),
                            *((UCHAR*)pucBuf + 2),
                            *((UCHAR*)pucBuf + 3),
                            *((UCHAR*)pucBuf + 4),
                            *((UCHAR*)pucBuf + 5),
                            *((UCHAR*)pucBuf + 6),
                            *((UCHAR*)pucBuf + 7));		
					
					
                }
                    
//#ifdef CC_VUDU_SUPPORT
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.afgBufFeederIBCType[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx]
                    == (UINT32)FEEDER_IBC_DMX_VUDU_KEY)
                {
                    DMX_PID_T rPid;
                    x_memset(&rPid, 0, sizeof(DMX_PID_T));
                    rPid.eDescMode = ((DMX_VUDU_KEY_T *)(&_arVuduKey[u1SrcId][prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx]))->eMode;
                    
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo != 0xFF)
                    {

#if defined(CC_MT5365) || defined(CC_MT5395) || defined(SWDMX_IS_POST_MT5368)
                        if(!DMX_SetFilePid(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo,
                                DMX_PID_FLAG_DESC_MODE, &rPid))
#else
                        if(!DMX_SetPid(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo,
                                DMX_PID_FLAG_DESC_MODE, &rPid))
#endif
                        {
                            LOG(3, "MpgHandleFeeder DMX_SetPid V DMX_PID_FLAG_DESC_MODE fail\n");
                        }
                    }
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio != 0xFF)
                    {
#if defined(CC_MT5365) || defined(CC_MT5395) || defined(SWDMX_IS_POST_MT5368)
                        if(!DMX_SetFilePid(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio,
                                DMX_PID_FLAG_DESC_MODE, &rPid))
#else
                        if(!DMX_SetPid(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio,
                                DMX_PID_FLAG_DESC_MODE, &rPid))
#endif
                        {
                            LOG(3, "MpgHandleFeeder DMX_SetPid A DMX_PID_FLAG_DESC_MODE fail\n");
                        }
                    }
                    // 0831 ??
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2 != 0xFF)
                    {
#if defined(CC_MT5365) || defined(CC_MT5395) || defined(SWDMX_IS_POST_MT5368)
                        if(!DMX_SetFilePid(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2,
                                DMX_PID_FLAG_DESC_MODE, &rPid))
#else
                        if(!DMX_SetPid(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2,
                                DMX_PID_FLAG_DESC_MODE, &rPid))
#endif
                        {
                            LOG(3, "MpgHandleFeeder DMX_SetPid A DMX_PID_FLAG_DESC_MODE fail\n");
                        }
                    }
                    // 0831 ??
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3 != 0xFF)
                    {
#if defined(CC_MT5365) || defined(CC_MT5395) || defined(SWDMX_IS_POST_MT5368)
                        if(!DMX_SetFilePid(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3,
                                DMX_PID_FLAG_DESC_MODE, &rPid))
#else
                        if(!DMX_SetPid(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3,
                                DMX_PID_FLAG_DESC_MODE, &rPid))
#endif
                        {
                            LOG(3, "MpgHandleFeeder DMX_SetPid A DMX_PID_FLAG_DESC_MODE fail\n");
                        }
                    }
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingPTS = 0;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize = 0;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingStartAddr = 0;
                    if(!DMX_VUDU_SetKey(&_arVuduKey[u1SrcId][prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx]))
                    {
                        LOG(3, "MpgHandleFeeder DMX_VUDU_SetKey fail\n");
                    }
                    else
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetKey = TRUE;
                        LOG(5, "MpgHandleFeeder DMX_VUDU_SetKey OK\n");
                    }
                    fgSkip = TRUE;
                }
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.afgBufFeederIBCType[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx]
                    == (UINT32)FEEDER_IBC_DASH_SET_INFO)
                {

          LOG(5,"ui8_bandwidth %d b_bandwidth_chg %d\n ",
            (_arIBCDashSetInfo[u1SrcId][prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx]).ui8_bandwidth,
            (_arIBCDashSetInfo[u1SrcId][prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx]).b_bandwidth_chg);
          prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.fgBandWidthChg = (_arIBCDashSetInfo[u1SrcId][prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx]).b_bandwidth_chg;                    
                }
        
        
//#endif
                #ifdef SWDMX_MPG_DEBUG_BUFFER
                LOG(7, "Mpg Fd Eat UB %d BT %d RT %d BWI %d BRI %d BAC %d RWI %d RRI %d RT %d BRS %d BPTS %d UAdr %d\n",
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufTotalSize,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufWriteIdx,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4BufSize[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx],
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4BufPTS[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx],
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingStartAddr);
                #endif
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx++;
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum)
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx = 0;
                }
                if(fgSkip)
                {
                    return MPG_SEND_SKIP;
                }
                // sometimes, ack size may be 0
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize == 0)
                    return MPG_SEND_FAIL;

                if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingStartAddr <
                    prSwdmxInst->rFeederInfo.u4EndAddr) &&
                   ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingStartAddr +
                     prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize) >=
                     prSwdmxInst->rFeederInfo.u4EndAddr))
                {
                    HalFlushInvalidateDCacheMultipleLine(
                        VIRTUAL(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingStartAddr),
                        (prSwdmxInst->rFeederInfo.u4EndAddr -
                         prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingStartAddr));
                    HalFlushInvalidateDCacheMultipleLine(
                        VIRTUAL(prSwdmxInst->rFeederInfo.u4StartAddr),
                        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize -
                         (prSwdmxInst->rFeederInfo.u4EndAddr -
                          prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingStartAddr)));
                }
                else
                {
                    HalFlushInvalidateDCacheMultipleLine(
                        VIRTUAL(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingStartAddr),
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize);
                }
            }
            else if((!bIsModedata)&& 
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidPidChg ||
                 prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudPidChg ||
                 prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidCodecChg ||
                 prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudCodecChg))
            {


                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.afgBufFeederIBCType[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx]
                    == (UINT32)FEEDER_IBC_PARAM_STRM_INFO)
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize = 0;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingStartAddr = 0;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt--;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx++;
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx = 0;
                    }
                    #if 0
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx++;
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx = 0;
                    }      
                    #endif
                }
                
                if (prSwdmxInst->u4LogFilter & check_fifo_data) 
                {
                    /* avoid log info too mach */
                    static UINT32 _ui4LogCnt = 0;
                    if (_ui4LogCnt >= 3)
                    {
                        LOG(5,"%s %d don't move data temp,until stream change finished \n",__FUNCTION__,__LINE__);                    
                        _ui4LogCnt = 0;
                    }
                    _ui4LogCnt++;
                }
            
                return MPG_SEND_WAIT;
            }
            else
            {
                if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgPauseMoving)
                {
                    //LOG(7,"no data need process when pause moving\n");
                    return MPG_SEND_OK;
                }
                
                LOG(3, "Mpg Fd u4BufAvailCnt 0 u4UsingBufSize 0\n");
                #if 1//def CC_DLNA_SUPPORT                                 //for DLNA handle EOF
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.fgGetEof)                                      // get EOF from feeder
                {
                     LOG(3, "Mpg Fd u4BufAvailCnt 0 u4UsingBufSize and send EOS 0\n");
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = TRUE;
          prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpping = FALSE;
          prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext = FALSE;          
                    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetInfo)
                    {
                        _SWDMX_MpgHandleEOS(u1SrcId, i4PlaySpeed);
                    }
                    if(prRangeList)
                    {
                        prRangeList->eRangeStats = eSWDMX_RANGE_STATE_PENDING;
                    }
                    if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) &&
                       (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) &&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_RAW_AUDIO_ES)&&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_ENCRYPT_192)&&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS)&&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_204)&&
					   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_206)&&
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_192))
                    {
                        if(prRangeList)
                        {
                            prRangeList->eRangeStats = eSWDMX_RANGE_STATE_FINISHED;
                        }
                    }
                    return MPG_SEND_FAIL;
                }
                #endif
                
        		if (IS_LOCAL_NET(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type) &&
        			(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed > 0) &&
        			(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed < 1000) &&
        			prSwdmxInst->fgSupportConnStalling)
        		{
        		    LOG(2,"Stalling status,Can't move data continue \n");
                    return MPG_SEND_FAIL;
        		
        		}                
                else if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize != prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize)
                {
                    //DTV00334590 add for the file size is error
                    if(((UINT32)(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize >> 32) != (UINT32)0xFFFFFFFF) &&
                        ((UINT32)(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize) != (UINT32)0xFFFFFFFF))
                    {
                        LOG(0,"sendsize 0x%x\n",prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize);                    
                        ASSERT(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt > 0);
                    }
                    else
                    {
                        LOG(1, "can not get file size, handle eos\n");
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = TRUE;
                        if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetInfo)
                        {
                            _SWDMX_MpgHandleEOS(u1SrcId, i4PlaySpeed);
                        }
                        if(prRangeList)
                        {
                            prRangeList->eRangeStats = eSWDMX_RANGE_STATE_PENDING;
                        }
                        if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) &&
                           (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) &&
                           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_RAW_AUDIO_ES)&&
                           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_ENCRYPT_192)&&
                           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS)&&
                           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_204)&&
						   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_206)&&
                           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_192))
                        {
                            if(prRangeList)
                            {
                                prRangeList->eRangeStats = eSWDMX_RANGE_STATE_FINISHED;
                            }
                        }
                    }
                }
                return MPG_SEND_FAIL;
            }
        }
    }
    #if 1//def CC_DLNA_SUPPORT                           //for DLNA handle EOF
    if(( prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.fgGetEof==TRUE) &&(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt==0))
    {
        LOG(7,"swdmx  will send  the Last data \n ");
        return MPG_SEND_LAST;
    }
    #endif
    #ifdef SWDMX_STATISTICS
    _CalFeederTime();
    #endif

    return MPG_SEND_OK;
}
//-----------------------------------------------------------------------------
// Inter-file functions
//-----------------------------------------------------------------------------
/**
*/
INT32 _SWDMX_MpgSendData(UINT8 u1SrcId, SWDMX_RANGE_LIST_T* prRangeList,
            SWDMX_CUR_CMD_T* prCmd)
{
#ifdef TIME_SHIFT_SUPPORT
    BOOL fgRet;
    BOOL fgVideoScambled =FALSE;
    BOOL fgAudioScambled =FALSE;
#endif
    BOOL fgLast = FALSE;
    INT32 i4Ret;
    UINT32 u4SendSize;
    UINT32 u4Ptr;
    UINT64 u8SeekPos;
    INT32 i4PlaySpeed;
    INT32 i4_curr_speed = 0;

    DMX_MM_DATA_T rDmxMMData;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    u8SeekPos = prCmd->u8SeekPos;
    i4PlaySpeed = prCmd->i4PlaySpeed;
    UNUSED(u8SeekPos);
   
    _SWDMX_MpgDetectStrmChgInfo(u1SrcId);
    
    if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) && (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnVDmx))
    {
        if(!_SWDMX_MpgInitDmx(u1SrcId,eSWDMX_STRM_TYPE_VID))
        {
            LOG(0,"Mpg init video pid index fail\n");
            return MPG_SEND_FAIL;
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnVDmx = TRUE;
    }
    if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo2) && (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnVDmx2))
    {
        if(!_SWDMX_MpgInitDmx(u1SrcId,eSWDMX_STRM_TYPE_VID2))
        {
            LOG(0,"Mpg init video2 pid index fail\n");
            return MPG_SEND_FAIL;
        }        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnVDmx2 = TRUE;
    }
    if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) && (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnADmx))
    {
        if(!_SWDMX_MpgInitDmx(u1SrcId,eSWDMX_STRM_TYPE_AUD))
        {
            LOG(0,"Mpg init audio pid index fail\n");
            return MPG_SEND_FAIL;
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnADmx = TRUE;        
    }
    if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio2) && (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnADmx2))
    {
        if(!_SWDMX_MpgInitDmx(u1SrcId,eSWDMX_STRM_TYPE_AUD2))
        {
            LOG(0,"Mpg init audio2 pid index fail\n");
            return MPG_SEND_FAIL;
        }        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnADmx2 = TRUE;        
    }    
    if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio3) && (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnADmx3))
    {
        if(!_SWDMX_MpgInitDmx(u1SrcId,eSWDMX_STRM_TYPE_AUD3))
        {
            LOG(0,"Mpg init audio3 pid index fail\n");
            return MPG_SEND_FAIL;
        }        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnADmx3 = TRUE;        
    }        
    
    if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) && 
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnVidHdcp))
    {
        _SWDMX_MpgHDCP2SetRivPid(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo);
        /*set video hdcp key info*/
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnVidHdcp = FALSE;
    }
    if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo2) && 
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnVid2Hdcp))
    {
        /*set video2 hdcp key info*/
        _SWDMX_MpgHDCP2SetRivPid(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo2);        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnVid2Hdcp = FALSE;
    }     
    if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) && 
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnAudHdcp))
    {
        /*set audio hdcp key info*/
        _SWDMX_MpgHDCP2SetRivPid(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio);        
        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnAudHdcp = FALSE;
    }    
    
    if ((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgBeginToPlay) &&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) &&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed == 1000))
    {
        #define _LOOP_CNT_    200
        UINT32 u4Cnt = 0;    
        while (u4Cnt < _LOOP_CNT_)
        {
            if (!_SWDMX_MpgCheckVdecState(u1SrcId)) //until waiting vdec play when start play,swdmx begin move data.
            {
                 x_thread_delay(10);
                 u4Cnt++;
            }        
            else
            {
                break;
            }
        }

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgBeginToPlay = TRUE;      
    }
    
    
#ifdef CC_SWDMX_RENDER_POSITION
    _SWDMX_MpgHandleLastMemory(u1SrcId,prRangeList);
#endif

#ifdef SUPPORT_CIPLUS_RECORD
    if( (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt==SWDMX_FMT_MPEG2_TS_ENCRYPT_192) &&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS != 0) && prRangeList )    // To get the first PTS
    {
        MM_RANGE_INFO_T *prRangeInfo = prRangeList->prDmxRangeInfo;

        if (prRangeInfo && (prRangeInfo->ui4_rl_time!=0xFFFFFFFF) && (prSwdmxInst->u4TotalTime!=0xFFFFFFFF) )
        {
            UINT64 u8CurTime = 0;
            UINT32 u4FakeTime = 0;
            UINT64 u8SizeFake = 0;
            UINT64 u8Remainder = 0;
            BOOL   fgDataFake = FALSE;
            VDP_PIC_INFO_T rPicInfo;

            x_memset(&rPicInfo, 0, sizeof(VDP_PIC_INFO_T));
            UNUSED(RTC_GetTimeDate( &u8CurTime ));
            if (((INT64)u8CurTime >= (INT64)prRangeInfo->t_record_time))
            {
                if (((INT64)u8CurTime-(INT64)prRangeInfo->t_record_time) > (INT64)prRangeInfo->ui4_rl_time)
                {
                    u4FakeTime = (UINT32)(((INT64)u8CurTime - (INT64)prRangeInfo->t_record_time) - (INT64)prRangeInfo->ui4_rl_time);
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FakeTime = u4FakeTime;
					if (prSwdmxInst->u4LogFilter & check_rl)
					{
						LOG(1,"%s:has fake time %u rltime %u\n",__FUNCTION__, u4FakeTime, prRangeInfo->ui4_rl_time);
					}
                    fgDataFake = TRUE;
                }
                else
                {
                    fgDataFake = FALSE;
                }
            }
            else
            {
                LOG(9, "%s LC: Err Sys time or record time\n", __FUNCTION__);
            }

            if (fgDataFake)
            {
                if (u4FakeTime*90000 < prSwdmxInst->u4TotalTime)
                {
                    u8SizeFake = _SWDMX_Div6464(90000*((u4FakeTime>PER_PARSE_DATA_SIZE)?(u4FakeTime-PER_PARSE_DATA_SIZE):(0))
                                                * prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize,
                                                prSwdmxInst->u4TotalTime, &u8Remainder);

                    u8SizeFake = _SWDMX_Div6464(u8SizeFake, MPG_ALIGN_SIZE_TS_192, &u8Remainder) * MPG_ALIGN_SIZE_TS_192;

                    fgRet = (VDP_GetPicInfo(prSwdmxInst->u1B2rId, &rPicInfo));
                    if (fgRet)
                    {
                        if (u4FakeTime*90000 + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS > rPicInfo.u4Pts)
                        {
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicStartPlayOrgPTS
                                = u4FakeTime*90000 + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS;
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AudStartPlayOrgPTS
                                = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicStartPlayOrgPTS;
                        }
                    }else
                    {
                        LOG(0,"Mpg get vdp info for fake time fail\n");
                    }
                    
                    // Set u4DropPts to VDP, tell vdp to drop Pic with a PTS littler the  u4DropPts
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime = prSwdmxInst->u4TotalTime - 
                        ((u4FakeTime>PER_PARSE_DATA_SIZE)?(u4FakeTime-PER_PARSE_DATA_SIZE):(0))*90000;   // For Seek, Jump
                    u8Remainder = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset = u8SizeFake;        // New Base Offset
                    if (prSwdmxInst->u4LogFilter & check_rl)
					{
						LOG(1,"partially expired u4PicStartPlayOrgPTS %u start offset %llu\n",
							prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicStartPlayOrgPTS, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset);
					}
                 }
                 else
                 {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicStartPlayOrgPTS
                            = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS + prRangeInfo->ui4_rl_time*90000;
                    if (prSwdmxInst->u4LogFilter & check_rl)
					{
						LOG(1,"totally expired u4PicStartPlayOrgPTS %u start offset %llu\n",
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicStartPlayOrgPTS, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset);
					}
                    MPV_FlushEsmQ(prSwdmxInst->u1VdecId, FALSE);
                    UNUSED(VDEC_ReleaseDispQ(prSwdmxInst->u1VdecId));
                    if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                       (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                    {
                        MPV_FlushEsmQ(prSwdmxInst->u1Vdec2Id, FALSE);
                        UNUSED(VDEC_ReleaseDispQ(prSwdmxInst->u1Vdec2Id));
                    }

                    _SWDMX_MpgResetData(u1SrcId);

                    // Notes: It only be reset in resetSwdmxInfo
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotStartToPlay = TRUE;
                    
                    UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
                    UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
                    UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1VdecId, FALSE, 0));
                    UNUSED(VDEC_SetRenderFromPts(prSwdmxInst->u1VdecId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicStartPlayOrgPTS));
                    if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                       (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                    {
                        UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                        UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                        UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1Vdec2Id, FALSE, 0));
                        UNUSED(VDEC_SetRenderFromPts(prSwdmxInst->u1Vdec2Id, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicStartPlayOrgPTS));
                    }
					LOG(1,"%s:VDEC_SetRenderFromPts for fake time %u\n", __FUNCTION__, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicStartPlayOrgPTS);
                    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
                    {
#ifdef CC_AUD_SUPPORT_DUAL_DSP
                    AUD_DSPCmdStop(AUD_DSP0, prSwdmxInst->u1AdecId);
                    AUD_DSPCmdPlay(AUD_DSP0, prSwdmxInst->u1AdecId);
#else
                    AUD_DSPCmdStop(prSwdmxInst->u1AdecId);
                    AUD_DSPCmdPlay(prSwdmxInst->u1AdecId);
#endif
                        LOG(5, "[Info] %s(%d):%u LC: Tmp solution(Stop&Play) for Flush audio data.\n",
                                __FUNCTION__, prSwdmxInst->u1SwdmxId, __LINE__);
                    }
                    LOG(5, "%s LC: The Stream is time out.\n", __FUNCTION__);
                 }
                 
                 LOG(7, "%s LC: CT(0x%llX) RT(0x%llX) LT(0x%X) TT(0x%X) SFO(0x%llX)-->SFO(0x%llX)\n",
                        __FUNCTION__, u8CurTime, prRangeInfo->t_record_time, prRangeInfo->ui4_rl_time, 
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime,
                        u8Remainder, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset);
            }
       }
    }
#endif // SUPPORT_CIPLUS_RECORD

#ifdef HANDLE_PTS_SKIP
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1SkipPts == NEED_RESET_STC)
    {
#if 0
        if (FALSE == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAVSyncOnOff)
        {
            // Tell VDP, not do pending always
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAVSyncOnOff = TRUE;
            _VDP_SetSyncSpeed(prSwdmxInst->u1B2rId, TRUE, 3);
            LOG (3, "Set AVSyncSpeed(%u) fgOnOff(%u)\n", 3, TRUE);
        }
        else
        {
            UINT32 u4Pts = 0, u4Stc = 0, u4Delta;
            
            u4Pts = _VDP_GetCurrentPts(prSwdmxInst->u1B2rId);
            u4Stc = STC_GetStcValue(prSwdmxInst->u1StcId);

            // Compare little PTS value with STC. ensure STC be set to a small one
            if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1VSkipLittlePts > u4Stc)
            {
                u4Delta = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1VSkipLittlePts - u4Stc;
            }
            else
            {
                u4Delta = u4Stc - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1VSkipLittlePts;
            }

            if (u4Delta < SKIP_PTS_RECOVER_THRESHOLD)
            {
                // STC be set to a small one
                // ensure small PTS frames are displaying 
                if (u4Pts > u4Stc)
                {
                    u4Delta = u4Pts - u4Stc;
                }
                else
                {
                    u4Delta = u4Stc - u4Pts;
                }

                if (u4Delta < SKIP_PTS_RECOVER_THRESHOLD)
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1SkipPts = NO_SKIP_PTS;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAVSyncOnOff = FALSE;
                    _VDP_SetSyncSpeed(prSwdmxInst->u1B2rId, FALSE, 0);
                    LOG (3, "Auto Recover: AVSyncSpeed(%u) fgOnOff(%u)\n", 0, FALSE);
                }
            }
        }        
#endif        
#if 0
        // In VDP, not do pending may be perfect
        UINT32 u4Stc = _VDP_GetCurrentPts(prSwdmxInst->u1B2rId);
        if( u4Stc && ((u4Stc + SKIP_PTS < STC_GetStcValue(prSwdmxInst->u1StcId)) ||
            (u4Stc > SKIP_PTS + STC_GetStcValue(prSwdmxInst->u1StcId))))
        {
            STC_SetStcValue(prSwdmxInst->u1StcId, u4Stc + 3000);
            LOG(3, "Reset stc to 0x%x\n", u4Stc + 3000);
        }
#endif
    }    
#endif
    if(prCmd->fgChange)
    {
       i4_curr_speed = prCmd->i4PlaySpeed/1000;
    }
    else
    {
       i4_curr_speed = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed/1000;
    }
           
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgDynamicDuration &&
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192)
    {
        _SWDMX_MpgHandleRecordingFile(u1SrcId, i4_curr_speed);
    }  

#ifdef HANDLE_CODEC_PID_CHG 
  if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192 &&
    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFlushVidData ||
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFlushAudData))
  {
    _SWDMX_MpgPvrHandleCodecPidChg(u1SrcId);
  }
#endif

  // handle speed and position
    // must handle position before we parsing first sequence header.
    if(prCmd->fgChange)
    {
#ifdef HANDLE_PTS_SKIP
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1SkipPts = NO_SKIP_PTS;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4VBaseSkipPts = 0;      
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4ABaseSkipPts = 0;      
        
#if 0      
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAVSyncOnOff = FALSE;
        _VDP_SetSyncSpeed(prSwdmxInst->u1B2rId, FALSE, 0);
        LOG (3, "Change Recover: Set AVSyncSpeed(%u) fgOnOff(%u)\n", 0, FALSE);
#endif
        
#endif
        if (prSwdmxInst->eSeekType ==  eSWDMX_TYPE_TIME_SEEK)
        {
            _SWDMX_MpgHandleTimeChange(u1SrcId, prCmd);
        }
        else
        {
            _SWDMX_MpgHandleChange(u1SrcId, prCmd);
            
        } 
    }
    else if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) &&
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo)&&
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)&&
            (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSetActivePid))
    {
    
        /* include two case:1 change audio or no signel in timeshift */
        _SWDMX_MpgSetActivePix(u1SrcId);
    } 
    // audio only: change audio stream when enable prebuffer.
    else if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)&&    // TS : not video  and has only audio case
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)&&
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudioPlayed)&&
            (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSetActivePid)
           ) 
    {
        _SWDMX_MpgSetActivePix(u1SrcId);
    }
      
#ifdef TIME_SHIFT_SUPPORT
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        BOOL fgVideoNotSupport = FALSE;
        VDEC_HDR_INFO_T rHdrInfo;
        HAL_TIME_T NosigCheckTime;
        UNUSED(VDEC_QueryInfo(prSwdmxInst->u1VdecId, &rHdrInfo));
        /*
        if(DMX_GetScrambleState(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo) == DMX_SCRAMBLE_STATE_SCRAMBLED)
        {
            fgVideoNotSupport = TRUE;
        }
        else
        //VDEC_DEC_DECODE_HD_NOT_SUPPORT, etc.
        if((rHdrInfo.eNotifyStatus != VDEC_DEC_DECODE_UNKNOWN) &&
           (rHdrInfo.eNotifyStatus != VDEC_DEC_DECODE_NORMAL) &&
           (rHdrInfo.eNotifyStatus != VDEC_DEC_DECODE_NO_DATA))
        {
            fgVideoNotSupport = TRUE;
        }
        */
     if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
     {
       if(DMX_GetScrambleState(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo) == DMX_SCRAMBLE_STATE_SCRAMBLED)
       {
           fgVideoScambled=TRUE;
       }
     }
     if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
     {
       if(DMX_GetScrambleState(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio) == DMX_SCRAMBLE_STATE_SCRAMBLED)
       {
          fgAudioScambled=TRUE;
       }
     }
     //DTV00095614  video scramble, audio only, when set speed 1x, we should pause swdmx
     if((fgVideoScambled)&&(i4PlaySpeed==1))
     {
         SWDMX_Pause(u1SrcId);
         if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
         {
             _SWDMX_RANGE_CALLBACK(
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                    MM_RANGE_SEEK_DONE,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                    0xFFFFFFFF,
                    (UINT32)u1SrcId);
         }
         else
         {
               LOG(3, "pfnSwdmxRangeCb null\n");
         }
              LOG(5, "video scramble : MM_RANGE_SEEK_DONE\n");
    }


     if(((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)&&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)&&fgVideoScambled)
        ||           
        ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)&&
        (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)&&fgAudioScambled)
        ||
        ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)&&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)&&fgAudioScambled&&fgVideoScambled))
        {
             prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgInScramble = TRUE;
             LOG(5,"in scramble status\n");
        }
        else 
        {
           prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgInScramble = FALSE;
        }
        
        //DTV00333609  when unplug CA sim card, video always in sramble status, as swdmx didn't move data,
        // 
        
        //if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage != MPG_TSS_NORMAL) ||
        //  (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgInScramble==TRUE))
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage != MPG_TSS_NORMAL)
        {
            // DTV00214748 when speed=1000, and in no signal status, we should calibrate prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime
            //as x_thread_delay() not very exactly
            if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNeedAdjust)&&(i4PlaySpeed==1000))
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNeedAdjust=TRUE;
                HAL_GetTime(&NosigCheckTime);
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OrgtDeltaTime= (NosigCheckTime.u4Seconds*1000 + NosigCheckTime.u4Micros/1000)
                                                     - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime;
            }
            i4Ret = _SWDMX_MpgHandleNoSignel(u1SrcId, &u8SeekPos, i4PlaySpeed);
            //if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage == MPG_TSS_NORMAL)&&
            //  (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgInScramble!= TRUE))
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage == MPG_TSS_NORMAL)

            {
                // DTV00145526, The audio does NOT match the video after unplug/plug the signal cable.
                // Because MW does not close audio in this case,
                // we can't flush audio fifo.
                // Audio driver does not know we flush data if we didn't close
                // audio.

#if 1
                //_SWDMX_MpgHandleChange(i4PlaySpeed, u8SeekPos);
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNeedAdjust=FALSE;
                MPV_FlushEsmQ(prSwdmxInst->u1VdecId, FALSE);
                UNUSED(VDEC_ReleaseDispQ(prSwdmxInst->u1VdecId));
                if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                   (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                {
                    MPV_FlushEsmQ(prSwdmxInst->u1Vdec2Id, FALSE);
                    UNUSED(VDEC_ReleaseDispQ(prSwdmxInst->u1Vdec2Id));
                }
#else
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNeedAdjust=FALSE;
                _SWDMX_MpgHandleChange(i4PlaySpeed, u8SeekPos);
                //MPV_FlushEsmQ(prSwdmxInst->u1VdecId, FALSE);
                //UNUSED(VDEC_ReleaseDispQ(prSwdmxInst->u1VdecId));
#endif
                // TODO
                // Audio also need a flush
                // and resync action
            }
            return i4Ret;
        }
        else if(((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
                 ||
                 ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) &&
                  (fgVideoNotSupport)))
                &&
                // while we are parsing table, not handle this.
                // DTV00142030, Can't pause time shift playback mode in any audio channel.
                // when there is no video, we do not send data anymore
                // while beginin parsing table, i4PlaySpeed = 0;
                //(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPSISize)
                //&&
                // both audio on and off have to check this.
                //(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) &&
                (i4PlaySpeed != 1000) &&
                (i4PlaySpeed != 0))
        {
            i4Ret = _SWDMX_MpgHandleEmpty(u1SrcId, &u8SeekPos, i4PlaySpeed);
            return i4Ret;
        }
       else
       {
           prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNeedAdjust = FALSE;

       }
       prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1NumNoSignal = 0;
    }
#endif

    LOG(9, "_SWDMX_MpgSendData pos 0x%llx\n",
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize);

#ifdef TIME_SHIFT_SUPPORT
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgChangeVideo)
        {
            LOG(5, "_SWDMX_MpgSendData fgChangeVideo\n");
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgChangeVideo = FALSE;
            fgRet = _SWDMX_DMX_Reset(u1SrcId);//DMX_DDI_RequestReset();
            if(!fgRet)
            {
                LOG(3, "_SWDMX_MpgSendData _SWDMX_DMX_Reset Fail\n");
            }
        }
    }
#endif
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpping)
    {
        i4Ret = _SWDMX_MpgHandleNextTrick(u1SrcId,i4PlaySpeed);
        
        if (MPG_SEND_OK != i4Ret)
        {
            return i4Ret;
        }
    }

    // must put ahead _SWDMX_MpgHandleSeek
    // there is a case, after send EOS to decoder
    // and before decoder look EOS, decoder found PIC and notify
    // prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext = TRUE
    // we must let _SWDMX_MpgHandleSeek call again to deliver EOS.
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF)
    {
        // audio still not aout after EOS
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady) &&
           (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio))
        {
            AUD_MMAoutEnable(prSwdmxInst->u1AdecId, TRUE);
            STC_StartStc(prSwdmxInst->u1StcId);
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio = TRUE;

            // 0831
            if(prSwdmxInst->fgEnAudio2Dmx && !prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio2)
            {
                AUD_MMAoutEnable(prSwdmxInst->u1Adec2Id, TRUE);
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio2 = TRUE;
                
            }
            // 0831 ??
            if(prSwdmxInst->fgEnAudio3Dmx && !prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio3)
            {
                //AUD_MMAoutEnable(prSwdmxInst->u1Adec3Id, TRUE);
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio3 = TRUE;
            }
        }

        // DTV00136518, The special .mpe video freezed after input time=00:00:20 and do time seek function.
        // Audio ready comes after eos.
        if((((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) && (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady))
            ||
            (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)) &&
            ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) &&
             (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos) &&
             (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause)))
        {
            // i4PlaySpeed = 1x and audio ready later after video send eos
            // if now in VDEC_Pause, VDec might in pause status.
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
            {
                VDP_SetPauseMm(prSwdmxInst->u1B2rId, FALSE);
                _SWDMX_MpgVdecPlay(u1SrcId);
                
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPause = FALSE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideoReady = TRUE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo = TRUE;
                LOG(5, "_SWDMX_MpgSendData VDEC_Play after EOS\n");
            }
        }

        //DTV00091703 when audio eos has been sent to audio drv, but didn't notify to mw,  at this time change audio trick, we should
        // send audio eos again.
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) && (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos))
        {
             
            DMX_AUDIO_PES_T rPes;                     
            UINT32 au4BufStart[2], au4BufEnd[2];
            x_memset(&rPes, 0, sizeof(rPes));
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioWptr != 0)
            {
                rPes.u4Wp = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioWptr;
            }
            else
            {
#ifdef AUD_OLDFIFO_INTF
                VERIFY(AUD_GetAudFifo(&au4BufStart[0], &au4BufEnd[0],
                        &au4BufStart[1], &au4BufEnd[1]) == AUD_OK);
#else
                VERIFY(AUD_GetAudFifo(prSwdmxInst->u1AdecId, &au4BufStart[0], &au4BufEnd[0]) == AUD_OK);
#endif
                         rPes.u4Wp = (au4BufStart[0] + 4); // Jessica.
            }
            rPes.u1DeviceId = prSwdmxInst->u1AdecId;
            //UNUSED(AUD_SendAudioPes(&rPes)); // audio driver said they need this one.
            rPes.fgEOS = TRUE;
                     
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed >0)
            {
                rPes.fgForward = TRUE;           //for trick mode 
            }
            else
            {
                rPes.fgForward = FALSE;
            }             
             //_SWDMX_MpgAudioCallback(&rPes);
            UNUSED(AUD_SendAudioPes(&rPes));
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = TRUE;
            if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = TRUE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = TRUE;
             
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS =
                ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS) + (MPG_STC_BASE));
#ifdef TIME_SHIFT_SUPPORT
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
#endif
                {
                    UNUSED(AUD_SetStartPts(prSwdmxInst->u1AdecId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS));

                }
                //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = TRUE;
                //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = TRUE;
            }
            LOG(0 , "_SWDMX_MpgSendData send dummy EOS to Adec line %d\n", __LINE__);            
        }        
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio2) && (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio2Eos))
        {
            DMX_AUDIO_PES_T rPes;                     
            UINT32 au4BufStart[2], au4BufEnd[2];
            x_memset(&rPes, 0, sizeof(rPes));
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio2Wptr != 0)
            {
                rPes.u4Wp = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio2Wptr;
            }
            else
            {
#ifdef AUD_OLDFIFO_INTF
                VERIFY(AUD_GetAudFifo(&au4BufStart[0], &au4BufEnd[0],
                        &au4BufStart[1], &au4BufEnd[1]) == AUD_OK);
#else
                VERIFY(AUD_GetAudFifo(prSwdmxInst->u1Adec2Id, &au4BufStart[0], &au4BufEnd[0]) == AUD_OK);
#endif
                 rPes.u4Wp = (au4BufStart[0] + 4); // Jessica.
            }
            rPes.u1DeviceId = prSwdmxInst->u1Adec2Id;
            //UNUSED(AUD_SendAudioPes(&rPes)); // audio driver said they need this one.
            rPes.fgEOS = TRUE;
                     
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed >0)
            {
                rPes.fgForward = TRUE;           //for trick mode 
            }
            else
            {
                rPes.fgForward = FALSE;
            }             
            UNUSED(AUD_SendAudioPes(&rPes));
            
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio2Eos = TRUE;
                        
            LOG(0, " _SWDMX_MpgSendData send dummy EOS to Adec2 line %d\n", __LINE__);
        }
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio3) && (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio3Eos))
        {
            DMX_AUDIO_PES_T rPes;                     
            UINT32 au4BufStart[2], au4BufEnd[2];
            x_memset(&rPes, 0, sizeof(rPes));
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio3Wptr != 0)
            {
                rPes.u4Wp = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudio3Wptr;
            }
            else
            {
#ifdef AUD_OLDFIFO_INTF
                VERIFY(AUD_GetAudFifo(&au4BufStart[0], &au4BufEnd[0],
                        &au4BufStart[1], &au4BufEnd[1]) == AUD_OK);
#else
                VERIFY(AUD_GetAudFifo(prSwdmxInst->u1Adec3Id, &au4BufStart[0], &au4BufEnd[0]) == AUD_OK);
#endif
                 rPes.u4Wp = (au4BufStart[0] + 4); // Jessica.
            }
            
            rPes.u1DeviceId = prSwdmxInst->u1Adec3Id;
            
            //UNUSED(AUD_SendAudioPes(&rPes)); // audio driver said they need this one.
            rPes.fgEOS = TRUE;
                     
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed >0)
            {
                rPes.fgForward = TRUE;           //for trick mode 
            }
            else
            {
                rPes.fgForward = FALSE;
            }             
            UNUSED(AUD_SendAudioPes(&rPes));
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio3Eos = TRUE;    
            LOG(0, "_SWDMX_MpgSendData  send dummy EOS to Adec3 line %d\n", __LINE__);
        }        
        prSwdmxInst->fgRcvEOS = TRUE; //fix underflow case
        LOG(7, "_SWDMX_MpgSendData _fgSendDataEOS true.\n");
        return MPG_SEND_EOS;
    }  
    
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFirst) // first send data
    {
        if (FeederGetBufferInfo(prSwdmxInst->eFeederSrc, &prSwdmxInst->rFeederInfo) !=
          FEEDER_E_OK)
        {
            LOG(3, "_SWDMX_MpgSendData FeederGetBufferInfo Fail\n");
            return MPG_SEND_FAIL;
        }
    }


    // We have to request feeder data first.
    // Then check fifo status.
    //if((i4Ret = _SWDMX_MpgHandleFifoFull()) != MPG_SEND_OK)
    //{
    //    return i4Ret;
    //}

    u4SendSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize;

	if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8RewindMaxSendedSize !=0 &&
		(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize) && 
		(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8RewindMaxSendedSize ||
		(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize + u4SendSize) > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8RewindMaxSendedSize))
	{		
		prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize -= (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8RewindJumpSize * prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4RewindJumpCnt++);
		prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
		prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize = 0;
		LOG(0,"%s:rewind not send over max, back to %llu!!!\n",__FUNCTION__,prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize);				
	}
    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize)
    ||((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.fgLastData)&&(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize==0))
        )        // have sended all the data
    {
#ifdef TIME_SHIFT_SUPPORT
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
        {
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo))
            {
                _SWDMX_RANGE_CALLBACK(
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                    MM_INTERNAL_ERROR,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                    0xFFFFFFFF,
                    (UINT32)u1SrcId);
            }
            LOG(1, "_SWDMX_MpgSendData SWDMX send (EOF), impossible\n");
            //UNUSED(_SWDMX_MpgResetFeederReq(u1SrcId));
            //return MPG_SEND_FAIL;
        }
#endif
         {
            LOG(5, "_SWDMX_MpgSendData SWDMX send (EOF)\n");
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = TRUE;
        
            if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetInfo)
            {
               _SWDMX_MpgHandleEOS(u1SrcId, i4PlaySpeed);
            }
            if(prRangeList)
            {
               prRangeList->eRangeStats = eSWDMX_RANGE_STATE_PENDING;
            }
            if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) &&
            (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) &&
            // DTV00211818
            // when audio es playback.
            // pause -> seek -> seek -> play
            // we will send finish event. this is not correct.
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_RAW_AUDIO_ES)&&
            //for fix DTV00439006,not good
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_ENCRYPT_192)&&
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS)&&
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_204)&&
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_206)&&   
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_192))
            {
               if(prRangeList)
               {
                   prRangeList->eRangeStats = eSWDMX_RANGE_STATE_FINISHED;
               }
            }
            return MPG_SEND_EOS;
        }

    }

    if((UINT64)u4SendSize > ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize)))
    {
        u4SendSize = (UINT32)((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize));
    }


    if(u4SendSize == 0)
    {
        LOG(1, "_SWDMX_MpgSendData u4SendSize < 0 Fail\n");
        ASSERT(0);
    }

#ifdef TIME_SHIFT_SUPPORT
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        UINT32 u4Temp;
        fgRet = _SWDMX_MpgGetTickByPos(u1SrcId,
            TRUE,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize,
            prCmd->i4PlaySpeed,
            &u4Temp);
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex) &&
           (fgRet))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum = u4Temp;
            //LOG(5, "Trace u4CurTickNum(%d) u8SendedSize(0x%llx)\n",
            //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum,
            //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize);
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime =
                (UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex->ui4_tick_num;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime *=
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TickBase;

            LOG(9, "_SWDMX_MpgSendData u4CurTickNum 0x%x\n",
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum);
            if(SWDMX_MPG_TICK_FLAG_CHECK(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex,
                PVR_TICK_INDEX_FLAG_EMPTY) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage == MPG_TSS_NORMAL))
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalTickNum =
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex->ui4_tick_num;

                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage = MPG_TSS_PREPARE_NO_SIGNAL;
                LOG(3, "u4NoSignalStage 1.2.1, PREPARE_NO_SIGNAL tick %d\n",
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalTickNum);
                return MPG_SEND_FULL;
            }
            else if(SWDMX_MPG_TICK_FLAG_CHECK(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex,
                PVR_TICK_INDEX_FLAG_BAD) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage == MPG_TSS_NORMAL))
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalTickNum =
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex->ui4_tick_num;

                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage = MPG_TSS_PREPARE_BAD_STORAGE;
                LOG(3, "u4NoSignalStage 1.2.2, PREPARE_BAD_STORAGE tick %d\n",
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalTickNum);
                return MPG_SEND_FULL;
            }
        }
        else
        {
            // DTV00060341 [Time Shift] Play directly and display "Retrieving Data..." by press PLAY/PAUSE after record more than 2 hrs.
            // Handle out of range case
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgOutOfRange) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SafeEndAddr > 0) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SafeStartAddr > 0))
            {
                UINT64 u8Temp;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgOutOfRange = FALSE;
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed < 0)
                {
                    u8Temp = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SafeEndAddr;
                }
                else
                {
                    u8Temp = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SafeStartAddr;
                }
                u8Temp = _SWDMX_MpgTSAlignDown(u1SrcId, u8Temp);
                if(prCmd->i4PlaySpeed >= 0)
                {
                    u8Temp += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase;
                }
                LOG(3, "Change start position 0x%llx ==========\n",
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize);
                prCmd->fgSeek = FALSE; // original method
                prCmd->u8SeekPos = u8Temp;
                _SWDMX_MpgHandleChange(u1SrcId, prCmd);
                return MPG_SEND_FULL;
            }
        }
    }
#endif

    i4Ret = _SWDMX_MpgHandleFeeder(u1SrcId, prRangeList, prCmd->i4PlaySpeed);

    if(i4Ret != MPG_SEND_OK)
    {
        #if 1//def CC_DLNA_SUPPORT                       // for DLNA handle EOF
        if(i4Ret==MPG_SEND_LAST)
        {
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize<=u4SendSize)     // for DLAN handle  EOF
            {
                fgLast=TRUE;                                               // the last group of data will be send to dmx
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.fgLastData=TRUE;
                u4SendSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize;
            }
        }
        else
        #endif
        {
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
            {
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize == 0)
                {
                    return i4Ret;
                }
            }
            else if (i4Ret == MPG_SEND_WAIT)
            {
                if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidPidChg ||
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudPidChg ||
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidCodecChg ||
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudCodecChg)
                {
                    i4Ret = _SWDMX_MpgHandleFifoEmpty(u1SrcId);
                    if (i4Ret == MPG_SEND_WAIT)
                    {
                        return i4Ret;
                    }                    
                }                            
                if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidPidChg ||
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudPidChg )
                    
                {
                   i4Ret = _SWDMX_MpgHandlePidChg(u1SrcId);

                }
                if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidCodecChg ||
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudCodecChg)
                {
                    i4Ret = _SWDMX_MpgHandleCodecChg(u1SrcId);
                }

                if (prSwdmxInst->u4LogFilter & check_fifo_data) 
                {
                    static UINT32 _ui4LogChangeCnt = 0;
                    if (_ui4LogChangeCnt >=3)
                    {
                        LOG(2,",pls waiting change done! \n");
                        _ui4LogChangeCnt = 0;
                    }
                    _ui4LogChangeCnt++;
                }            
                x_thread_delay(10);            
                
                return i4Ret;
                
            }
            else 
            {
                return i4Ret;
            }
        }
    }

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize == 0)
    {
#ifdef TIME_SHIFT_SUPPORT
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
        {
            LOG(5, "_SWDMX_MpgSendData u4UsingBufSize 0\n");
            return MPG_SEND_FULL;
        }
#endif
        LOG(6, "_SWDMX_MpgSendData u4UsingBufSize 0\n");
        // may be u4UsingBufSize == 0 if add hls seamless playback function
        //ASSERT(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize > 0);
        
        return MPG_SEND_FAIL;
    }



    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
       ||
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192)
       ||
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
       ||
       (IS_PUSH_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type))
       ||
       // Network application
       // when eof with request count > 0, but not receive feeder's EOF yet,
       // we don't know it is eof actually. (eof will receive at next ack)
       // And ack size are correct in most case (retry in mtmplayer).
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type != MM_SRC_TYPE_HIGH_SPEED_STORAGE)
       ||
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_206))
    {
        if(u4SendSize > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize)
        {
            u4SendSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize;
        }
    }

    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize + u4SendSize) >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize)
    {
        fgLast = TRUE;
    }

    // Move from above (before _SWDMX_MpgHandleFeeder)
    if((i4Ret = _SWDMX_MpgHandleFifoFull(u1SrcId, i4PlaySpeed, fgLast)) != MPG_SEND_OK)
    {
        prSwdmxInst->fgFifoFull = TRUE;
        return i4Ret;
    }


    x_memset(&rDmxMMData, 0, sizeof(rDmxMMData));
    rDmxMMData.u4FrameSize = u4SendSize;
    rDmxMMData.u4BufStart = prSwdmxInst->rFeederInfo.u4StartAddr;
    rDmxMMData.u4BufEnd = prSwdmxInst->rFeederInfo.u4EndAddr;
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingStartAddr >= rDmxMMData.u4BufEnd)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingStartAddr -= (prSwdmxInst->rFeederInfo.u4EndAddr - prSwdmxInst->rFeederInfo.u4StartAddr);
    }
    rDmxMMData.u4StartAddr = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingStartAddr);
    if(rDmxMMData.u4StartAddr >= rDmxMMData.u4BufEnd)
    {
        rDmxMMData.u4StartAddr -= (rDmxMMData.u4BufEnd - rDmxMMData.u4BufStart);
    }

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFirst)
    {
        rDmxMMData.fgFrameHead = TRUE;
        LOG(2, "_SWDMX_MpgSendData fgFrameHead 0x%x-0x%x, 0x%x, S=%d.\n",
            rDmxMMData.u4BufStart, rDmxMMData.u4BufEnd,
            rDmxMMData.u4StartAddr, rDmxMMData.u4FrameSize);
    }
    if(fgLast)
    {
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed >= 1000) &&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192) && 
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgDynamicDuration))
        {
            LOG(3, "SWDMX chasing playback, should not send eos\n");
            _SWDMX_MpgPauseRecordingPlayback(u1SrcId);
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgPauseMoving = TRUE;
        }
        else
        {
            rDmxMMData.fgEOS = TRUE;
        }
    }

    //CR DTV00213030  for linux turkey because timing issue,
    //after seek ,at the time we are sending data to dmx but stream ID have not been enable yet
    //if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)&&(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio))
    {
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst->u.pt_pb_idx_tbl_entry)
          )
        {
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingPTS)
            {
                rDmxMMData.u4Pts = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingPTS;
                rDmxMMData.u4Dts = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingPTS;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingPTS = 0;
            }
        }
        else
        {
            UINT64 u8Remainder;

            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingPTS)
            {
                rDmxMMData.u4Pts = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingPTS;
                rDmxMMData.u4Dts = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingPTS;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingPTS = 0;
            }
            // actually, below condition will not entry anymore.
            // because we have calculated it in _SWDMX_MpgHandleAudioIndex
            else
            if((rDmxMMData.fgFrameHead) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize > 0) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize != INVALID_FILESIZE) &&
               (((UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize != (UINT32)0xFFFFFFFF) &&
                ((UINT32)(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize >> 32) != (UINT32)0xFFFFFFFF)) &&
               (prSwdmxInst->eSeekType == eSWDMX_TYPE_BYTE_SEEK))
            {
                rDmxMMData.u4Pts = _SWDMX_Div6464((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset)*((UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime),
                    (UINT64)(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset), &u8Remainder);
                rDmxMMData.u4Pts += MPG_STC_BASE;
                rDmxMMData.u4Dts = rDmxMMData.u4Pts;
            }
        }
    }

    if(prSwdmxInst->u4LogFilter & check_move_data)
    {
        LOG(1,"fgFrameHead 0x%x-0x%x, 0x%x, S=%d.\n",
            rDmxMMData.u4BufStart, rDmxMMData.u4BufEnd,
            rDmxMMData.u4StartAddr, rDmxMMData.u4FrameSize);
    }
    
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgPMTChanged &&
        !prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidOn &&
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed == 1000)
    {
        LOG(6,"Detect video pid changed and not enable video,temp not move data\n");
        
        return MPG_SEND_SKIP;
    }
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgPMTChanged &&
        !prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudOn &&
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed == 1000)
    {
        LOG(6,"Detect audio pid changed and not enable audio,temp not move data\n");    
        return MPG_SEND_SKIP;
    }    

        
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgPMTChanged)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgPMTChanged = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidOn = FALSE;
		prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudOn = FALSE;            
    }
  
#if defined(CC_TRUSTZONE_SUPPORT)
    if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.eEncryptMode == SWDMX_ENCRYPT_MODE_LOCAL_KEY) || 
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.eEncryptMode == SWDMX_ENCRYPT_MODE_DTCP_IP_KEY))
    {
        SWDMX_TO_TZ_DESCRYPT_DATA_T rTzDescryptData;
        
        x_memset(&rTzDescryptData, 0, sizeof(SWDMX_TO_TZ_DESCRYPT_DATA_T));


        
        rTzDescryptData.fgFrameHead = rDmxMMData.fgFrameHead;
        rTzDescryptData.u4BufStart  = rDmxMMData.u4BufStart;
        rTzDescryptData.u4BufEnd    = rDmxMMData.u4BufEnd;
        rTzDescryptData.u4StartAddr = rDmxMMData.u4StartAddr;
        rTzDescryptData.u4FrameSize = rDmxMMData.u4FrameSize;
        rTzDescryptData.eEncryptMode = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.eEncryptMode;
        
        //decrypt content
        TZ_SWDMX_DecryptContent((void*)&rTzDescryptData);

        rDmxMMData.u4BufStart  = rTzDescryptData.u4BufStart;
        rDmxMMData.u4BufEnd    = rTzDescryptData.u4BufEnd;
        rDmxMMData.u4StartAddr = rTzDescryptData.u4StartAddr;
        rDmxMMData.u4FrameSize = rTzDescryptData.u4FrameSize;
        
        if(prSwdmxInst->u4LogFilter & check_move_data)
        {
            LOG(2,"fgFrameHead 0x%x-0x%x, 0x%x, S=%d.\n",
                rDmxMMData.u4BufStart, rDmxMMData.u4BufEnd,
                rDmxMMData.u4StartAddr, rDmxMMData.u4FrameSize);
        }        
    }
#endif    
    
    i4Ret = _SWDMX_MpgHandleMoveData(u1SrcId, &rDmxMMData, i4PlaySpeed);
	if(prSwdmxInst->u4LogFilter & check_move_data)
	{
		LOG(1,"fgFrameHead 0x%x-0x%x, 0x%x, S=%d. ret %d\n",
			rDmxMMData.u4BufStart, rDmxMMData.u4BufEnd,
			rDmxMMData.u4StartAddr, rDmxMMData.u4FrameSize, i4Ret);
	}

	if(i4Ret != MPG_SEND_OK)
    {    	
        return i4Ret;
    }
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFirst)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFirst = FALSE;
    }

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = 0;

    // add for DTV00098584
    if(i4PlaySpeed < 0 
        && (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize <= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset)
        && (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES))
    {
        // AFIFO has remainder, decoder cannot decode, so flush completely.
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime > 10*90000)
        {
            _SWDMX_MpgFlushAFifo(u1SrcId);
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio != 0xFF)
            {
                UNUSED(DMX_MM_FlushBuffer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio));
            }
#ifdef CC_AUD_SUPPORT_DUAL_DSP
            AUD_DSPCmdStop(AUD_DSP0, prSwdmxInst->u1AdecId);
            AUD_DSPCmdPlay(AUD_DSP0, prSwdmxInst->u1AdecId);
#else
            AUD_DSPCmdStop(prSwdmxInst->u1AdecId);
            AUD_DSPCmdPlay(prSwdmxInst->u1AdecId);
#endif            
        }
        _SWDMX_MpgHandleEOS(u1SrcId, i4PlaySpeed);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = TRUE;

        if(prRangeList)
        {
             prRangeList->eRangeStats = eSWDMX_RANGE_STATE_PENDING;
        }
        
        if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) &&
            (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo))
        {
            if(prRangeList)
            {
                prRangeList->eRangeStats = eSWDMX_RANGE_STATE_FINISHED;
            }
        }
        return MPG_SEND_OK;
    }

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize >= u4SendSize)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize += u4SendSize;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingStartAddr += u4SendSize;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize -= u4SendSize;
        //_u4AvailSize += u4SendSize;

        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize == 0) &&
           IS_PUSH_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type))
        {
            if(FeederUpdateReadPointer(prSwdmxInst->eFeederSrc, 0) != FEEDER_E_OK)
            {
                LOG(1, "_SWDMX_MpgSendData FeederUpdateReadPointer fail\n");
            }
        }
    }
    else
    {
        if(!fgLast)
        {
            LOG(1, "_SWDMX_MpgSendData u4UsingBufSize not correct\n");
            //ASSERT(0);
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = TRUE;
            if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetInfo)
            {
                 _SWDMX_MpgHandleEOS(u1SrcId, i4PlaySpeed);
            }
            if(prRangeList)
            {
                 prRangeList->eRangeStats = eSWDMX_RANGE_STATE_PENDING;
            }
            if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) &&
               (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) &&
                   // DTV00211818
                   // when audio es playback.
                   // pause -> seek -> seek -> play
                   // we will send finish event. this is not correct.
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_RAW_AUDIO_ES)&&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_ENCRYPT_192)&&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS)&&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_204)&&
			   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_206)&&      
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_192))
               {
                    if(prRangeList)
                    {
                        prRangeList->eRangeStats = eSWDMX_RANGE_STATE_FINISHED;
                    }
               }
                return MPG_SEND_FAIL;
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingStartAddr += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize = 0;
        if(IS_PUSH_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type))
        {
            if(FeederUpdateReadPointer(prSwdmxInst->eFeederSrc, 0) != FEEDER_E_OK)
            {
                LOG(1, "_SWDMX_MpgSendData FeederUpdateReadPointer fail\n");
            }
        }
    }
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos)
    {
        LOG(1, "_SWDMX_MpgSendData u8SendedSize >  u8ReadedPos\n");
        ASSERT(0);
    }

    u4Ptr = rDmxMMData.u4StartAddr + rDmxMMData.u4FrameSize;
    if(u4Ptr >= prSwdmxInst->rFeederInfo.u4EndAddr)
    {
        u4Ptr -= (prSwdmxInst->rFeederInfo.u4EndAddr - prSwdmxInst->rFeederInfo.u4StartAddr);
    }
    if(IS_PUSH_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type))
    {
    }
    else if(FeederUpdateReadPointer(prSwdmxInst->eFeederSrc, u4Ptr) != FEEDER_E_OK)
    {
        LOG(1, "_SWDMX_MpgSendData FeederUpdateReadPointer fail\n");
        //ASSERT(0);
    }

#ifdef TIME_SHIFT_SUPPORT
    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT) &&
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpping) &&
       (DMX_GetScrambleState(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo) == DMX_SCRAMBLE_STATE_SCRAMBLED))
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpNext = TRUE;
    }
#endif

    // we use cpu to parse program stream.
    // when clip contains many garbage, we should delay a while to release CPU
    // to other threads.
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_PS)
    {
        BOOL fgRetFULL = FALSE;
        UINT64 u8Escape;
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CheckedPos > 
           prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize)
        {
            u8Escape = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CheckedPos - 
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        }
        else
        {
            u8Escape = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize - 
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CheckedPos;
        }
        if(u8Escape > CHECK_NO_DATA_SIZE)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CheckedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
            if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgPesFound)
            {
                fgRetFULL = TRUE;
            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgPesFound = FALSE;
            if(fgRetFULL)
            {
                x_thread_delay(CHECK_NO_DATA_DELAY);
            }
        }
    }

    return MPG_SEND_OK;
}


BOOL _SWDMX_MpgSendDataBatch(UINT8 u1SrcId)
{
    INT32 i4Ret;
    SWDMX_CUR_CMD_T rCmd;
    // detect first
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    x_memset(&rCmd, 0, sizeof(SWDMX_CUR_CMD_T));
    while(1)
    {
        i4Ret = _SWDMX_MpgSendData(u1SrcId, NULL, &rCmd);
        if(i4Ret == MPG_SEND_OK)
        {
            continue;
        }
        else if(i4Ret == MPG_SEND_FULL)
        {
            x_thread_delay(1);
        }
        else if(i4Ret == MPG_SEND_EOS)
        {
            LOG(7, "_SWDMX_MpgSendDataBatch _SWDMX_MpgSendData Finish.\n");
            break;
        }
        else if(i4Ret == MPG_SEND_FAIL)
        {
            LOG(5, "_SWDMX_MpgSendDataBatch _SWDMX_MpgSendData Fail.\n");
            return FALSE;
        }
        else
        {
            LOG(5, "_SWDMX_MpgSendDataBatch _SWDMX_MpgSendData Unknow return.\n");
            return FALSE;
        }

        //if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToDecoder)
        //{
        //    _SWDMX_MpgResetData(u1SrcId);
        //}
    }
    return TRUE;
}

BOOL _SWDMX_MpgSendDataBatchForTotalTime(UINT8 u1SrcId)
{
    INT32 i4Ret;
    SWDMX_CUR_CMD_T rCmd;
    // detect first
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
    x_memset(&rCmd, 0, sizeof(SWDMX_CUR_CMD_T));
    while(1)
    {
        i4Ret = _SWDMX_MpgSendData(u1SrcId, NULL, &rCmd);
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS)
        {
            // there is some fake PTS in this file end.
            // please check program 4 and 8. (1 base).
            // [DTV00047346] [TS file playback] Can NOT display the TS, log will print fail info.
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTSCnt >= MPG_PTS_CHECK_NUM)
            {
                break;
            }
        }
        if(i4Ret == MPG_SEND_OK)
        {
            continue;
        }
        else if(i4Ret == MPG_SEND_FULL)
        {
            x_thread_delay(1);
        }
        else if(i4Ret == MPG_SEND_EOS)
        {
            LOG(7, "_SWDMX_MpgSendDataBatchForTotalTime _SWDMX_MpgSendData Finish.\n");
            break;
        }
        else if(i4Ret == MPG_SEND_FAIL)
        {
            LOG(5, "_SWDMX_MpgSendDataBatchForTotalTime _SWDMX_MpgSendData Fail.\n");
            return FALSE;
        }
        else
        {
            LOG(5, "_SWDMX_MpgSendDataBatchForTotalTime _SWDMX_MpgSendData Unknow return.\n");
            return FALSE;
        }

        //if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToDecoder)
        //{
        //    _SWDMX_MpgResetData(u1SrcId);
        //}
    }
    return TRUE;
}

#ifndef CC_TS_DISABLE
BOOL _SWDMX_MpgTsFillBufferStart(UINT8 u1SrcId)
{
    BOOL fgRet;
  SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
  SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    LOG(5, "_SWDMX_MpgTsFillBufferStart\n");

    _SWDMX_MpgResetData(u1SrcId);
    _SWDMX_MpgResetVariable(u1SrcId);
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPSISize = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendSeqHdr = TRUE; // not parse sequence header
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToDecoder = TRUE; // skip it
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = TRUE; // skip it
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = TRUE; // skip it
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = TRUE; // skip it
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio2Eos = TRUE; // skip it  // 0831    
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio3Eos = TRUE; // skip it  // 0831
    fgRet = _SWDMX_MpgSendDataBatch(u1SrcId);

    return fgRet;
}
#endif

#ifndef CC_TS_DISABLE
BOOL _SWDMX_MpgTsFillBufferEnd(UINT8 u1SrcId)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);

    LOG(5, "_SWDMX_MpgTsFillBufferEnd\n");

    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = TRUE;

    return TRUE;
}
#endif

/**
*/
BOOL _SWDMX_MpgBaseInit(UINT8 u1SrcId, ENUM_SWDMX_FMT_T eType)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);

    LOG(5, "_SWDMX_MpgBaseInit(%d)\n", u1SrcId);

    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

#ifdef SWDMX_MPG_PS_GET_INFO
    _SWDMX_MpgCreateFindSema(u1SrcId);
#endif

    UNUSED(FeederInstallCallback(prSwdmxInst->eFeederSrc, FEEDER_NOTIFY_DATA_REQ_DONE,
        _SWDMX_FeederCallBack, (UINT32)&prSwdmxInst->rFeederInfo));

    //DMX_Init();
    //DMX_DDI_Init();
    _SWDMX_MpgResetVariable(u1SrcId);

    #ifdef SWDMX_MPG_USE_INDEX
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgUseIdx = FALSE;
    #endif

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSeek = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2PidIdxStart = 4;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2VideoPidIdx = 0xFF;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2AudioPidIdx = 0xFF;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2Audio2PidIdx = 0xFF;
    //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2PcrPidIdx = 0xFF;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1VideoKeyIndex = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1AudioKeyIndex = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1Audio2KeyIndex = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u4VideoDescMode = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u4AudioDescMode = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u4Audio2DescMode = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSeekvid = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSeekaud = 0;

#if 1//def CC_DLNA_SUPPORT
    // always check, some format feeder buffer is different
    //if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufSize == 0)
    {
        UINT32 u4FeederBufNum;
        if (FeederGetBufferInfo(prSwdmxInst->eFeederSrc, &prSwdmxInst->rFeederInfo) !=
          FEEDER_E_OK)
        {
            LOG(1, "Feeder input buffer error.\n");
            return FALSE;
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufSize = (prSwdmxInst->rFeederInfo.u4Size);
        u4FeederBufNum = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufSize / (MPG_BATCH_SIZE_PVR*MPG_BATCH_READ_SIZE * _u4DoubleDataSize));
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufSize > 0) &&
           (u4FeederBufNum > MPG_BUF_NUM_RESERVED)) // - 3 * (192*188*10)
        {
            if((u4FeederBufNum - MPG_BUF_NUM_RESERVED) > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum = (u4FeederBufNum - MPG_BUF_NUM_RESERVED);
            }
            else
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum = (u4FeederBufNum);
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum >= 2)
                {
                    // this is for remove buffer from u4BufReadIdx to u4UsingStartAddr
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum--;
                }
            }
        }
        else if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufSize > 0) &&
                 (u4FeederBufNum > 0))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum = (u4FeederBufNum);
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum >= 2)
            {
                // this is for remove buffer from u4BufReadIdx to u4UsingStartAddr
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum--;
            }
        }
        else
        {
            ASSERT(0);
            LOG(1, "feeder buf size 0\n");
        }
        if(eType == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
        {
            // reserve two buffers for dmx pvr internal buffer.
            // one for swdmx_mpg_pvr internal buffer, SWDMX_PVR_MIN_BUFDATA.
            // one for current move data, MPG_BATCH_SIZE_TS_192.
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum >= 3)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum -= 2;
            }
        }
		
    	if (eType == SWDMX_FMT_MPEG2_TS_206)
		{
			prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum = 2;
		}			
		
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum > MPG_BUF_NUM_MAX)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum = MPG_BUF_NUM_MAX;
        }
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum != MPG_BUF_NUM)
        {
            LOG(5, "feeder buf size 0x%x, buf num %d\n",
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufSize, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum);
        }
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufSize > 0) &&
           (u4FeederBufNum > 0))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum = (u4FeederBufNum);
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum >= 2)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum--;
            }
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum > MPG_REQ_NUM_MAX)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum = MPG_REQ_NUM_MAX;
            }
        }
        else
        {
            ASSERT(0);
            LOG(1, "feeder buf size 0\n");
        }
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum;
        }
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum != MPG_REQ_NUM)
        {
            LOG(5, "feeder buf size 0x%x, req num %d\n",
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufSize, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum);
        }
        #ifdef SWDMX_MPG_DEBUG_INPUT_DATA
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum < 2)
        {
            LOG(0, "req num %d\n",
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum);
            ASSERT(0);
        }
        #endif
    }
#endif

#ifdef SWDMX_MPG_DEBUG_FIFO
#ifdef SWDMX_MPG_AFIFO_SIZE
    if((!_fgAFifo) && (_fgAManual))
    {
        _u4AFifoStart = (UINT32)VIRTUAL((UINT32)BSP_AllocAlignedDmaMemory(SWDMX_MPG_AFIFO_SIZE, 16));
        if(_u4AFifoStart)
        {
            _fgAFifo = TRUE;
        }
        _u4AFifoCur = _u4AFifoStart;
        _u4AFifoEnd = _u4AFifoStart + SWDMX_MPG_AFIFO_SIZE;
    }
#endif
#ifdef SWDMX_MPG_DMXFIFO_SIZE
    if((!_fgDmxFifo) && (_fgDmxManual))
    {
        _u4DmxFifoStart = (UINT32)VIRTUAL((UINT32)BSP_AllocAlignedDmaMemory(SWDMX_MPG_DMXFIFO_SIZE, 16));
        if(_u4DmxFifoStart)
        {
            _fgDmxFifo = TRUE;
        }
        _u4DmxFifoCur = _u4DmxFifoStart;
        _u4DmxFifoEnd = _u4DmxFifoStart + SWDMX_MPG_DMXFIFO_SIZE;
    }
#endif
#endif

    return TRUE;
}


/**
*/
BOOL _SWDMX_MpgEsInit(UINT8 u1SrcId, ENUM_SWDMX_FMT_T eType)
{
    BOOL fgRet;
#ifndef SWDMX_MPG_DMX_20
    UINT8 u1SrcIdSecond;
    SWDMX_INFO_T* prSwdmxInstSecond;
#endif
#ifndef SWDMX_MPG_DMX_20
    DMX_DECODER_CALLBACKS_T rDecoderCallbacks;
#endif

    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    LOG(5, "_SWDMX_MpgEsInit(%d)\n", u1SrcId);

    UNUSED(_SWDMX_MpgBaseInit(u1SrcId, eType));

    // Initialize dmx
    #ifndef SWDMX_MPG_DMX_20
    u1SrcIdSecond = (u1SrcId+1)%SWDMX_SOURCE_MAX;
    prSwdmxInstSecond = _SWDMX_GetInst(u1SrcIdSecond);
    UNUSED(prSwdmxInstSecond);

    if (eType == SWDMX_FMT_RAW_AUDIO_ES)
    {
#ifdef CC_DMX_PURE_AUDIO
        {
            fgRet = DMX_SelectInputType(DMX_IN_PLAYBACK_PURE_AUDIO);
        }
#else
        {
            fgRet = DMX_SelectInputType(DMX_IN_PLAYBACK_MM);
        }
#endif
        if(!fgRet)
        {
            LOG(3, "DMX_SelectInputType DMX_IN_PLAYBACK_MM/PURE_AUDIO\n");
            return fgRet;
        }
        // for audio es file , feeder has changed the buffer to 192kB,so we will change the request size.
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeReadSize = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize*MPG_BATCH_READ_SIZE/2);

        
    }
    else
    {
        if(!prSwdmxInstSecond->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
        {
            fgRet = DMX_SelectInputType(DMX_IN_PLAYBACK_ES);
            if(!fgRet)
            {
                LOG(3, "DMX_SelectInputType DMX_IN_PLAYBACK_ES\n");
                return fgRet;
            }
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeReadSize = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize*MPG_BATCH_READ_SIZE);        
    }
    #endif
    UNUSED(fgRet);
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt = eType;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize = MPG_BATCH_SIZE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase = MPG_ALIGN_SIZE;

    DMX_SetToDecoder(TRUE);
#ifndef SWDMX_MPG_DMX_20
    // move to enable stream
    rDecoderCallbacks.pfnSendVideoPes = _SWDMX_MpgVideoCallback;
    rDecoderCallbacks.pfnUpdateVideoWp = VDEC_SetWptr;
    rDecoderCallbacks.pfnSendAudioPes = _SWDMX_MpgAudioCallback;
    DMX_SetDecoderCallbacks(&rDecoderCallbacks);
#endif

    _SWDMX_MpgResetData(u1SrcId);
    _SWDMX_MpgResetVariable(u1SrcId);

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousUIPos = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPSISize = FALSE;

    return TRUE;
}

/**
*/
#ifdef CC_IC_VERIFY
BOOL _SWDMX_MpgPsInit(UINT8 u1SrcId, ENUM_SWDMX_FMT_T eType)
{
    BOOL fgRet = TRUE;
#ifndef SWDMX_MPG_DMX_20
    DMX_DECODER_CALLBACKS_T rDecoderCallbacks;
#endif

    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    LOG(5, "_SWDMX_MpgPsInit\n");

    UNUSED(_SWDMX_MpgBaseInit(u1SrcId, eType));

    // Initialize dmx
    #ifndef SWDMX_MPG_DMX_20
    fgRet = DMX_SelectInputType(DMX_IN_PLAYBACK_PS);
    if(!fgRet)
    {
        LOG(3, "DMX_SelectInputType DMX_IN_PLAYBACK_PS\n");
        return fgRet;
    }
    #endif

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt = eType;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize = MPG_BATCH_SIZE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeReadSize = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize*MPG_BATCH_READ_SIZE);
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase = MPG_ALIGN_SIZE;

    if(eType == SWDMX_FMT_MPEG1_DAT)
    {
        fgRet = DMX_PS_SetDataFormat(prSwdmxInst->u1DmxId, DMX_DATA_FORMAT_DAT);
        if(!fgRet)
        {
            LOG(3, "DMX_PS_SetDataFormat DMX_DATA_FORMAT_RAW\n");
            return fgRet;
        }
    }
    else if(eType == SWDMX_FMT_MPEG2_PS)
    {
        fgRet = DMX_PS_SetDataFormat(prSwdmxInst->u1DmxId, DMX_DATA_FORMAT_RAW);
        if(!fgRet)
        {
            LOG(3, "DMX_PS_SetDataFormat DMX_DATA_FORMAT_DAT\n");
            return fgRet;
        }
    }
    else
    {
        LOG(3, "DMX_PS_SetDataFormat Unknown\n");
        return fgRet;
    }

    DMX_SetToDecoder(TRUE);
#ifndef SWDMX_MPG_DMX_20
    rDecoderCallbacks.pfnSendVideoPes = _SWDMX_MpgVideoCallback;
    rDecoderCallbacks.pfnUpdateVideoWp = VDEC_SetWptr;
    rDecoderCallbacks.pfnSendAudioPes = _SWDMX_MpgAudioCallback;
    DMX_SetDecoderCallbacks(&rDecoderCallbacks);
#endif

    _SWDMX_MpgResetData(u1SrcId);
    _SWDMX_MpgResetVariable(u1SrcId);

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPSISize = FALSE;

    #ifdef SWDMX_MPG_USE_INDEX
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgUseIdx = TRUE;
    #endif

    return TRUE;
}
#endif

/**
*/
#ifndef CC_TS_DISABLE
BOOL _SWDMX_MpgTsInit(UINT8 u1SrcId, ENUM_SWDMX_FMT_T eType)
{
    BOOL fgRet;
#ifndef SWDMX_MPG_DMX_20
    DMX_DECODER_CALLBACKS_T rDecoderCallbacks;
#endif

    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    LOG(5, "_SWDMX_MpgTsInit\n");

    UNUSED(fgRet);
    UNUSED(_SWDMX_MpgBaseInit(u1SrcId, eType));

#ifdef TIME_SHIFT_SUPPORT
    if(eType == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        /*
        if(DMX_GetInputType() != DMX_IN_BROADCAST_TS)
        {
            LOG(3, "Time-shift DMX mode not using DMX_IN_BROADCAST_TS\n");
            return FALSE;
        }
        */

        if(!_SWDMX_PVR_Init(u1SrcId))
        {
            LOG(3, "_SWDMX_MpgTsInit _SWDMX_PVR_Init Fail\n");
            return FALSE;
        }
        if(!_SWDMX_PVR_OPEN(u1SrcId))
        {
            LOG(3, "_SWDMX_MpgTsInit _SWDMX_PVR_OPEN Fail\n");
            return FALSE;
        }

        // Make it single move in the begining
        if(!_SWDMX_PVR_SetDataMode(u1SrcId, 1))
        {
            LOG(3, "_SWDMX_MpgTsInit _SWDMX_PVR_SetDataMode fail\n");
        }

        UNUSED(DMX_SetTSMode(prSwdmxInst->u1DmxId, DMX_TSFMT_TIMESHIFT));

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize = MPG_BATCH_SIZE_PVR;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeReadSize = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize*MPG_BATCH_READ_SIZE * _u4DoubleDataSize);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase = MPG_ALIGN_SIZE_PVR;

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgValidRange = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgOutOfRange = FALSE;
        //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgOutOfSafeRange = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorLBA = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeStart = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeEnd = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorValidStart = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorValidEnd = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage = MPG_TSS_NORMAL;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TickBase = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalTickNum = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ReadTickNum = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeStartTick = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeEndTick = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ValidStartTick = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ValidEndTick = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8MonitorAddr = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SafeStartAddr = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SafeEndAddr = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ValidStartAddr = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ValidEndAddr = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoSize = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex = NULL;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex = NULL;
        x_memset(&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo, 0, sizeof(MM_REC_BUF_RANGE_INFO_T));
        x_memset(&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl, 0, sizeof(PVR_TICK_CTRL_BLK_T));
    }
    else
#endif
    {
#if 0//def TIME_SHIFT_SUPPORT
        if(eType == SWDMX_FMT_MPEG2_TS_ENCRYPT_192)
        {
            // PVR background record, use DMX_IN_BROADCAST_TS, not DMX_IN_PLAYBACK_TS
            if(DMX_GetInputType() != DMX_IN_BROADCAST_TS)
            {
                LOG(3, "Time-shift DMX mode not using DMX_IN_BROADCAST_TS\n");
                return FALSE;
            }
        }
        else
#endif
        {
            // Initialize dmx
            #ifndef SWDMX_MPG_DMX_20
            fgRet = DMX_SelectInputType(DMX_IN_PLAYBACK_TS);
            if(!fgRet)
            {
                LOG(3, "DMX_SelectInputType DMX_IN_PLAYBACK_TS\n");
                return fgRet;
            }
            #endif
        }

        UNUSED(DMX_SetTSMode(prSwdmxInst->u1DmxId, DMX_TSFMT_188));       // Default

        if((eType == SWDMX_FMT_MPEG2_TS_ZERO_192) ||
            (eType == SWDMX_FMT_MPEG2_TS_192) ||
            (eType == SWDMX_FMT_MPEG2_TS_206))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize = MPG_BATCH_SIZE_TS_192;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase = MPG_ALIGN_SIZE_TS_192;
//            UNUSED(DMX_DDI_SetPacketSize(192));
//            UNUSED(DMX_SetPacketSize(192));

            UNUSED(DMX_SetTSMode(prSwdmxInst->u1DmxId, DMX_TSFMT_192));
        }
        else if (eType == SWDMX_FMT_MPEG2_TS_130)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize = MPG_BATCH_SIZE_TS_130;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase = MPG_ALIGN_SIZE_TS_130;
            UNUSED(DMX_SetTSMode(prSwdmxInst->u1DmxId, DMX_TSFMT_130));
        }
        else if (eType == SWDMX_FMT_MPEG2_TS_134)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize = MPG_BATCH_SIZE_TS_134;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase = MPG_ALIGN_SIZE_TS_134;
            UNUSED(DMX_SetTSMode(prSwdmxInst->u1DmxId, DMX_TSFMT_134));
        }
        else if (eType == SWDMX_FMT_MPEG2_TS_204)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize = MPG_BATCH_SIZE_TS_204;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase = MPG_ALIGN_SIZE_TS_204;
            UNUSED(DMX_SetTSMode(prSwdmxInst->u1DmxId, DMX_TSFMT_204));
        }
        
#ifdef TIME_SHIFT_SUPPORT
        else if(eType == SWDMX_FMT_MPEG2_TS_ENCRYPT_192)
        {
/*
            if(!_SWDMX_PVR_Init(u1SrcId))
            {
                LOG(3, "%s,%d: _SWDMX_PVR_Init Fail\n", __FUNCTION__, __LINE__);
                return FALSE;
            }
            if(!_SWDMX_PVR_OPEN(u1SrcId))
            {
                LOG(3, "%s,%d: _SWDMX_PVR_OPEN Fail\n", __FUNCTION__, __LINE__);
                return FALSE;
            }
*/
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize = MPG_BATCH_SIZE_TS_192;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase = MPG_ALIGN_SIZE_TS_192;

            UNUSED(DMX_SetTSMode(prSwdmxInst->u1DmxId, DMX_TSFMT_192_ENCRYPT));       // Default
        }
#endif
        else
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize = MPG_BATCH_SIZE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase = MPG_ALIGN_SIZE;
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeReadSize = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize*MPG_BATCH_READ_SIZE);

		if (eType == SWDMX_FMT_MPEG2_TS_206)
		{
    		prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeReadSize = prSwdmxInst->u4PCPLen + 14;
			
		}
		
    }
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt = eType;
	if (prSwdmxInst->ui1ModifyReqSize == REQ_SIZE_MULTIPLE_DEFAULT)
	{
		prSwdmxInst->u4Multiple = 5;
	}
	else
	{
		LOG(0,"Use cli control req size multiple\n");
	}

    DMX_SetToDecoder(TRUE);
#ifndef SWDMX_MPG_DMX_20
    rDecoderCallbacks.pfnSendVideoPes = _SWDMX_MpgVideoCallback;
    rDecoderCallbacks.pfnUpdateVideoWp = VDEC_SetWptr;
    rDecoderCallbacks.pfnSendAudioPes = _SWDMX_MpgAudioCallback;
    DMX_SetDecoderCallbacks(&rDecoderCallbacks);
#endif

    _SWDMX_MpgResetData(u1SrcId);
    _SWDMX_MpgResetVariable(u1SrcId);

    SWDMX_DmxInit(u1SrcId);

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq = NULL;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = 0;
	prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8RewindMaxSendedSize = 0;
	prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8RewindSendedSize = 0;
	prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4RewindJumpCnt = 0;
	prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8RewindJumpSize = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPSISize = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousUIPos = 0;
    
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgStartTimeSeek = TRUE; //time-based start play 
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgBeginToPlay = FALSE; 
	prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgPendingATrackIdx = FALSE;
    return TRUE;
}
#endif


/**
*/
BOOL _SWDMX_MpgOpen(UINT8 u1SrcId, ENUM_SWDMX_FMT_T eType,
    UINT32 u4TrackId,
    UINT64 u8FileSize,
    SWDMX_STREAM_INFO_T* prStreamInfo)
{
    BOOL fgRet;
#ifndef SWDMX_MPG_DMX_20
    UINT8 u1SrcIdSecond;
    SWDMX_INFO_T* prSwdmxInstSecond;
#endif
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if(prStreamInfo == NULL)
    {
        LOG(1, "_SWDMX_MpgOpen prStreamInfo NULL\n");
        return FALSE;
    }

#ifndef SWDMX_MPG_DMX_20
    u1SrcIdSecond = (u1SrcId+1)%SWDMX_SOURCE_MAX;
    prSwdmxInstSecond = _SWDMX_GetInst(u1SrcIdSecond);
#endif

    LOG(5, "_SWDMX_MpgOpen(%d) eType %d\n", u1SrcId, eType);
    LOG(5, "    u8FileSize in 32 bits = 0x%llx\n", u8FileSize);

    _SWDMX_MpgResetData(u1SrcId);
    _SWDMX_MpgResetVariable(u1SrcId);

    // assume our vdec id is same with swdmx id
    // (same with the one in playback)
    prSwdmxInst->u1VdecId = u1SrcId;

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize = 0;
    //_u4AvailSize = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPSISize = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize = u8FileSize;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset = 0;

    if(u8FileSize == 0)
    {
        LOG(1, "_SWDMX_MpgOpen u8FileSize Fail\n");
        return FALSE;
    }

    fgRet = FALSE;
    if ((eType == SWDMX_FMT_MPEG1_DAT) ||
        (eType == SWDMX_FMT_MPEG2_PS) ||
        IS_TS_FILE(eType) ||
        (eType == SWDMX_FMT_MPEG2_TS_TIME_SHIFT) ||
        (eType == SWDMX_FMT_MPEG2_VIDEO_ES) ||
        (eType == SWDMX_FMT_H264_VIDEO_ES) ||
        (eType == SWDMX_FMT_AVS_VIDEO_ES) ||
        (eType == SWDMX_FMT_MPEG4_VIDEO_ES) ||
        (eType == SWDMX_FMT_VC1_ES) ||
        (eType == SWDMX_FMT_RAW_AUDIO_ES) ||
        (eType == SWDMX_FMT_H265_VIDEO_ES))
    {
        if((prStreamInfo->u2VideoNum > 0) && (u4TrackId < prStreamInfo->u2VideoNum))
        {
            if(u4TrackId >= SWDMX_MAX_VID_TRACK)
            {
                LOG(3, "_SWDMX_MpgOpen vid u4TrackId %d -> %d\n",
                    u4TrackId, (SWDMX_MAX_VID_TRACK-1));
                u4TrackId = (SWDMX_MAX_VID_TRACK-1);
            }

            fgRet = SWDMX_SetInfo(u1SrcId, (UINT8)eSWDMX_SET_VIDEOTYPE, (UINT32)prStreamInfo->aeVideo[u4TrackId], 0, 0);
            if(!fgRet)
            {
                LOG(3, "_SWDMX_MpgOpen _SWDMX_MpgSetInfo V Fail\n");
                return FALSE;
            }

            fgRet = SWDMX_SetStrmID(u1SrcId, (UINT32)prStreamInfo->au2VideoId[u4TrackId],
                0, eSWDMX_STRM_TYPE_VID);
            if(!fgRet)
            {
                LOG(3, "_SWDMX_MpgOpen _SWDMX_MpgSetStrmID V Fail\n");
                return FALSE;
            }

            // In playmgr, we assume swdmx source id equals to vdec id
            fgRet = SWDMX_SetInfo(u1SrcId,
                (UINT8)eSWDMX_SET_VDEC_ID,
                (UINT32)u1SrcId,
                0,
                0);
            if (!fgRet)
            {
                LOG(1, "_SWDMX_MpgOpen Fail to set vdec id\n");
                return FALSE;
            }

            fgRet = SWDMX_SetInfo(u1SrcId, (UINT8)eSWDMX_ENABLE_STREAM,
                (UINT32)eSWDMX_STRM_TYPE_VID, 0, 0);
            if(!fgRet)
            {
                LOG(3, "_SWDMX_MpgOpen eSWDMX_ENABLE_STREAM V Fail\n");
                return FALSE;
            }
        }
        if((prStreamInfo->u2AudioNum > 0) && (u4TrackId < prStreamInfo->u2AudioNum)
#ifndef SWDMX_MPG_DMX_20
           &&
           // check if another instance is audio
           // we should not use audio track
           // or free pid index will flush audio, then audio will stop itself.
           (!prSwdmxInstSecond->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
#endif
           )
        {
            if(u4TrackId >= SWDMX_MAX_AUD_TRACK)
            {
                LOG(3, "_SWDMX_MpgOpen aud u4TrackId %d -> %d\n",
                    u4TrackId, (SWDMX_MAX_AUD_TRACK-1));
                u4TrackId = (SWDMX_MAX_AUD_TRACK-1);
            }

            fgRet = SWDMX_SetInfo(u1SrcId, (UINT8)eSWDMX_SET_AUDIOTYPE, (UINT32)prStreamInfo->aeAudio[u4TrackId], 0, 0);
            if(!fgRet)
            {
                LOG(3, "_SWDMX_MpgOpen _SWDMX_MpgSetInfo A Fail\n");
                return FALSE;
            }

            fgRet = SWDMX_SetStrmID(u1SrcId, (UINT32)prStreamInfo->au2AudioId[u4TrackId],
                prStreamInfo->au2AudioSubId[u4TrackId], eSWDMX_STRM_TYPE_AUD);
            if(!fgRet)
            {
                LOG(3, "_SWDMX_MpgOpen _SWDMX_MpgSetStrmID A Fail\n");
                return FALSE;
            }

            fgRet = SWDMX_SetInfo(u1SrcId, (UINT8)eSWDMX_ENABLE_STREAM,
                (UINT32)eSWDMX_STRM_TYPE_AUD, 0, 0);
            if(!fgRet)
            {
                LOG(3, "_SWDMX_MpgOpen eSWDMX_ENABLE_STREAM A Fail\n");
                return FALSE;
            }
        }
        // 0831
         if((prStreamInfo->u2AudioNum > 1) && (u4TrackId < prStreamInfo->u2AudioNum)
#ifndef SWDMX_MPG_DMX_20
           &&
           // check if another instance is audio
           // we should not use audio track
           // or free pid index will flush audio, then audio will stop itself.
           (!prSwdmxInstSecond->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio2)
#endif
           )
        {
            if(u4TrackId >= SWDMX_MAX_AUD_TRACK)
            {
                LOG(3, "_SWDMX_MpgOpen aud u4TrackId %d -> %d\n",
                    u4TrackId, (SWDMX_MAX_AUD_TRACK-1));
                u4TrackId = (SWDMX_MAX_AUD_TRACK-1);
            }

            fgRet = SWDMX_SetInfo(u1SrcId, (UINT8)eSWDMX_SET_AUDIO2TYPE, (UINT32)prStreamInfo->aeAudio[u4TrackId], 0, 0);
            if(!fgRet)
            {
                LOG(3, "_SWDMX_MpgOpen _SWDMX_MpgSetInfo A Fail\n");
                return FALSE;
            }

            fgRet = SWDMX_SetStrmID(u1SrcId, (UINT32)prStreamInfo->au2AudioId[u4TrackId],
                prStreamInfo->au2AudioSubId[u4TrackId], eSWDMX_STRM_TYPE_AUD2);
            if(!fgRet)
            {
                LOG(3, "_SWDMX_MpgOpen _SWDMX_MpgSetStrmID A Fail\n");
                return FALSE;
            }

            fgRet = SWDMX_SetInfo(u1SrcId, (UINT8)eSWDMX_ENABLE_STREAM,
                (UINT32)eSWDMX_STRM_TYPE_AUD2, 0, 0);
            if(!fgRet)
            {
                LOG(3, "_SWDMX_MpgOpen eSWDMX_ENABLE_STREAM A Fail\n");
                return FALSE;
            }
        }
         // 0831
         if((prStreamInfo->u2AudioNum > 1) && (u4TrackId < prStreamInfo->u2AudioNum)
#ifndef SWDMX_MPG_DMX_20
           &&
           // check if another instance is audio
           // we should not use audio track
           // or free pid index will flush audio, then audio will stop itself.
           (!prSwdmxInstSecond->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio3)
#endif
           )
        {
            if(u4TrackId >= SWDMX_MAX_AUD_TRACK)
            {
                LOG(3, "_SWDMX_MpgOpen aud u4TrackId %d -> %d\n",
                    u4TrackId, (SWDMX_MAX_AUD_TRACK-1));
                u4TrackId = (SWDMX_MAX_AUD_TRACK-1);
            }

            fgRet = SWDMX_SetInfo(u1SrcId, (UINT8)eSWDMX_SET_AUDIO3TYPE, (UINT32)prStreamInfo->aeAudio[u4TrackId], 0, 0);
            if(!fgRet)
            {
                LOG(3, "_SWDMX_MpgOpen _SWDMX_MpgSetInfo A Fail\n");
                return FALSE;
            }

            fgRet = SWDMX_SetStrmID(u1SrcId, (UINT32)prStreamInfo->au2AudioId[u4TrackId],
                prStreamInfo->au2AudioSubId[u4TrackId], eSWDMX_STRM_TYPE_AUD3);
            if(!fgRet)
            {
                LOG(3, "_SWDMX_MpgOpen _SWDMX_MpgSetStrmID A Fail\n");
                return FALSE;
            }

            fgRet = SWDMX_SetInfo(u1SrcId, (UINT8)eSWDMX_ENABLE_STREAM,
                (UINT32)eSWDMX_STRM_TYPE_AUD2, 0, 0);
            if(!fgRet)
            {
                LOG(3, "_SWDMX_MpgOpen eSWDMX_ENABLE_STREAM A Fail\n");
                return FALSE;
            }
        }        
        if((prStreamInfo->u2PcrNum > 0) && (u4TrackId < prStreamInfo->u2PcrNum))
        {
            if(u4TrackId >= SWDMX_MAX_PCR_TRACK)
            {
                LOG(3, "_SWDMX_MpgOpen aud u4TrackId %d -> %d\n",
                    u4TrackId, (SWDMX_MAX_PCR_TRACK-1));
                u4TrackId = (SWDMX_MAX_PCR_TRACK-1);
            }

            fgRet = SWDMX_SetStrmID(u1SrcId, (UINT32)prStreamInfo->au2PcrId[u4TrackId],
                0, eSWDMX_STRM_TYPE_PCR);
            if(!fgRet)
            {
                LOG(3, "_SWDMX_MpgOpen _SWDMX_MpgSetStrmID PCR Fail\n");
                return FALSE;
            }

            fgRet = SWDMX_SetInfo(u1SrcId, (UINT8)eSWDMX_ENABLE_STREAM,
                (UINT32)eSWDMX_STRM_TYPE_PCR, 0, 0);
            if(!fgRet)
            {
                LOG(3, "_SWDMX_MpgOpen eSWDMX_ENABLE_STREAM PCR Fail\n");
                return FALSE;
            }
        }
        if((prStreamInfo->u2VideoNum == 0) && (prStreamInfo->u2AudioNum == 0))
        {
            LOG(3, "_SWDMX_MpgOpen No A/V\n");
            return FALSE;
        }
    }
    else
    {
        LOG(3, "_SWDMX_MpgOpen Unknown eType\n");
    }

    if(!fgRet)
    {
        LOG(3, "_SWDMX_MpgOpen FALSE\n");
        return FALSE;
    }

    _SWDMX_MpgResetData(u1SrcId);
    _SWDMX_MpgResetVariable(u1SrcId);

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPSISize = FALSE;

    UNUSED(prStreamInfo);
    return TRUE;
}


/**
*/
BOOL _SWDMX_MpgPlay(UINT8 u1SrcId)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

#ifdef TIME_SHIFT_SUPPORT
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNeedAdjust = FALSE;  //should clear the flag of needed adjust current time in no signal status
        return _SWDMX_PVR_Resume(u1SrcId);
    }
#endif
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgRequestPause)
    {
        LOG(3,"data request enable,ready to send data!\n");
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgRequestPause = FALSE;
    }
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
    {
        prSwdmxInst->u4PreAudUnderFlowCnt = AUD_GetUnderFlowCnt(prSwdmxInst->u1AdecId);
    }

    return TRUE;
}

/**
*/
BOOL _SWDMX_MpgPause(UINT8 u1SrcId)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
#ifdef TIME_SHIFT_SUPPORT
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        return _SWDMX_PVR_Pause(u1SrcId);
    }
#endif

    return TRUE;
}


/**
*/
BOOL _SWDMX_MpgAbort(UINT8 u1SrcId)
{
    UNUSED(u1SrcId);
    return TRUE;
}


#ifndef CC_PS_DISABLE
BOOL _SWDMX_MpgPsSetVideoId(UINT8 u1SrcId, UINT8 u1Pidx, UINT16 u2VideoId)
{
    DMX_PS_T rDmxPS;
    UINT32 u4Flags;
    BOOL fgRet;

    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    #ifndef SWDMX_MPG_DMX_20
    u1Pidx = (0 + (u1SrcId * 3));
    #endif

    fgRet = FALSE;

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo != 0xFF)
    {
        LOG(3, "_SWDMX_MpgPsSetVideoId u1PidxVideo != 0xFF\n");
        return FALSE;
    }
    if(!u2VideoId)
    {
        LOG(3, "_SWDMX_MpgPsSetVideoId u2VideoId == 0\n");
        return FALSE;
    }

    LOG(5, "_SWDMX_MpgPsSetVideoId u2VideoId = %d\n",
        u2VideoId);

    //if(u2VideoId)
    {
        u4Flags = (UINT32)(DMX_PID_FLAG_BUFFER | DMX_PID_FLAG_VALID
            | DMX_PID_FLAG_STREAM_ID | DMX_PID_FLAG_INSTANCE_TAG |
            DMX_PID_FLAG_DEVICE_ID);
        x_memset(&rDmxPS, 0, sizeof(rDmxPS));
        rDmxPS.u1StreamID = (UINT8)u2VideoId;
        {
            UINT32 u4Addr, u4Size;
            if(!_SWDMX_GetVideoFifo(u1SrcId, &u4Addr, &u4Size))
            {
                LOG(3, "_SWDMX_GetAudioFifo Fail\n");
                return FALSE;
            }

            rDmxPS.fgAllocateBuffer   = FALSE;
            rDmxPS.u4BufAddr          = u4Addr;
            rDmxPS.u4BufSize          = u4Size;
        }
        rDmxPS.ePidType = DMX_PID_TYPE_ES_VIDEO;
        rDmxPS.fgEnable = TRUE;
        rDmxPS.u1DeviceId = VLD0;
        rDmxPS.u1ChannelId = (prSwdmxInst->u1VdecId);
        rDmxPS.pvInstanceTag = (void*)prSwdmxInst;                //set instance id to dmx

        fgRet = DMX_PS_SetStream(u1Pidx, u4Flags, &rDmxPS);
        if(!fgRet)
        {
            LOG(3, "_SWDMX_MpgPsSetVideoId DMX_PS_SetStream Fail\n");
            return FALSE;
        }

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo = u1Pidx;
    }
    return TRUE;
}
#endif

#ifndef CC_PS_DISABLE
BOOL _SWDMX_MpgPsSetAudioId(UINT8 u1SrcId, UINT8 u1Pidx,
        UINT16 u2AudioId, UINT16 u2AudioSubId)
{
    DMX_PS_T rDmxPS;
    UINT32 u4Flags;
    #ifndef SWDMX_MPG_DMX_20
    u1Pidx = (1 + (u1SrcId * 3));
    #endif
    BOOL fgRet = FALSE;

    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio != 0xFF)
    {
        LOG(3, "_SWDMX_MpgPsSetAudioId u1PidxAudio != 0xFF\n");
        return FALSE;
    }
    if(!u2AudioId)
    {
        LOG(3, "_SWDMX_MpgPsSetAudioId u2AudioId == 0\n");
        return FALSE;
    }

    LOG(5, "_SWDMX_MpgPsSetAudioId u2AudioId = %d, u2AudioSubId = %d\n",
        u2AudioId, u2AudioSubId);

    //if(u2AudioId)
    {
        // 1. Set stream first
        u4Flags = (UINT32)(DMX_PID_FLAG_BUFFER
            | DMX_PID_FLAG_STREAM_ID | DMX_PID_FLAG_INSTANCE_TAG |
            DMX_PID_FLAG_DEVICE_ID);
        x_memset(&rDmxPS, 0, sizeof(rDmxPS));
        rDmxPS.u1StreamID = (UINT8)u2AudioId;
        {
            UINT32 u4Addr, u4Size;
            if(!_SWDMX_GetAudioFifo(u1SrcId, &u4Addr, &u4Size))
            {
                LOG(3, "_SWDMX_GetAudioFifo Fail\n");
                return FALSE;
            }

            rDmxPS.fgAllocateBuffer   = FALSE;
            rDmxPS.u4BufAddr          = u4Addr;
            rDmxPS.u4BufSize          = u4Size;
        }
        rDmxPS.ePidType = DMX_PID_TYPE_ES_AUDIO;
        rDmxPS.fgEnable = TRUE;

        if(u2AudioSubId)
        {
            rDmxPS.u1SubstreamID = (UINT8)u2AudioSubId;
            rDmxPS.fgEnableSsidFilter = TRUE;
            u4Flags |= DMX_PID_FLAG_SUBSTREAM_ID;
        }

        rDmxPS.pvInstanceTag = (void*)prSwdmxInst;                //set instance id to dmx
        rDmxPS.u1DeviceId = (prSwdmxInst->u1AdecId);
        rDmxPS.u1ChannelId = (prSwdmxInst->u1AdecId);

        fgRet = DMX_PS_SetStream(u1Pidx, u4Flags, &rDmxPS);
        if(!fgRet)
        {
            LOG(3, "_SWDMX_MpgPsSetAudioId DMX_PS_SetStream Fail\n");
            return FALSE;
        }

        // 2. Set stream format
        // use stream id.
        // because aud_mw.c might call DMX_PS_SetAudioType after
        // SetInfo(eSWDMX_SET_AUDIOTYPE)
        if(u2AudioId == 0xBD)
        {
            if(u2AudioSubId >= 0x80 && u2AudioSubId <= 0x88)
            {
                fgRet = DMX_PS_SetAudioType(u1Pidx, DMX_AUDIO_AC3);
            }
            else if((u2AudioSubId & 0xF8) == 0x88)
            {
                fgRet = DMX_PS_SetAudioType(u1Pidx, DMX_AUDIO_DTS);
            }
            else if(u2AudioSubId >= 0xA0 && u2AudioSubId <= 0xA8)
            {
                fgRet = DMX_PS_SetAudioType(u1Pidx, DMX_AUDIO_LPCM);
            }
            else
            {
                LOG(3, "u2AudioId 0xBD u2AudioSubId 0x%x Unknown -> set MPEG\n", u2AudioSubId);
                fgRet = DMX_PS_SetAudioType(u1Pidx, DMX_AUDIO_MPEG);
            }
        }
        else if(u2AudioId >= 0xC0 && u2AudioId <= 0xDF)
        {
            fgRet = DMX_PS_SetAudioType(u1Pidx, DMX_AUDIO_MPEG);
        }
        else
        {
            LOG(3, "u2AudioId 0x%x Unknown -> set MPEG\n", u2AudioId);
            fgRet = DMX_PS_SetAudioType(u1Pidx, DMX_AUDIO_MPEG);
        }
        /*
        if(prSwdmxInst->eAudioType == ENUM_SWDMX_ADEC_AC3)
        {
            fgRet = DMX_PS_SetAudioType(u1Pidx, DMX_AUDIO_AC3);
        }
        else if(prSwdmxInst->eAudioType == ENUM_SWDMX_ADEC_PCM)
        {
            fgRet = DMX_PS_SetAudioType(u1Pidx, DMX_AUDIO_LPCM);
        }
        else if(prSwdmxInst->eAudioType == ENUM_SWDMX_ADEC_MPEG)
        {
            fgRet = DMX_PS_SetAudioType(u1Pidx, DMX_AUDIO_MPEG);
        }
        else if(prSwdmxInst->eAudioType == ENUM_SWDMX_ADEC_MP3)
        {
            fgRet = DMX_PS_SetAudioType(u1Pidx, DMX_AUDIO_MPEG);
        }
        else
        {
            LOG(3, "eAudioType Unknown\n");
            fgRet = FALSE;
        }
        */
        if(!fgRet)
        {
            LOG(3, "_SWDMX_MpgPsSetAudioId DMX_PS_SetAudioType Fail\n");
            return FALSE;
        }

        // 3. Set stream enable
        u4Flags = (UINT32)(DMX_PID_FLAG_VALID);
        x_memset(&rDmxPS, 0, sizeof(rDmxPS));
        rDmxPS.u1StreamID = (UINT8)u2AudioId;
        {
            UINT32 u4Addr, u4Size;
            if(!_SWDMX_GetAudioFifo(u1SrcId, &u4Addr, &u4Size))
            {
                LOG(3, "_SWDMX_GetAudioFifo Fail\n");
                return FALSE;
            }

            rDmxPS.fgAllocateBuffer   = FALSE;
            rDmxPS.u4BufAddr          = u4Addr;
            rDmxPS.u4BufSize          = u4Size;
        }
        rDmxPS.ePidType = DMX_PID_TYPE_ES_AUDIO;
        rDmxPS.fgEnable = TRUE;

        if(u2AudioSubId)
        {
            rDmxPS.u1SubstreamID = (UINT8)u2AudioSubId;
            rDmxPS.fgEnableSsidFilter = TRUE;
            u4Flags |= DMX_PID_FLAG_SUBSTREAM_ID;
        }

        fgRet = DMX_PS_SetStream(u1Pidx, u4Flags, &rDmxPS);
        if(!fgRet)
        {
            LOG(3, "_SWDMX_MpgPsSetAudioId DMX_PS_SetStream Fail\n");
            return FALSE;
        }

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio = u1Pidx;
    }
    return TRUE;
}
#endif

#ifndef CC_PS_DISABLE
BOOL _SWDMX_MpgPsFreeVideoId(UINT8 u1SrcId)
{
    BOOL fgRet;
    DMX_PS_T rDmxPS;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    LOG(5, "_SWDMX_MpgPsFreeVideoId(%d)\n", u1SrcId);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo != 0xFF)
    {
        x_memset(&rDmxPS, 0, sizeof(rDmxPS));
        rDmxPS.fgEnable = FALSE;

        fgRet = DMX_PS_SetStream(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo, DMX_PID_FLAG_VALID, &rDmxPS);
        if(!fgRet)
        {
            LOG(3, "_SWDMX_MpgPsFreeVideoId DMX_PS_SetStream V Fail\n");
            return FALSE;
        }
        fgRet = DMX_PS_FreeStream(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo);
        if(!fgRet)
        {
            LOG(3, "_SWDMX_MpgPsFreeVideoId DMX_PS_FreeStream V Fail\n");
            return FALSE;
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo = 0xFF;
        return TRUE;
    }
    LOG(3, "_SWDMX_MpgPsFreeVideoId Fail\n");
    return FALSE;
}
#endif


#ifndef CC_PS_DISABLE
BOOL _SWDMX_MpgPsFreeAudioId(UINT8 u1SrcId)
{
    BOOL fgRet;
    DMX_PS_T rDmxPS;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    LOG(5, "_SWDMX_MpgPsFreeAudioId(%d)\n", u1SrcId);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio != 0xFF)
    {
        x_memset(&rDmxPS, 0, sizeof(rDmxPS));
        rDmxPS.fgEnable = FALSE;

        fgRet = DMX_PS_SetStream(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio, DMX_PID_FLAG_VALID, &rDmxPS);
        if(!fgRet)
        {
            LOG(3, "_SWDMX_MpgPsFreeAudioId DMX_PS_SetStream A Fail\n");
            //return FALSE;
        }
        fgRet = DMX_PS_FreeStream(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio);
        if(!fgRet)
        {
            LOG(3, "_SWDMX_MpgPsFreeAudioId DMX_PS_FreeStream A Fail\n");
            //return FALSE;
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio = 0xFF;
        return TRUE;
    }
    LOG(3, "_SWDMX_MpgPsFreeAudioId Fail\n");
    return FALSE;
}
#endif

#ifndef CC_TS_DISABLE
BOOL _SWDMX_MpgTsSetVideoId(UINT8 u1SrcId, UINT8 u1Pidx,
        UINT16 u2VideoId, UINT8 u1KeyIndex, UINT32 u4DescMode, BOOL fgSecondVideo)
{
    //BOOL fgRet;
    SWDMX_DMX_PES_T rPes;
    SWDMX_ERR_CODE_T eRet;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    LOG(5, "_SWDMX_MpgTsSetVideoId(%d) u2VideoId = %d\n", u1SrcId, u2VideoId);

    x_memset(&rPes, 0, sizeof(SWDMX_DMX_PES_T));
    if(fgSecondVideo)
    {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo2 != 0xFF)
        {
            LOG(3, "_SWDMX_MpgTsSetVideoId u1PidxVideo2 != 0xFF\n");
            return FALSE;
        }
        rPes.fgSecond = TRUE;
    }
    else
    {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo != 0xFF)
        {
            LOG(3, "_SWDMX_MpgTsSetVideoId u1PidxVideo != 0xFF\n");
            return FALSE;
        }
    }
    if(!u2VideoId)
    {
        LOG(3, "_SWDMX_MpgTsSetVideoId u2VideoId != 0\n");
        return FALSE;
    }

#ifndef CC_TS_H264_DISABLE
    if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_H264)
    {
    }
    else
#endif
#ifndef CC_TS_MVC_DISABLE
    if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_MVC)
    {
    }
    else
#endif
#ifndef CC_TS_MPEG2_DISABLE
    if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_MPEG1_MPEG2)
    {
    }
    else
#endif
#ifndef CC_TS_VC1_DISABLE
    if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_VC1)
    {
    }
    else
#endif
#ifndef CC_TS_AVS_DISABLE
    if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_AVS)
    {
    }
    else
#endif
  if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_H265)
  {
  }
  else
    {
        LOG(3, "TsSetVideoId Unknown eVideoType %d\n",
            prSwdmxInst->eVideoType);
    }

    #ifndef SWDMX_MPG_DMX_20
    u1Pidx = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2PidIdxStart + (u1SrcId * 3);
    #endif

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2VideoPidIdx != 0xFF)
    {
        u1Pidx = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2VideoPidIdx + (UINT16)fgSecondVideo;
    }

    //x_memset(&rPes, 0, sizeof(rPes));
    rPes.u2Pid = u2VideoId;
    rPes.u2DeviceId = (UINT16)(VLD0);
    if(fgSecondVideo)
    {
        rPes.u2ChannelId = prSwdmxInst->u1Vdec2Id;
        LOG(5,"set u2ChannelId %d\n",rPes.u2ChannelId);
    }
    else
    {
        rPes.u2ChannelId = prSwdmxInst->u1VdecId;
        LOG(5,"set u2ChannelId %d\n",rPes.u2ChannelId);
        
    }
    rPes.u4BufferSize = TS_PES_VIDEO_FIFO_SIZE;
#ifdef TIME_SHIFT_SUPPORT
    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT) ||
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192))
    {
        rPes.u1TsIndex = DMX_MUL_GetTSIdx(prSwdmxInst->u1DmxId);
        rPes.u1KeyIndex = u1KeyIndex;
        rPes.u4DescMode = u4DescMode;
    }
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        rPes.pfnScramble = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.pfnVScrambleNfy;
    }
#endif

    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS) ||
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_192))
    {
        LOG(5, "_SWDMX_MpgTsSetVideoId DMX_MUL_GetTSIdx u1KeyIndex:%d,u4DescMode:%d\n",u1KeyIndex,u4DescMode);
        rPes.u1TsIndex = DMX_MUL_GetTSIdx(prSwdmxInst->u1DmxId);
        if(u1KeyIndex!=0 &&u4DescMode !=0)
        {
            rPes.u1KeyIndex = u1KeyIndex;
            rPes.u4DescMode = u4DescMode;
        }
    }

    eRet = SWDMX_DmxPesAllocateBuffer(u1SrcId, &rPes, &u1Pidx, DMX_PID_TYPE_ES_VIDEO);

    
    if(eRet != SWDMX_E_OK)
    {
        LOG(3, "_SWDMX_MpgTsSetVideoId SWDMX_DmxPesAllocateBuffer V Fail\n");
        return FALSE;
    }
    eRet = SWDMX_DmxPesStart(u1Pidx);
    if(eRet != SWDMX_E_OK)
    {
        LOG(3, "_SWDMX_MpgTsSetVideoId SWDMX_DmxPesStart V Fail\n");
        return FALSE;
    }

    if(fgSecondVideo)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo2 = u1Pidx;
    }
    else
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo = u1Pidx;
    }

    return TRUE;
}
#endif

BOOL _SWDMX_MpgTsSetPreBuffer(UINT8 u1SrcId, UINT8 u1Pidx,UINT16 u2AudioId, ENUM_SWDMX_ADEC_T e_aud_fmt,
                              UINT32 u4BufAddr,UINT32 u4BufSize)
{
    UINT32 u4Flags;    
    DMX_PID_T rPid;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
    
    LOG(5, "_SWDMX_MpgTsSetPreBuffer(%d) u1Pidx= %d u2AudioId = %d e_aud_fmt = %d\n", u1SrcId,u1Pidx,u2AudioId,e_aud_fmt);

                
    u4Flags = (UINT32)(DMX_PID_FLAG_TS_INDEX | DMX_PID_FLAG_PID | DMX_PID_FLAG_BUFFER |
        DMX_PID_FLAG_CALLBACK | DMX_PID_FLAG_STEER | DMX_PID_FLAG_DEVICE_ID |
        DMX_PID_FLAG_KEY_INDEX | DMX_PID_FLAG_DESC_MODE | DMX_PID_FLAG_PRIMARY |
        DMX_MM_FLAG_INSTANCE_TAG | DMX_PID_FLAG_SCRAMBLE_STATE ); 
                
    
    // Set PID
    x_memset((void*)&rPid, 0, sizeof(DMX_PID_T));
    
    rPid.u2Pid = u2AudioId;
    rPid.u4BufAddr = u4BufAddr;
    rPid.u4BufSize = u4BufSize;
    rPid.ePidType = DMX_PID_TYPE_ES_AUDIO;
    rPid.u1DeviceId   = (prSwdmxInst->u1AdecId);
    rPid.u1ChannelId  = (prSwdmxInst->u1AdecId);
    rPid.u1SteerMode = DMX_STEER_TO_FTUP;
    rPid.fgAllocateBuffer = FALSE;
    rPid.pvScrambleTag = NULL;
    rPid.fgPrimary = TRUE;
    rPid.pvInstanceTag = (void*)prSwdmxInst;                //set instance id to dmx  

    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_192) && 
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1AudioKeyIndex != 0) &&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u4AudioDescMode != 0))
    {
         LOG(5,"_SWDMX_MpgTsSetPreBuffer SWDMX_FMT_MPEG2_TS_192 u1KeyIndex:%d.\n",prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1AudioKeyIndex);
         rPid.u1TsIndex = DMX_MUL_GetTSIdx(prSwdmxInst->u1DmxId);
         rPid.u1KeyIndex = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1AudioKeyIndex;
         rPid.eDescMode = (DMX_DESC_MODE_T)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u4AudioDescMode;
    }
    
#ifdef TIME_SHIFT_SUPPORT
    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT) ||
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192))
    {
        rPid.u1TsIndex = DMX_MUL_GetTSIdx(prSwdmxInst->u1DmxId);
        rPid.u1KeyIndex = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1AudioKeyIndex;
        rPid.eDescMode = (DMX_DESC_MODE_T)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u4AudioDescMode;
    }
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        rPid.pfnScramble = (PFN_DMX_NOTIFY)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.pfnAScrambleNfy;
    }
#endif
        
#if defined(CC_MT5365)  || defined(CC_MT5395) || defined(SWDMX_IS_POST_MT5368)
    if (!DMX_SetFilePid(u1Pidx, u4Flags, &rPid))
#else
    if (!DMX_SetPid(u1Pidx, u4Flags, &rPid))
#endif      
    {
        // Todo: release filter and pid
        return FALSE;
    }
    if (e_aud_fmt == ENUM_SWDMX_ADEC_PCM)
    {
        LOG(0,"swdmx set audio type is lpcm in prebuffer\n");
        DMX_TS_SetAudioType(u1Pidx, DMX_AUDIO_LPCM);
    }
    
    return TRUE;
}
            

#ifndef CC_TS_DISABLE
BOOL _SWDMX_MpgTsSetAudioId(UINT8 u1SrcId, UINT8 u1Pidx,
            UINT16 u2AudioId, UINT16 u2DeviceId,
            UINT8 u1KeyIndex, UINT32 u4DescMode)
{
    //BOOL fgRet;
    SWDMX_DMX_PES_T rPes;
    SWDMX_ERR_CODE_T eRet;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    LOG(5, "_SWDMX_MpgTsSetAudioId(%d) u2AudioId = %d\n", u1SrcId, u2AudioId);

    if((u2DeviceId ==  AUD_DEC_MAIN) && (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio != 0xFF))
    {
        LOG(3, "_SWDMX_MpgTsSetAudioId u1PidxAudio != 0xFF\n");
        return FALSE;
    }
    // 0831
    if((u2DeviceId == AUD_DEC_AUX) && (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2 != 0xFF))
    {
        LOG(3, "_SWDMX_MpgTsSetAudioId u1PidxAudio != 0xFF\n");
        return FALSE;
    }
    // 0831
    if((u2DeviceId == AUD_DEC_THIRD) && (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3 != 0xFF))
    {
        LOG(3, "_SWDMX_MpgTsSetAudioId u1PidxAudio != 0xFF\n");
        return FALSE;
    }    
    if(!u2AudioId)
    {
        LOG(3, "_SWDMX_MpgTsSetAudioId u2AudioId != 0\n");
        return FALSE;
    }
    if(u2DeviceId > INTERNAL_DAC_ID_4TH)
    {
        LOG(3, "_SWDMX_MpgTsSetAudioId u2DeviceId %d > %d\n", u2DeviceId, INTERNAL_DAC_ID_4TH);
        return FALSE;
    }

    #ifndef SWDMX_MPG_DMX_20
    u1Pidx = (UINT8)((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2PidIdxStart + 1) + u2DeviceId
        + (u1SrcId * 3));
    #endif

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2AudioPidIdx != 0xFF ||
      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2Audio2PidIdx != 0xFF)
    {
        if(u2DeviceId == AUD_DEC_MAIN)
        {
            u1Pidx = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2AudioPidIdx;
        }
        // 0831
        else if(u2DeviceId == AUD_DEC_AUX)
        {
            u1Pidx = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2Audio2PidIdx;
        }
        // 0831
        else if(u2DeviceId == AUD_DEC_THIRD)
        {
            u1Pidx = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2Audio3PidIdx;
        }
        else
        {
            LOG(0, "_SWDMX_MpgTsSetAudioId u2DeviceId(%d) Fail\n", u2DeviceId);
            return FALSE;
        }
    }

    x_memset(&rPes, 0, sizeof(rPes));
    rPes.u2Pid = u2AudioId;
    if( AUD_DEC_MAIN == u2DeviceId)
    {
        rPes.u2DeviceId = (u2DeviceId + prSwdmxInst->u1AdecId);
      if(prSwdmxInst->fgEnablePrebuffer)
      {
        rPes.u2Pid = 0x1FFF;/* audio hard buffer require it ,and fgDisableFifoOutput=true*/
      }
    }
    else if( AUD_DEC_AUX == u2DeviceId)
    {
        // do not know the reason why they have to be added .
//      rPes.u2DeviceId = (u2DeviceId + prSwdmxInst->u1Adec2Id);
        rPes.u2DeviceId =  u2DeviceId;
    }
    else if( AUD_DEC_THIRD == u2DeviceId)
    {
//      rPes.u2DeviceId = (u2DeviceId + prSwdmxInst->u1Adec3Id);
        rPes.u2DeviceId = u2DeviceId;
    }
    // 0831
    rPes.u2ChannelId = u2DeviceId;

    rPes.u4BufferSize = TS_PES_AUDIO_FIFO_SIZE;
#ifdef TIME_SHIFT_SUPPORT
    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT) ||
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192))
    {
        rPes.u1TsIndex = DMX_MUL_GetTSIdx(prSwdmxInst->u1DmxId);
        rPes.u1KeyIndex = u1KeyIndex;
        rPes.u4DescMode = u4DescMode;
    }
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        rPes.pfnScramble = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.pfnAScrambleNfy;
    }
#endif

    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS) ||
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_192))
    {
        LOG(5, "_SWDMX_MpgTsSetAudioId DMX_MUL_GetTSIdx u1KeyIndex:%d,u4DescMode:%d\n",u1KeyIndex,u4DescMode);
        rPes.u1TsIndex = DMX_MUL_GetTSIdx(prSwdmxInst->u1DmxId);
        if(u1KeyIndex!=0 &&u4DescMode !=0)
        {
            rPes.u1KeyIndex = u1KeyIndex;
            rPes.u4DescMode = u4DescMode;
        }
    }

    eRet = SWDMX_DmxPesAllocateBuffer(u1SrcId, &rPes, &u1Pidx, DMX_PID_TYPE_ES_AUDIO);
    if(eRet != SWDMX_E_OK)
    {
        LOG(3, "_SWDMX_MpgTsSetAudioId SWDMX_DmxPesAllocateBuffer A Fail\n");
        return FALSE;
    }

    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgICVerify)
    {
        if (prSwdmxInst->rCurRangeReq.prDmxRangeInfo)
        {
            if(AUDIO_IS_LPCM(prSwdmxInst->rCurRangeReq.prDmxRangeInfo->e_mm_src_type) ||
               USB_SOURCE(prSwdmxInst->rCurRangeReq.prDmxRangeInfo->e_mm_src_type))
            {
                BOOL fgRet=FALSE;
                if ((prSwdmxInst->eAudioType == ENUM_SWDMX_ADEC_PCM) &&
                    (!prSwdmxInst->fgEnablePrebuffer))
                {
                    LOG(0,"swdmx set audio type is lpcm u1Pidx \n",u1Pidx);
                    fgRet = DMX_TS_SetAudioType(u1Pidx, DMX_AUDIO_LPCM);
                    if(!fgRet)
                    {
                        LOG(3, "_SWDMX_MpgTsSetAudioId DMX_TS_CPU_SetAudioType Fail\n");
                        return FALSE;
                    }
                }
                else
                {
                    LOG(0,"swdmx set audio type is %d\n",prSwdmxInst->eAudioType);
                }
            }
        }
        else
        {
            LOG(0, "_SWDMX_MpgTsSetAudioId prDmxRangeInfo = NULL!\n");
        }
    }

    eRet = SWDMX_DmxPesStart(u1Pidx);
    if(eRet != SWDMX_E_OK)
    {
        LOG(3, "_SWDMX_MpgTsSetAudioId SWDMX_DmxPesStart A Fail\n");
        return FALSE;
    }
    if(u2DeviceId == AUD_DEC_MAIN)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio = u1Pidx;
    }
    // 0831
    else if(u2DeviceId == AUD_DEC_AUX)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2 = u1Pidx;
    }
    else if(u2DeviceId == AUD_DEC_THIRD)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3 = u1Pidx;
    }
    else
    {
        LOG(0, "_SWDMX_MpgTsSetAudioId u2DeviceId(%d) Fail\n", u2DeviceId);
        return FALSE;
    }

    return TRUE;
}
#endif


#ifndef CC_TS_DISABLE
#ifdef SWDMX_MPG_SET_PCR_ID
BOOL _SWDMX_MpgTsSetPCRId(UINT8 u1SrcId, UINT16 u2PCRId)
{
    SWDMX_DMX_PES_T rPes;
    UINT8 u1Pidx;
    SWDMX_ERR_CODE_T eRet;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    LOG(5, "%s(%d) u2PCRId = %d\n", __FUNCTION__, u1SrcId, u2PCRId);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxPCR != 0xFF)
    {
        LOG(3, "%s u1PidxPCR != 0xFF\n", __FUNCTION__);
        return FALSE;
    }

    u1Pidx = 0;

    x_memset(&rPes, 0, sizeof(rPes));
    rPes.u2Pid = u2PCRId;
    rPes.u2DeviceId = 0;
    rPes.u4BufferSize = 0;
#ifdef TIME_SHIFT_SUPPORT
    rPes.u1TsIndex = DMX_MUL_GetTSIdx(prSwdmxInst->u1DmxId);
#endif
    eRet = SWDMX_DmxPesAllocateBuffer(u1SrcId, &rPes, &u1Pidx, DMX_PID_TYPE_NONE);
    if(eRet != SWDMX_E_OK)
    {
        LOG(3, "_SWDMX_MpgTsSetVideoId SWDMX_DmxPesAllocateBuffer V Fail\n");
        return FALSE;
    }
    eRet = SWDMX_DmxPesStart(u1Pidx);
    if(eRet != SWDMX_E_OK)
    {
        LOG(3, "_SWDMX_MpgTsSetVideoId SWDMX_DmxPesStart V Fail\n");
        return FALSE;
    }

    if(!DMX_SetPcr(u1Pidx, TRUE, FALSE))
    {
        return FALSE;
    }

    if(DMX_SetStcSrc(u1Pidx, 0) != 0)
    {
        return FALSE;
    }

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxPCR = u1Pidx;

    return TRUE;
}
#endif
#endif


#ifndef CC_TS_DISABLE
BOOL _SWDMX_MpgTsFreeVideoId(UINT8 u1SrcId, BOOL fgSecondVideo)
{
    UINT8 u1Pidx;
    SWDMX_ERR_CODE_T eRet;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    LOG(5, "_SWDMX_MpgTsFreeVideoId(%d)\n", u1SrcId);

    if(fgSecondVideo)
    {
        u1Pidx = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo2;
    }
    else
    {
        u1Pidx = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo;
    }
    if(u1Pidx != 0xFF)
    {
        eRet = SWDMX_DmxPesStop(u1Pidx);
        if(eRet != SWDMX_E_OK)
        {
            LOG(3, "_SWDMX_MpgTsFreeVideoId SWDMX_DmxPesStop V Fail\n");
            //return FALSE;
        }
        eRet = SWDMX_DmxPesReleaseBuffer(u1SrcId, u1Pidx);
        if(eRet != SWDMX_E_OK)
        {
            LOG(3, "_SWDMX_MpgTsFreeVideoId SWDMX_DmxPesReleaseBuffer V Fail\n");
            //return FALSE;
        }
        if(fgSecondVideo)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo2 = 0xFF;
        }
        else
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo = 0xFF;
        }
        return TRUE;
    }
    LOG(3, "_SWDMX_MpgTsFreeVideoId Fail\n");
    return FALSE;
}
#endif


#ifndef CC_TS_DISABLE
BOOL _SWDMX_MpgTsFreeAudioId(UINT8 u1SrcId)
{
    SWDMX_ERR_CODE_T eRet;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    LOG(5, "_SWDMX_MpgTsFreeAudioId(%d)\n", u1SrcId);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio != 0xFF)
    {
        eRet = SWDMX_DmxPesStop(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio);
        if(eRet != SWDMX_E_OK)
        {
            LOG(3, "_SWDMX_MpgTsFreeAudioId SWDMX_DmxPesStop A Fail\n");
            //return FALSE;
        }
        eRet = SWDMX_DmxPesReleaseBuffer(u1SrcId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio);
        if(eRet != SWDMX_E_OK)
        {
            LOG(3, "_SWDMX_MpgTsFreeAudioId SWDMX_DmxPesReleaseBuffer A Fail\n");
            //return FALSE;
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio = 0xFF;
        return TRUE;
    }
    LOG(3, "_SWDMX_MpgTsFreeAudioId Fail\n");
    return FALSE;
}
// 0831
BOOL _SWDMX_MpgTsFreeAudio2Id(UINT8 u1SrcId)
{
    SWDMX_ERR_CODE_T eRet;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    LOG(5, "_SWDMX_MpgTsFreeAudioId(%d)\n", u1SrcId);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2 != 0xFF)
    {
        eRet = SWDMX_DmxPesStop(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2);
        if(eRet != SWDMX_E_OK)
        {
            LOG(3, "_SWDMX_MpgTsFreeAudioId SWDMX_DmxPesStop A Fail\n");
            //return FALSE;
        }
        eRet = SWDMX_DmxPesReleaseBuffer(u1SrcId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2);
        if(eRet != SWDMX_E_OK)
        {
            LOG(3, "_SWDMX_MpgTsFreeAudioId SWDMX_DmxPesReleaseBuffer A Fail\n");
            //return FALSE;
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2 = 0xFF;
        return TRUE;
    }
    LOG(3, "_SWDMX_MpgTsFreeAudioId Fail\n");
    return FALSE;
}

// 0831
BOOL _SWDMX_MpgTsFreeAudio3Id(UINT8 u1SrcId)
{
    SWDMX_ERR_CODE_T eRet;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    LOG(5, "_SWDMX_MpgTsFreeAudioId(%d)\n", u1SrcId);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3 != 0xFF)
    {
        eRet = SWDMX_DmxPesStop(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3);
        if(eRet != SWDMX_E_OK)
        {
            LOG(3, "_SWDMX_MpgTsFreeAudioId SWDMX_DmxPesStop A Fail\n");
            //return FALSE;
        }
        eRet = SWDMX_DmxPesReleaseBuffer(u1SrcId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3);
        if(eRet != SWDMX_E_OK)
        {
            LOG(3, "_SWDMX_MpgTsFreeAudioId SWDMX_DmxPesReleaseBuffer A Fail\n");
            //return FALSE;
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3 = 0xFF;
        return TRUE;
    }
    LOG(3, "_SWDMX_MpgTsFreeAudioId Fail\n");
    return FALSE;
}

#endif


#ifndef CC_TS_DISABLE
#ifdef SWDMX_MPG_SET_PCR_ID
BOOL _SWDMX_MpgTsFreePCRId(UINT8 u1SrcId)
{
    SWDMX_ERR_CODE_T eRet;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    LOG(5, "%s\n", __FUNCTION__);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxPCR != 0xFF)
    {
        if(!DMX_SetPcr(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxPCR, TRUE, FALSE))
        {
            return FALSE;
        }

        eRet = SWDMX_DmxPesStop(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxPCR);
        if(eRet != SWDMX_E_OK)
        {
            LOG(3, "%s SWDMX_DmxPesStop Fail\n", __FUNCTION__);
            //return FALSE;
        }
        eRet = SWDMX_DmxPesReleaseBuffer(u1SrcId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxPCR);
        if(eRet != SWDMX_E_OK)
        {
            LOG(3, "%s SWDMX_DmxPesReleaseBuffer A Fail\n", __FUNCTION__);
            //return FALSE;
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxPCR = 0xFF;
        return TRUE;
    }
    LOG(3, "%s Fail\n", __FUNCTION__);
    return FALSE;
}
#endif
#endif


#ifndef CC_ES_DISABLE
BOOL _SWDMX_MpgEsSetVideoId(UINT8 u1SrcId, UINT8 u1Pidx)
{
    DMX_ES_T rDmxES;
    #ifndef SWDMX_MPG_DMX_20
    u1Pidx = (0 + (u1SrcId * 3));
    #endif
    UINT32 u4Flags;
    BOOL fgRet;
    UINT32 u4Addr, u4Size;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    LOG(5, "_SWDMX_MpgEsSetVideoId(%d)\n", u1SrcId);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo != 0xFF)
    {
        LOG(3, "_SWDMX_MpgEsSetVideoId u1PidxVideo != 0xFF\n");
        return FALSE;
    }

#ifndef CC_ES_H264_DISABLE
    if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_H264)
    {
    }
    else
#endif
#ifndef CC_ES_MPEG2_DISABLE
    if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_MPEG1_MPEG2)
    {
    }
    else
#endif
#ifndef CC_ES_MPEG4_DISABLE
    if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_MPEG4)
    {
    }
    else
#endif
#ifndef CC_ES_VC1_DISABLE
    if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_VC1)
    {
    }
    else
#endif
#ifndef CC_ES_AVS_DISABLE
    if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_AVS)
    {
    }
    else
#endif
#ifndef CC_ES_H265_DISABLE
    if(prSwdmxInst->eVideoType == ENUM_SWDMX_VDEC_H265)
    {
    }
    else
#endif
    {
        LOG(3, "EsSetVideoId Unknown eVideoType %d\n",
            prSwdmxInst->eVideoType);
        return FALSE;
    }

    //set es pid for playback

    u4Flags = (UINT32)(DMX_PID_FLAG_BUFFER | DMX_PID_FLAG_VALID
                | DMX_PID_FLAG_INSTANCE_TAG | DMX_PID_FLAG_DEVICE_ID);
    x_memset(&rDmxES, 0, sizeof(rDmxES));

    if(!_SWDMX_GetVideoFifo(u1SrcId, &u4Addr, &u4Size))
    {
        LOG(3, "_SWDMX_GetAudioFifo Fail\n");
        return FALSE;
    }

    rDmxES.fgAllocateBuffer   = FALSE;
    rDmxES.u4BufAddr          = u4Addr;
    rDmxES.u4BufSize          = u4Size;

    rDmxES.u1DeviceId         = (VLD0);
    rDmxES.u1ChannelId        = (prSwdmxInst->u1VdecId);
    rDmxES.fgEnable = TRUE;
    rDmxES.ePidType = DMX_PID_TYPE_ES_VIDEO;
    rDmxES.pvInstanceTag = (void*)prSwdmxInst;                //set instance id to dmx

    fgRet = DMX_ES_SetPid(u1Pidx, u4Flags, &rDmxES);
    if(!fgRet)
    {
        LOG(3, "_SWDMX_MpgEsSetVideoId DMX_ES_SetPid Fail\n");
        return FALSE;
    }
    //set es filesize
    fgRet = DMX_ES_SetFileLength(u1Pidx,(UINT32)0xFFFFFFFF);
    if(!fgRet)
    {
        LOG(3, "_SWDMX_MpgEsSetVideoId _DMX_ES_SetFileLength Fail\n");
        return FALSE;
    }
    _SWDMX_MpgResetData(u1SrcId);
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo = u1Pidx;

    return TRUE;
}
#endif


#ifndef CC_ES_DISABLE
BOOL _SWDMX_MpgEsSetAudioId(UINT8 u1SrcId, UINT8 u1Pidx)
{
    DMX_MM_T rDmxMMInfo;
    #ifndef SWDMX_MPG_DMX_20
    u1Pidx = (1 + (u1SrcId * 3));
    #endif
    UINT32 u4Flags;
    BOOL fgRet;
    UINT32 u4Addr, u4Size;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    LOG(5, "_SWDMX_MpgEsSetAudioId(%d), eFeederSrc = %d\n",
        prSwdmxInst->eFeederSrc);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio != 0xFF)
    {
        LOG(3, "_SWDMX_MpgEsSetAudioId u1PidxVideo != 0xFF\n");
        return FALSE;
    }

#if !defined(CC_ES_MP3_DISABLE) && !defined(CC_ES_MP2_DISABLE)
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
    {
    }
    else
#endif
    {
        LOG(3, "EsSetAudioId Unknown eFmt %d\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt);
        return FALSE;
    }

    u4Flags = (UINT32)(DMX_MM_FLAG_TYPE | DMX_MM_FLAG_NOTIFY |
      DMX_MM_FLAG_VALID | DMX_MM_FLAG_BUF | DMX_MM_FLAG_INSTANCE_TAG |
      DMX_MM_FLAG_DEVICE_ID);

    x_memset(&rDmxMMInfo, 0, sizeof(rDmxMMInfo));
    rDmxMMInfo.fgEnable = TRUE;

#ifdef CC_DMX_PURE_AUDIO
    {
        rDmxMMInfo.ePidType = DMX_PID_TYPE_PURE_AUDIO;
    }
#else
    {
        rDmxMMInfo.ePidType = DMX_PID_TYPE_ES_AUDIO;
    }
#endif

    rDmxMMInfo.fgAllocBuf = FALSE;

    if(!_SWDMX_GetAudioFifo(u1SrcId, &u4Addr, &u4Size))
    {
        LOG(3, "_SWDMX_MpgEsSetAudioId _SWDMX_GetAudioFifo Fail\n");
        return FALSE;
    }

    rDmxMMInfo.u4BufAddr = u4Addr;
    rDmxMMInfo.u4BufSize = u4Size;
    rDmxMMInfo.pvInstanceTag = (void*)prSwdmxInst;                //set instance id to dmx
    rDmxMMInfo.u1ChannelId = prSwdmxInst->u1AdecId;
    rDmxMMInfo.u1DeviceId = prSwdmxInst->u1AdecId;

    fgRet = DMX_MM_Set(u1Pidx, u4Flags, &rDmxMMInfo);
    if(!fgRet)
    {
        LOG(3, "_SWDMX_MpgEsSetAudioId DMX_MM_Set Fail\n");
        return FALSE;
    }
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio = u1Pidx;

    return TRUE;
}
#endif

#ifndef CC_ES_DISABLE
BOOL _SWDMX_MpgEsFreeVideoId(UINT8 u1SrcId)
{
    BOOL fgRet;
    DMX_ES_T rDmxES;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
       LOG(5, "_SWDMX_MpgEsFreeVideoId(%d)\n", u1SrcId);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo != 0xFF)
    {
        x_memset(&rDmxES, 0, sizeof(rDmxES));
        rDmxES.fgEnable = FALSE;
        fgRet = DMX_ES_SetPid(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo, DMX_PID_FLAG_VALID, &rDmxES);
        if(!fgRet)
        {
            LOG(3, "_SWDMX_MpgEsFreeVideoId DMX_ES_SetPid V Fail\n");
            //return FALSE;
        }
        fgRet = DMX_ES_FreePid(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo);
        if(!fgRet)
        {
            LOG(3, "_SWDMX_MpgEsFreeVideoId SWDMX_DmxPesReleaseBuffer V Fail\n");
            //return FALSE;
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo = 0xFF;
        return TRUE;
    }
    LOG(3, "_SWDMX_MpgEsFreeVideoId Fail\n");
    return FALSE;
}
#endif

#ifndef CC_ES_DISABLE
BOOL _SWDMX_MpgEsFreeAudioId(UINT8 u1SrcId)
{
    BOOL fgRet;
    DMX_MM_T rDmxMMInfo;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
    LOG(5, "_SWDMX_MpgEsFreeAudioId\n");

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio != 0xFF)
    {
        x_memset(&rDmxMMInfo, 0, sizeof(rDmxMMInfo));
        rDmxMMInfo.fgEnable = FALSE;
        fgRet = DMX_MM_Set(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio, DMX_PID_FLAG_VALID, &rDmxMMInfo);
        if(!fgRet)
        {
            LOG(3, "_SWDMX_MpgEsFreeAudioId DMX_MM_Set Fail\n");
            //return FALSE;
        }
        fgRet = DMX_MM_Free(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio);
        if(!fgRet)
        {
            LOG(3, "_SWDMX_MpgEsFreeAudioId DMX_MM_Free Fail\n");
            //return FALSE;
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio = 0xFF;
        return TRUE;
    }
    LOG(3, "_SWDMX_MpgEsFreeAudioId Fail\n");
    return FALSE;
}
#endif


/**
 To get first and last PTS
*/
BOOL _SWDMX_MpgBaseGetInfo(UINT8 u1SrcId, ENUM_SWDMX_FMT_T eType,
        UINT32 u4InfoMask,
        UINT64 u8FileSize,
        SWDMX_STREAM_INFO_T* prStreamInfo)
{
    BOOL fgRet = TRUE;
    UINT64 u8SendSize;
    UINT64 u8Tmp, u8Remainder;
    UINT32 u4LastPTS, u4FirstPTS;
    UINT32 u4PicCnt;
    UINT32 u4FindLastPtsTimes = 2;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if(prStreamInfo == NULL)
    {
        LOG(1, "_SWDMX_MpgBaseGetInfo prStreamInfo NULL\n");
        return FALSE;
    }

    u8SendSize = 0;
    u4FirstPTS = 0;
    u4LastPTS = 0;

    LOG(5, "_SWDMX_MpgBaseGetInfo(%d)\n", u1SrcId);

    fgRet = _SWDMX_MpgOpen(u1SrcId, eType, 0, u8FileSize, prStreamInfo);
    if(!fgRet)
    {
        LOG(3, "_SWDMX_MpgBaseGetInfo _SWDMX_MpgOpen Fail.\n");
        return FALSE;
    }

    _SWDMX_MpgResetData(u1SrcId);
    _SWDMX_MpgResetVariable(u1SrcId);
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPSISize = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendSeqHdr = TRUE; // not parse sequence header
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToDecoder = TRUE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = TRUE; // skip send eos it
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = TRUE; // skip send eos it
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = TRUE; // skip send eos it
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio2Eos = TRUE; // skip send eos it // 0831    
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio3Eos = TRUE; // skip send eos it // 0831
    // first send
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize = u8FileSize;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset = 0;
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize > FIRST_PTS_DETECT_SIZE)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize = FIRST_PTS_DETECT_SIZE;
    }
    ASSERT(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize < (UINT64)0xFFFFFFFF);
    u8SendSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize;


    fgRet = _SWDMX_MpgSendDataBatchForTotalTime(u1SrcId);
    if(!fgRet)
    {
        LOG(3, "_SWDMX_MpgBaseGetInfo _SWDMX_MpgSendDataBatch First Fail.\n");
    }
    LOG(5, "First(%d): u4FirstPTS %d, u4PicCnt %d, u8SendSize 0x%llx\n",
        u1SrcId,
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS,
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicCnt, u8SendSize);
    u4FirstPTS = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS;
    u4LastPTS = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS;
    u4PicCnt = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicCnt;
    // ~First

    // Second
    while(u4FindLastPtsTimes < LAST_PTS_DETECT_TIME)
    {
        _SWDMX_MpgResetData(u1SrcId);
        _SWDMX_MpgResetVariable(u1SrcId);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPSISize = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToDecoder = TRUE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = TRUE; // skip send eos it
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = TRUE; // skip send eos it
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = TRUE; // skip send eos it
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio2Eos = TRUE; // skip send eos it // 0831
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio3Eos = TRUE; // skip send eos it // 0831
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize = u8FileSize;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize -=
            (LAST_PTS_DETECT_SIZE*(u4FindLastPtsTimes-2));
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset = 0;
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize > (LAST_PTS_DETECT_SIZE*u4FindLastPtsTimes))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - (LAST_PTS_DETECT_SIZE*u4FindLastPtsTimes));
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = 0;
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;

        ASSERT((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize) < (UINT64)0xFFFFFFFF);
        u8SendSize += (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize);

        fgRet = _SWDMX_MpgSendDataBatchForTotalTime(u1SrcId);
        if(!fgRet)
        {
            LOG(3, "_SWDMX_MpgBaseGetInfo _SWDMX_MpgSendDataBatch Second Fail.\n");
        }
        LOG(5, "Second(%d): Times %d, u4LastPTS %d, u4PicCnt %d, u8SendSize 0x%llx\n",
            u1SrcId,
            u4FindLastPtsTimes,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicCnt, u8SendSize);
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS)
        {
            u4LastPTS = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS;
            u4PicCnt += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PicCnt;
            break;
        }
        u4FindLastPtsTimes++;
        if((eType == SWDMX_FMT_MPEG2_VIDEO_ES) ||
           (eType == SWDMX_FMT_H264_VIDEO_ES) ||
           (eType == SWDMX_FMT_MPEG4_VIDEO_ES) ||
           (eType == SWDMX_FMT_AVS_VIDEO_ES) ||
           (eType == SWDMX_FMT_VC1_ES) ||
           (eType == SWDMX_FMT_H265_VIDEO_ES))
        {
            // one shot for es
            break;
        }
    }
    if(u4FindLastPtsTimes >= LAST_PTS_DETECT_TIME)
    {
        u4LastPTS = 0;
        // calculate totaltime
    }
    // ~Second

    // Calculate TotalTime
    if((u4FirstPTS == 0) || (u4LastPTS == 0) ||
        (eType == SWDMX_FMT_MPEG2_VIDEO_ES) ||
        (eType == SWDMX_FMT_H264_VIDEO_ES) ||
        (eType == SWDMX_FMT_MPEG4_VIDEO_ES) ||
        (eType == SWDMX_FMT_AVS_VIDEO_ES) ||
        (eType == SWDMX_FMT_VC1_ES) ||
        (eType == SWDMX_FMT_H265_VIDEO_ES))
    {
        if((u4PicCnt > 0) && (u8SendSize > 0))
        {
            u8Tmp = u8FileSize;
            u8Tmp *= u4PicCnt;
            // ToDo: To have frame rate, 30 frame rate
            //u8Tmp = _SWDMX_Div6464(u8Tmp, (UINT64)(u4SendSize*30), &u8Remainder);
            //u8Tmp *= 90000; // milli-seconds -> 90K unit
            u8Tmp = _SWDMX_Div6464(u8Tmp, (u8SendSize), &u8Remainder);
            u8Tmp *= (UINT64)3000; // milli-seconds -> 90K unit
            //ASSERT(u8Tmp < (UINT64)0xFFFFFFFF);
            if(u8Tmp > (UINT64)0xFFFFFFFF)
            {
                u8Tmp = (UINT64)0xFFFFFFFF;
            }
            prStreamInfo->u4TotalTime = (UINT32)u8Tmp;
        }
        else
        {
            prStreamInfo->u4TotalTime = 0;
        }
    }
    else
    {
        if(u4FirstPTS > u4LastPTS)
        {
            prStreamInfo->u4TotalTime = ((0xFFFFFFFF - u4FirstPTS) + u4LastPTS);

        }
        else
        {
            prStreamInfo->u4TotalTime = (u4LastPTS - u4FirstPTS);
        }
        if(prStreamInfo->u4TotalTime > 0)
        {
            u8Tmp = _SWDMX_Div6464(u8FileSize*90000, (UINT64)prStreamInfo->u4TotalTime, &u8Remainder);
            if(u8Tmp > (25*1024*1024)) // 200 Mbps
            {
                // this kind of data rate is impossilbe, total time must be wrong
                prStreamInfo->u4TotalTime = 0;
            }
        }
        prStreamInfo->u4FirstPts = u4FirstPTS;
        // Use 90K time unit now
        // To milli-seconds
        //prStreamInfo->rVar.u4TotalTime *= 1000;
        //prStreamInfo->rVar.u4TotalTime /= 90000;
    }
    // ~Calc

    _SWDMX_MpgResetData(u1SrcId);
    _SWDMX_MpgResetVariable(u1SrcId);
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPSISize = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendSeqHdr = FALSE;
#ifdef SWDMX_MPG_VC1_SUPPORT
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendSeqHdrVc1 = FALSE;
#endif

    fgRet = _SWDMX_MpgCloseGetInfo(u1SrcId);
    if(!fgRet)
    {
        LOG(3, "_SWDMX_MpgBaseGetInfo _SWDMX_MpgCloseGetInfo Fail.\n");
        return FALSE;
    }
    UNUSED(u4InfoMask);
    return TRUE;
}


/**
 To get sequence header
*/
BOOL _SWDMX_MpgGetSeqInfo(UINT8 u1SrcId, ENUM_SWDMX_FMT_T eType,
        UINT32 u4InfoMask,
        UINT64 u8FileSize,
        SWDMX_PROGRAM_INFO_T* prPInfo)
{
    BOOL fgRet = TRUE;
    INT32 i4Ret;
    UINT32 i;
    UINT32 j;
    SWDMX_CUR_CMD_T rCmd;
    VDEC_SEQUENCE_DATA_T *prVdecSeqData;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if(prPInfo == NULL)
    {
        LOG(1, "_SWDMX_MpgGetSeqInfo prStreamInfo NULL\n");
        return FALSE;
    }
    if (u1SrcId >= SWDMX_SOURCE_MAX)
    {
        LOG(1, "_SWDMX_MpgGetSeqInfo (u1SrcId >= SWDMX_SOURCE_MAX)\n");
        return FALSE;
    }

    LOG(5, "%s(%d)\n", __FUNCTION__, u1SrcId);

    _SWDMX_MpgResetData(u1SrcId);
    _SWDMX_MpgResetVariable(u1SrcId);
    x_memset(&rCmd, 0, sizeof(SWDMX_CUR_CMD_T));
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPSISize = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendSeqHdr = FALSE;
#ifdef SWDMX_MPG_VC1_SUPPORT
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendSeqHdrVc1 = FALSE;
#endif

    for(i=0;i<prPInfo->u4PgmNum;i++)
    {
        if(i >= SWDMX_MAX_PROGRAM)
        {
            LOG(3, "_SWDMX_MpgGetSeqInfo SWDMX_MAX_PROGRAM Fail.\n");
            break;
        }
        for(j=0;j<prPInfo->rPgm[i].u2VideoNum;j++)
        {
            //x_memset(_ucMpgSeqHdr, 0, MPG_MPEG2_SEQ_HDR_SIZE);
            prVdecSeqData = _arSeqInfo;
            prVdecSeqData += (UINT32)u1SrcId;
            x_memset((void*)prVdecSeqData, 0, sizeof(VDEC_SEQUENCE_DATA_T));
            if(j >= SWDMX_MAX_VID_TRACK)
            {
                LOG(3, "_SWDMX_MpgGetSeqInfo SWDMX_MAX_VID_TRACK Fail.\n");
                break;
            }
            //_eVideo = prPInfo->rPgm[i].aeVideo[j];
            fgRet = _SWDMX_MpgOpen(u1SrcId, eType, j, u8FileSize, &(prPInfo->rPgm[i]));
            if(!fgRet)
            {
                LOG(3, "_SWDMX_MpgGetSeqInfo _SWDMX_MpgOpen Fail.\n");
                continue;
            }

            _SWDMX_MpgResetData(u1SrcId);
            _SWDMX_MpgResetVariable(u1SrcId);
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendSeqHdr = FALSE;
#ifdef SWDMX_MPG_VC1_SUPPORT
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendSeqHdrVc1 = FALSE;
#endif
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPSISize = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = TRUE; // skip it
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = TRUE; // skip it
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = TRUE; // skip it
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio2Eos = TRUE; // skip it  // 0831
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio3Eos = TRUE; // skip it  // 0831

            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize = u8FileSize;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset = 0;
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize > SEQ_DETECT_SIZE)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize = SEQ_DETECT_SIZE;
            }

            // send
            fgRet = TRUE;
            while(1)
            {
                i4Ret = _SWDMX_MpgSendData(u1SrcId, NULL, &rCmd);
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendSeqHdr)
                {
                    break;
                }
                if(i4Ret == MPG_SEND_OK)
                {
                    continue;
                }
                else if(i4Ret == MPG_SEND_FULL)
                {
                    x_thread_delay(1);
                }
                else if(i4Ret == MPG_SEND_EOS)
                {
                    LOG(7, "_SWDMX_MpgGetSeqInfo _SWDMX_MpgSendData Finish.\n");
                    break;
                }
                else if(i4Ret == MPG_SEND_FAIL)
                {
                    LOG(5, "_SWDMX_MpgGetSeqInfo _SWDMX_MpgSendData Fail.\n");
                    fgRet = FALSE;
                    break;
                }
                else
                {
                    LOG(5, "_SWDMX_MpgGetSeqInfo _SWDMX_MpgSendData Unknow return.\n");
                    fgRet = FALSE;
                    break;
                }
            }
            // ~send

            // Parsing
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendSeqHdr)
            {
                prPInfo->rPgm[i].u4Width[j] = _arSeqInfo[u1SrcId].u2_width;
                prPInfo->rPgm[i].u4Height[j] = _arSeqInfo[u1SrcId].u2_height;
            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendSeqHdr = FALSE;
#ifdef SWDMX_MPG_VC1_SUPPORT
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendSeqHdrVc1 = FALSE;
#endif
            // ~Parsing

            fgRet = _SWDMX_MpgCloseGetInfo(u1SrcId);
            if(!fgRet)
            {
                LOG(3, "_SWDMX_MpgGetSeqInfo _SWDMX_MpgCloseGetInfo Fail.\n");
                //return FALSE;
            }
        }
    }

    _SWDMX_MpgResetData(u1SrcId);
    _SWDMX_MpgResetVariable(u1SrcId);
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPSISize = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendSeqHdr = FALSE;
#ifdef SWDMX_MPG_VC1_SUPPORT
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendSeqHdrVc1 = FALSE;
#endif

    UNUSED(u4InfoMask);

    return TRUE;
}

/**
*/
#ifndef CC_PS_DISABLE
#ifdef SWDMX_MPG_PS_GET_INFO
BOOL _SWDMX_MpgPsGetStreamInfo(UINT8 u1SrcId, ENUM_SWDMX_FMT_T eType,
        UINT32 u4InfoMask,
        UINT64 u8FileSize,
        SWDMX_PROGRAM_INFO_T* prPInfo)
{
    DMX_PS_T rDmxPS;
    UINT16 u2MsgQIdx;
    UINT32 u4FindFin;
    SIZE_T zMsgSize;
    UINT32 u4Flags;
    UINT8 u1Pidx;
    BOOL fgRet;
    UINT64 u8Tmp, u8Remainder;
    UINT32 u4Tmp;
      SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if(prPInfo == NULL)
    {
        LOG(1, "_SWDMX_MpgPsGetStreamInfo prStreamInfo NULL\n");
        return FALSE;
    }

    zMsgSize = sizeof(INT32);
    u1Pidx = 0;
    fgRet = FALSE;

    LOG(5, "_SWDMX_MpgPsGetStreamInfo\n");

#ifdef CC_IC_VERIFY
    _SWDMX_MpgPsInit(u1SrcId, eType);
#endif

    _SWDMX_FlushFindMsgQ(u1SrcId);

    prPInfo->u4PgmNum = 0;

    u4Flags = (DMX_PID_FLAG_BUFFER | DMX_PID_FLAG_STREAM_ID);
    x_memset(&rDmxPS, 0, sizeof(rDmxPS));
    {
        UINT32 u4Addr, u4Size;
        if(!_SWDMX_GetVideoFifo(u1SrcId, &u4Addr, &u4Size))
        {
            LOG(3, "_SWDMX_MpgEsSetAudioId _SWDMX_GetAudioFifo Fail\n");
            return FALSE;
        }

        rDmxPS.fgAllocateBuffer   = FALSE;
        rDmxPS.u4BufAddr          = u4Addr;
        rDmxPS.u4BufSize          = u4Size;
    }
    rDmxPS.ePidType = DMX_PID_TYPE_ES_VIDEO;

    fgRet = DMX_PS_SetStream(u1Pidx, u4Flags, &rDmxPS);
    if(!fgRet)
    {
        Printf("DMX_PS_SetStream Fail\n");
        return FALSE;
    }

    u4Flags = DMX_PID_FLAG_VALID;
    x_memset(&rDmxPS, 0, sizeof(rDmxPS));
    rDmxPS.fgEnable = TRUE;

    fgRet = DMX_PS_SetStream(u1Pidx, u4Flags, &rDmxPS);
    if(!fgRet)
    {
        Printf("DMX_PS_SetStream Fail\n");
        return FALSE;
    }

    // demux have limitation. I have to set smaller size than I will send
    u8Tmp = _SWDMX_Div6464(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize, (UINT64)(2048), &u8Remainder);
    UNUSED(_SWDMX_Div6464(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize, (UINT64)(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase), &u8Remainder));
    u4Tmp = u8Remainder;
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize > (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase*2))
    {
        fgRet = DMX_PS_DetectStreamID(TRUE,
            (u8Tmp),
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - (u4Tmp) - (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase*2)));
    }
    else
    {
        u8Tmp = _SWDMX_Div6464(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize, (UINT64)(2048), &u8Remainder);
        fgRet = DMX_PS_DetectStreamID(TRUE,
            (u8Tmp),//(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize/2048),
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - (u4Tmp)));
    }

    if(!fgRet)
    {
        Printf("DMX_PS_DetectStreamID Fail\n");
        DMX_PS_FreeStream(u1Pidx);
        return FALSE;
    }

    u4Flags = DMX_PID_FLAG_CALLBACK;
    x_memset(&rDmxPS, 0, sizeof(rDmxPS));
    rDmxPS.pfnNotify = _SWDMX_MpgPsInfoNotify;
    rDmxPS.pvNotifyTag = 0;

    fgRet = DMX_PS_SetStream(u1Pidx, u4Flags, &rDmxPS);
    if(!fgRet)
    {
        Printf("DMX_PS_SetStream Fail\n");
        DMX_PS_FreeStream(u1Pidx);
        return FALSE;
    }

    _SWDMX_FlushDataMsgQ(u1SrcId);

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgJumpping = FALSE;
    //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFirst = TRUE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPTSFound = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize = 0;
    //_u4AvailSize = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPosWithPTSFound = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8Previous2IPosWithPTSFound = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = 0;

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = TRUE; // skip it
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = TRUE; // skip it
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = TRUE; // skip it

    _SWDMX_MpgSendDataBatch(u1SrcId);

    #if 0
    //detect PS
    //dmx callback to swdmx tell streamid or pid for a/v
    VERIFY(x_timer_start(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hFindTimer, OPEN_TIMEOUT, X_TIMER_FLAG_ONCE,
        _SWDMX_TimerFindTimeout, (VOID*)0) == OSR_OK);
    #endif
    VERIFY(x_msg_q_receive(&u2MsgQIdx, &u4FindFin, &zMsgSize, &(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hFindMsgQ), 1,
    X_MSGQ_OPTION_WAIT) == OSR_OK);
    VERIFY(x_timer_stop(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.hFindTimer) == OSR_OK);

    u4Flags = DMX_PID_FLAG_VALID;
    x_memset(&rDmxPS, 0, sizeof(rDmxPS));
    rDmxPS.fgEnable = FALSE;

    fgRet = DMX_PS_SetStream(u1Pidx, u4Flags, &rDmxPS);
    if(!fgRet)
    {
        Printf("DMX_PS_SetStream Fail\n");
        return FALSE;
    }

    fgRet = DMX_PS_FreeStream(u1Pidx);
    if(!fgRet)
    {
        Printf("DMX_PS_FreeStream Fail\n");
        return FALSE;
    }

    if((u4FindFin != DETECT_OK) ||
        ((_ucPSVideoStreamId == 0)&&(_ucPSAudioStreamId == 0)))
    {
        LOG(1, "PS open fail, findfin = %d, VideoStreamId = %d, AudioStreamId = %d",
            u4FindFin, (INT32)_ucPSVideoStreamId, (INT32)_ucPSAudioStreamId);
        return FALSE;
    }

    prPInfo->u4PgmNum = 1;
    if(_ucPSVideoStreamId)
    {
        prPInfo->rPgm[0].fgVideo = TRUE;
        prPInfo->rPgm[0].au2VideoId = _ucPSVideoStreamId;
        prPInfo->rPgm[0].aeVideo = ENUM_SWDMX_VDEC_MPEG1_MPEG2;
    }
    if(_ucPSAudioStreamId)
    {
        prPInfo->rPgm[0].fgStreamInfo = TRUE;
        prPInfo->rPgm[0].fgAudio = TRUE;
        prPInfo->rPgm[0].u2AudioId = _ucPSAudioStreamId;
        if(_ucPSAudioStreamId >= 0xC0 && _ucPSAudioStreamId <=0xDF)
        {
            prPInfo->rPgm[0].aeAudio = ENUM_SWDMX_ADEC_MPEG;
        }
        else if((_ucPSAudioStreamId == 0xBD) &&
            (_ucPSAudioSubStreamId >= 0xA0) && (_ucPSAudioSubStreamId <= 0xA8))
        {
            prPInfo->rPgm[0].aeAudio = ENUM_SWDMX_ADEC_PCM;
        }
        else if((_ucPSAudioStreamId == 0xBD) &&
            (_ucPSAudioSubStreamId >= 0x80) && (_ucPSAudioSubStreamId <= 0x88))
        {
            prPInfo->rPgm[0].aeAudio = ENUM_SWDMX_ADEC_AC3;
        }
        else
        {
            LOG(3, "prStreamInfo->aeAudio Unknown\n");
            prPInfo->rPgm[0].aeAudio = ENUM_SWDMX_ADEC_UNKNOWN;
        }
    }

    // in PS pre-parsing mode, we have to reset dmx to prevent infinite loop
    DMX_Init();
  #ifdef CC_IC_VERIFY
    _SWDMX_MpgPsInit(u1SrcId, eType);
  #endif
  
    if(_ucPSVideoStreamId || _ucPSAudioStreamId)
    {
        // to get total duration
        return _SWDMX_MpgBaseGetInfo(u1SrcId, eType, prPInfo->rPgm[0]);
    }

    UNUSED(u4InfoMask);

    return FALSE;
}
#endif
#endif

/**
*/
#ifndef CC_TS_DISABLE
BOOL _SWDMX_MpgTsGetStreamInfo(UINT8 u1SrcId, ENUM_SWDMX_FMT_T eType,
        UINT32 u4InfoMask,
        UINT64 u8FileSize,
        SWDMX_PROGRAM_INFO_T* prPInfo)
{
    UINT32 u4Src, u4Num;
    UINT32 u4Timeout;
    UINT32 u4AudPid;
    UINT32 u4VidPid;
    //UINT32 u4VidPidSub;
    UINT32 u4APIDType;
    UINT32 u4VPIDType;
    UINT32 u4SubVPIDType;
    INT32 i4Ret;
    BOOL fgRet;
    UINT32 i, j;

      SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if(prPInfo == NULL)
    {
        LOG(1, "_SWDMX_MpgTsGetStreamInfo prStreamInfo NULL\n");
        return FALSE;
    }

#ifdef TIME_SHIFT_SUPPORT
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        if(!_SWDMX_PVR_GetInfo(u1SrcId, prPInfo))
        {
            return FALSE;
        }
        else
        {
            return TRUE;
        }
        /*
        // to get total duration
        fgRet = _SWDMX_MpgOpen(eType, 0, u8FileSize, prStreamInfo);
        //fgRet = _SWDMX_MpgBaseGetInfo(eType, prStreamInfo);
        if(fgRet)
        {
            LOG(5, "_SWDMX_MpgTsOpen return TRUE\n");
            return TRUE;
        }
        LOG(3, "_SWDMX_MpgTsOpen return FALSE\n");
        return FALSE;
        */
    }
#endif

    LOG(5, "_SWDMX_MpgTsGetStreamInfo\n");

    if(!_SWDMX_MpgTsInit(u1SrcId, eType))
    {
        LOG(1, "_SWDMX_MpgTsGetStreamInfo _SWDMX_MpgTsInit fail\n");
        return FALSE;
    }

    x_memset(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl, 0, sizeof(PSIPSR_TBL_PMT_T)*SWDMX_MAX_PMT_NUM);
    u4Src = 0;
    u4Num = 0;
    u4Timeout = OPEN_TIMEOUT; // timeout

    {
        prPInfo->u4PgmNum = 0;
        //detect TS
        i4Ret = SWDMX_PsiPsrParsePsi(u1SrcId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl, &u4Num, u4Timeout, u4Src);

        if (i4Ret==(INT32)E_PSIPSR_OK)
        {
            LOG(3, "PSI parsing done---------------------\n");
            if(u4Num >= SWDMX_MAX_PMT_NUM)
            {
                LOG(3, "u4Num %d > default %d\n", u4Num, SWDMX_MAX_PMT_NUM);
                //ASSERT(u4Num < SWDMX_MAX_PMT_NUM);
                u4Num = SWDMX_MAX_PMT_NUM;
            }
            for (i=0; i<u4Num; i++)
            {
                prPInfo->rPgm[prPInfo->u4PgmNum].u2VideoNum = 0;
                prPInfo->rPgm[prPInfo->u4PgmNum].u2AudioNum = 0;
                prPInfo->rPgm[prPInfo->u4PgmNum].u2SubpicNum = 0;
                prPInfo->rPgm[prPInfo->u4PgmNum].u2PcrNum = 0;
                LOG(5, "prog=0x%x, pcr=0x%x, v=0x%x, 0x%x(%d,%d), v2=0x%x(%d), a1=0x%x(%d), a2=0x%x(%d), a3=0x%x(%d)\n",
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4ProgNum, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4PCR,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4VPID,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4SubVPID,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4VPIDType,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4SubVPIDType,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4VPID2, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4VPID2Type,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4APID1, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4APID1Type,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4APID2, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4APID2Type,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4APID3, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4APID3Type);

                for (j=0; j<2 ;j++)
                {
                    u4VidPid = 0;
                    u4SubVPIDType = 0;
                    if((j == 0) && (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4VPID > 0))
                    {
                        u4VidPid = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4VPID;
                        //u4VidPidSub = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4VPIDSub;
                        u4VPIDType = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4VPIDType;
                        u4SubVPIDType = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4SubVPIDType;
                    }
                    else if((j == 1) && (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4VPID2 > 0))
                    {
                        u4VidPid = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4VPID2;
                        //u4VidPidSub = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4VPIDSub;
                        u4VPIDType = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4VPID2Type;
                        // only support on first video track
                        //u4SubVPIDType = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4SubVPIDType;
                    }
                    if(u4VidPid > 0)
                    {
                        if(prPInfo->rPgm[prPInfo->u4PgmNum].u2VideoNum < SWDMX_MAX_VID_TRACK)
                        {
                            prPInfo->rPgm[prPInfo->u4PgmNum].au2VideoId[prPInfo->rPgm[prPInfo->u4PgmNum].u2VideoNum] =
                                (UINT16)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4VPID;
                            prPInfo->rPgm[prPInfo->u4PgmNum].au2SubVideoId[prPInfo->rPgm[prPInfo->u4PgmNum].u2VideoNum] =
                                (UINT16)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4SubVPID;
                            x_memcpy((VOID*)&prPInfo->rPgm[prPInfo->u4PgmNum].aau1VideoHdr[prPInfo->rPgm[prPInfo->u4PgmNum].u2VideoNum][0],
                                (VOID*)&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].au1VData[0],
                                SWDMX_MAX_HDR_SIZE);
                            if(u4VPIDType == STREAM_TYPE_VIDEO)
                            {
                                prPInfo->rPgm[prPInfo->u4PgmNum].aeVideo[prPInfo->rPgm[prPInfo->u4PgmNum].u2VideoNum] = ENUM_SWDMX_VDEC_MPEG1_MPEG2;
                            }
                            else if(u4VPIDType == STREAM_TYPE_H264)
                            {
                                prPInfo->rPgm[prPInfo->u4PgmNum].aeVideo[prPInfo->rPgm[prPInfo->u4PgmNum].u2VideoNum] = ENUM_SWDMX_VDEC_H264;
                            }
                            else if(u4VPIDType == STREAM_TYPE_AVS)
                            {
                                prPInfo->rPgm[prPInfo->u4PgmNum].aeVideo[prPInfo->rPgm[prPInfo->u4PgmNum].u2VideoNum] = ENUM_SWDMX_VDEC_AVS;
                            }
                            else if(u4VPIDType == STREAM_TYPE_VC1)
                            {
                                prPInfo->rPgm[prPInfo->u4PgmNum].aeVideo[prPInfo->rPgm[prPInfo->u4PgmNum].u2VideoNum] = ENUM_SWDMX_VDEC_VC1;
                            }
              else if (u4VPIDType == STREAM_TYPE_H265)
              {
                                prPInfo->rPgm[prPInfo->u4PgmNum].aeVideo[prPInfo->rPgm[prPInfo->u4PgmNum].u2VideoNum] = ENUM_SWDMX_VDEC_H265;
                LOG(1,"%s video type %d\n",__FUNCTION__,prPInfo->rPgm[prPInfo->u4PgmNum].aeVideo[prPInfo->rPgm[prPInfo->u4PgmNum].u2VideoNum]);
              }
                
                            else
                            {
                                prPInfo->rPgm[prPInfo->u4PgmNum].aeVideo[prPInfo->rPgm[prPInfo->u4PgmNum].u2VideoNum] = ENUM_SWDMX_VDEC_UNKNOWN;
                                LOG(3, "_SWDMX_MpgTsOpen Unknown Video Type\n");
                            }
                            if(u4SubVPIDType == STREAM_TYPE_MVC)
                            {
                                prPInfo->rPgm[prPInfo->u4PgmNum].aeSubVideo[prPInfo->rPgm[prPInfo->u4PgmNum].u2VideoNum] = ENUM_SWDMX_VDEC_MVC;
                                x_memcpy(
                                    (VOID*)&prPInfo->rPgm[prPInfo->u4PgmNum].aau1VideoHdr[prPInfo->rPgm[prPInfo->u4PgmNum].u2VideoNum][0],
                                    (VOID*)&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].au1VData[0],
                                    SWDMX_MVC_HDR_SIZE);
                            }
                            else if(u4SubVPIDType == STREAM_TYPE_MULTITRACK)
                            {
                                prPInfo->rPgm[prPInfo->u4PgmNum].aeSubVideo[prPInfo->rPgm[prPInfo->u4PgmNum].u2VideoNum]
                                    = ENUM_SWDMX_VDEC_MULTITRACK;
                            }
                            if(prPInfo->rPgm[prPInfo->u4PgmNum].aeVideo[prPInfo->rPgm[prPInfo->u4PgmNum].u2VideoNum]!=ENUM_SWDMX_VDEC_UNKNOWN)
                            {
                                prPInfo->rPgm[prPInfo->u4PgmNum].u2VideoNum++;
                            }
                        }
                        else
                        {
                            LOG(3, "_SWDMX_MpgTsOpen video num full\n");
                        }
                    }
                }
                for (j=0; j<3 ;j++)
                {
                    u4AudPid = 0;
                    if((j == 0) && (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4APID1 > 0))
                    {
                        u4AudPid = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4APID1;
                        u4APIDType = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4APID1Type;
                    }
                    else if((j == 1) && (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4APID2 > 0))
                    {
                        u4AudPid = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4APID2;
                        u4APIDType = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4APID2Type;
                    }
                    else if((j == 2) && (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4APID3 > 0))
                    {
                        u4AudPid = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4APID3;
                        u4APIDType = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4APID3Type;
                    }
                    if(u4AudPid > 0)
                    {
                        if(prPInfo->rPgm[prPInfo->u4PgmNum].u2AudioNum < SWDMX_MAX_AUD_TRACK)
                        {
                            prPInfo->rPgm[prPInfo->u4PgmNum].au2AudioId[prPInfo->rPgm[prPInfo->u4PgmNum].u2AudioNum] = (UINT16)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.arPMTTbl[i].u4APID1;
                            if((u4APIDType == STREAM_TYPE_MPEG1) ||
                                (u4APIDType == STREAM_TYPE_MPEG2))
                            {
                                prPInfo->rPgm[prPInfo->u4PgmNum].aeAudio[prPInfo->rPgm[prPInfo->u4PgmNum].u2AudioNum] = ENUM_SWDMX_ADEC_MPEG;
                            }
                            else if((u4APIDType == STREAM_TYPE_AC3) ||
                                (u4APIDType == STREAM_TYPE_AC3_EU) ||
                                (u4APIDType == STREAM_TYPE_EAC3))
                            {
                                prPInfo->rPgm[prPInfo->u4PgmNum].aeAudio[prPInfo->rPgm[prPInfo->u4PgmNum].u2AudioNum] = ENUM_SWDMX_ADEC_AC3;
                            }
                            else if((u4APIDType == STREAM_TYPE_AAC) ||
                                (u4APIDType == STREAM_TYPE_AAC_ISDB))
                            {
                                prPInfo->rPgm[prPInfo->u4PgmNum].aeAudio[prPInfo->rPgm[prPInfo->u4PgmNum].u2AudioNum] = ENUM_SWDMX_ADEC_AAC;
                            }
                            //Sample rate, frequence, etc.
                            else if(u4APIDType ==
                                    STREAM_TYPE_SWDMX_LPCM)
                            {
                                prPInfo->rPgm[prPInfo->u4PgmNum].aeAudio[prPInfo->rPgm[prPInfo->u4PgmNum].u2AudioNum] = ENUM_SWDMX_ADEC_PCM;
                            }
                            else
                            {
                                prPInfo->rPgm[prPInfo->u4PgmNum].aeAudio[prPInfo->rPgm[prPInfo->u4PgmNum].u2AudioNum] = ENUM_SWDMX_ADEC_UNKNOWN;
                                LOG(3, "_SWDMX_MpgTsOpen Unknown Audio Type\n");
                            }
                            if(prPInfo->rPgm[prPInfo->u4PgmNum].aeAudio[prPInfo->rPgm[prPInfo->u4PgmNum].u2AudioNum]!=ENUM_SWDMX_ADEC_UNKNOWN)
                            {
                                prPInfo->rPgm[prPInfo->u4PgmNum].u2AudioNum++;
                            }
                        }
                        else
                        {
                            LOG(3, "_SWDMX_MpgTsOpen audio num full\n");
                        }
                    }
                }
                if((prPInfo->rPgm[prPInfo->u4PgmNum].u2VideoNum > 0) || (prPInfo->rPgm[prPInfo->u4PgmNum].u2AudioNum > 0))
                {
                    // to get total duration
                    fgRet = _SWDMX_MpgBaseGetInfo(u1SrcId, eType,
                                    u4InfoMask,
                                    u8FileSize,
                                    &(prPInfo->rPgm[prPInfo->u4PgmNum]));
                    if(!fgRet)
                    {
                        LOG(3, "_SWDMX_MpgTsOpen _SWDMX_MpgBaseGetInfo return FALSE\n");
                        continue;
                    }
                    LOG(5, "_SWDMX_MpgTsOpen _SWDMX_MpgBaseGetInfo return TRUE\n");

                    prPInfo->u4PgmNum++;
                }
            }
        }
        else
        {
            LOG(1, "PSI parse timeout\n");
            return FALSE;
        }

        LOG(5, "TS, prog cnt %d\n", u4Num);
        if(u4Num == 0)
        {
            LOG(3, "TS, No program Pid\n");
            return FALSE;
        }
    }

    //LOG(3, "_SWDMX_MpgTsOpen return FALSE\n");
    return TRUE;
}
#endif

/**
*/
#ifndef CC_ES_DISABLE
BOOL _SWDMX_MpgEsGetStreamInfo(UINT8 u1SrcId, ENUM_SWDMX_FMT_T eType,
        UINT32 u4InfoMask,
        UINT64 u8FileSize,
        SWDMX_PROGRAM_INFO_T* prPInfo)
{
    BOOL fgRet;

    if(prPInfo == NULL)
    {
        LOG(1, "_SWDMX_MpgEsGetStreamInfo prStreamInfo NULL\n");
        return FALSE;
    }

    LOG(5, "%s(%d)\n", __FUNCTION__, u1SrcId);

    if(!_SWDMX_MpgEsInit(u1SrcId, eType))
    {
        LOG(1, "_SWDMX_MpgEsGetStreamInfo _SWDMX_MpgEsInit fail\n");
        return FALSE;
    }

    prPInfo->u4PgmNum = 0;
#ifndef CC_ES_H264_DISABLE
    if(eType == SWDMX_FMT_H264_VIDEO_ES)
    {
        prPInfo->rPgm[0].aeVideo[0] = ENUM_SWDMX_VDEC_H264;
    }
    else
#endif
#ifndef CC_ES_MPEG2_DISABLE
    if(eType == SWDMX_FMT_MPEG2_VIDEO_ES)
    {
        prPInfo->rPgm[0].aeVideo[0] = ENUM_SWDMX_VDEC_MPEG1_MPEG2;
    }
    else
#endif
#ifndef CC_ES_MPEG4_DISABLE
    if(eType == SWDMX_FMT_MPEG4_VIDEO_ES)
    {
        prPInfo->rPgm[0].aeVideo[0] = ENUM_SWDMX_VDEC_MPEG4;
    }
    else
#endif
#ifndef CC_ES_VC1_DISABLE
    if(eType == SWDMX_FMT_VC1_ES)
    {
        prPInfo->rPgm[0].aeVideo[0] = ENUM_SWDMX_VDEC_VC1;
    }
    else
#endif
#ifndef CC_ES_AVS_DISABLE
    if(eType == SWDMX_FMT_AVS_VIDEO_ES)
    {
        prPInfo->rPgm[0].aeVideo[0] = ENUM_SWDMX_VDEC_AVS;
    }
    else
#endif
#ifndef CC_ES_H265_DISABLE
    if(eType == SWDMX_FMT_H265_VIDEO_ES)
    {
        prPInfo->rPgm[0].aeVideo[0] = ENUM_SWDMX_VDEC_H265;
    }
    else
#endif
    {
        LOG(3, "_SWDMX_MpgEsGetStreamInfo Unknown eType %d\n", eType);
        return FALSE;
    }
    prPInfo->u4PgmNum = 1;
    prPInfo->rPgm[0].u2VideoNum = 1;
    prPInfo->rPgm[0].u2AudioNum = 0;
    prPInfo->rPgm[0].u2SubpicNum = 0;
    prPInfo->rPgm[0].u2PcrNum = 0;
    prPInfo->rPgm[0].au2VideoId[0] = 0xE0;

    // to get total duration
    fgRet = _SWDMX_MpgBaseGetInfo(u1SrcId, eType,
                        u4InfoMask,
                        u8FileSize,
                        &(prPInfo->rPgm[0]));
    if(fgRet)
    {
        LOG(5, "_SWDMX_MpgEsGetStreamInfo return TRUE\n");
        return TRUE;
    }
    LOG(3, "_SWDMX_MpgEsGetStreamInfo return FALSE\n");
    return FALSE;
}
#endif


/**
*/
BOOL _SWDMX_MpgGetStreamInfo(UINT8 u1SrcId, ENUM_SWDMX_FMT_T eType,
        UINT32 u4InfoMask,
        UINT64 u8FileSize,
        SWDMX_PROGRAM_INFO_T* prPInfo)
{
    BOOL fgRet;
      SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if(prPInfo == NULL)
    {
        LOG(1, "_SWDMX_MpgGetStreamInfo prStreamInfo NULL\n");
        return FALSE;
    }

    LOG(5, "_SWDMX_MpgGetStreamInfo eType %d\n", eType);
    LOG(5, "    u8FileSize in 32 bits= 0x%llx\n", u8FileSize);

    if(u8FileSize == 0)
    {
        LOG(5, "_SWDMX_MpgGetStreamInfo u8FileSize Fail\n");
        return FALSE;
    }

    _SWDMX_MpgResetData(u1SrcId);
    _SWDMX_MpgResetVariable(u1SrcId);
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPSISize = FALSE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendSeqHdr = TRUE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetInfo = TRUE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize = u8FileSize;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotToDecoder = TRUE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideoEos = TRUE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendVideo2Eos = TRUE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudioEos = TRUE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio2Eos = TRUE; // 0831    
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendAudio3Eos = TRUE; // 0831

    if(u4InfoMask & SWDMX_STREAM_INFO_MASK_TRACK)
    {
        fgRet = FALSE;
#ifdef SWDMX_MPG_PS_GET_INFO
        if((eType == SWDMX_FMT_MPEG2_PS) ||
            (eType == SWDMX_FMT_MPEG1_DAT))
        {
            if(u8FileSize > PS_OPEN_FILE_SIZE)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize = PS_OPEN_FILE_SIZE;
            }
            fgRet = _SWDMX_MpgPsGetStreamInfo(u1SrcId, eType, u4InfoMask, u8FileSize, prPInfo);
        }
        else
#endif
#ifndef CC_TS_DISABLE
#ifdef TIME_SHIFT_SUPPORT
        if(eType == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
        {
            fgRet =  _SWDMX_MpgTsGetStreamInfo(u1SrcId, eType,
                u4InfoMask, u8FileSize, prPInfo);
        }
        else
#endif
        if (IS_TS_FILE(eType))
        {
            if(u8FileSize > TS_OPEN_FILE_SIZE)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize = TS_OPEN_FILE_SIZE;
            }
            fgRet =  _SWDMX_MpgTsGetStreamInfo(u1SrcId, eType,
                u4InfoMask, u8FileSize, prPInfo);
        }
        else
#endif
#ifndef CC_ES_DISABLE
        if((eType == SWDMX_FMT_MPEG2_VIDEO_ES) ||
            (eType == SWDMX_FMT_H264_VIDEO_ES) ||
            (eType == SWDMX_FMT_MPEG4_VIDEO_ES) ||
            (eType == SWDMX_FMT_AVS_VIDEO_ES) ||
            (eType == SWDMX_FMT_VC1_ES) ||
            (eType == SWDMX_FMT_H265_VIDEO_ES))
        {
            if(u8FileSize > ES_OPEN_FILE_SIZE)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize = ES_OPEN_FILE_SIZE;
            }
            fgRet =  _SWDMX_MpgEsGetStreamInfo(u1SrcId, eType,
                u4InfoMask, u8FileSize, prPInfo);
        }
        else
#endif
        {
            LOG(3, "_SWDMX_MpgGetStreamInfo Unknown eType\n");
        }
        if(!fgRet)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetInfo = FALSE;
            LOG(3, "_SWDMX_MpgGetStreamInfo TRACK FALSE\n");
            return FALSE;
        }
    }
    if(u4InfoMask & SWDMX_STREAM_INFO_MASK_RESOLUTION)
    {
        fgRet =  _SWDMX_MpgGetSeqInfo(u1SrcId, eType, u4InfoMask, u8FileSize, prPInfo);
        if(!fgRet)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetInfo = FALSE;
            LOG(3, "_SWDMX_MpgGetStreamInfo RESOLUTION FALSE\n");
            return FALSE;
        }
    }

    _SWDMX_MpgResetData(u1SrcId);
    _SWDMX_MpgResetVariable(u1SrcId);
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetInfo = FALSE;

    LOG(5, "_SWDMX_MpgGetStreamInfo(%d) Result:\n", u1SrcId);
    LOG(5, "    u2VideoNum     = %d\n", prPInfo->rPgm[0].u2VideoNum);
    LOG(5, "    u2AudioNum     = %d\n", prPInfo->rPgm[0].u2AudioNum);
    LOG(5, "    u2VideoId[0]   = %d\n", prPInfo->rPgm[0].au2VideoId[0]);
    LOG(5, "    u2AudioId[0]   = %d\n", prPInfo->rPgm[0].au2AudioId[0]);
    LOG(5, "    u4TotalTime    = %d\n", prPInfo->rPgm[0].u4TotalTime);
    LOG(5, "    u8FileSize in 32 bits = 0x%llx\n", u8FileSize);
    LOG(5, "    eVideo[0]      = %d\n", prPInfo->rPgm[0].aeVideo[0]);
    LOG(5, "    eAudio[0]      = %d\n", prPInfo->rPgm[0].aeAudio[0]);

    return TRUE;
}

/**
*/
BOOL _SWDMX_MpgCloseGetInfo(UINT8 u1SrcId)
{
    BOOL fgRet;
    LOG(5, "_SWDMX_MpgCloseForOpen(%d)\n", u1SrcId);
    fgRet = SWDMX_SetInfo(u1SrcId, (UINT8)eSWDMX_DISABLE_STREAM,
        (UINT32)eSWDMX_STRM_TYPE_VID, 0, 0);
    if(!fgRet)
    {
        LOG(3, "_SWDMX_MpgOpen eSWDMX_DISABLE_STREAM V Fail\n");
    }
    fgRet = SWDMX_SetInfo(u1SrcId, (UINT8)eSWDMX_DISABLE_STREAM,
        (UINT32)eSWDMX_STRM_TYPE_AUD, 0, 0);
    if(!fgRet)
    {
        LOG(3, "_SWDMX_MpgOpen eSWDMX_DISABLE_STREAM A Fail\n");
    }
    fgRet = SWDMX_SetInfo(u1SrcId, (UINT8)eSWDMX_DISABLE_STREAM,
        (UINT32)eSWDMX_STRM_TYPE_AUD2, 0, 0);
    if(!fgRet)
    {
        LOG(3, "_SWDMX_MpgOpen eSWDMX_DISABLE_STREAM A2 Fail\n");
    }
     // 0831
    fgRet = SWDMX_SetInfo(u1SrcId, (UINT8)eSWDMX_DISABLE_STREAM,
        (UINT32)eSWDMX_STRM_TYPE_AUD3, 0, 0);
        
    fgRet = SWDMX_SetInfo(u1SrcId, (UINT8)eSWDMX_DISABLE_STREAM,
        (UINT32)eSWDMX_STRM_TYPE_SUBTITLE, 0, 0);
    if(!fgRet)
    {
        LOG(3, "_SWDMX_MpgOpen eSWDMX_DISABLE_STREAM SUB Fail\n");
    }
    fgRet = SWDMX_SetInfo(u1SrcId, (UINT8)eSWDMX_DISABLE_STREAM,
        (UINT32)eSWDMX_STRM_TYPE_PCR, 0, 0);
    if(!fgRet)
    {
        LOG(3, "_SWDMX_MpgOpen eSWDMX_DISABLE_STREAM PCR Fail\n");
    }
    UNUSED(fgRet);
    return _SWDMX_MpgStop(u1SrcId);
}
#if 0
/**
*/
BOOL _SWDMX_MpgClose(UINT8 u1SrcId)
{
    LOG(5, "_SWDMX_MpgClose\n");

    if(!_SWDMX_MpgStop(u1SrcId))
    {
        return FALSE;
    }

    return TRUE;
}
#endif


/**
*/
VOID _SWDMX_MpgSetRange(UINT8 u1SrcId, SWDMX_RANGE_LIST_T *prRangeList, UINT32 u4VidStrmID,
                                      UINT32 u4AudStrmID, UINT32 u4SubTitleID)
{
    MM_RANGE_INFO_T* prRangeInfo = 0;
     SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    LOG(5, "_SWDMX_MpgSetRange(%d)\n", u1SrcId);

    if(prRangeList == NULL)
    {
        LOG(0, "Demuxer Range is NULL\n");
        return;
    }

    prRangeInfo = prRangeList->prDmxRangeInfo;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq = prRangeList;

    if (prRangeInfo != NULL)
    {
        _SWDMX_MpgResetData(u1SrcId);
        _SWDMX_MpgResetVariable(u1SrcId);

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize = (prRangeInfo->z_range_sz + prRangeInfo->ui8_fileoffset);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset = prRangeInfo->ui8_fileoffset;
        // for resume stop.
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = 0;
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize)
        {
            LOG(3, "u8StartFileOffset >= u8FileSize\n");
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize > 0)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - 1);
            }
            else
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset = 0;
            }
        }
#if defined(CC_TRUSTZONE_SUPPORT)
    if (prRangeInfo->e_encrypt_mode == MM_ENCRYPT_METHORD_LOCAL_KEY)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.eEncryptMode = SWDMX_ENCRYPT_MODE_LOCAL_KEY;
            LOG(5,"tell this bitstream is encrypt content,key is seted via mtal by 3rd\n");      
    }

        
#endif
        if(prSwdmxInst)
        {
            if((prSwdmxInst->fgPlayChange) &&
               (((UINT32)(prSwdmxInst->u8SeekPos>>32) != (UINT32)0xFFFFFFFF)
                || ((UINT32)(prSwdmxInst->u8SeekPos) != (UINT32)0xFFFFFFFF)))
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = prSwdmxInst->u8SeekPos;
                prSwdmxInst->u8SeekPos = (UINT64)0xFFFFFFFF;
                prSwdmxInst->u8SeekPos <<= 32;
                prSwdmxInst->u8SeekPos += (UINT64)0xFFFFFFFF;
                prSwdmxInst->fgPlayChange = FALSE;
                UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
                UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
                UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1VdecId, FALSE, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
                if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
                   (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
                {
                    UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                    UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
                    UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1Vdec2Id, FALSE, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize));
                }
            }
            else
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = prRangeInfo->ui8_fileoffset;
            }
        }
        else
        {
            LOG(3, "_SWDMX_MpgSetRange prSwdmxInst null\n");
        }

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type = MM_SRC_TYPE_HIGH_SPEED_STORAGE;
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type =
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->e_mm_src_type;
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type ==
                MM_SRC_TYPE_NETWORK_VUDU) ||
               IS_PUSH_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type))
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS = MPG_STC_BASE;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS = MPG_STC_BASE;
            }
        }

#ifdef TIME_SHIFT_SUPPORT
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
        {
            if(prRangeInfo->pt_idxtbl_lst)
            {
                if(prRangeInfo->pt_idxtbl_lst->u.pt_ts_idx_tbl_entry)
                {
                    x_memcpy(&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl,
                        &prRangeInfo->pt_idxtbl_lst->u.pt_ts_idx_tbl_entry->t_tick_ctrl_blk,
                        sizeof(PVR_TICK_CTRL_BLK_T));

                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_start_address = (VOID*)VIRTUAL((UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_start_address);
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_end_address = (VOID*)VIRTUAL((UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_end_address);

                    if((UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.ui4_entry_size != (UINT32)sizeof(SWDMX_MPG_PVR_TICK_INDEX_T))
                    {
                        LOG(0, "ui4_entry_size(%d) != sizeof(SWDMX_MPG_PVR_TICK_INDEX_T)(%d)\n",
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.ui4_entry_size,
                            sizeof(SWDMX_MPG_PVR_TICK_INDEX_T));
                    }

                    if((UINT32)((UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_end_address -
                                (UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_start_address) !=
                        (UINT32)((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.ui4_entry_num) *
                                 prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.ui4_entry_size))
                    {
                        LOG(0, "pv_end_address(0x%x) - pv_start_address(0x%x) != ui4_entry_num(%d) * ui4_entry_size(%d)\n",
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_end_address,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_start_address,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.ui4_entry_num,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.ui4_entry_size);
                    }

                }
                else
                {
                    LOG(3, "pt_ts_idx_tbl_entry null\n");
                }
            }
            else
            {
                LOG(3, "pt_idxtbl_lst null\n");
            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1NumNoSignal = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS = MPG_STC_BASE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastPTS = MPG_STC_BASE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize = 0x0FFFFFFF;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize <<= 32;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize += 0xFFFFFFFF;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize =
                (UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.ui4_lba_init *
                 (UINT64)MPG_LBA_BLOCK_SIZE ;

            {
                UINT64 u8Temp;
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.ui4_fifo_pkt_num > 0)
                {
                    UINT64 u8Remainder;
                    u8Temp = _SWDMX_Div6464(
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize,
                        (UINT32)((UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.ui4_fifo_pkt_num *
                                 (UINT64)MPG_LBA_BLOCK_SIZE),
                        &u8Remainder);
                    u8Temp = u8Remainder;
                }
                else
                {
                    LOG(3, "ui4_fifo_pkt_num = 0\n");
                    u8Temp = 0;
                }

                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFirst)
                {
                    LOG(5, "SetRange File Pos 0x%llx\n",
                        (u8Temp + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.ui8_fifo_offset));
                }
                UNUSED(u8Temp);
            }

            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize +=
                 prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.ui8_fifo_offset;
        }
#endif
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize = 0;
        //_u4AvailSize = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVideoPTSFound = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousIPosWithPTSFound = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8Previous2IPosWithPTSFound = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousSendedSizeOfNon1X = 0;
        // move up
        //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4PreviousPTS = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime = (UINT32)prRangeInfo->ui8_pb_duration;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTimeOffset = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS = ((UINT32)prRangeInfo->t_pts_offset);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstVideoPTS = 0xFFFFFFFF;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SecondVideoPTS = 0xFFFFFFFF;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstAudioModifyPTS = 0xFFFFFFFF;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4DeltaAudioPTS = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastMemoryPTS = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgLastMemory = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpWaitTime.u4Seconds = 1; /*use to trick opr in dlna server time-based */
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpWaitTime.u4Micros = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed = 1000;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgDynamicDuration = prRangeInfo->b_record_ongoing;
        LOG(5, "_SWDMX_MpgSetRange u8FileSize 0x%llx, u8SendedSize 0x%llx, u4TotalTime %lu, u4FirstPTS %d\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize,
            (UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime,
            (UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS);

        // DTV00211081 [MM Compatibility]Video FB for a moment after FF then play with special file
        // For small file with 10 second up duration.
        // divide send data size to a small one.
        // Or when we send one time we will get 20 frames.
        // We can't identify the same one when we resend data.
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize >= MPG_BATCH_SIZE) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize < (1024*1024)) &&
           ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime > (90000*10)) ||
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime == 0)))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize /= (UINT32)MPG_BATCH_TIME_SMALL_FILE;
            LOG(3, "_SWDMX_MpgSetRange use small send size\n");
            if (prSwdmxInst->eSeekType ==  eSWDMX_TYPE_TIME_SEEK)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpWaitTime.u4Seconds = 0; /*use to trick opr in dlna server time-based */
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rJumpWaitTime.u4Micros = 500000;/* wait time: 0.5s */
            }
        }
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize >= MPG_BATCH_SIZE) &&
           ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type ==
                MM_SRC_TYPE_NETWORK_RHAPSODY) ||
            ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type ==
                MM_SRC_TYPE_NETWORK_CMPB) &&
             (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo))))
        {
            //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize /= (UINT32)MPG_BATCH_TIME_RHAPSODY;
            if (_u4DoubleDataSize == 1)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeReadSize /= (UINT32)MPG_BATCH_TIME_RHAPSODY;
            }
            LOG(3, "_SWDMX_MpgSetRange use RHAPSODY send size\n");
        }
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type ==
            MM_SRC_TYPE_NETWORK_CMPB) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_sz_max_acces_unt > 0))
        {
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize > 0) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeReadSize >
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_sz_max_acces_unt))
            {
                UINT32 u4Tmp;
                u4Tmp
                    = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_sz_max_acces_unt;
                u4Tmp /= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize;
                u4Tmp = (u4Tmp == 0) ? 1 : u4Tmp;
                u4Tmp *= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize;
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeReadSize = u4Tmp;
                LOG(3, "u4OneTimeReadSize(%d) use ui4_sz_max_acces_unt(%d)\n",
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_sz_max_acces_unt);
            }
        }
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize >
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeReadSize)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeReadSize =
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize;
        }
        else if(((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize * MPG_BATCH_READ_SIZE) < 
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeReadSize) &&
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_206))
                
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeReadSize = 
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize * MPG_BATCH_READ_SIZE);
        }

        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
        {
            _SWDMX_MpgAudESSetReqSize(u1SrcId);
            
            if (prSwdmxInst->eSeekType == eSWDMX_TYPE_TIME_SEEK)
            {
                STC_StopStc(prSwdmxInst->u1StcId);
                STC_SetStcValue(prSwdmxInst->u1StcId, 0);
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = TRUE;
            }
        }

        //_prRangeList = prRangeList;
        /*while (pBuldIdxTbl != NULL)
        {
            if (pBuldIdxTbl->e_elem_type == MM_ELEMT_TYPE_AUDIO &&
                pBuldIdxTbl->t_strm_id.u.t_stm_avi_id == u4AudStrmID)
            {
                //_prAudIdxTbl = pBuldIdxTbl;
            }
            else if (pBuldIdxTbl->e_elem_type == MM_ELEMT_TYPE_VIDEO &&
                pBuldIdxTbl->t_strm_id.u.t_stm_avi_id == u4VidStrmID)
            {
                //_prVidIdxTbl = pBuldIdxTbl;
            }
            pBuldIdxTbl = (MM_RANGE_ELMT_IDXTBL_T*)pBuldIdxTbl->pv_next_tbl;
        }*/

        prRangeList->eRangeStats = eSWDMX_RANGE_STATE_NOT_FINISHED;
        prRangeList->u4CurPTS =
            (UINT32)prRangeList->prDmxRangeInfo->t_vid_start_render_pts;

        #ifdef SWDMX_MPG_USE_INDEX
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgUseIdx)
        {
            if(!_SWDMX_MpgIdxOpen(u1SrcId,
                (UINT32)(SWDMX_MPG_IDX_TYPE_POSITION | SWDMX_MPG_IDX_TYPE_TIME),
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize))
            {
                LOG(1, "_SWDMX_MpgIdxOpen fail\n");
            }
        }
        #endif
    }
    else
    {
        LOG(0, "Demuxer Range is NULL\n");
    }

    // for audio es, when normal play from start(will not go to handlechangle), i4CurSpeed in rVar will be 0
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed = 1000;

    UNUSED(u4VidStrmID);
    UNUSED(u4AudStrmID);
    UNUSED(u4SubTitleID);
}


/**
*/
SWDMX_HDR_PRS_STATE_T _SWDMX_MpgHeaderParse(
    UINT8 u1SrcId, SWDMX_RANGE_LIST_T* prRangeList,
    SWDMX_CUR_CMD_T* prCmd)
{
    INT32 i4Ret;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    if (prSwdmxInst == NULL)
    {
        return eSWDMX_HDR_PRS_FAIL;
    }
    //LOG(9, "_SWDMX_MpgHeaderParse\n");

    i4Ret = _SWDMX_MpgSendData(u1SrcId, prRangeList, prCmd);
    if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES) &&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio))
    {
        _SWDMX_MpgGetAudioCurrentPos(u1SrcId);
    }
    
    if(i4Ret == MPG_SEND_OK)
    {
        return eSWDMX_HDR_PRS_SUCCEED;
    }
    else if(i4Ret == MPG_SEND_FULL)
    {
        x_thread_delay(10);
        return eSWDMX_HDR_FED_BUF_NOT_ENOUGH;
    }
    else if(i4Ret == MPG_SEND_EOS)
    {
        x_thread_delay(1);
        LOG(7, "_SWDMX_MpgHeaderParse _SWDMX_MpgSendData Finish.\n");
        return eSWDMX_HDR_PRS_SUCCEED;
    }
    else if(i4Ret == MPG_SEND_FAIL)
    {
        x_thread_delay(20);
        LOG(5, "_SWDMX_MpgHeaderParse _SWDMX_MpgSendData Fail.\n");
        return eSWDMX_HDR_FED_BUF_NOT_ENOUGH;
    }
    else if(i4Ret == MPG_SEND_SKIP)
    {
        x_thread_delay(1);
        return eSWDMX_HDR_FED_BUF_NOT_ENOUGH;
    }
    else if(i4Ret == MPG_SEND_WAIT)
    {
        x_thread_delay(1);
        return eSWDMX_HDR_FED_BUF_NOT_ENOUGH;
    }
    else
    {
        x_thread_delay(1);
        LOG(3, "_SWDMX_MpgHeaderParse i4Ret %d unknow.\n", i4Ret);
    }

    LOG(5, "_SWDMX_MpgHeaderParse _SWDMX_MpgSendData Unknow return.\n");
    return eSWDMX_HDR_FED_BUF_NOT_ENOUGH;
}


/**
*/
BOOL _SWDMX_MpgStop(UINT8 u1SrcId)
{
    BOOL fgRet = FALSE;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    LOG(5, "_SWDMX_MpgStop(%d)\n", u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

#ifdef TIME_SHIFT_SUPPORT
    UNUSED(DMX_PVRPlay_SetUseDescramble(FALSE));
#endif

#ifdef TIME_SHIFT_SUPPORT
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        if(!_SWDMX_PVR_Stop(u1SrcId))
        {
            LOG(3, "_SWDMX_MpgStop _SWDMX_PVR_Stop fail\n");
        }

        if(!_SWDMX_PVR_Close(u1SrcId))
        {
            return FALSE;
        }
    }
#endif

    _SWDMX_MpgResetData(u1SrcId);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnVDmx)
    {
        UINT8 u1PidxVideo = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo;

        if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_PS) ||
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG1_DAT))
        {
            fgRet = _SWDMX_MpgPsFreeVideoId(u1SrcId);
        }
        else
        if (IS_TS_FILE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
        {
            fgRet = _SWDMX_MpgTsFreeVideoId(u1SrcId, FALSE);
        }
        else
        if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_VIDEO_ES) ||
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_H264_VIDEO_ES) ||
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG4_VIDEO_ES) ||
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_AVS_VIDEO_ES) ||
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_VC1_ES) ||
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_H265_VIDEO_ES))
        {
            fgRet = _SWDMX_MpgEsFreeVideoId(u1SrcId);
        }

        if(fgRet)
        {
            fgRet = DMX_MUL_FreePidx(u1PidxVideo);
        }
        if(!fgRet)
        {
            LOG(3, "DMX_MUL_FreePidx Fail\n");
            return FALSE;
        }        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnVDmx = FALSE;
    }
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnVDmx2)
    {
        UINT8 u1PidxVideo2 = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo2;
    
        if (IS_TS_FILE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
        {
            fgRet = _SWDMX_MpgTsFreeVideoId(u1SrcId, TRUE);
        }
        if (fgRet)
        {
            fgRet = DMX_MUL_FreePidx(u1PidxVideo2);
        }
        if(!fgRet)
        {
            LOG(3, "DMX_MUL_FreePidx Fail\n");
            return FALSE;
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnVDmx2 =FALSE;
    }
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnADmx)
    {
    UINT8 i;
    DMX_MM_T rPid;
        UINT8 u1PidxAudio;
    SWDMX_AUDIO_STREAM_T *ptAudioStreamInfo = NULL;
        u1PidxAudio = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio;
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_PS) ||
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG1_DAT))
        {
            fgRet = _SWDMX_MpgPsFreeAudioId(u1SrcId);
        }
        else if (IS_TS_FILE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
        {
            fgRet = _SWDMX_MpgTsFreeAudioId(u1SrcId);
        }
        else if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
        {
            fgRet = _SWDMX_MpgEsFreeAudioId(u1SrcId);
        }
        if (fgRet)
        {
            fgRet = DMX_MUL_FreePidx(u1PidxAudio);
        }
        if(!fgRet)
        {
            LOG(3, "DMX_MUL_FreePidx Fail\n");
        }       

    if(prSwdmxInst->fgEnablePrebuffer)
    {
      /* release prebuffer */
      rPid.fgEnable = FALSE;
      ptAudioStreamInfo = &prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.t_audio_stream_info;
      for (i = 0; i < ptAudioStreamInfo->u4_audio_pid_num; i++)
      {
        VERIFY(DMX_MM_Set(ptAudioStreamInfo->t_audio_stream[i].u1Pidx,
                  DMX_MM_FLAG_VALID, &rPid));
        DMX_MM_Free(ptAudioStreamInfo->t_audio_stream[i].u1Pidx);
        DMX_MUL_FreePidx( ptAudioStreamInfo->t_audio_stream[i].u1Pidx);
        DMX_AudHandler_Free(ptAudioStreamInfo->t_audio_stream[i].u1Pidx);
      }
      DMX_AudHandler_SetEnable(FALSE);
      DMX_AudHandler_SetActivePidx(DMX_AUDIO_HANDLER_NULL_PIDX);                
      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSetActivePid = FALSE;
	  prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgPendingATrackIdx = FALSE;
    }
        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudioPlayed = FALSE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnADmx = FALSE;
    }
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnADmx2)
    {
        UINT8 u1PidxAudio2;
        u1PidxAudio2 = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2;
        if (IS_TS_FILE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
        {
            fgRet = _SWDMX_MpgTsFreeAudio2Id(u1SrcId);
        }
        if (fgRet)
        {
            fgRet = DMX_MUL_FreePidx(u1PidxAudio2);
        }
        if(!fgRet)
        {
            LOG(3, "DMX_MUL_FreePidx Fail\n");
        }       

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnADmx2 = FALSE;        
        
    }
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnADmx3)
    {
        UINT8 u1PidxAudio3;
        u1PidxAudio3 = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3;
        if (IS_TS_FILE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
        {
            fgRet = _SWDMX_MpgTsFreeAudio3Id(u1SrcId);
        }
        if (fgRet)
        {
            fgRet = DMX_MUL_FreePidx(u1PidxAudio3);
        }
        if(!fgRet)
        {
            LOG(3, "DMX_MUL_FreePidx Fail\n");
        }       

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnADmx3 = FALSE;        
        
    }    
#if defined(CC_TRUSTZONE_SUPPORT)    
    if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.eEncryptMode == SWDMX_ENCRYPT_MODE_LOCAL_KEY))
    {
        TZ_SWDMX_FreeDecryptBuf();
                
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.eEncryptMode = SWDMX_ENCRYPT_MODE_CLEAR_DATA;    
    }
#endif  
    //UNUSED(VDEC_SetGetSeqHdrOnlyEnd(prSwdmxInst->u1VdecId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVdecPowerOff));
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVdecPowerOff = FALSE;
  
    return TRUE;
}

/**
*/
BOOL _SWDMX_MpgFlush(UINT8 u1SrcId)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    LOG(5, "_SWDMX_MpgFlush(%d)\n", u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed < 0) && (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES))
    {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos)
        {
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset;
            }
            _SWDMX_MpgModifyPlayPos(u1SrcId);
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos;        
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4DeltaAudioPTS = 0;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSetStc = FALSE; // PTS reset
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudioReady = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio = FALSE;   
        }
    }        
    _SWDMX_MpgResetData(u1SrcId);
    return TRUE;
}

BOOL _SWDMX_MpgSetInfo(UINT8 u1SrcId, UINT8 u1Type,UINT32 u4Para1,UINT32 u4Para2,UINT32 u4Para3)
{
#ifdef TIME_SHIFT_SUPPORT
    SWDMX_MPG_PVR_TICK_INDEX_T *prStartAddr;
    SWDMX_MPG_PVR_TICK_INDEX_T *prEndAddr;
    SWDMX_MPG_PVR_TICK_INDEX_T *prTickIndex;
#endif
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

#ifdef TIME_SHIFT_SUPPORT
    if(u1Type == (UINT8)eSWDMX_SET_REC_BUF_RANGE)
    {
        LOG(7, "_SWDMX_MpgSetInfo(%d) u1Type = %d, u4Para1 = %d\n",
            u1SrcId, u1Type, u4Para1);
    }
    else
#endif
    {
        LOG(5, "_SWDMX_MpgSetInfo(%d) u1Type = %d, u4Para1 = %d\n",
            u1SrcId, u1Type, u4Para1);
    }

    if((u1Type == (UINT8)eSWDMX_SET_VIDEOTYPE) ||
       (u1Type == (UINT8)eSWDMX_SET_VIDEO2TYPE) ||
       (u1Type == (UINT8)eSWDMX_SET_SUBVIDEOTYPE))
    {
        return TRUE;
    }
    else if(u1Type == (UINT8)eSWDMX_SET_AUDIOTYPE)
    {
        return TRUE;
    }
    // 0831
    else if(u1Type == (UINT8)eSWDMX_SET_AUDIO2TYPE)
    {
        return TRUE;
    }
    // 0831
    else if(u1Type == (UINT8)eSWDMX_SET_AUDIO3TYPE)
    {
        return TRUE;
    }    
    else if(u1Type == (UINT8)eSWDMX_SET_VIDEO_DECRYPT)
    {
       LOG(5, "_SWDMX_MpgSetInfo  eSWDMX_SET_VIDEO_DECRYPT %d,%d\n", u4Para1, u4Para2);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1VideoKeyIndex = (UINT16)u4Para1;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u4VideoDescMode = (UINT8)u4Para2;
        return TRUE;
    }
    else if(u1Type == (UINT8)eSWDMX_SET_AUDIO_DECRYPT)
    {
        LOG(5, "_SWDMX_MpgSetInfo  eSWDMX_SET_AUDIO_DECRYPT %d,%d\n", u4Para1, u4Para2);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1AudioKeyIndex = (UINT16)u4Para1;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u4AudioDescMode = (UINT8)u4Para2;
        return TRUE;
    }
    // 0831
    else if(u1Type == (UINT8)eSWDMX_SET_AUDIO2_DECRYPT)
    {
        LOG(5, "_SWDMX_MpgSetInfo  eSWDMX_SET_AUDIO2_DECRYPT %d,%d\n", u4Para1, u4Para2);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1Audio2KeyIndex = (UINT16)u4Para1;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u4Audio2DescMode = (UINT8)u4Para2;
        return TRUE;
    }
    // 0831
    else if(u1Type == (UINT8)eSWDMX_SET_AUDIO3_DECRYPT)
    {
        LOG(5, "_SWDMX_MpgSetInfo  eSWDMX_SET_AUDIO3_DECRYPT %d,%d\n", u4Para1, u4Para2);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1Audio3KeyIndex = (UINT16)u4Para1;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u4Audio3DescMode = (UINT8)u4Para2;
        return TRUE;
    }
    else if(u1Type == (UINT8)eSWDMX_SET_VID_PID_IDX)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2VideoPidIdx = (UINT16)u4Para1;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1VideoKeyIndex = (UINT8)u4Para2;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u4VideoDescMode = u4Para3;
        return TRUE;
    }
    else if(u1Type == (UINT8)eSWDMX_SET_AUD_PID_IDX)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2AudioPidIdx = (UINT16)u4Para1;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1AudioKeyIndex = (UINT8)u4Para2;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u4AudioDescMode = u4Para3;
        return TRUE;
    }
    else if(u1Type == (UINT8)eSWDMX_SET_PCR_PID_IDX)
    {
        //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2PcrPidIdx = (UINT16)u4Para1;
        return TRUE;
    }
    else if(u1Type == (UINT8)eSWDMX_SET_CHK_PSI_BUF_SIZE)
    {
        #ifndef SWDMX_MPG_USE_MTMPLAYER_PVR
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPSISize = ((u4Para1 > 0) ? TRUE : FALSE);
        #endif
        return TRUE;
    }
    else if(u1Type == (UINT8)eSWDMX_PID_INDEX_START)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2PidIdxStart = (UINT16)(u4Para1);
        return TRUE;
    }
    else if(u1Type == (UINT8)eSWDMX_SET_VID_SCRAMBLE_NFY)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.pfnVScrambleNfy = (VOID*)(u4Para1);
        return TRUE;
    }
    else if(u1Type == (UINT8)eSWDMX_SET_AUD_SCRAMBLE_NFY)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.pfnAScrambleNfy = (VOID*)(u4Para1);
        return TRUE;
    }
    else if(u1Type == (UINT8)eSWDMX_SET_SYSTEM_B)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSystemB = (BOOL)(u4Para1);
        return TRUE;
    }
    else if(u1Type == (UINT8)eSWDMX_SET_HDMVC_INFO)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgHdMvc = (BOOL)(u4Para1);
        return TRUE;
    }
#ifdef TIME_SHIFT_SUPPORT
    else if(u1Type == (UINT8)eSWDMX_SET_REC_BUF_RANGE)
    {
        if(u4Para1 == 0)
        {
            LOG(3, "_SWDMX_MpgSetInfo eSWDMX_SET_REC_BUF_RANGE u4Para1 null\n");
            return FALSE;
        }

        _SWDMX_LockRangeSema(u1SrcId);

        x_memcpy(&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo,
            (MM_REC_BUF_RANGE_INFO_T*)u4Para1, sizeof(MM_REC_BUF_RANGE_INFO_T));

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TickBase =
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.ui4_tick_period;
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TickBase == 0)
        {
            LOG(1, "_SWDMX_MpgSetInfo ui4_tick_period 0\n");
            //ASSERT(0);
            _SWDMX_UnlockRangeSema(u1SrcId);
            return FALSE;
        }

        // start addr
        prStartAddr = (SWDMX_MPG_PVR_TICK_INDEX_T*)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_start_address;
        if(prStartAddr == NULL)
        {
            LOG(3, "_SWDMX_MpgSetInfo pv_start_address null\n");
            _SWDMX_UnlockRangeSema(u1SrcId);
            return FALSE;
        }

        // end addr
        // from the explain of mw pv_end_address is the end address of the tick_index_talbe;
        prEndAddr = (SWDMX_MPG_PVR_TICK_INDEX_T*)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_end_address -1;
        if(prEndAddr == NULL)
        {
            LOG(3, "_SWDMX_MpgSetInfo pv_end_address null\n");
            _SWDMX_UnlockRangeSema(u1SrcId);
            return FALSE;
        }

        //  0  u8FifoOffset (u8FifoStart)   lba_init (Start lba)    u8FifoSize
        // (Max file size = u8FifoSize + u8FifoOffset)
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset =
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.ui8_fifo_offset;

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoSize =
            (((UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.ui4_fifo_pkt_num)
            *(UINT64)MPG_LBA_BLOCK_SIZE);

        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoSize == 0)
        {
            LOG(3, "_SWDMX_MpgSetInfo u8FifoSize 0\n");
            _SWDMX_UnlockRangeSema(u1SrcId);
            return FALSE;
        }

        // safe start
        prTickIndex = (SWDMX_MPG_PVR_TICK_INDEX_T*)
            (prStartAddr + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_safe.ui4_start);
        if((prTickIndex == NULL) || (prTickIndex > prEndAddr))
        {
            LOG(3, "_SWDMX_MpgSetInfo safe start prTickIndex fail\n");
            _SWDMX_UnlockRangeSema(u1SrcId);
            return FALSE;
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SafeStartAddr =
            _SWDMX_MpgLBA2Pos(u1SrcId, ((prTickIndex)->ui4_lba));
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeStartTick =
            prTickIndex->ui4_tick_num;

        // safe end
        prTickIndex = (SWDMX_MPG_PVR_TICK_INDEX_T*)
            (prStartAddr + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_safe.ui4_end);
        if((prTickIndex == NULL) || (prTickIndex > prEndAddr))
        {
            LOG(3, "_SWDMX_MpgSetInfo safe end prTickIndex fail\n");
            _SWDMX_UnlockRangeSema(u1SrcId);
            return FALSE;
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SafeEndAddr =
            _SWDMX_MpgLBA2Pos(u1SrcId, ((prTickIndex)->ui4_lba));
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeEndTick =
            prTickIndex->ui4_tick_num;

        // valid start
        prTickIndex = (SWDMX_MPG_PVR_TICK_INDEX_T*)
            (prStartAddr + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_start);
        if((prTickIndex == NULL) || (prTickIndex > prEndAddr))
        {
            LOG(3, "_SWDMX_MpgSetInfo valid start prTickIndex fail\n");
            _SWDMX_UnlockRangeSema(u1SrcId);
            return FALSE;
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ValidStartAddr =
            _SWDMX_MpgLBA2Pos(u1SrcId, ((prTickIndex)->ui4_lba));
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ValidStartTick =
            prTickIndex->ui4_tick_num;

        // valid end
        prTickIndex = (SWDMX_MPG_PVR_TICK_INDEX_T*)
            (prStartAddr + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_end);
        if((prTickIndex == NULL) || (prTickIndex > prEndAddr))
        {
            LOG(3, "_SWDMX_MpgSetInfo valid end prTickIndex fail\n");
            _SWDMX_UnlockRangeSema(u1SrcId);
            return FALSE;
        }

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ValidEndAddr =
            _SWDMX_MpgLBA2Pos(u1SrcId, ((prTickIndex)->ui4_lba));
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ValidEndTick =
            prTickIndex->ui4_tick_num;

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorValidStart = TRUE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorValidEnd = TRUE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeStart = TRUE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeEnd = TRUE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgValidRange = TRUE;

        if(prSwdmxInst)
        {
            if(prSwdmxInst->eSwDmxStatus == eSWDMX_STATE_PAUSE)
            {
                if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos) <
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SafeStartAddr))
                {
                    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeStart) &&
                       (!prSwdmxInst->fgPlayChange) && // not changing speed
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed < 0))
                    {
                        LOG(3, "UpdateRange fgMonitorSafeStart addr 0x%llx safe start addr 0x%llx\n",
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SafeStartAddr);
                        if((prSwdmxInst) &&
                           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
                        {
                            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
                            {
                                _SWDMX_RANGE_CALLBACK(
                                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                                    MM_OUT_OF_SAFE_RANGE_START,
                                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                                    0xFFFFFFFF,
                                    (UINT32)u1SrcId);
                            }
                        }
                    }
                }

                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ValidStartAddr)
                {
                    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorValidStart) &&
                       (!prSwdmxInst->fgPlayChange) && // not changing speed
                       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed < 0))
                    {
                        LOG(3, "UpdateRange fgMonitorValidStart addr 0x%llx valid start addr 0x%llx\n",
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ValidStartAddr);
                        if((prSwdmxInst) &&
                           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
                        {
                            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
                            {
                                _SWDMX_RANGE_CALLBACK(
                                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                                    MM_REACH_VALID_RANGE_START,
                                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                                    0xFFFFFFFF,
                                    (UINT32)u1SrcId);
                            }
                        }
                    }
                }
            }
        }
        else
        {
            LOG(3, "_SWDMX_MpgSetInfo prSwdmxInst null\n");
            _SWDMX_UnlockRangeSema(u1SrcId);
            return FALSE;
        }

        _SWDMX_UnlockRangeSema(u1SrcId);

        return TRUE;
    }
    else if(u1Type == (UINT8)eSWDMX_PRINT_REC_BUF_STATUS)
    {
        _SWDMX_LockRangeSema(u1SrcId);
        LOG(0, "Monitor: Safe start(%d) end(%d), Valid start(%d) end(%d)\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeStart,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeEnd,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorValidStart,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorValidEnd);
        LOG(0, "Range Addr: 0x%llx 0x%llx 0x%llx 0x%llx\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ValidStartAddr,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SafeStartAddr,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SafeEndAddr,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ValidEndAddr);
        LOG(0, "Range num (0x%x-0x%x): %d %d %d %d\n",
            (UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_start_address,
            (UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_end_address,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_start,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_safe.ui4_start,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_safe.ui4_end,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_end);
        LOG(0, "Range Tick (%d): %d %d %d %d\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TickBase,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ValidStartTick,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeStartTick,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeEndTick,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ValidEndTick);
        LOG(0, "Fifo: Start 0x%llx, Size 0x%llx\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoSize);
        _SWDMX_UnlockRangeSema(u1SrcId);
    }
    else if(u1Type == (UINT8)eSWDMX_SET_MONITOF_LBA)
    {
        if(u4Para1 == (UINT32)0xFFFFFFFF)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorLBA = FALSE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8MonitorAddr = 0;
        }
        else
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorLBA = TRUE;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8MonitorAddr =
                _SWDMX_MpgLBA2Pos(u1SrcId, (u4Para1));
        }
        return TRUE;
    }
#endif
    else if(u1Type == (UINT8)eSWDMX_SET_FILE_SZ_UPDATE)
    {
        UINT64      ui8file_sz = 0;
        UINT32      ui4_total_dur = 0;
        
        if(u4Para1 == 0)
        {
            LOG(3, "_SWDMX_MpgSetInfo eSWDMX_SET_FILE_SZ_UPDATE FILE SIZE POINTER null\n");
            return FALSE;
        }
        ui8file_sz = ((MM_ONGOING_REC_FILE_INFO_T*)u4Para1)->ui8_file_sz;
        ui4_total_dur = ((MM_ONGOING_REC_FILE_INFO_T*)u4Para1)->ui4_total_dur;
        if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgDynamicDuration)
        {
            LOG(3,"dectect file duration dynamic update,ui8file_sz : %llu , FileSize : %llu!\n",
                ui8file_sz,prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize);
            if(ui8file_sz > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgDynamicDuration = TRUE;
            }
        }
        else
        {
            if(ui8file_sz != 0)
            {
                if(ui8file_sz < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize)
                {
                    LOG(0,"fatal error , file size should not reduce!\n");
                    LOG(0,"current file size : %llu , ui8file_sz : %llu!\n",
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize,ui8file_sz);
                }
            }
            else
            {
                LOG(3,"dectect ongoing rec stop , disable dynamic duration!\n");
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgDynamicDuration = FALSE;
                return TRUE;
            }
        }
        LOG(6,"u8FileSize : %llu , ui4_total_dur : %d!\n",ui8file_sz,ui4_total_dur);

        prSwdmxInst->u4TotalTime = ui4_total_dur;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize 
            = ui8file_sz;

        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FakeTime)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime = prSwdmxInst->u4TotalTime - 
                ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FakeTime>PER_PARSE_DATA_SIZE)?
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FakeTime-PER_PARSE_DATA_SIZE):(0))*90000; 
        } else
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime = ui4_total_dur;
        }

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPauseMoving = TRUE;     
    }
    else if(u1Type == (UINT8)eSWDMX_PRINT_INTERNAL_STATUS)
    {
            UINT32 u4Addr, u4Size;
      
#ifdef TIME_SHIFT_SUPPORT
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
        {
            VDP_PIC_INFO_T rVdpPicInfo;
            UCHAR ucVdpId = 0; // prSwdmxInst->u1B2rId
            UINT32 u4TickAudio = 0;
            UINT32 u4TickVideo = 0;
            x_memset(&rVdpPicInfo, 0, sizeof(VDP_PIC_INFO_T));
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) &&
               (VDP_GetPicInfo(ucVdpId, &rVdpPicInfo) == VDP_SET_OK))
            {
                u4TickVideo = rVdpPicInfo.u4TickNum;
            }
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
            {
                UNUSED(AUD_MMFindTickInfo(prSwdmxInst->u1AdecId, &u4TickAudio));
            }
            // 0831
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio2)
            {
                UNUSED(AUD_MMFindTickInfo(prSwdmxInst->u1Adec2Id, &u4TickAudio));
            }
            // 0831
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio3)
            {
                UNUSED(AUD_MMFindTickInfo(prSwdmxInst->u1Adec3Id, &u4TickAudio));
            }
            LOG(0, "CurTickNum: Video(%d) Audio(%d) Swdmx(%d)\n",
                u4TickVideo, u4TickAudio, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum);
        }
#endif
        LOG(0, "Cur: u8SendedSize(0x%llx) u8ReadedPos(0x%llx)\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos);
        LOG(0, "rBuf: u4BufTotalSize(%d) u4ReqTotalSize(%d)\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufTotalSize,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize);
        #ifdef SWDMX_MPG_DMX_20
            LOG(0, "AvailableAFifo(%d) AvailableVFifo(%d)\n",
                DMX_MUL_GetEmptySize(prSwdmxInst->u1DmxId,
                    DMX_PID_TYPE_ES_AUDIO,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio),
                DMX_MUL_GetEmptySize(prSwdmxInst->u1DmxId,
                    DMX_PID_TYPE_ES_VIDEO,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo));
                    
            LOG(0,"AvailableAuxFifo(%d) AvailableTHDFifo(%d)\n",
                DMX_MUL_GetEmptySize(prSwdmxInst->u1DmxId,
                DMX_PID_TYPE_ES_AUDIO,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2),
                DMX_MUL_GetEmptySize(prSwdmxInst->u1DmxId,
                DMX_PID_TYPE_ES_AUDIO,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3));
                
            _SWDMX_GetAudioFifo(u1SrcId, &u4Addr, &u4Size);            
            LOG(0,"Audio Main Fifo StartAddr 0x%x Size 0x%x \n",u4Addr,u4Size);
            _SWDMX_GetAudio2Fifo(u1SrcId, &u4Addr, &u4Size);            
            LOG(0,"Audio Aux Fifo StartAddr 0x%x Size 0x%x \n",u4Addr,u4Size);
            _SWDMX_GetAudio3Fifo(u1SrcId, &u4Addr, &u4Size);            
            LOG(0,"Audio Thd Fifo StartAddr 0x%x Size 0x%x \n",u4Addr,u4Size);
            _SWDMX_GetVideoFifo(u1SrcId, &u4Addr, &u4Size);            
            LOG(0,"Video the first Fifo StartAddr 0x%x Size 0x%x \n",u4Addr,u4Size);
            if (prSwdmxInst->pVFifo2Info)
            {
                _SWDMX_GetVideo2Fifo(u1SrcId, &u4Addr, &u4Size);       
                LOG(0,"Video the second Fifo StartAddr 0x%x Size 0x%x \n",u4Addr,u4Size);
            }
            
        #else
#ifdef CC_DMX_PURE_AUDIO
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
        {
            LOG(0, "AvailableAFifo(%d) AvailableVFifo(%d)\n",
                DMX_MM_GetBufEmptySize(
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio),
                0);
           }
        else
#endif
        {
            LOG(0, "AvailableAFifo(%d) AvailableVFifo(%d)\n",
                DMX_GetMinFreeBufferSize(DMX_PID_TYPE_ES_AUDIO),
                DMX_GetMinFreeBufferSize(DMX_PID_TYPE_ES_VIDEO));
        }
        #endif
        LOG(0, "Speed: %d\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed);
    }
    else if(u1Type == (UINT8)eSWDMX_SET_AOUT_ENABLE)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio = TRUE;
        // 0831 ??
        if(prSwdmxInst->fgEnAudio2Dmx)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio2 = TRUE;            
        }
        // 0831 ??
        if(prSwdmxInst->fgEnAudio3Dmx)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio3 = TRUE;
        }   
        LOG(5, "Call AUD_MMAoutEnable from VDP\n");
    }
    else if (u1Type == (UINT8)eSWDMX_TYPE_GNRC_ALL_STREAM_INFO)
    {   
        x_memset((void*)&gt_gnrc_stream,0x0,sizeof(MM_GNRC_STREAM_T));
        x_memcpy((void*)&gt_gnrc_stream,(void*)u4Para1,sizeof(MM_GNRC_STREAM_T));
        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgNotifyAllAudPid =TRUE;   
		prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgAudioExist = gt_gnrc_stream.fg_aud_exist;

        LOG(1," notify aud all pid\n");
    }
    else if (u1Type == (UINT8)eSWDMX_TYPE_SET_HDCP_KEY)
    {
#ifdef LINUX_TURNKEY_SOLUTION                 
        if ((UINT8*)u4Para1 != NULL)
        {
            g_ptHDCPKey = (UINT8*)u4Para1;
            LOG(5,"Set HDCP Key info OK\n");
            LOG(5,"Key 0x%02x%02x%02x%02x%02x%02x%02x%02x\n",
                g_ptHDCPKey[0],
                g_ptHDCPKey[1],
                g_ptHDCPKey[2],
                g_ptHDCPKey[3],
                g_ptHDCPKey[4],
                g_ptHDCPKey[5],
                g_ptHDCPKey[6],
                g_ptHDCPKey[7]);
        }      
#endif          
    }        
    else if(u1Type == (UINT8)eSWDMX_SET_DURATION)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime = u4Para1;
		
        LOG(1, "The File Total Time(%u)\n", prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime);
		
		if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type  == MM_SRC_TYPE_NETWORK_CMPB)	
		{
            if(90000 <= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime )
            {
            	UINT32  u4AudioTmpThreshold = 0;
				UINT64  u8Remainder = 0;
				
                u4AudioTmpThreshold = _SWDMX_Div6464(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize, 
                                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime/90000, &u8Remainder);

				LOG(5,"u4AudioTmpThreshold %d\n",u4AudioTmpThreshold);
                
    			if (u4AudioTmpThreshold < AVG_BIT_RATE_THRESHOLD) 
    			    
    			{
                    prSwdmxInst->fgEnablePrebuffer = TRUE;
    			}											
            }		
			
			/* for debug ,if audio dec fmt is lpcm ,can not enable this flag */
			if (PREBUFFER_FORCE_ENABLE == prSwdmxInst->ui8ForceEnablePrebuffer)
			{
				prSwdmxInst->fgEnablePrebuffer = TRUE;
			}
			else if (PREBUFFER_FORCE_DISABLE == prSwdmxInst->ui8ForceEnablePrebuffer)
			{
				prSwdmxInst->fgEnablePrebuffer = FALSE;
			}			
			
		}		
        return TRUE;
    }

    UNUSED(u4Para2);
    UNUSED(u4Para3);
    return FALSE;
}


BOOL _SWDMX_MpgGetInfo(UINT8 u1SrcId, UINT8 u1Type,UINT32* pu4Para1,UINT32* pu4Para2,UINT32* pu4Para3)
{
    UINT64 *pu8Tmp;
    UINT64 u8Offset, u8OffsetI;
    UINT16 u2DecodingOrder;
    /*UINT16 u2QueueSize, u2MaxQueueSize;*/
    INT32 i4TempRef;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
    LOG(6, "_SWDMX_MpgGetInfo u1Type = %d\n", u1Type);

    if(u1Type == (UINT8)eSWDMX_SET_CHK_PSI_BUF_SIZE)
    {
        if(pu4Para1 == NULL)
        {
            LOG(1, "_SWDMX_MpgGetInfo pu4Para1 = NULL\n");
            return FALSE;
        }
        *pu4Para1 = (UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPSISize;
        return TRUE;
    }
    else if(u1Type == (UINT8)eSWDMX_GET_CURRENT_TIME)
    {     
    if(pu4Para1 == NULL)
        {
            LOG(1, "_SWDMX_MpgGetInfo pu4Para1 = NULL\n");
            return FALSE;
        }    

        {
            UINT64 u8Tmp;
            UINT64 u8CurPos;
            UINT64 u8Remainder;

            *pu4Para1 = 0;

            u8CurPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
            {
                u8Offset = 0;
                u8OffsetI = 0;
                u2DecodingOrder = 0;
                i4TempRef = 0;
                if(VDP_GetFilePosition(prSwdmxInst->u1B2rId, &i4TempRef, &u2DecodingOrder, &u8Offset, &u8OffsetI))
                {
                    if(u8Offset > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize)
                    {
                        LOG(7, "_SWDMX_MpgGetInfo VDP_GetFilePosition u8Offset %d > u8FileSize %d\n",
                            (UINT32)u8Offset, (UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize);
                        u8CurPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize;
                    }
                }
            }
            else if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
            {
                if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
                   &&
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed < 0))
                   // do not need to consider changing
                   // because we could get our swdmx current position
                   // that's the correct one.
                   //(prSwdmxInst) &&
                   //(!prSwdmxInst->fgPlayChange) && // not changing speed
                {
                    u8CurPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr;
                    // seek end
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr)
                    {
                        u8CurPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize;
                    }
                }
                else
                {
                    UINT32 u4DmxAvailSizeAudio = 0;
                    UINT32 u4Addr, u4Size;
                    UINT32 u4BufSize;
                    UINT32 u4DataSize;
                    #ifdef SWDMX_MPG_DMX_20
                    u4DmxAvailSizeAudio = DMX_MUL_GetEmptySize(prSwdmxInst->u1DmxId,
                        DMX_PID_TYPE_ES_AUDIO,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio);
                    #else
#ifdef CC_DMX_PURE_AUDIO
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
                    {
                        u4DmxAvailSizeAudio = DMX_MM_GetBufEmptySize(
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio);
                    }
                    else
#endif
                    {
                        u4DmxAvailSizeAudio = DMX_GetMinFreeBufferSize(DMX_PID_TYPE_ES_AUDIO);
                    }
                    #endif

                    if(!_SWDMX_GetAudioFifo(u1SrcId, &u4Addr, &u4Size))
                    {
                        LOG(3, "_SWDMX_MpgEsSetAudioId _SWDMX_GetAudioFifo Fail\n");
                        return FALSE;
                    }

                    u4BufSize = u4Size;
                    u4DataSize = u4BufSize - u4DmxAvailSizeAudio;
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize > u4DataSize)
                    {
                        u8CurPos = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize - u4DataSize);
                    }
                    else
                    {
                        u8CurPos = 0;
                    }
                    #if 0
                    LOG(0, "---GetInfo %d %d %d (%d-%d)\n",
                        (UINT32)*pu8Tmp, (UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize, u4DataSize,
                        u4BufSize, u4DmxAvailSizeAudio);
                    #endif
                }
            }

            if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime > 0) &&
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize > 0))
            {
                //90000->90000
                u8Tmp = _SWDMX_Div6464((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset)*(UINT64)90000,
                                  (UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime ,
                                  &u8Remainder);
                if(u8Tmp > 0)
                {
                    if(u8CurPos > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset)
                    {
                        *pu4Para1 = (UINT32)_SWDMX_Div6464((u8CurPos-prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset)*(UINT64)90000,
                                                   u8Tmp, &u8Remainder);
                    }
                    else
                    {
                        *pu4Para1 = 0;
                    }
                }
                UNUSED(u8Remainder);
            }
        }

        if(//(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed >= 0) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst->u.pt_pb_idx_tbl_entry)
          )
        {
            MM_RANGE_ELEMT_IDXTBL_PB_ENTRY_T* prTblEntry = NULL;
            MM_RANGE_ELMT_IDXTBL_T* prIdxTbl = NULL;
            {
                prIdxTbl = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst;
                prTblEntry = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst->u.pt_pb_idx_tbl_entry;
                if((prTblEntry) && (prIdxTbl))
                {
                    //*pu4Para1 = prTblEntry[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurIndexNum].ui4_pts;
                    *pu4Para1 = STC_GetStcValue(prSwdmxInst->u1StcId);
                }
                else
                {
                    LOG(3, "_SWDMX_MpgGetInfo prTblEntry NULL\n");
                }
            }
        }

        return TRUE;
    }
    else if(u1Type == (UINT8)eSWDMX_GET_CURRENT_POSITION)
    {
      BOOL b_enable_log = FALSE;    
    
        if(pu4Para1 == NULL)
        {
            LOG(1, "_SWDMX_MpgGetInfo pu4Para1 = NULL\n");
            return FALSE;
        }

        b_enable_log = ((prSwdmxInst->u4LogFilter & check_cur_pos) != 0)? TRUE : FALSE;
        pu8Tmp = (UINT64*)(VOID*)pu4Para1;

        *pu8Tmp = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
        {
            VDEC_HDR_INFO_T rHdrInfo;

            u8Offset = 0;
            u8OffsetI = 0;
            u2DecodingOrder = 0;
            i4TempRef = 0;

            x_memset(&rHdrInfo, 0, sizeof(rHdrInfo));
            
            if (VDEC_QueryInfo(prSwdmxInst->u1VdecId, &rHdrInfo) &&
              prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo &&
              rHdrInfo.u4DisplayQPicCnt > 0)
            {                
              if(VDP_GetFilePosition(prSwdmxInst->u1B2rId, &i4TempRef, &u2DecodingOrder, &u8Offset, &u8OffsetI))
              {
                if(u8Offset > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize)
                {
                  if(b_enable_log)
                  {
                      LOG(1, "[eSWDMX_GET_CURRENT_POSITION]_SWDMX_MpgGetInfo VDP_GetFilePosition u8Offset 0x%llx > u8FileSize 0x%llx\n",
                            u8Offset, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize);
                  }                    
                    *pu8Tmp = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize;
                }
                else
                {
                    VDP_PIC_INFO_T rVdpPicInfo;
                    x_memset(&rVdpPicInfo, 0, sizeof(VDP_PIC_INFO_T));
                    if (VDP_GetPicInfo(prSwdmxInst->u1B2rId, &rVdpPicInfo) == VDP_SET_OK)
                    {
                        *pu8Tmp = rVdpPicInfo.u8OffsetDisp;
                        if(b_enable_log)
                        {
                           LOG(1, "[eSWDMX_GET_CURRENT_POSITION]VDP_GetPicInfo u8OffsetDisp 0x%llx\n", rVdpPicInfo.u8OffsetDisp);
                        } 
                    }
                    else
                    {
                      if(b_enable_log)
                      {
                        LOG(1, "[eSWDMX_GET_CURRENT_POSITION]VDP_GetPicInfo failed \n");
                      } 
                    }
                }
              }
              else
              {
                  if(b_enable_log)
                  {
                      LOG(1, "[eSWDMX_GET_CURRENT_POSITION]VDP_GetFilePosition failed \n");
                  } 
                  *pu8Tmp=0;
              }             
            }
            else
            {
                DMX_MM_T rDMXInfo = {0};
                UINT32 u4VDataSize = 0, u4ADataSize = 0;
                
                x_memset(&rDMXInfo, 0, sizeof(DMX_MM_T));
                if(b_enable_log)
                {
                   LOG(1, "get pos from dmx fgEnableVideo %d DisplayQPicCnt %u\n", prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo, rHdrInfo.u4DisplayQPicCnt);
                } 

                if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio &&
                    0xFF != prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio)
                {
                    if (DMX_MM_Get(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio,
                        DMX_MM_FLAG_BUF, &rDMXInfo))
                    {
                        u4ADataSize = (rDMXInfo.u4Wp < rDMXInfo.u4Rp) ?
                            (rDMXInfo.u4BufSize + rDMXInfo.u4Wp - rDMXInfo.u4Rp) : (rDMXInfo.u4Wp - rDMXInfo.u4Rp);
                    }
                    else
                    {
                      if(b_enable_log)
                      {
                        LOG(1, "[eSWDMX_GET_CURRENT_POSITION]get dmx audio data size failed \n");
                      } 
                      return FALSE;
                    }
                }
                
                x_memset(&rDMXInfo, 0, sizeof(DMX_MM_T));
                if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo &&
                    0xFF != prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo)
                {
                    if (DMX_MM_Get(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo,
                        DMX_MM_FLAG_BUF, &rDMXInfo))
                    {
                        u4VDataSize = (rDMXInfo.u4Wp < rDMXInfo.u4Rp) ?
                            (rDMXInfo.u4BufSize + rDMXInfo.u4Wp - rDMXInfo.u4Rp) : (rDMXInfo.u4Wp - rDMXInfo.u4Rp);
                    }
                    else
                    {
                      if(b_enable_log)
                      {
                        LOG(1, "[eSWDMX_GET_CURRENT_POSITION]get dmx audio data size failed \n");
                      }
                      return FALSE;
                    }
                }
                
                if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize > u4ADataSize)
                {
                    *pu8Tmp = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize - u4ADataSize);
                    
                    if(*pu8Tmp > u4VDataSize)
                    {
                        *pu8Tmp = *pu8Tmp - u4VDataSize;
                    }
                    else
                    {
                        *pu8Tmp = 0;
                    }
                }
                else
                {
                    *pu8Tmp = 0;
                }       

               if(b_enable_log)
               {
                    LOG(1, "[eSWDMX_GET_CURRENT_POSITION]dmx audio size 0x%llX video size 0x%llX sended size 0x%llX\n",
                            u4ADataSize, u4VDataSize, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize);
               }                 
            }
      
            //DTV00572656 when fr to start, the sended size is set as filesz
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192)
                     &&
                     (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed < 0)
                     &&
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousUIPos < *pu8Tmp))
            
            {   
                if(b_enable_log)
                {
                  LOG(1, "[eSWDMX_GET_CURRENT_POSITION]tshift rewind u8PreviousUIPos 0x%llX < current pos 0x%llX\n",
                      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousUIPos, *pu8Tmp);
                }
                *pu8Tmp = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousUIPos;          
            }
            else
            {
              prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousUIPos = *pu8Tmp;
            }
          }
        else if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
        {
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
               &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed < 0))
               // do not need to consider changing
               // because we could get our swdmx current position
               // that's the correct one.
               //(prSwdmxInst) &&
               //(!prSwdmxInst->fgPlayChange) && // not changing speed
            {
                UINT64 u8PreviousUIPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousUIPos;
                UINT64 u8JumpStartAddr = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr;
                
                if (u8PreviousUIPos < u8JumpStartAddr )
                {
                    *pu8Tmp = u8PreviousUIPos;
                }
                else
                {
                    *pu8Tmp = u8JumpStartAddr;
                }
                         
                LOG(1,"---GetInfo *pu8Tmp 0x%llx u8JumpStartAddr 0x%llx u8PreviousUIPos 0x%llx\n",*pu8Tmp,u8JumpStartAddr,u8PreviousUIPos);
                // seek end
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8JumpStartAddr)
                {
                    *pu8Tmp = 0;
                }
            }
            else
            {
                DMX_MM_T rDMXInfo;
                UINT32 u4DataSize = 0;
                UINT32 u4DmxAvailSizeAudio = 0;
                x_memset(&rDMXInfo, 0, sizeof(DMX_MM_T));

                if (0xFF != prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio)
                {
                    if (DMX_MM_Get(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio,
                        DMX_MM_FLAG_BUF, &rDMXInfo))
                    {
                        u4DataSize = (rDMXInfo.u4Wp < rDMXInfo.u4Rp) ?
                            (rDMXInfo.u4BufSize + rDMXInfo.u4Wp - rDMXInfo.u4Rp) : (rDMXInfo.u4Wp - rDMXInfo.u4Rp);
                    }
                    else
                    {
                        if(b_enable_log)
                        {
                          LOG(1, "[eSWDMX_GET_CURRENT_POSITION]audio only, get dmx audio data size failed \n");
                        } 
                        return FALSE;
                    }
                }
                else
                {
                    return FALSE;
                }
                
                if(u4DataSize > u4DmxAvailSizeAudio)
                {
                    u4DataSize -= u4DmxAvailSizeAudio;
                }
                else
                {
                    u4DataSize = 0; 
                }
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize > u4DataSize)
                {
                    *pu8Tmp = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize - u4DataSize;
                }
                else
                {
                    *pu8Tmp = 0;
                }
                if(b_enable_log)
                {
                    LOG(1, "[eSWDMX_GET_CURRENT_POSITION]audio only GetInfo %d %d %d %d\n",
                        (UINT32)*pu8Tmp, (UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize, u4DataSize,
                        u4DmxAvailSizeAudio);
                }
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PreviousUIPos = *pu8Tmp;              
            }
        }
    if(b_enable_log)
    {
        LOG(1, "[eSWDMX_GET_CURRENT_POSITION]result 0x%llX\n",*pu8Tmp);
    }
    return TRUE;
    }
#ifdef TIME_SHIFT_SUPPORT
    else if(u1Type == (UINT8)eSWDMX_GET_CURRENT_TICK)
    {
        if(pu4Para1 == NULL)
        {
            LOG(1, "_SWDMX_MpgGetInfo pu4Para1 = NULL\n");
            return FALSE;
        }
        if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)&&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio)) //DTV0077970  for audio only program, when nosignal status, we use u4CurTickNum,
        {
            // pu4Para1 will be set in AUD_MMFindTickInfo
            if(!AUD_MMFindTickInfo(prSwdmxInst->u1AdecId, pu4Para1))
            {
                *pu4Para1 = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum;
            }
        }
        else
        {
            *pu4Para1 = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum;
        }
        return TRUE;
    }

    else if(u1Type == (UINT8)eSWDMX_GET_CURRENT_LBA)
    {
        UINT64 u8Tmp;
        UINT64 u8Remainder;
        if(pu4Para1 == NULL)
        {
            LOG(1, "_SWDMX_MpgGetInfo pu4Para1 = NULL\n");
            return FALSE;
        }
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset)
        {
          u8Tmp = _SWDMX_Div6464(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize -prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset,
                               (UINT64)(MPG_LBA_BLOCK_SIZE), &u8Remainder);
         // Current MW use UINT32 to get LBA,
         // We might change to UINT64 in the future.
         *pu4Para1 = (UINT32)u8Tmp;
         //        x_memcpy((void*)pu4Para1, // UINT64
         //            &u8Tmp,
         //            sizeof(UINT64));
        }
        else
        {
            *pu4Para1=0;

        }
        return TRUE;
    }
#endif
    else if (u1Type == eSWDMX_GET_IS_TRICK)
    {
        BOOL fgForward = TRUE;
        if(pu4Para1 == NULL)
        {
            LOG(1, "_SWDMX_MpgGetInfo pu4Para1 = NULL\n");
            return FALSE;
        }
        if(pu4Para2 == NULL)
        {
            LOG(1, "_SWDMX_MpgGetInfo pu4Para2 = NULL\n");
            return FALSE;
        }
        if(*pu4Para2 == 0)
        {
            fgForward = FALSE;
        }
        *pu4Para1 = _SWDMX_MpgIsSpeedAvailable(u1SrcId, fgForward);

    #if 0 // audio driver already handle pause or other command before aout
    // we could remove this code now
#ifdef SWDMX_MPG_SYNC_DTV_MODE
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
#endif
        {
            // to protect trigger audio on right time
            if(((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) &&
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotAudio) &&
                (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableAudio))
               /*
               ||
               ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) &&
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotVideo) &&
                (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnableVideo))
               */
              )
            {
                *pu4Para1 = FALSE;
            }
            /********
            VDEC_GetQueueInfo(prSwdmxInst->u1VdecId, &u2QueueSize, &u2MaxQueueSize);            
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF)&&
                (u2QueueSize <= 1)&&
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_RAW_AUDIO_ES)&&
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_VIDEO_ES)&&
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_H264_VIDEO_ES)&&
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_VC1_ES)&&
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_AVS_VIDEO_ES)&&
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG4_VIDEO_ES))  //EOS has send by swdmx, can't do speed change for a/v file
            {
                *pu4Para1 = FALSE;
                 LOG(5,"_SWDMX_MpgGetInfo EOS has been send, can't change speed\n");
            }
            ********/
        }
        #endif
        return TRUE;
    }
    else if(u1Type == eSWDMX_GET_STC_OFFSET)
    {
        if(pu4Para1 == NULL)
        {
            LOG(1, "_SWDMX_MpgGetInfo pu4Para1 = NULL\n");
            return FALSE;
        }
        *pu4Para1 = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS;
        return TRUE;
    }
    else if(u1Type == eSWDMX_GET_AUDIO_ACTIVE_PIDX)
    {

        UINT32 u4DmxAvailSizeAudio = 0;
        UINT32 u4Addr, u4Size;
        UINT32 u4BufSize;
        UINT32 u4DataSize;

        #ifdef SWDMX_MPG_DMX_20
        //DTV00214257  should add 1880 (10 pes) as  sub by dmx
        //u4DmxAvailSizeAudio = DMX_GetMinFreeBufferSize(DMX_PID_TYPE_ES_AUDIO);
        // -> should query dram size
        u4DmxAvailSizeAudio = DMX_MUL_GetMinFreeDRAMBufferSize(prSwdmxInst->u1DmxId,
            DMX_PID_TYPE_ES_AUDIO,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio);
        #else
#ifdef CC_DMX_PURE_AUDIO
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
        {
            u4DmxAvailSizeAudio = DMX_MM_GetBufEmptySize(
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio);
        }
        else
#endif
        {
            //u4DmxAvailSizeAudio = DMX_GetMinFreeBufferSize(DMX_PID_TYPE_ES_AUDIO)
            //DTV00214257  should add 1880 (10 pes) as  sub by dmx
            u4DmxAvailSizeAudio = DMX_GetMinFreeBufferSize(
                DMX_PID_TYPE_ES_AUDIO) + 1880;
            //u4DmxAvailSizeAudio = DMX_GetMinFreeDRAMBufferSize(DMX_PID_TYPE_ES_AUDIO);
        }
        #endif

        if(!_SWDMX_GetAudioFifo(u1SrcId, &u4Addr, &u4Size))
        {
            LOG(3, "_SWDMX_MpgEsSetAudioId _SWDMX_GetAudioFifo Fail\n");
            return FALSE;
        }

        u4BufSize = u4Size;
        u4DataSize = u4BufSize - u4DmxAvailSizeAudio;
        *pu4Para1 = (UINT32)u4DataSize;
        return TRUE;
    }
    else if(u1Type == eSWDMX_GET_VIDEO_PIDX)
    {
        if(pu4Para1 == NULL)
        {
            LOG(1, "_SWDMX_MpgGetInfo pu4Para1 = NULL\n");
            return FALSE;
        }
        *pu4Para1 = (UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo;
        return TRUE;
    }
    else if(u1Type == eSWDMX_GET_AUDIO_PIDX)
    {
        if(pu4Para1 == NULL)
        {
            LOG(1, "_SWDMX_MpgGetInfo pu4Para1 = NULL\n");
            return FALSE;
        }
        *pu4Para1 = (UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio;
        return TRUE;
    }
    else if(u1Type == eSWDMX_GET_HDMVC_INFO)
    {
        if(pu4Para1 == NULL)
        {
            LOG(1, "_SWDMX_MpgGetInfo pu4Para1 = NULL\n");
            return FALSE;
        }
        *pu4Para1 = (UINT32)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgHdMvc;
        return TRUE;
    }
    else if(u1Type == eSWDMX_GET_AUDIO_PTS_INFO)
    {
        SWDMX_PTS_INFO_T *prPtsInfo = (SWDMX_PTS_INFO_T *)pu4Para1;
        
        if(prPtsInfo == NULL)
        {
            LOG(1, "_SWDMX_MpgGetInfo AUDIO_PTS_INFO pu4Para1 = NULL\n");
            return FALSE;
        }
        prPtsInfo->u4Pts = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastAudioPTS - 
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS + 
                    MPG_STC_BASE;
        prPtsInfo->i4DeltaPts = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4DeltaAudioPTS;
        prPtsInfo->rDeltaTime = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rDeltaACBTime;
        x_memset(&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rDeltaACBTime, 0, sizeof(HAL_TIME_T));
        return TRUE;
    }
    else if(u1Type == eSWDMX_GET_VIDEO_PTS_INFO)
    {
        SWDMX_PTS_INFO_T *prPtsInfo = (SWDMX_PTS_INFO_T *)pu4Para1;
        
        if(prPtsInfo == NULL)
        {
            LOG(1, "_SWDMX_MpgGetInfo VIDEO_PTS_INFO pu4Para1 = NULL\n");
            return FALSE;
        }
        
        prPtsInfo->u4Pts = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4LastVideoPTS - 
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FirstPTS + 
                    MPG_STC_BASE;
        prPtsInfo->i4DeltaPts = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4DeltaVideoPTS;
        prPtsInfo->rDeltaTime = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rDeltaVCBTime;
        x_memset(&prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rDeltaVCBTime, 0, sizeof(HAL_TIME_T));
        return TRUE;
    }
  else if (u1Type == eSWDMX_TYPE_GET_AUD_STREAM_INFO)
  {
      UINT32 i;
      SWDMX_AUDIO_STREAM_T *ptAudioStreamInfo = NULL;
      
        ptAudioStreamInfo = &prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.t_audio_stream_info;
        
        for ( i = 0; (i < ptAudioStreamInfo->u4_audio_pid_num) && (i < MAX_SWDMX_PID_INDEX); i++)
        {
            LOG(0,"No. %d Pidx %d StreamId %d\n",i,
                ptAudioStreamInfo->t_audio_stream[i].u1Pidx,
                ptAudioStreamInfo->t_audio_stream[i].u2StreamId);            
        }
  } 

    UNUSED(pu4Para2);
    UNUSED(pu4Para3);
    return FALSE;
}

BOOL _SWDMX_MpgSetStrmID(UINT8 u1SrcId, UINT8 u1HdrType,
    UINT32 u4StrmID, UINT32 u4StrmSubID)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);

    LOG(5, "_SWDMX_MpgSetStrmID(%d) u1HdrType = %d, u4StrmID = %d, u4StrmSubID = %d\n",
        u1SrcId, u1HdrType, u4StrmID, u4StrmSubID);

    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    switch(u1HdrType)
    {
        case eSWDMX_STRM_TYPE_VID:
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2VideoId = (UINT16)u4StrmID;
            break;
        case eSWDMX_STRM_TYPE_VID2:
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2Video2Id = (UINT16)u4StrmID;
            break;
        case eSWDMX_STRM_TYPE_AUD:
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2AudioId = (UINT16)u4StrmID;
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2AudioSubId = (UINT16)u4StrmSubID;
            ucCount = 2;
#ifdef HANDLE_CHANGE_AUDIO_TYPE
            if (IS_TS_FILE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt))
            {     
                if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1WaitAudio != AUDIO_TYPE_HANDLE_END) &&
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type != MM_SRC_TYPE_PUSH) &&
                   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type != MM_SRC_TYPE_NETWORK_VUDU))
                {
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1WaitAudio)
                    {
                        LOG(1, "re-set audio stream\n");
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1WaitAudio = AUDIO_TYPE_FOUND;
                    }
                    else if(u4StrmID & 0x8000)
                    {
                        LOG(1, "audio type not sure\n");
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1WaitAudio = UNKNOWN_AUDIO_TYPE;                    
                    }
                }
                LOG(1, "u2AudioId 0x%x, u1WaitAudio %d, e_mm_src_type %d\n", u4StrmID,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1WaitAudio,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type);
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2AudioId = (UINT16)(u4StrmID & 0x7FFF);
            }
#endif
            break;
        case eSWDMX_STRM_TYPE_AUD2:
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2Audio2Id = (UINT16)u4StrmID;
            break;
        case eSWDMX_STRM_TYPE_AUD3:
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2Audio3Id = (UINT16)u4StrmID;
            break;            
        case eSWDMX_STRM_TYPE_SUBTITLE:
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2SubTitleId = (UINT16)u4StrmID;
            break;
        #ifdef SWDMX_MPG_SET_PCR_ID
        case eSWDMX_STRM_TYPE_PCR:
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2PcrId = (UINT16)u4StrmID;
            break;
        #endif
        default:
            return FALSE;
    }

    return TRUE;
}
BOOL _SWDMX_MpgEnableHdcpKey(UINT8 u1SrcId,UINT8 u1Type)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
    
    LOG(5, "_SWDMX_MpgEnableHdcpKey(%d), u1StrmType =%d, eFmt = %d\n",
        u1SrcId, u1Type, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt);         
        
    switch(u1Type)
    {
        case eSWDMX_STRM_TYPE_VID:
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnVidHdcp = TRUE;            
            break;
        }
        case eSWDMX_STRM_TYPE_VID2:
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnVid2Hdcp = TRUE;            
            break;
        }
        case eSWDMX_STRM_TYPE_AUD:
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnAudHdcp = TRUE;            
            break;
        }        
        case eSWDMX_STRM_TYPE_AUD2:
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnAud2Hdcp = TRUE;            
            break;
        }        
        default:
            break;                 
    }
    return TRUE;
        
}

BOOL _SWDMX_MpgEnableStrm(UINT8 u1SrcId, UINT8 u1StrmType, VOID* pfnCbFunc)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    LOG(0, "_SWDMX_MpgEnableStrm(%d), u1StrmType =%d, eFmt = %d\n",
        u1SrcId, u1StrmType, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt);

    switch(u1StrmType)
    {
        case eSWDMX_STRM_TYPE_VID:
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnableVideo =TRUE;        
            break;

        case eSWDMX_STRM_TYPE_VID2:
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnableVideo2 =TRUE;        
            break;
        case eSWDMX_STRM_TYPE_AUD:
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnableAudio=TRUE;        
            break;
        case eSWDMX_STRM_TYPE_AUD2:
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnableAudio2=TRUE;        
            break;
        case eSWDMX_STRM_TYPE_AUD3:
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgEnableAudio3=TRUE;        
            break;      
        case eSWDMX_STRM_TYPE_SUBTITLE:
            if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSubTitle)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSubTitle = TRUE;
            }
            break;
        case eSWDMX_STRM_TYPE_PCR:
#ifndef CC_TS_DISABLE
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
            {
                /*
                if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgPcr)
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotPcr = FALSE;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGotPcrReady = FALSE;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnablePcr = FALSE;
                    // Currently, MW set PCR via dmx_mw.c, but not dmx_mm_mw.c
                    // It's enough for us to know PCR is enable or not.

                    #ifdef SWDMX_MPG_SET_PCR_ID
                    fgRet = _SWDMX_MpgTsSetPCRId(u1SrcId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2PcrId);
                    if(fgRet)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgPcr = TRUE;
                    }
                    #else
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgPcr = TRUE;
                    #endif
                }
                */
            }
            break;
#endif
        default:
            break;
    }

    LOG(3, "_SWDMX_MpgEnableStrm(%d) %d\n", u1SrcId);
    UNUSED(pfnCbFunc);
    return TRUE;
}


BOOL _SWDMX_MpgDisableStrm(UINT8 u1SrcId, UINT8 u1StrmType)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    LOG(0, "_SWDMX_MpgDisableStrm(%d) u1StrmType = %d\n", u1SrcId, u1StrmType);

    switch(u1StrmType)
    {
        case eSWDMX_STRM_TYPE_VID:
			if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8RewindSendedSize != 0 && prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed < 0)
		    {
		  	    LOG(2,"%s:re-enable video set rewind max %llu\n",__FUNCTION__,prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8RewindSendedSize);
		  	    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8RewindMaxSendedSize = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8RewindSendedSize;
		    }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgDisableVideo =TRUE;
            break;

        case eSWDMX_STRM_TYPE_VID2:
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgDisableVideo2 =TRUE;        
            break;
        case eSWDMX_STRM_TYPE_AUD:
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgDisableAudio=TRUE;        
            break;
        case eSWDMX_STRM_TYPE_AUD2:
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgDisableAudio2=TRUE;        
            break;      
        case eSWDMX_STRM_TYPE_AUD3:
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgDisableAudio3=TRUE;        
            break;      
        case eSWDMX_STRM_TYPE_SUBTITLE:
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSubTitle = FALSE;
            break;
        case eSWDMX_STRM_TYPE_PCR:
#ifndef CC_TS_DISABLE
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
            {
                /*
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgPcr)
                {
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgEnablePcr = FALSE;
                    // Currently, MW set PCR via dmx_mw.c, but not dmx_mm_mw.c
                    // It's enough for us to know PCR is enable or not.
                    #ifdef SWDMX_MPG_SET_PCR_ID
                    fgRet = _SWDMX_MpgTsFreePCRId(u1SrcId);
                    if(fgRet)
                    {
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgPcr = FALSE;
                    }
                    #else
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgPcr = FALSE;
                    #endif
                }
                */
            }
            break;
#endif
        default:
            //fgRet = FALSE;
            break;
    }

    LOG(3, "_SWDMX_MpgDisableStrm(%d) do nothing\n", u1SrcId);
    return TRUE;
}

BOOL _SWDMX_MpgUpdateStrm(UINT8 u1SrcId, UINT8 u1StrmType ,UINT16 u2StrmID)
{
    
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    LOG(5, "_SWDMX_MpgUpdateStrm(%d), u1StrmType =%d, eFmt = %d u2StrmID %d\n",
        u1SrcId, u1StrmType, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt,u2StrmID);

    switch(u1StrmType)
    {
        case eSWDMX_STRM_TYPE_VID:
        {
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
            {            
                /* first disable stream */
                UINT8 u1PidxVideo = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo;
                
                if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS) ||
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_192) ||
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_204) ||
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_206) ||
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ZERO_192) ||
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192) ||
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
                {
                    _SWDMX_DmxUpdatePid(u1SrcId,u1PidxVideo,u2StrmID);                        
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2VideoId = u2StrmID;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdVidId = 0xFFFF;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4DmxPreviousAvailSizeVideo = 0;                    
                }
            }
        
            break;
        }
        case eSWDMX_STRM_TYPE_VID2:
        {
            break;
        }        
        case eSWDMX_STRM_TYPE_AUD:
        {
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
            {

                UINT8 u1PidxAudio = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio; 
                
                if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS) ||
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_192) ||
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_204) ||
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_206) ||                    
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ZERO_192) ||
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_ENCRYPT_192) ||
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
                {
                    
                    _SWDMX_DmxUpdatePid(u1SrcId,u1PidxAudio,u2StrmID);

                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2AudioId  = u2StrmID;
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdAudId = 0xFFFF; 
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4DmxPreviousAvailSizeAudio = 0;                        
                        
                }   
                
            }                    
            break;
        }    
        case eSWDMX_STRM_TYPE_AUD2:
        {
            break;
        }          
        
    }
    LOG(3, "_SWDMX_MpgUpdateStrm(%d) %d\n", u1SrcId);
    
    return TRUE;
}

static BOOL _SWDMX_MpgInitDmx(UINT8 u1SrcId,UINT8 u1StrmType)
{
    BOOL fgRet = FALSE;
    UINT8 u1Pidx;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
  LOG(5,"%s : SrcId %d StrmType %d\n",__FUNCTION__,u1SrcId,u1StrmType);
    switch(u1StrmType)
    {
        case eSWDMX_STRM_TYPE_VID:
        {
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
            {
                u1Pidx = (UINT8)((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2PidIdxStart)
                    + (u1SrcId * 3));
                if(!DMX_MUL_SetPidxInstance(prSwdmxInst->u1DmxId, u1Pidx))
                {
                    LOG(3, "DMX_MUL_SetPidxInstance Fail\n");
                    return FALSE;
                }
            }
            else
            {
                u1Pidx = DMX_MUL_GetAvailablePidx(prSwdmxInst->u1DmxId);
                if(u1Pidx >= DMX_NUM_PID_INDEX)
                {
                    LOG(3, "DMX_MUL_GetAvailablePidx Fail\n");
                    return FALSE;
                }
            }
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_PS) ||
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG1_DAT))
            {
                fgRet = _SWDMX_MpgPsSetVideoId(u1SrcId, u1Pidx, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2VideoId);
            }
            else
            if (IS_TS_FILE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
            {
                fgRet = _SWDMX_MpgTsSetVideoId(u1SrcId, u1Pidx, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2VideoId,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1VideoKeyIndex,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u4VideoDescMode, FALSE);
            }
            else
            if ((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_VIDEO_ES) ||
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_H264_VIDEO_ES) ||
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_AVS_VIDEO_ES) ||
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG4_VIDEO_ES) ||
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_VC1_ES) ||
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_H265_VIDEO_ES))
            {
                fgRet = _SWDMX_MpgEsSetVideoId(u1SrcId, u1Pidx);
            }
            if (!fgRet)
            {
                LOG(0,"mpg set video id fail u1Pidx %d\n",u1Pidx);
                return FALSE;
            }
            break;
        }
        case eSWDMX_STRM_TYPE_VID2:
        {
            u1Pidx = DMX_MUL_GetAvailablePidx(prSwdmxInst->u1DmxId);
            if(u1Pidx >= DMX_NUM_PID_INDEX)
            {
                LOG(3, "DMX_MUL_GetAvailablePidx Fail\n");
                return FALSE;
            }

            if (IS_TS_FILE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
            {
                fgRet = _SWDMX_MpgTsSetVideoId(u1SrcId, u1Pidx,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2Video2Id,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1Video2KeyIndex,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u4Video2DescMode, TRUE);
            }
            
            VDEC_SetMVCCmpare((UCHAR)0,TRUE);
            break;
        }
        case eSWDMX_STRM_TYPE_AUD:
        {
			if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgAudioExist)
			{
				if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio != 0xFF)
				{
					//sometimes, although pmt with multi-audio changed, but audio stream not switched and still need init prebuffer, so original audio pid not freed but init dmx remains to be done and reset the same audio pid to dmx
					LOG(1, "audio not changed and use original audio pid index %u\n", prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio);
					u1Pidx = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio;
				}
				else
				{
					u1Pidx = DMX_MUL_GetAvailablePidx(prSwdmxInst->u1DmxId);
	                if(u1Pidx >= DMX_NUM_PID_INDEX)
	                {
	                    LOG(3, "DMX_MUL_GetAvailablePidx Fail\n");
	                    return FALSE;
	                }
				}
				prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.rRecvStreamChgInfo.fgAudioExist = FALSE;
			}
            else if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
            {
                u1Pidx = (UINT8)((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2PidIdxStart + 1)
                    + (u1SrcId * 3));
                if(!DMX_MUL_SetPidxInstance(prSwdmxInst->u1DmxId, u1Pidx))
                {
                    LOG(3, "DMX_MUL_SetPidxInstance Fail\n");
                    return FALSE;
                }
            }
            else
            {
                u1Pidx = DMX_MUL_GetAvailablePidx(prSwdmxInst->u1DmxId);
                if(u1Pidx >= DMX_NUM_PID_INDEX)
                {
                    LOG(3, "DMX_MUL_GetAvailablePidx Fail\n");
                    return FALSE;
                }
            }
            if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_PS) ||
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG1_DAT))
            {
                fgRet = _SWDMX_MpgPsSetAudioId(u1SrcId, u1Pidx, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2AudioId,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2AudioSubId);
            }
            else if (IS_TS_FILE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
            {
                fgRet = _SWDMX_MpgTsSetAudioId(u1SrcId, u1Pidx,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2AudioId, 0,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1AudioKeyIndex,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u4AudioDescMode);
          if(prSwdmxInst->fgEnablePrebuffer)
          {
            _SWDMX_MpgInitPrebuffer(u1SrcId);
          }       
            }
            else if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
            {
                fgRet = _SWDMX_MpgEsSetAudioId(u1SrcId, u1Pidx);
            }
                        
            break;
        }
        case eSWDMX_STRM_TYPE_AUD2:
        {
            u1Pidx = DMX_MUL_GetAvailablePidx(prSwdmxInst->u1DmxId);
            if(u1Pidx >= DMX_NUM_PID_INDEX)
            {
                LOG(3, "DMX_MUL_GetAvailablePidx Fail\n");
                return FALSE;
            }

            if (IS_TS_FILE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
            {
                fgRet = _SWDMX_MpgTsSetAudioId(u1SrcId, u1Pidx,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2Audio2Id, AUD_DEC_AUX,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1Audio2KeyIndex,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u4Audio2DescMode);
            }
        
            break;
        }
        case eSWDMX_STRM_TYPE_AUD3:
        {
            u1Pidx = DMX_MUL_GetAvailablePidx(prSwdmxInst->u1DmxId);
            if(u1Pidx >= DMX_NUM_PID_INDEX)
            {
                LOG(3, "DMX_MUL_GetAvailablePidx Fail\n");
                return FALSE;
            }

            if (IS_TS_FILE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt) ||
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_TIME_SHIFT))
            {
                fgRet = _SWDMX_MpgTsSetAudioId(u1SrcId, u1Pidx,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2Audio3Id, AUD_DEC_THIRD,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1Audio3KeyIndex,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u4Audio3DescMode);
            }
        
            break;
        }
        default:
            LOG(0,"not match stream type,pls check it.\n");
            ASSERT(0);
        break;
        
    }
    return TRUE;
}
  

VOID _SWDMX_MpgSetSwdmxInfo(UINT8 u1SrcId, SWDMX_INFO_T* prSwdmxInfo)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    if(prSwdmxInfo == NULL)
    {
        return;
    }
    if(prSwdmxInst != prSwdmxInfo)
    {
        LOG(1, "_SWDMX_MpgSetSwdmxInfo prSwdmxInst != prSwdmxInfo\n");
    }
    UNUSED(prSwdmxInfo);
    UNUSED(prSwdmxInst);

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo = 0xFF;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo2 = 0xFF;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio = 0xFF;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio2 = 0xFF;   // 0831        
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio3 = 0xFF;   // 0831    
    #ifdef SWDMX_MPG_SET_PCR_ID
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxPCR = 0xFF;
    #endif
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize = MPG_BATCH_SIZE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeReadSize = (MPG_BATCH_SIZE*MPG_BATCH_READ_SIZE);
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase = MPG_ALIGN_SIZE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqID = 1;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqIBCID = 0;    
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederBufNum = MPG_BUF_NUM;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum = MPG_REQ_NUM;
}


#ifdef SWDMX_STATISTICS
VOID _SWDMX_ResetTime(UINT8 u1SrcId)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederAvgTime = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederCount = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederMaxTime = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederMinTime = 0;
}

VOID _SWDMX_PrintTime(UINT8 u1SrcId)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    LOG(0, "Feeder Count(%d) Time(%d, %d, %d)\n",
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederCount,
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederMaxTime, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederAvgTime, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederMinTime);
}

#endif


BOOL _SWDMX_MpgGetPosByTime(UINT8 u1SrcId, BOOL fgUpdate, UINT32 u4Time, UINT64 *pu8Pos)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_RAW_AUDIO_ES)
    {
        *pu8Pos = 0;
        return FALSE;
    }

    if(//(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) &&
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq) &&
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo) &&
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst) &&
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst->u.pt_pb_idx_tbl_entry)
      )
    {
        MM_RANGE_ELEMT_IDXTBL_PB_ENTRY_T* prTblEntry = NULL;
        MM_RANGE_ELMT_IDXTBL_T* prIdxTbl = NULL;
        {
            prIdxTbl = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst;
            prTblEntry = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst->u.pt_pb_idx_tbl_entry;
            if((prTblEntry) && (prIdxTbl))
            {
                UINT32 u4Cnt = 0;
                if(prIdxTbl->ui4_number_of_entry == 0)
                {
                    LOG(3, "_SWDMX_MpgGetInfo ui4_number_of_entry 0\n");
                    return FALSE;
                }
                while(u4Cnt < prIdxTbl->ui4_number_of_entry)
                {
                    if(prTblEntry[u4Cnt].ui4_pts >= u4Time)
                    {
                        break;
                    }
                    u4Cnt++;
                }
                if(u4Cnt < prIdxTbl->ui4_number_of_entry)
                {
                    *pu8Pos = prIdxTbl->ui8_base_offset +
                        prTblEntry[u4Cnt].ui4_relative_offset;
                    return TRUE;
                }

                LOG(3, "_SWDMX_MpgGetInfo out of last index time %d\n",
                    prTblEntry[prIdxTbl->ui4_number_of_entry-1].ui4_pts);
            }
            else
            {
                UINT64 u8Remainder;
                if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime > 0)
                {
                    *pu8Pos = _SWDMX_Div6464((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset)*(u4Time),
                                            (UINT64)(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TotalTime), &u8Remainder);
                    {
                        UNUSED(_SWDMX_Div6464(*pu8Pos, (UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase, &u8Remainder));
                        *pu8Pos -= u8Remainder;
                    }
                    *pu8Pos += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset;
                    return TRUE;
                }
                else
                {
                    *pu8Pos = 0;
                }
                *pu8Pos += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset;
            }
        }
    }

    UNUSED(fgUpdate);
    return FALSE;
}

BOOL _SWDMX_MpgGetPosByTick(UINT8 u1SrcId, BOOL fgUpdate, UINT32 u4Tick, UINT64 *pu8Pos)
{
#ifdef TIME_SHIFT_SUPPORT
    SWDMX_MPG_PVR_TICK_INDEX_T *prStartAddr;
    SWDMX_MPG_PVR_TICK_INDEX_T *prEndAddr;
    SWDMX_MPG_PVR_TICK_INDEX_T *prValidStart;
    SWDMX_MPG_PVR_TICK_INDEX_T *prValidEnd;
    SWDMX_MPG_PVR_TICK_INDEX_T *prTargetAddr;
#endif
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        *pu8Pos = 0;
        return FALSE;
    }
#ifdef TIME_SHIFT_SUPPORT

    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgValidRange)
    {
        LOG(9, "_SWDMX_MpgGetPosByTick valid range is not set\n");
        return FALSE;
    }
    // from the explain of mw pv_end_address is the end address of the tick_index_talbe;
    prEndAddr = (SWDMX_MPG_PVR_TICK_INDEX_T*)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_end_address -1;
    prStartAddr = (SWDMX_MPG_PVR_TICK_INDEX_T*)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_start_address;
    if(prStartAddr > prEndAddr)
    {
        LOG(3, "_SWDMX_MpgGetPosByTick prStartAddr >= prEndAddr fail\n");
        return FALSE;
    }

    _SWDMX_LockRangeSema(u1SrcId);

    prValidStart = (SWDMX_MPG_PVR_TICK_INDEX_T*)
        (prStartAddr + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_start);
    if((prValidStart == NULL) ||
       (prValidStart > prEndAddr) ||
       (prValidStart < prStartAddr))
    {
        LOG(3, "_SWDMX_MpgGetPosByTick valid start prTickIndex fail\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return FALSE;
    }

    prValidEnd = (SWDMX_MPG_PVR_TICK_INDEX_T*)
        (prStartAddr + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_end);
    if((prValidEnd == NULL) ||
       (prValidEnd > prEndAddr) ||
       (prValidEnd < prStartAddr))
    {
        LOG(3, "_SWDMX_MpgGetPosByTick valid end prTickIndex fail\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return FALSE;
    }

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_end >=
       prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_start)
    {
        if((u4Tick > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_end) ||
           (u4Tick < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_start))
        {
            if(fgUpdate)
            {
                LOG(3, "1 _SWDMX_MpgGetPosByTick u4Tick(%d) not in %d-%d\n",
                    u4Tick,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_start,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_end);
            }
            *pu8Pos = _SWDMX_MpgLBA2Pos(u1SrcId, (prValidStart->ui4_lba));
            *pu8Pos = _SWDMX_MpgTSAlignDown(u1SrcId, *pu8Pos);
            *pu8Pos += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase;
            _SWDMX_UnlockRangeSema(u1SrcId);
            return FALSE;
        }
    }
    else
    {
        if((u4Tick > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_end) &&
           (u4Tick < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_start))
        {
            if(fgUpdate)
            {
                LOG(3, "2 _SWDMX_MpgGetPosByTick u4Tick(%d) not in %d-%d\n",
                    u4Tick,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_start,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_end);
            }
            *pu8Pos = _SWDMX_MpgLBA2Pos(u1SrcId, (prValidStart->ui4_lba));
            *pu8Pos = _SWDMX_MpgTSAlignDown(u1SrcId, *pu8Pos);
            *pu8Pos += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase;
            _SWDMX_UnlockRangeSema(u1SrcId);
            return FALSE;
        }
    }

    prTargetAddr = (SWDMX_MPG_PVR_TICK_INDEX_T*)
        (prStartAddr + u4Tick);
    if(prTargetAddr == NULL)
    {
        LOG(3, "_SWDMX_MpgGetPosByTick prTargetAddr null\n");
        *pu8Pos = _SWDMX_MpgLBA2Pos(u1SrcId, (prValidStart->ui4_lba));
        *pu8Pos = _SWDMX_MpgTSAlignDown(u1SrcId, *pu8Pos);
        *pu8Pos += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase;
        _SWDMX_UnlockRangeSema(u1SrcId);
        return FALSE;
    }
    // DTV00142188, When ring buffer begins working,offset time jumps step by step to the biggest value.
    // MW change prEndAddr to not include the valid tick information
    // We have to change not to use prEndAddr for meta-data
    if(prTargetAddr > prEndAddr)
    {
        prTargetAddr -= ((prEndAddr +1)- prStartAddr);
    }
    *pu8Pos = _SWDMX_MpgLBA2Pos(u1SrcId, (prTargetAddr->ui4_lba));
    *pu8Pos = _SWDMX_MpgTSAlignDown(u1SrcId, *pu8Pos);

    if(fgUpdate)
    {
        // When we start with seek to last, we only update u4CurTickNum
        // Read need many time to reach curticknum.
        // We should update read tick too.
        // swdmx must be in pause state now for this change read position.
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ReadTickNum = prTargetAddr->ui4_tick_num;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum = prTargetAddr->ui4_tick_num;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex = prTargetAddr;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex = prTargetAddr;
        LOG(5, "_SWDMX_MpgGetPosByTick u8Pos = 0x%llx\n", (UINT64)*pu8Pos);
    }
    _SWDMX_UnlockRangeSema(u1SrcId);
#endif
    return TRUE;
}

BOOL _SWDMX_MpgGetPosByTickNum(UINT8 u1SrcId, BOOL fgUpdate, UINT32 u4TickNum, UINT64 *pu8Pos)
{

    SWDMX_INFO_T* prSwdmxInst;
#ifdef TIME_SHIFT_SUPPORT
    SWDMX_MPG_PVR_TICK_INDEX_T *prStartAddr;
    SWDMX_MPG_PVR_TICK_INDEX_T *prEndAddr;
    SWDMX_MPG_PVR_TICK_INDEX_T *prValidStart;
    SWDMX_MPG_PVR_TICK_INDEX_T *prValidEnd;
    SWDMX_MPG_PVR_TICK_INDEX_T *prTargetAddr;
#endif

    prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        *pu8Pos = 0;
        return FALSE;
    }
#ifdef TIME_SHIFT_SUPPORT

    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgValidRange)
    {
        LOG(9, "_SWDMX_MpgGetPosByTickNum valid range is not set\n");
        return FALSE;
    }
    // from the explain of mw pv_end_address is the end address of the tick_index_talbe;
    prEndAddr = (SWDMX_MPG_PVR_TICK_INDEX_T*)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_end_address -1;
    prStartAddr = (SWDMX_MPG_PVR_TICK_INDEX_T*)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_start_address;
    if(prStartAddr > prEndAddr)
    {
        LOG(3, "_SWDMX_MpgGetPosByTickNum prStartAddr >= prEndAddr fail\n");
        return FALSE;
    }

    _SWDMX_LockRangeSema(u1SrcId);

    prValidStart = (SWDMX_MPG_PVR_TICK_INDEX_T*)
        (prStartAddr + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_start);
    if((prValidStart == NULL) ||
       (prValidStart > prEndAddr) ||
       (prValidStart < prStartAddr))
    {
        LOG(3, "_SWDMX_MpgGetPosByTickNum valid start prTickIndex fail\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return FALSE;
    }

    prValidEnd = (SWDMX_MPG_PVR_TICK_INDEX_T*)
        (prStartAddr + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_end);
    if((prValidEnd == NULL) ||
       (prValidEnd > prEndAddr) ||
       (prValidEnd < prStartAddr))
    {
        LOG(3, "_SWDMX_MpgGetPosByTickNum valid end prTickIndex fail\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return FALSE;
    }

    if((u4TickNum >= prValidEnd->ui4_tick_num) ||
       (u4TickNum < prValidStart->ui4_tick_num))
    {
        if(fgUpdate)
        {
            LOG(3, "_SWDMX_MpgGetPosByTickNum u4TickNum(%d) not in %d-%d\n",
                u4TickNum, prValidStart->ui4_tick_num, prValidEnd->ui4_tick_num);
        }
        *pu8Pos = _SWDMX_MpgLBA2Pos(u1SrcId, (prValidStart->ui4_lba));
        *pu8Pos = _SWDMX_MpgTSAlignDown(u1SrcId, *pu8Pos);
        *pu8Pos += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase;
        _SWDMX_UnlockRangeSema(u1SrcId);
        return FALSE;
    }

    prTargetAddr = prValidStart + (u4TickNum - prValidStart->ui4_tick_num);
    if(prTargetAddr == NULL)
    {
        LOG(3, "_SWDMX_MpgGetPosByTickNum prTargetAddr null\n");
        *pu8Pos = _SWDMX_MpgLBA2Pos(u1SrcId, (prValidStart->ui4_lba));
        *pu8Pos = _SWDMX_MpgTSAlignDown(u1SrcId, *pu8Pos);
        *pu8Pos += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase;
        _SWDMX_UnlockRangeSema(u1SrcId);
        return FALSE;
    }
    if(prTargetAddr > prEndAddr)
    {
        prTargetAddr -= ((prEndAddr +1) - prStartAddr);
    }
    *pu8Pos = _SWDMX_MpgLBA2Pos(u1SrcId, (prTargetAddr->ui4_lba));
    *pu8Pos = _SWDMX_MpgTSAlignDown(u1SrcId, *pu8Pos);

    if(fgUpdate)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum = u4TickNum;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex = prTargetAddr;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex = prTargetAddr;
        LOG(5, "_SWDMX_MpgGetPosByTickNum u8Pos = 0x%llx\n", (UINT64)*pu8Pos);
    }
    _SWDMX_UnlockRangeSema(u1SrcId);
#endif
    return TRUE;
}

#ifdef LINUX_TURNKEY_SOLUTION
extern VOID rm_copy_from_user(VOID* pv_kernel,VOID *pv_user,UINT32 size);
#endif
BOOL _SWDMX_MpgGetIPosByTickNum(UINT8 u1SrcId, UINT64 u8Start, UINT32 u4TickNum, UINT64 *pu8Pos)
{
    BOOL fgRet;
#ifdef TIME_SHIFT_SUPPORT
    SWDMX_MPG_PVR_TICK_INDEX_T *prStartAddr;
    SWDMX_MPG_PVR_TICK_INDEX_T *prEndAddr;
    SWDMX_MPG_PVR_TICK_INDEX_T *prValidStart;
    SWDMX_MPG_PVR_TICK_INDEX_T *prValidEnd;
    SWDMX_MPG_PVR_TICK_INDEX_T *prTargetAddr;
    INT32 i4LBAOffset;
#endif
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        *pu8Pos = 0;
        return FALSE;
    }
    fgRet = FALSE;
#ifdef TIME_SHIFT_SUPPORT

    i4LBAOffset = 0;
    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgValidRange)
    {
        LOG(9, "_SWDMX_MpgGetIPosByTickNum valid range is not set\n");
        return FALSE;
    }
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNoUseIFrmInfo)
    {
        return FALSE;
    }
    // from the explain of mw pv_end_address is the end address of the tick_index_talbe, not the start address of the last entry 
    prEndAddr = (SWDMX_MPG_PVR_TICK_INDEX_T*)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_end_address -1;
    prStartAddr = (SWDMX_MPG_PVR_TICK_INDEX_T*)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_start_address;
    if(prStartAddr > prEndAddr)
    {
        LOG(3, "_SWDMX_MpgGetIPosByTickNum prStartAddr >= prEndAddr fail\n");
        return FALSE;
    }

    _SWDMX_LockRangeSema(u1SrcId);

    prValidStart = (SWDMX_MPG_PVR_TICK_INDEX_T*)
        (prStartAddr + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_start);
    if((prValidStart == NULL) ||
       (prValidStart > prEndAddr) ||
       (prValidStart < prStartAddr))
    {
        LOG(3, "_SWDMX_MpgGetIPosByTickNum valid start prTickIndex fail\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return FALSE;
    }

    prValidEnd = (SWDMX_MPG_PVR_TICK_INDEX_T*)
        (prStartAddr + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_end);
    if((prValidEnd == NULL) ||
       (prValidEnd > prEndAddr) ||
       (prValidEnd < prStartAddr))
    {
        LOG(3, "_SWDMX_MpgGetIPosByTickNum valid end prTickIndex fail\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return FALSE;
    }

    if((u4TickNum >= prValidEnd->ui4_tick_num) ||
       (u4TickNum < prValidStart->ui4_tick_num))
    {
        #if 0
        if(fgUpdate)
        {
            LOG(3, "_SWDMX_MpgGetIPosByTickNum u4TickNum(%d) not in %d-%d\n",
                u4TickNum, prValidStart->ui4_tick_num, prValidEnd->ui4_tick_num);
        }
        #endif
        *pu8Pos = _SWDMX_MpgLBA2Pos(u1SrcId, (prValidStart->ui4_lba));
        *pu8Pos = _SWDMX_MpgTSAlignDown(u1SrcId, *pu8Pos);
        *pu8Pos += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase;
        _SWDMX_UnlockRangeSema(u1SrcId);
        return FALSE;
    }

    prTargetAddr = prValidStart + (u4TickNum - prValidStart->ui4_tick_num);
    if(prTargetAddr == NULL)
    {
        LOG(3, "_SWDMX_MpgGetIPosByTickNum prTargetAddr null\n");
        *pu8Pos = _SWDMX_MpgLBA2Pos(u1SrcId, (prValidStart->ui4_lba));
        *pu8Pos = _SWDMX_MpgTSAlignDown(u1SrcId, *pu8Pos);
        *pu8Pos += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase;
        _SWDMX_UnlockRangeSema(u1SrcId);
        return FALSE;
    }
    if(prTargetAddr > prEndAddr)
    {
        prTargetAddr -= ((prEndAddr +1) - prStartAddr);
    }
    *pu8Pos = _SWDMX_MpgLBA2Pos(u1SrcId, (prTargetAddr->ui4_lba));
    if(SWDMX_MPG_TICK_FLAG_CHECK(prTargetAddr, PVR_TICK_INDEX_FLAG_HAS_I_FRAME))
    {
        // copy_from_user can't be called when it is out of ioctl thread.
        // we have to map the memory from user to kernel.
        // disable tick detail temporally
        //#ifndef SWDMX_MPG_USE_MTMPLAYER_PVR
        #if !defined(LINUX_TURNKEY_SOLUTION) && !defined(SWDMX_MPG_USE_MTMPLAYER_PVR)
        if((prTargetAddr->pt_tick_detail) && (VIRTUAL((UINT32)prTargetAddr->pt_tick_detail)))
        {
            UINT32 u4Tmp;
            UINT32 u4PicType = 0x3;
            UINT32 u4Lba = 0;
            UINT32 u4EntryNum;

            PVR_TICK_DETAIL_T *prTick_detail;   //DTV00087636   ,prTargetAddr->pt_tick_detail is a user space address, we shuld convert to kernel

            #ifdef LINUX_TURNKEY_SOLUTION
               prTick_detail = x_mem_alloc(sizeof(PVR_TICK_DETAIL_T));
               rm_copy_from_user(prTick_detail,prTargetAddr->pt_tick_detail,sizeof(PVR_TICK_DETAIL_T));
            #else
              prTick_detail = prTargetAddr->pt_tick_detail;
            #endif

            //UINT32 u4EntryNum = (UINT32)(PVR_TICK_DETAIL_GET_ENTRIES((PVR_TICK_DETAIL_T *)((UINT32)(VIRTUAL(prTargetAddr->pt_tick_detail)))));
            u4EntryNum = (UINT32)(PVR_TICK_DETAIL_GET_ENTRIES((PVR_TICK_DETAIL_T *)((UINT32)(VIRTUAL((UINT32)prTick_detail)))));
            u4Lba = prTargetAddr->ui4_lba;
            if(u4EntryNum > 100)
            {
                u4EntryNum = 0; // error handle
                LOG(3, "_SWDMX_MpgGetIPosByTickNum u4EntryNum > 100\n");
            }
            for(u4Tmp = 0 ; u4Tmp < u4EntryNum ; u4Tmp++)
            {
                //if(((UINT32)(VIRTUAL(prTargetAddr->pt_tick_detail)) + sizeof(PVR_TICK_DETAIL_T) + (u4Tmp * sizeof(PVR_PIC_INFO_T))) == 0)
                if(((UINT32)(VIRTUAL((UINT32)prTick_detail)) + sizeof(PVR_TICK_DETAIL_T) + (u4Tmp * sizeof(PVR_PIC_INFO_T))) == 0)

                {
                    LOG(3, "_SWDMX_MpgGetIPosByTickNum GET_PIC_TYPE null\n");
                    break;
                }
                //if((!prTargetAddr->pt_tick_detail) || (!VIRTUAL(prTargetAddr->pt_tick_detail)))
                if((!prTick_detail) || (!VIRTUAL((UINT32)prTick_detail)))

                {
                    LOG(3, "_SWDMX_MpgGetIPosByTickNum pt_tick_detail null\n");
                    break;
                }
                //u4PicType = PVR_PIC_INFO_GET_PIC_TYPE((PVR_PIC_INFO_T*)((UINT32)(VIRTUAL(prTargetAddr->pt_tick_detail)) + sizeof(PVR_TICK_DETAIL_T) + (u4Tmp * sizeof(PVR_PIC_INFO_T))));
                u4PicType = PVR_PIC_INFO_GET_PIC_TYPE((PVR_PIC_INFO_T*)((UINT32)(VIRTUAL((UINT32)prTick_detail)) + sizeof(PVR_TICK_DETAIL_T) + (u4Tmp * sizeof(PVR_PIC_INFO_T))));

                if(u4PicType == 0) // I frame
                {
                    //PVR_PIC_INFO_GET_LBA_OFFSET(((PVR_PIC_INFO_T*)((UINT32)(VIRTUAL(prTargetAddr->pt_tick_detail)) + sizeof(PVR_TICK_DETAIL_T) + (u4Tmp * sizeof(PVR_PIC_INFO_T)))), &i4LBAOffset);
                    PVR_PIC_INFO_GET_LBA_OFFSET(((PVR_PIC_INFO_T*)((UINT32)(VIRTUAL((UINT32)prTick_detail)) + sizeof(PVR_TICK_DETAIL_T) + (u4Tmp * sizeof(PVR_PIC_INFO_T)))), &i4LBAOffset);

                    if(i4LBAOffset < 0)
                    {
                        if(u4Lba < (-i4LBAOffset))
                        {
                            LOG(3, "_SWDMX_MpgGetIPosByTickNum (u4Lba < (-i4LBAOffset))\n");
                            //ASSERT(0);
                            break;
                        }
                    }
                    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed >= 0) &&
                       (((UINT32)(u4Lba + i4LBAOffset) * MPG_LBA_BLOCK_SIZE) > u8Start))
                    {
                        if((((UINT32)(u4Lba + i4LBAOffset) * MPG_LBA_BLOCK_SIZE) - u8Start) > (10*1024*1024))
                        {
                            LOG(3, "_SWDMX_MpgGetIPosByTickNum (u4Lba + i4LBAOffset)(%d) too far)\n",
                                (u4Lba + i4LBAOffset));
                            //ASSERT(0);
                            // error handle
                            break;
                        }
                        fgRet = TRUE;
                        break;
                    }
                    else if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed < 0) &&
                            (((UINT32)(u4Lba + i4LBAOffset) * MPG_LBA_BLOCK_SIZE) < u8Start))
                    {
                        if((((UINT32)(u4Lba + i4LBAOffset) * MPG_LBA_BLOCK_SIZE) + (10*1024*1024)) < u8Start)
                        {
                            LOG(3, "_SWDMX_MpgGetIPosByTickNum (u4Lba + i4LBAOffset)(%d) too far)\n",
                                (u4Lba + i4LBAOffset));
                            //ASSERT(0);
                            // error handle
                            break;
                        }
                        fgRet = TRUE;
                        break;
                    }
                }
            }
            #ifdef LINUX_TURNKEY_SOLUTION
             x_mem_free(prTick_detail);
            #endif
        }
        #endif
    }
    *pu8Pos += (i4LBAOffset*MPG_LBA_BLOCK_SIZE);
    *pu8Pos = _SWDMX_MpgTSAlignDown(u1SrcId, *pu8Pos);

    #if 0
    if(fgUpdate)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum = u4TickNum;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex = prTargetAddr;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex = prTargetAddr;
        LOG(5, "_SWDMX_MpgGetIPosByTickNum u8Pos = 0x%llx\n", (UINT64)*pu8Pos);
    }
    #endif
    _SWDMX_UnlockRangeSema(u1SrcId);
#endif
    return fgRet;
}

BOOL _SWDMX_MpgGetTickByPos(UINT8 u1SrcId, BOOL fgUpdate, UINT64 u8Pos, INT32 i4PlaySpeed, UINT32 *pu4TickNum)
{
#ifdef TIME_SHIFT_SUPPORT
    UINT32 u4Tmp;
    SWDMX_MPG_PVR_TICK_INDEX_T *prStartAddr;
    SWDMX_MPG_PVR_TICK_INDEX_T *prEndAddr;
    SWDMX_MPG_PVR_TICK_INDEX_T *prValidStart;
    SWDMX_MPG_PVR_TICK_INDEX_T *prValidEnd;
    SWDMX_MPG_PVR_TICK_INDEX_T *prSafeEnd;
    SWDMX_MPG_PVR_TICK_INDEX_T *prTargetAddr;
    SWDMX_MPG_PVR_TICK_INDEX_T *prTargetEndAddr;
#endif
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    *pu4TickNum = 0;
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        return FALSE;
    }
#ifdef TIME_SHIFT_SUPPORT

    if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgValidRange)
    {
        LOG(9, "_SWDMX_MpgGetTickByPos valid range is not set\n");
        return FALSE;
    }

    if(u8Pos < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset)
    {
        LOG(3, "_SWDMX_MpgGetTickByPos (u8Pos < u8FifoOffset) fail\n");
    }
    // from the explain of mw pv_end_address is the end address of the tick_index_talbe;
    prEndAddr = (SWDMX_MPG_PVR_TICK_INDEX_T*)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_end_address -1;
    prStartAddr = (SWDMX_MPG_PVR_TICK_INDEX_T*)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_start_address;
    if(prStartAddr > prEndAddr)
    {
        LOG(3, "_SWDMX_MpgGetTickByPos prStartAddr >= prEndAddr fail\n");
        return FALSE;
    }

    _SWDMX_LockRangeSema(u1SrcId);

    prValidStart = (SWDMX_MPG_PVR_TICK_INDEX_T*)
        (prStartAddr + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_start);
    if((prValidStart == NULL) ||
       (prValidStart > prEndAddr) ||
       (prValidStart < prStartAddr))
    {
        LOG(3, "_SWDMX_MpgGetTickByPos valid start prTickIndex fail\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return FALSE;
    }

    prValidEnd = (SWDMX_MPG_PVR_TICK_INDEX_T*)
        (prStartAddr + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_end);
    if((prValidEnd == NULL) ||
       (prValidEnd > prEndAddr) ||
       (prValidEnd < prStartAddr))
    {
        LOG(3, "_SWDMX_MpgGetTickByPos valid end prTickIndex fail\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return FALSE;
    }

    prSafeEnd = (SWDMX_MPG_PVR_TICK_INDEX_T*)
        (prStartAddr + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_safe.ui4_end);
    if((prSafeEnd == NULL) ||
       (prSafeEnd > prEndAddr) ||
       (prSafeEnd < prStartAddr))
    {
        LOG(3, "_SWDMX_MpgGetTickByPos safe end prTickIndex fail\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return FALSE;
    }

    // [DTV00141987] After fast rewind,the fast forward to right boundary ,audio isn't smooth
    // We should not use fast mode when out of safe range
    // = should be include. So we could have complete 2 tick between safe and valid
    if((u8Pos >= (((UINT64)prSafeEnd->ui4_lba * MPG_LBA_BLOCK_SIZE) +
                  prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset))
      )
    {
        //LOG(5, "_SWDMX_MpgGetTickByPos u8Pos(0x%llx) bigger than safe end 0x%llx\n",
        //    u8Pos,
        //    ((UINT64)prValidStart->ui4_lba * MPG_LBA_BLOCK_SIZE),
        //    ((UINT64)prValidEnd->ui4_lba * MPG_LBA_BLOCK_SIZE));

        /*
        if(fgUpdate)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgOutOfSafeRange = TRUE;
        }
        */
    }

    if((u8Pos >= (((UINT64)prValidEnd->ui4_lba * MPG_LBA_BLOCK_SIZE) 
        + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset
        + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase)) ||
       (u8Pos < (((UINT64)prValidStart->ui4_lba * MPG_LBA_BLOCK_SIZE) + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset)))
    {
        LOG(3, "_SWDMX_MpgGetTickByPos u8Pos(0x%llx) not in 0x%llx-0x%llx\n",
            u8Pos,
            _SWDMX_MpgLBA2Pos(u1SrcId, (prValidStart->ui4_lba)),
            _SWDMX_MpgLBA2Pos(u1SrcId, (prValidEnd->ui4_lba)));
        *pu4TickNum = prValidStart->ui4_tick_num;

        if(fgUpdate)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgOutOfRange = TRUE;
        }

        _SWDMX_UnlockRangeSema(u1SrcId);
        return FALSE;
    }

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex == NULL)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex = prValidStart;
    }
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex == NULL)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex = prValidStart;
    }

    if(prValidStart > prValidEnd)
    {
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex > prValidEnd) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex < prValidStart))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex = prValidStart;
        }
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex > prValidEnd) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex < prValidStart))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex = prValidStart;
        }
    }
    else
    {
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex > prValidEnd) ||
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex < prValidStart))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex = prValidStart;
        }
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex > prValidEnd) ||
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex < prValidStart))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex = prValidStart;
        }
    }

    prTargetAddr = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex;
    if(prTargetAddr == NULL)
    {
        LOG(3, "_SWDMX_MpgGetTickByPos prTargetAddr null\n");
        *pu4TickNum = prValidStart->ui4_tick_num;
        _SWDMX_UnlockRangeSema(u1SrcId);
        return FALSE;
    }
    prTargetEndAddr = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex;
    if(prTargetEndAddr == NULL)
    {
        LOG(3, "_SWDMX_MpgGetTickByPos prTargetEndAddr null\n");
        *pu4TickNum = prValidStart->ui4_tick_num;
        _SWDMX_UnlockRangeSema(u1SrcId);
        return FALSE;
    }

    for(u4Tmp=0;u4Tmp<prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.ui4_entry_num;u4Tmp++)
    {
        if(i4PlaySpeed >= 0)
        {
            if(prTargetAddr > prEndAddr)
            {
                prTargetAddr = prStartAddr;
            }
            if(u8Pos <= (((UINT64)prTargetAddr->ui4_lba * MPG_LBA_BLOCK_SIZE) +
                         prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset))
            {
                break;
            }
            if(SWDMX_MPG_TICK_FLAG_CHECK(prTargetAddr,
                (PVR_TICK_INDEX_FLAG_EMPTY | PVR_TICK_INDEX_FLAG_BAD)))
            {
                break;
            }
            prTargetAddr = prTargetAddr + 1;
        }
        else
        {
            if(prTargetAddr < prStartAddr)
            {
                prTargetAddr = prEndAddr;
            }
            if(u8Pos >= (((UINT64)prTargetAddr->ui4_lba * MPG_LBA_BLOCK_SIZE) +
                         prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset))
            {
                break;
            }
            if(SWDMX_MPG_TICK_FLAG_CHECK(prTargetAddr,
                (PVR_TICK_INDEX_FLAG_EMPTY | PVR_TICK_INDEX_FLAG_BAD)))
            {
                break;
            }
            prTargetAddr = prTargetAddr - 1;
        }
    }


    for(u4Tmp=0;u4Tmp<prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.ui4_entry_num;u4Tmp++)
    {
        if(i4PlaySpeed >= 0)
        {
            if(prTargetEndAddr > prEndAddr)
            {
                prTargetEndAddr = prStartAddr;
            }
            if((u8Pos + (UINT64)(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OneTimeSize * MPG_BATCH_READ_SIZE))
                < (((UINT64)prTargetEndAddr->ui4_lba * MPG_LBA_BLOCK_SIZE) +
                   prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset))
            {
                break;
            }
            if(SWDMX_MPG_TICK_FLAG_CHECK(prTargetEndAddr,
                (PVR_TICK_INDEX_FLAG_EMPTY | PVR_TICK_INDEX_FLAG_BAD)))
            {
                break;
            }
            if(prTargetEndAddr->ui4_tick_num >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeEndTick)
            {
                break;
            }
            prTargetEndAddr = prTargetEndAddr + 1;
        }
    }

    if(fgUpdate)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex = prTargetAddr;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex = prTargetEndAddr;
        if((i4PlaySpeed >= 0) &&
           (SWDMX_MPG_TICK_FLAG_CHECK(prTargetEndAddr,
            (PVR_TICK_INDEX_FLAG_EMPTY | PVR_TICK_INDEX_FLAG_BAD))))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex = prTargetEndAddr;
        }
    }

    *pu4TickNum = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex->ui4_tick_num;
    LOG(8, "_SWDMX_MpgGetTickByPos u4TickNum = %d\n", *pu4TickNum);
    _SWDMX_UnlockRangeSema(u1SrcId);
#endif
    return TRUE;
}
#if 0
BOOL _SWDMX_MpgCheckNoSignal()
{
#ifdef TIME_SHIFT_SUPPORT
    UINT32 u4Tmp;
    UINT32 u4Num;
    SWDMX_MPG_PVR_TICK_INDEX_T *prStartAddr;
    SWDMX_MPG_PVR_TICK_INDEX_T *prEndAddr;
    SWDMX_MPG_PVR_TICK_INDEX_T *prValidStart;
    SWDMX_MPG_PVR_TICK_INDEX_T *prValidEnd;
    SWDMX_MPG_PVR_TICK_INDEX_T *prTargetAddr;
#endif
    u4Num = 0;
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        return FALSE;
    }
#ifdef TIME_SHIFT_SUPPORT
    prEndAddr = (SWDMX_MPG_PVR_TICK_INDEX_T*)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_end_address;
    prStartAddr = (SWDMX_MPG_PVR_TICK_INDEX_T*)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_start_address;
    if(prStartAddr >= prEndAddr)
    {
        LOG(3, "_SWDMX_MpgCheckNoSignal prStartAddr >= prEndAddr fail\n");
        return FALSE;
    }

    _SWDMX_LockRangeSema(u1SrcId);

    prValidStart = (SWDMX_MPG_PVR_TICK_INDEX_T*)
        (prStartAddr + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_start);
    if((prValidStart == NULL) ||
       (prValidStart >= prEndAddr) ||
       (prValidStart < prStartAddr))
    {
        LOG(3, "_SWDMX_MpgCheckNoSignal valid start prTickIndex fail\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return FALSE;
    }

    prValidEnd = (SWDMX_MPG_PVR_TICK_INDEX_T*)
        (prStartAddr + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_end);
    if((prValidEnd == NULL) ||
       (prValidEnd >= prEndAddr) ||
       (prValidEnd < prStartAddr))
    {
        LOG(3, "_SWDMX_MpgCheckNoSignal valid end prTickIndex fail\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return FALSE;
    }

    _SWDMX_UnlockRangeSema(u1SrcId);

    if((u8Pos >= ((UINT64)prValidEnd->ui4_lba * MPG_LBA_BLOCK_SIZE)) ||
       (u8Pos < ((UINT64)prValidStart->ui4_lba * MPG_LBA_BLOCK_SIZE)))
    {
        LOG(3, "_SWDMX_MpgCheckNoSignal u8Pos(0x%llx) not in 0x%llx-0x%llx\n",
            u8Pos,
            ((UINT64)prValidStart->ui4_lba * MPG_LBA_BLOCK_SIZE),
            ((UINT64)prValidEnd->ui4_lba * MPG_LBA_BLOCK_SIZE));
        return FALSE;
    }

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex == NULL)
    {
        LOG(3, "_SWDMX_MpgCheckNoSignal prLastTickIndex null\n");
        return FALSE;
    }
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex == NULL)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex = prValidStart;
    }

    if(prValidStart > prValidEnd)
    {
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex > prValidEnd) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex < prValidStart))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex = prValidStart;
            LOG(3, "_SWDMX_MpgCheckNoSignal prLastTickIndex out of range 1\n");
            return FALSE;
        }
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex > prValidEnd) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex < prValidStart))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex = prValidStart;
            LOG(3, "_SWDMX_MpgCheckNoSignal prLastEndTickIndex out of range 2\n");
            return FALSE;
        }
    }
    else
    {
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex > prValidEnd) ||
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex < prValidStart))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex = prValidStart;
            LOG(3, "_SWDMX_MpgCheckNoSignal prLastTickIndex out of range 3\n");
            return FALSE;
        }
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex > prValidEnd) ||
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex < prValidStart))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex = prValidStart;
            LOG(3, "_SWDMX_MpgCheckNoSignal prLastEndTickIndex out of range 4\n");
            return FALSE;
        }
    }

    prTargetAddr = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex;
    if(prTargetAddr == NULL)
    {
        LOG(3, "_SWDMX_MpgCheckNoSignal prTargetAddr null\n");
        return FALSE;
    }

    for(u4Tmp=0;u4Tmp<prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.ui4_entry_num;u4Tmp++)
    {
        if(prTargetAddr >= prEndAddr)
        {
            prTargetAddr = prStartAddr;
        }
        if(prTargetAddr == prValidEnd)
        {
            break;
        }
        if(SWDMX_MPG_TICK_FLAG_CHECK(prTargetAddr,
            (PVR_TICK_INDEX_FLAG_EMPTY | PVR_TICK_INDEX_FLAG_BAD)))
        {
            break;
        }
        prTargetAddr = prTargetAddr + 1;
    }

    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex = prTargetAddr;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex = prTargetAddr;
        if((i4PlaySpeed > 0) &&
           (SWDMX_MPG_TICK_FLAG_CHECK(prTargetEndAddr,
            (PVR_TICK_INDEX_FLAG_EMPTY | PVR_TICK_INDEX_FLAG_BAD))))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex = prTargetEndAddr;
        }
    }

    *pu4TickNum = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex->ui4_tick_num;
    LOG(8, "_SWDMX_MpgCheckNoSignal u4TickNum = %d\n", *pu4TickNum);
#endif
    return TRUE;
}
#endif

BOOL _SWDMX_MpgIsPositionAvailable(UINT8 u1SrcId, UINT64 u8Position)
{
#ifdef TIME_SHIFT_SUPPORT
    SWDMX_MPG_PVR_TICK_INDEX_T *prStartAddr;
    SWDMX_MPG_PVR_TICK_INDEX_T *prEndAddr;
    SWDMX_MPG_PVR_TICK_INDEX_T *prSafeStart;
    SWDMX_MPG_PVR_TICK_INDEX_T *prSafeEnd;
#endif

    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        return TRUE;
    }

#ifdef TIME_SHIFT_SUPPORT
    // from the explain of mw pv_end_address is the end address of the tick_index_talbe;
    prEndAddr = (SWDMX_MPG_PVR_TICK_INDEX_T*)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_end_address -1;
    prStartAddr = (SWDMX_MPG_PVR_TICK_INDEX_T*)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_start_address;
    if(prStartAddr > prEndAddr)
    {
        LOG(3, "_SWDMX_MpgIsPositionAvailable prStartAddr >= prEndAddr fail\n");
        return TRUE;
    }

    _SWDMX_LockRangeSema(u1SrcId);

    prSafeStart = (SWDMX_MPG_PVR_TICK_INDEX_T*)
        (prStartAddr + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_safe.ui4_start);
    if((prSafeStart == NULL) ||
       (prSafeStart > prEndAddr) ||
       (prSafeStart < prStartAddr))
    {
        LOG(3, "_SWDMX_MpgIsPositionAvailable valid start prTickIndex fail\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return TRUE;
    }

    prSafeEnd = (SWDMX_MPG_PVR_TICK_INDEX_T*)
        (prStartAddr + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_safe.ui4_end);
    if((prSafeEnd == NULL) ||
       (prSafeEnd > prEndAddr) ||
       (prSafeEnd < prStartAddr))
    {
        LOG(3, "_SWDMX_MpgIsPositionAvailable valid end prTickIndex fail\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return TRUE;
    }   
    
    if(u8Position > (((UINT64)prSafeEnd->ui4_lba * MPG_LBA_BLOCK_SIZE) +
                      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset))
    {
        LOG(5, "_SWDMX_MpgIsPositionAvailable u8Pos(0x%llx) not in 0x%llx-0x%llx\n",
            u8Position,
            _SWDMX_MpgLBA2Pos(u1SrcId, (prSafeStart->ui4_lba)),
            _SWDMX_MpgLBA2Pos(u1SrcId, (prSafeEnd->ui4_lba)));

        _SWDMX_UnlockRangeSema(u1SrcId);
        return FALSE;
    }
    if(u8Position < (((UINT64)prSafeStart->ui4_lba * MPG_LBA_BLOCK_SIZE) +
                      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset))
    {
        LOG(5, "_SWDMX_MpgIsPositionAvailable u8Pos(0x%llx) not in 0x%llx-0x%llx\n",
            u8Position,
            _SWDMX_MpgLBA2Pos(u1SrcId, (prSafeStart->ui4_lba)),
            _SWDMX_MpgLBA2Pos(u1SrcId, (prSafeEnd->ui4_lba)));

        _SWDMX_UnlockRangeSema(u1SrcId);
        return FALSE;
    }
    _SWDMX_UnlockRangeSema(u1SrcId);
#endif
    return TRUE;
}


BOOL _SWDMX_MpgIsSpeedAvailable(UINT8 u1SrcId, BOOL fgForward)
{
#ifdef TIME_SHIFT_SUPPORT
    UINT64 u8Position;
    SWDMX_MPG_PVR_TICK_INDEX_T *prStartAddr;
    SWDMX_MPG_PVR_TICK_INDEX_T *prEndAddr;
    SWDMX_MPG_PVR_TICK_INDEX_T *prSafeStart;
    SWDMX_MPG_PVR_TICK_INDEX_T *prSafeEnd;
#endif

    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if((prSwdmxInst->eSeekType == eSWDMX_TYPE_TIME_SEEK) &&
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES))
    {
        return FALSE;
    }
    else if((prSwdmxInst->eSeekType == eSWDMX_TYPE_BYTE_SEEK) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_MPEG2_TS_206))
    {
		return FALSE;
    }	
    else if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        return TRUE;
    }

#ifdef TIME_SHIFT_SUPPORT
    // handle no signa case
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage != MPG_TSS_NORMAL)
    {
        return TRUE;
    }
    // handle empty case
    else if((!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo) &&
            // while we are parsing table, not handle this.
            (!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgCheckPSISize) &&
            // both audio on and off have to check this.
            //(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio) &&
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed != 1000) &&
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed != 0))
               // do not need to consider changing
               // because we could get our swdmx current position
               // that's the correct one.
               //(prSwdmxInst) &&
               //(!prSwdmxInst->fgPlayChange) && // not changing speed
    {
        return TRUE;
    }
#endif

#ifdef TIME_SHIFT_SUPPORT
    // from the explain of mw pv_end_address is the end address of the tick_index_talbe;
    prEndAddr = (SWDMX_MPG_PVR_TICK_INDEX_T*)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_end_address -1;
    prStartAddr = (SWDMX_MPG_PVR_TICK_INDEX_T*)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_start_address;
    if(prStartAddr > prEndAddr)
    {
        LOG(3, "_SWDMX_MpgIsSpeedAvailable prStartAddr >= prEndAddr fail\n");
        return TRUE;
    }

    _SWDMX_LockRangeSema(u1SrcId);

    prSafeStart = (SWDMX_MPG_PVR_TICK_INDEX_T*)
        (prStartAddr + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_safe.ui4_start);
    if((prSafeStart == NULL) ||
       (prSafeStart > prEndAddr) ||
       (prSafeStart < prStartAddr))
    {
        LOG(3, "_SWDMX_MpgIsSpeedAvailable valid start prTickIndex fail\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return TRUE;
    }

    prSafeEnd = (SWDMX_MPG_PVR_TICK_INDEX_T*)
        (prStartAddr + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_safe.ui4_end);
    if((prSafeEnd == NULL) ||
       (prSafeEnd > prEndAddr) ||
       (prSafeEnd < prStartAddr))
    {
        LOG(3, "_SWDMX_MpgIsSpeedAvailable valid end prTickIndex fail\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return TRUE;
    }

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset)
    {
        LOG(3, "_SWDMX_MpgIsSpeedAvailable (u8SendedSize < u8FifoOffset) fail\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return TRUE;
    }

    u8Position = (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize);
    // DTV00142192, After repeatedly press"Step Forward" key, video freezes and offset time adds.
    // use the new seek position
    if((prSwdmxInst) &&
       (prSwdmxInst->fgPlayChange) &&
       (prSwdmxInst->u8SeekPos != (UINT64)(-1)) &&
       (prSwdmxInst->eSwDmxStatus == eSWDMX_STATE_PAUSE))
    {
        // pause and change position
        u8Position = (prSwdmxInst->u8SeekPos);
    }

    if((u8Position > (((UINT64)prSafeEnd->ui4_lba * MPG_LBA_BLOCK_SIZE) +
                      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset)) &&
       (fgForward))
    {
        LOG(1, "_SWDMX_MpgIsSpeedAvailable u8Pos(0x%llx) not in 0x%llx-0x%llx\n",
            u8Position,
            _SWDMX_MpgLBA2Pos(u1SrcId, (prSafeStart->ui4_lba)),
            _SWDMX_MpgLBA2Pos(u1SrcId, (prSafeEnd->ui4_lba)));

        _SWDMX_UnlockRangeSema(u1SrcId);
        return FALSE;
    }
    if((u8Position < (((UINT64)prSafeStart->ui4_lba * MPG_LBA_BLOCK_SIZE) +
                      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset)) &&
       (!fgForward))
    {
        LOG(1, "_SWDMX_MpgIsSpeedAvailable u8Pos(0x%llx) not in 0x%llx-0x%llx\n",
            u8Position,
            _SWDMX_MpgLBA2Pos(u1SrcId, (prSafeStart->ui4_lba)),
            _SWDMX_MpgLBA2Pos(u1SrcId, (prSafeEnd->ui4_lba)));

        _SWDMX_UnlockRangeSema(u1SrcId);
        return FALSE;
    }
    _SWDMX_UnlockRangeSema(u1SrcId);
#endif
    return TRUE;
}

INT32 _SWDMX_MpgHandleNoSignel(UINT8 u1SrcId, UINT64 *pu8SeekPos, INT32 i4PlaySpeed)
{
    INT32 i4Ret;
#ifdef TIME_SHIFT_SUPPORT
    static UINT32 u4LogCnt = 0;
    UINT32 u4TickNum;
    UINT64 u8TickNum;
    UINT64 u8Remainder;
    UINT32 u4CurDeltaTime;
    HAL_TIME_T CheckTime;
    SWDMX_MPG_PVR_TICK_INDEX_T *prStartAddr;
    SWDMX_MPG_PVR_TICK_INDEX_T *prEndAddr;
    SWDMX_MPG_PVR_TICK_INDEX_T *prValidStart;
    SWDMX_MPG_PVR_TICK_INDEX_T *prValidEnd;
    SWDMX_MPG_PVR_TICK_INDEX_T *prTargetAddr;
#endif

    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    i4Ret = MPG_SEND_OK;
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        return MPG_SEND_FAIL;
    }
#ifdef TIME_SHIFT_SUPPORT
    // Step
    if(i4PlaySpeed == 1)
    {
        SWDMX_Pause(u1SrcId);
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
        {
            _SWDMX_RANGE_CALLBACK(
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                MM_RANGE_SEEK_DONE,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                0xFFFFFFFF,
                (UINT32)u1SrcId);
        }
        else
        {
            LOG(3, "pfnSwdmxRangeCb null\n");
        }
        LOG(5, "NoSignel: MM_RANGE_SEEK_DONE\n");
    }
    else if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1NumNoSignal >= 0xF0)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1NumNoSignal = 0;
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
        {
            _SWDMX_RANGE_CALLBACK(
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                MM_RANGE_SEEK_DONE,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                0xFFFFFFFF,
                (UINT32)u1SrcId);
        }
        else
        {
            LOG(3, "pfnSwdmxRangeCb null\n");
        }
        LOG(5, "NoSignel: MM_RANGE_SEEK_DONE\n");
    }
    else
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1NumNoSignal += 4;
    }

    // DTV00214748 we should calibrate prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime as x_thread_delay() is not evry exactly
    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNeedAdjust==TRUE)&&(i4PlaySpeed==1000))
    {
       HAL_GetTime(&CheckTime);
       u4CurDeltaTime= CheckTime.u4Seconds*1000+ CheckTime.u4Micros/1000 - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime;
       if(u4CurDeltaTime > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OrgtDeltaTime)
       {
           if((u4CurDeltaTime-prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OrgtDeltaTime)>300)
           {
              prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime += (u4CurDeltaTime-prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OrgtDeltaTime);
              LOG(5,"_SWDMX_MpgHandleNoSignal adjust u8CurTime Delta:%d ms\n",
                u4CurDeltaTime-prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4OrgtDeltaTime);
           }
       }
    }
    else
    {
       prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNeedAdjust=FALSE;
    }

    x_thread_delay(1000/MPG_TIMER_DELAY_TIMES);
    if(i4PlaySpeed >= 0)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime +=
            i4PlaySpeed/MPG_TIMER_DELAY_TIMES;
    }
    else
    {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime >= ((UINT32)(-i4PlaySpeed)/MPG_TIMER_DELAY_TIMES))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime -=
                ((UINT32)(-i4PlaySpeed)/MPG_TIMER_DELAY_TIMES);
        }
        else
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime = 0;
        }
    }

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TickBase > 0)
    {
        u8TickNum = _SWDMX_Div6464(
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime,
            (UINT64)(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TickBase),
            &u8Remainder);
    }
    else
    {
        ASSERT(0);
        u8TickNum = _SWDMX_Div6464(
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime,
            (UINT64)(500),  // u8CurTime is milli-second unit
            &u8Remainder);
    }
    ASSERT(u8TickNum < (UINT32)0xFFFFFFFF);
    u4TickNum = (UINT32)u8TickNum;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum = u4TickNum;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ReadTickNum = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum;

    // DTV00142071, After plug RF cable again, mini pane time displays incorrectly.
    // set current tick to vdp, so MW will get correct one after plug signal
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
    {
        VDP_SET_PIC_INFO_T rVdpSetPicInfo;
        x_memset(&rVdpSetPicInfo, 0, sizeof(rVdpSetPicInfo));
        rVdpSetPicInfo.u4TickNum = u4TickNum;
        if (VDP_SetPicInfo(prSwdmxInst->u1B2rId, rVdpSetPicInfo) != VDP_SET_OK)
        {
            LOG(3, "NoSignel: VDP_SetPicInfo u4TickNum(%d) fail\n", u4TickNum);
        }
    }

    u4LogCnt++;
    if(u4LogCnt >= MPG_TIMER_DELAY_TIMES)
    {
        LOG(5, "NoSignel: CurTickNum %d\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum);
        u4LogCnt = 0;
        UNUSED(u4LogCnt);
    }

    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage == MPG_TSS_PREPARE_NO_SIGNAL) ||
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage == MPG_TSS_PREPARE_BAD_STORAGE))
    {
        if(((i4PlaySpeed >= 0) &&
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum >=
             prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalTickNum))
           ||
           ((i4PlaySpeed < 0) &&
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum <=
             prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalTickNum))
          )
        {
            LOG(3, "NoSignel: u4NoSignalStage 2, tick num %d\n",
                u4TickNum);
            if((prSwdmxInst) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
            {
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
                {
                    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage == MPG_TSS_PREPARE_NO_SIGNAL)
                    {
                        _SWDMX_RANGE_CALLBACK(
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                            MM_SIGNAL_Y_TO_N,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                            0xFFFFFFFF,
                            (UINT32)u1SrcId);
                    }
                    else //(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage == MPG_TSS_PREPARE_BAD_STORAGE)
                    {
                        _SWDMX_RANGE_CALLBACK(
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                            MM_BAD_TICK_N_TO_Y,
                            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                            0xFFFFFFFF,
                            (UINT32)u1SrcId);
                    }
                }
            }
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage == MPG_TSS_PREPARE_NO_SIGNAL)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage = MPG_TSS_UNDER_NO_SIGNAL;
            }
            else //(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage == MPG_TSS_PREPARE_BAD_STORAGE)
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage = MPG_TSS_UNDER_BAD_STORAGE;
            }
        }
    }

    //if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage != MPG_TSS_UNDER_NO_SIGNAL) &&
    //   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage != MPG_TSS_UNDER_BAD_STORAGE)&&
    //   (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgInScramble!=TRUE))
    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage != MPG_TSS_UNDER_NO_SIGNAL) &&
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage != MPG_TSS_UNDER_BAD_STORAGE))

    {
        LOG(3, "NoSignel: u4NoSignalStage 1, waiting, cur tick %d, ng tick %d\n",
            u4TickNum,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalTickNum);
        return MPG_SEND_FULL;
    }

    prEndAddr = (SWDMX_MPG_PVR_TICK_INDEX_T*)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_end_address -1;
    prStartAddr = (SWDMX_MPG_PVR_TICK_INDEX_T*)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_start_address;
    if(prStartAddr > prEndAddr)
    {
        LOG(3, "NoSignel:  prStartAddr >= prEndAddr fail\n");
        return MPG_SEND_FAIL;
    }

    _SWDMX_LockRangeSema(u1SrcId);

    prValidStart = (SWDMX_MPG_PVR_TICK_INDEX_T*)
        (prStartAddr + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_start);
    if((prValidStart == NULL) ||
       (prValidStart > prEndAddr) ||
       (prValidStart < prStartAddr))
    {
        LOG(3, "NoSignel: valid start prTickIndex fail\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return MPG_SEND_FAIL;
    }

    prValidEnd = (SWDMX_MPG_PVR_TICK_INDEX_T*)
        (prStartAddr + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_end);
    if((prValidEnd == NULL) ||
       (prValidEnd > prEndAddr) ||
       (prValidEnd < prStartAddr))
    {
        LOG(3, "NoSignel: valid end prTickIndex fail\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return MPG_SEND_FAIL;
    }

    if((u4TickNum >= prValidEnd->ui4_tick_num) ||
       (u4TickNum < prValidStart->ui4_tick_num))
    {
        LOG(3, "NoSignel: invalid u4TickNum %d, %d-%d\n",
            u4TickNum, prValidStart->ui4_tick_num, prValidEnd->ui4_tick_num);
        if(i4PlaySpeed >= 0)
        {
            LOG(3, "NoSignel: invalid u4TickNum %d->%d\n",
                u4TickNum, prValidEnd->ui4_tick_num);
            u4TickNum = prValidEnd->ui4_tick_num;
        }
        else
        {
            LOG(3, "NoSignel: invalid u4TickNum %d->%d\n",
                u4TickNum, prValidStart->ui4_tick_num);
            u4TickNum = prValidStart->ui4_tick_num;
        }
    }

    prTargetAddr = prValidStart + (u4TickNum - prValidStart->ui4_tick_num);
    if(prTargetAddr == NULL)
    {
        LOG(3, "NoSignel: prTargetAddr null\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return MPG_SEND_FAIL;
    }
    if(prTargetAddr > prEndAddr)
    {
        prTargetAddr -= ((prEndAddr +1) - prStartAddr);
    }
    if(prTargetAddr == NULL)
    {
        LOG(3, "NoSignel: prTargetAddr null\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return MPG_SEND_FAIL;
    }
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex = prTargetAddr;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex = prTargetAddr;

    if((!(SWDMX_MPG_TICK_FLAG_CHECK(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex,
          PVR_TICK_INDEX_FLAG_EMPTY))) &&
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage == MPG_TSS_UNDER_NO_SIGNAL))
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage = MPG_TSS_NORMAL;
        *pu8SeekPos = _SWDMX_MpgLBA2Pos(u1SrcId, (prTargetAddr->ui4_lba));
        *pu8SeekPos = _SWDMX_MpgTSAlignDown(u1SrcId, *pu8SeekPos);
        LOG(3, "NoSignel: u4NoSignalStage 0, from have signal tick num %d\n",
            prTargetAddr->ui4_tick_num);
        if((prSwdmxInst) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
        {
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
            {
                _SWDMX_RANGE_CALLBACK(
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                    MM_SIGNAL_N_TO_Y,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                    0xFFFFFFFF,
                    (UINT32)u1SrcId);
            }
        }
    }
    else if((!(SWDMX_MPG_TICK_FLAG_CHECK(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex,
          PVR_TICK_INDEX_FLAG_BAD))) &&
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage == MPG_TSS_UNDER_BAD_STORAGE))
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage = MPG_TSS_NORMAL;
        *pu8SeekPos = _SWDMX_MpgLBA2Pos(u1SrcId, (prTargetAddr->ui4_lba));
        *pu8SeekPos = _SWDMX_MpgTSAlignDown(u1SrcId, *pu8SeekPos);
        LOG(3, "NoSignel: u4NoSignalStage 0, from good storage tick num %d\n",
            prTargetAddr->ui4_tick_num);
        if((prSwdmxInst) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
        {
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
            {
                _SWDMX_RANGE_CALLBACK(
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                    MM_BAD_TICK_Y_TO_N,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                    0xFFFFFFFF,
                    (UINT32)u1SrcId);
            }
        }
    }

    if(((SWDMX_MPG_TICK_FLAG_CHECK(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex,
          PVR_TICK_INDEX_FLAG_EMPTY))) &&
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage == MPG_TSS_NORMAL))
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage = MPG_TSS_UNDER_NO_SIGNAL;
        *pu8SeekPos = _SWDMX_MpgLBA2Pos(u1SrcId, (prTargetAddr->ui4_lba));
        *pu8SeekPos = _SWDMX_MpgTSAlignDown(u1SrcId, *pu8SeekPos);
        LOG(3, "NoSignel: u4NoSignalStage UNDER_NO_SIGNAL, no signal tick num %d\n",
            prTargetAddr->ui4_tick_num);
        if((prSwdmxInst) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
        {
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
            {
                _SWDMX_RANGE_CALLBACK(
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                    MM_SIGNAL_Y_TO_N,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                    0xFFFFFFFF,
                    (UINT32)u1SrcId);
            }
        }
    }
    else if(((SWDMX_MPG_TICK_FLAG_CHECK(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex,
          PVR_TICK_INDEX_FLAG_BAD))) &&
       (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage == MPG_TSS_NORMAL))
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage = MPG_TSS_UNDER_BAD_STORAGE;
        *pu8SeekPos = _SWDMX_MpgLBA2Pos(u1SrcId, (prTargetAddr->ui4_lba));
        *pu8SeekPos = _SWDMX_MpgTSAlignDown(u1SrcId, *pu8SeekPos);
        LOG(3, "NoSignel: u4NoSignalStage UNDER_BAD_STORAGE, bad tick num %d\n",
            prTargetAddr->ui4_tick_num);
        if((prSwdmxInst) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
        {
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
            {
                _SWDMX_RANGE_CALLBACK(
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                    MM_BAD_TICK_N_TO_Y,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                    0xFFFFFFFF,
                    (UINT32)u1SrcId);
            }
        }
    }

    // because here is empty, lba value is invalid
    /*
    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorLBA)
        &&
       (
        ((i4PlaySpeed >= 0) &&
         (((UINT64)prTargetAddr->ui4_lba * MPG_LBA_BLOCK_SIZE) >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8MonitorAddr))
        ||
        ((i4PlaySpeed < 0) &&
         (((UINT64)prTargetAddr->ui4_lba * MPG_LBA_BLOCK_SIZE) < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8MonitorAddr))
       )
      )
    {
        LOG(3, "NoSignel: fgMonitorLBA addr 0x%llx in start addr 0x%llx end addr 0x%llx\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8MonitorAddr,
            u8StartAddr,
            u8EndAddr);
        if((prSwdmxInst) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
        {
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
            {
                _SWDMX_RANGE_CALLBACK(
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                    MM_MONITOR_LBA_ARRIVAL,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                    0xFFFFFFFF,
                    (UINT32)u1SrcId);
            }
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorLBA = FALSE;
    }
    */

    if(prTargetAddr->ui4_tick_num >=
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeEndTick))
    {
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeEnd) &&
           (i4PlaySpeed >= 0))
        {
            LOG(3, "NoSignel: fgMonitorSafeEnd tick %d safe end tick %d\n",
                prTargetAddr->ui4_tick_num,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeEndTick);
            if((prSwdmxInst) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
            {
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
                {
                    _SWDMX_RANGE_CALLBACK(
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                        MM_OUT_OF_SAFE_RANGE_END,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                        0xFFFFFFFF,
                        (UINT32)u1SrcId);
                }
            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeEnd = FALSE;
        }
    }
    else if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeEnd)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeEnd = TRUE;
    }

    if((prTargetAddr->ui4_tick_num) <
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeStartTick))
    {
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeStart) &&
           (i4PlaySpeed < 0))
        {
            LOG(3, "NoSignel: fgMonitorSafeStart tick %d safe start tick %d\n",
                prTargetAddr->ui4_tick_num,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeStartTick);
            if((prSwdmxInst) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
            {
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
                {
                    _SWDMX_RANGE_CALLBACK(
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                        MM_OUT_OF_SAFE_RANGE_START,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                        0xFFFFFFFF,
                        (UINT32)u1SrcId);
                }
            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeStart = FALSE;
        }
    }
    else if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeStart)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeStart = TRUE;
    }

    if(prTargetAddr->ui4_tick_num >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ValidEndTick)
    {
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorValidEnd) &&
           (i4PlaySpeed >= 0))
        {
            LOG(3, "NoSignel: fgMonitorValidEnd tick %d valid end tick %d\n",
                prTargetAddr->ui4_tick_num,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ValidEndTick);
            if((prSwdmxInst) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
            {
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
                {
                    _SWDMX_RANGE_CALLBACK(
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                        MM_REACH_VALID_RANGE_END,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                        0xFFFFFFFF,
                        (UINT32)u1SrcId);
                }
            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorValidEnd = FALSE;
        }
        i4Ret = MPG_SEND_FULL;
    }

    if(prTargetAddr->ui4_tick_num < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ValidStartTick)
    {
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorValidStart) &&
           (i4PlaySpeed < 0))
        {
            LOG(3, "NoSignel: fgMonitorValidStart tick %d valid start tick %d\n",
                prTargetAddr->ui4_tick_num,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ValidStartTick);
            if((prSwdmxInst) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
            {
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
                {
                    _SWDMX_RANGE_CALLBACK(
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                        MM_REACH_VALID_RANGE_START,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                        0xFFFFFFFF,
                        (UINT32)u1SrcId);
                }
            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorValidStart = FALSE;
        }
        i4Ret = MPG_SEND_FULL;
    }

    _SWDMX_UnlockRangeSema(u1SrcId);
#endif
    return i4Ret;
}

INT32 _SWDMX_MpgHandleEmpty(UINT8 u1SrcId, UINT64 *pu8SeekPos, INT32 i4PlaySpeed)
{
    INT32 i4Ret;
#ifdef TIME_SHIFT_SUPPORT
    static UINT32 u4LogCnt = 0;
    UINT32 u4TickNum;
    UINT64 u8TickNum;
    UINT64 u8Remainder;
    SWDMX_MPG_PVR_TICK_INDEX_T *prStartAddr;
    SWDMX_MPG_PVR_TICK_INDEX_T *prEndAddr;
    SWDMX_MPG_PVR_TICK_INDEX_T *prValidStart;
    SWDMX_MPG_PVR_TICK_INDEX_T *prValidEnd;
    SWDMX_MPG_PVR_TICK_INDEX_T *prTargetAddr;
#endif
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    i4Ret = MPG_SEND_OK;
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt != SWDMX_FMT_MPEG2_TS_TIME_SHIFT)
    {
        return MPG_SEND_FAIL;
    }
#ifdef TIME_SHIFT_SUPPORT
    // Step
    if(i4PlaySpeed == 1)
    {
        SWDMX_Pause(u1SrcId);
        if(/*(_SWDMX_RANGE_CALLBACK) &&*/
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
        {
            _SWDMX_RANGE_CALLBACK(
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                MM_RANGE_SEEK_DONE,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                0xFFFFFFFF,
                (UINT32)u1SrcId);
        }
        else
        {
            LOG(3, "pfnSwdmxRangeCb null\n");
        }
        LOG(5, "Empty: MM_RANGE_SEEK_DONE\n");
    }

    x_thread_delay(1000/MPG_TIMER_DELAY_TIMES);
    if(i4PlaySpeed >= 0)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime +=
            i4PlaySpeed/MPG_TIMER_DELAY_TIMES;
    }
    else
    {
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime >= ((UINT32)(-i4PlaySpeed)/MPG_TIMER_DELAY_TIMES))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime -=
                ((UINT32)(-i4PlaySpeed)/MPG_TIMER_DELAY_TIMES);
        }
        else
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime = 0;
        }
    }

    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TickBase > 0)
    {
        u8TickNum = _SWDMX_Div6464(
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime,
            (UINT64)(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TickBase),
            &u8Remainder);
    }
    else
    {
        ASSERT(0);
        u8TickNum = _SWDMX_Div6464(
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime,
            (UINT64)(45000),
            &u8Remainder);
    }
    ASSERT(u8TickNum < (UINT32)0xFFFFFFFF);
    u4TickNum = (UINT32)u8TickNum;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum = u4TickNum;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ReadTickNum = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum;

    // This function is audio only case. We don't need this.
    #if 0
    {
        VDP_SET_PIC_INFO_T rVdpSetPicInfo;
        x_memset(&rVdpSetPicInfo, 0, sizeof(rVdpSetPicInfo));
        rVdpSetPicInfo.u4TickNum = u4TickNum;
        if (VDP_SetPicInfo(prSwdmxInst->u1B2rId, &rVdpSetPicInfo) != VDP_SET_OK)
        {
            LOG(3, "Empty: VDP_SetPicInfo u4TickNum(%d) fail\n", u4TickNum);
        }
    }
    #endif

    u4LogCnt++;
    if(u4LogCnt >= MPG_TIMER_DELAY_TIMES)
    {
        LOG(5, "Empty: CurTickNum %d\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4CurTickNum);
        u4LogCnt = 0;
        UNUSED(u4LogCnt);
    }

    prEndAddr = (SWDMX_MPG_PVR_TICK_INDEX_T*)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_end_address -1;
    prStartAddr = (SWDMX_MPG_PVR_TICK_INDEX_T*)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rTickCtl.pv_start_address;
    if(prStartAddr > prEndAddr)
    {
        LOG(3, "Empty:  prStartAddr >= prEndAddr fail\n");
        return MPG_SEND_FAIL;
    }

    _SWDMX_LockRangeSema(u1SrcId);

    prValidStart = (SWDMX_MPG_PVR_TICK_INDEX_T*)
        (prStartAddr + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_start);
    if((prValidStart == NULL) ||
       (prValidStart > prEndAddr) ||
       (prValidStart < prStartAddr))
    {
        LOG(3, "Empty:  valid start prTickIndex fail\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return MPG_SEND_FAIL;
    }

    prValidEnd = (SWDMX_MPG_PVR_TICK_INDEX_T*)
        (prStartAddr + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.rRangeInfo.t_valid.ui4_end);
    if((prValidEnd == NULL) ||
       (prValidEnd > prEndAddr) ||
       (prValidEnd < prStartAddr))
    {
        LOG(3, "Empty: valid end prTickIndex fail\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return MPG_SEND_FAIL;
    }

    if((u4TickNum >= prValidEnd->ui4_tick_num) ||
       (u4TickNum < prValidStart->ui4_tick_num))
    {
        LOG(3, "Empty: invalid u4TickNum %d, %d-%d\n",
            u4TickNum, prValidStart->ui4_tick_num, prValidEnd->ui4_tick_num);
        if(i4PlaySpeed >= 0)
        {
            LOG(3, "Empty: invalid u4TickNum %d->%d\n",
                u4TickNum, prValidEnd->ui4_tick_num);
            u4TickNum = prValidEnd->ui4_tick_num;
        }
        else
        {
            LOG(3, "Empty: invalid u4TickNum %d->%d\n",
                u4TickNum, prValidStart->ui4_tick_num);
            u4TickNum = prValidStart->ui4_tick_num;
        }
    }

    prTargetAddr = prValidStart + (u4TickNum - prValidStart->ui4_tick_num);
    if(prTargetAddr == NULL)
    {
        LOG(3, "Empty: prTargetAddr null\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return MPG_SEND_FAIL;
    }
    if(prTargetAddr > prEndAddr)
    {
        prTargetAddr -= ((prEndAddr +1) - prStartAddr);
    }
    if(prTargetAddr == NULL)
    {
        LOG(3, "Empty: prTargetAddr null\n");
        _SWDMX_UnlockRangeSema(u1SrcId);
        return MPG_SEND_FAIL;
    }
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex = prTargetAddr;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastEndTickIndex = prTargetAddr;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = _SWDMX_MpgLBA2Pos(u1SrcId, (prTargetAddr->ui4_lba));
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize = _SWDMX_MpgTSAlignDown(u1SrcId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize);
    if(i4PlaySpeed >= 0)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize += prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase;
    }
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;
    _SWDMX_MpgResetData(u1SrcId);

    if((SWDMX_MPG_TICK_FLAG_CHECK(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex,
        (PVR_TICK_INDEX_FLAG_EMPTY | PVR_TICK_INDEX_FLAG_BAD))) &&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage == MPG_TSS_NORMAL))
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime =
            (UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex->ui4_tick_num;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8CurTime *=
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4TickBase;

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalTickNum =
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex->ui4_tick_num;

        if(SWDMX_MPG_TICK_FLAG_CHECK(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex,
           (PVR_TICK_INDEX_FLAG_EMPTY)))
        {
            LOG(3, "Empty: u4NoSignalStage 1.2.1 audio only, PREPARE_NO_SIGNAL tick %d\n",
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalTickNum);

            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage = MPG_TSS_PREPARE_NO_SIGNAL;
        }
        else //if(SWDMX_MPG_TICK_FLAG_CHECK(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prLastTickIndex,
             //   (PVR_TICK_INDEX_FLAG_BAD)))
        {
            LOG(3, "Empty: u4NoSignalStage 1.2.2 audio only, PREPARE_BAD_STORAGE tick %d\n",
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalTickNum);

            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4NoSignalStage = MPG_TSS_PREPARE_BAD_STORAGE;
        }
        _SWDMX_UnlockRangeSema(u1SrcId);
        return MPG_SEND_FULL;
    }


    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorLBA)
        &&
       (
        ((i4PlaySpeed >= 0) &&
         (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8MonitorAddr))
        ||
        ((i4PlaySpeed < 0) &&
         (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8MonitorAddr))
       )
      )
    {
        LOG(3, "Empty: fgMonitorLBA addr 0x%llx in start addr 0x%llx end addr 0x%llx\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8MonitorAddr,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize);
        if((prSwdmxInst) &&
           (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
        {
            if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
            {
                _SWDMX_RANGE_CALLBACK(
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                    MM_MONITOR_LBA_ARRIVAL,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                    0xFFFFFFFF,
                    (UINT32)u1SrcId);
            }
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorLBA = FALSE;
    }

    if(prTargetAddr->ui4_tick_num >=
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeEndTick))
    {
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeEnd) &&
           (i4PlaySpeed >= 0))
        {
            LOG(3, "Empty: fgMonitorSafeEnd tick %d safe end tick %d\n",
                prTargetAddr->ui4_tick_num,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeEndTick);
            if((prSwdmxInst) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
            {
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
                {
                    _SWDMX_RANGE_CALLBACK(
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                        MM_OUT_OF_SAFE_RANGE_END,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                        0xFFFFFFFF,
                        (UINT32)u1SrcId);
                }
            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeEnd = FALSE;
        }
    }
    else if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeEnd)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeEnd = TRUE;
    }

    if((prTargetAddr->ui4_tick_num) <
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeStartTick))
    {
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeStart) &&
           (i4PlaySpeed < 0))
        {
            LOG(3, "Empty: fgMonitorSafeStart tick %d safe start tick %d\n",
                prTargetAddr->ui4_tick_num,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4SafeStartTick);
            if((prSwdmxInst) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
            {
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
                {
                    _SWDMX_RANGE_CALLBACK(
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                        MM_OUT_OF_SAFE_RANGE_START,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                        0xFFFFFFFF,
                        (UINT32)u1SrcId);
                }
            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeStart = FALSE;
        }
    }
    else if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeStart)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorSafeStart = TRUE;
    }

    if(prTargetAddr->ui4_tick_num >= prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ValidEndTick)
    {
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorValidEnd) &&
           (i4PlaySpeed >= 0))
        {
            LOG(3, "Empty: fgMonitorValidEnd tick %d valid end tick %d\n",
                prTargetAddr->ui4_tick_num,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ValidEndTick);
            if((prSwdmxInst) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
            {
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
                {
                    _SWDMX_RANGE_CALLBACK(
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                        MM_REACH_VALID_RANGE_END,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                        0xFFFFFFFF,
                        (UINT32)u1SrcId);
                }
            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorValidEnd = FALSE;
        }
        i4Ret = MPG_SEND_FULL;
    }

    if(prTargetAddr->ui4_tick_num < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ValidStartTick)
    {
        if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorValidStart) &&
           (i4PlaySpeed < 0))
        {
            LOG(3, "Empty: fgMonitorValidStart tick %d valid start tick %d\n",
                prTargetAddr->ui4_tick_num,
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4ValidStartTick);
            if((prSwdmxInst) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq))
            {
                if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo)
                {
                    _SWDMX_RANGE_CALLBACK(
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pv_tag,
                        MM_REACH_VALID_RANGE_START,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->ui4_range_id,
                        0xFFFFFFFF,
                        (UINT32)u1SrcId);
                }
            }
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgMonitorValidStart = FALSE;
        }
        i4Ret = MPG_SEND_FULL;
    }

    _SWDMX_UnlockRangeSema(u1SrcId);
#endif
    return i4Ret;
}

BOOL _SWDMX_MpgResetFeederReq(UINT8 u1SrcId)          // CR [DTV00211387]  reset feeder request when comes timeout error
{
    UINT32 u4ReqCnt;
    INT32 i4Ret;
    UINT32 u4AlignSize;
    FEEDER_TRANSMIT_COND rFeederCond;

    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if (FeederGetBufferInfo(prSwdmxInst->eFeederSrc, &prSwdmxInst->rFeederInfo) !=
      FEEDER_E_OK)
    {
        LOG(1, "Feeder input buffer error.\n");
        return FALSE;
    }
LOG(5,"reset Feeder Req\n");          //bill
#ifdef SWDMX_MPG_DEBUG_BUFFER
    if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt > 0) || (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes > 0))
    {
        LOG(7, "Mpg Fd Flh UB %d BT %d RT %d BWI %d BRI %d BAC %d RWI %d RRI %d RT %d UAdr %d\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufTotalSize,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufWriteIdx,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingStartAddr);
    }
#endif

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqID += 50; // always a even value
    //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufAvailCnt = 0;
    //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufReadIdx = 0;
    //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufWriteIdx = 0;
    //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4BufTotalSize = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqIBCID = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTimes = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqReadIdx = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqWriteIdx = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4ReqTotalSize = 0;
    //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.u4UsingBufSize = 0;
    //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8ReadedPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize;

    for(u4ReqCnt = 0;u4ReqCnt < prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqNum;u4ReqCnt++)
    {
        // make it invalid, not a even value
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqId[u4ReqCnt] = 1;
#ifdef SWDMX_MPG_DEBUG_INPUT_DATA
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rBuf.au4ReqDup[u4ReqCnt] = 0;
#endif
    }

#if 1//def CC_DLNA_SUPPORT
    FeederSetReadyThreshold(prSwdmxInst->eFeederSrc, MPG_DLNA_FEEDER_UNREACH);
    FeederSetUnderFlowThreshold(prSwdmxInst->eFeederSrc, MPG_DLNA_FEEDER_UNREACH);
    FeederSetInfo(prSwdmxInst->eFeederSrc, FEEDER_SWDMX_THRESHOLD, FALSE);
#endif
    // Update read ptr to feeder
    if(IS_PUSH_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type))
    {
    }
    else if(prSwdmxInst->rFeederInfo.u4WriteAddr)
    {
        if(FeederUpdateReadPointer(prSwdmxInst->eFeederSrc, prSwdmxInst->rFeederInfo.u4WriteAddr) != FEEDER_E_OK)
        {
            LOG(1, "_SWDMX_MpgResetFeeder FeederUpdateReadPointer fail\n");
        }
    }
    
    // DDI is 4 byte alignment
    if ( !IS_PUSH_MODE(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.e_mm_src_type) &&
        (prSwdmxInst->eSeekType !=  eSWDMX_TYPE_TIME_SEEK))
    {
        u4AlignSize = (prSwdmxInst->rFeederInfo.u4WriteAddr % 4);
        if(u4AlignSize > 0)
        {
            LOG(5, "Mpg Fd align u4WriteAddr %d\n",
                prSwdmxInst->rFeederInfo.u4WriteAddr);
            i4Ret = FeederSetRequest(prSwdmxInst->eFeederSrc,
                    (4-u4AlignSize),
                    (UINT64)(0),
                    &rFeederCond,
                    (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4FeederReqID-25)); // 25 is a past requestID
            if(i4Ret != FEEDER_E_OK)
            {
                LOG(1, "Mpg Fd align FeederSetRequest Fail\n");
                /* not necessary
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgSendEOF = TRUE;
                if(!prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgGetInfo)
                {
                    _SWDMX_MpgHandleEOS();
                }
                if(prRangeList)
                {
                    prRangeList->eRangeStats = eSWDMX_RANGE_STATE_PENDING;
                }
                */
                return FALSE;
            }
        }
    }
    
    return TRUE;
}

#ifdef TIME_SHIFT_SUPPORT
UINT64 _SWDMX_MpgTSAlignDown(UINT8 u1SrcId, UINT64 u8Position)
{
    UINT64 u8Remainder;
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);

    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
    UNUSED(_SWDMX_Div6464((u8Position - prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset), (UINT64)prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4AlignBase, &u8Remainder));
        u8Position -= u8Remainder;

    return u8Position;
}

UINT64 _SWDMX_MpgLBA2Pos(UINT8 u1SrcId, UINT32 u4LBA)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
    return (((UINT64)(u4LBA) * MPG_LBA_BLOCK_SIZE) + prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FifoOffset);
}
#endif

BOOL _SWDMX_MpgGetAudioCurrentPos(UINT8 u1SrcId)
{
        UINT32 u4DmxAvailSizeAudio;
        UINT32 u4Addr, u4Size;
        UINT32 u4BufSize;
         BOOL fgRet = TRUE;

        SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
        SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

        #ifdef SWDMX_MPG_DMX_20
        u4DmxAvailSizeAudio = DMX_MUL_GetEmptySize(prSwdmxInst->u1DmxId,
            DMX_PID_TYPE_ES_AUDIO,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio);
        #else
#ifdef CC_DMX_PURE_AUDIO
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.eFmt == SWDMX_FMT_RAW_AUDIO_ES)
        {
            u4DmxAvailSizeAudio = DMX_MM_GetBufEmptySize(
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio);
           }
        else
#endif
        {
            u4DmxAvailSizeAudio = DMX_GetMinFreeBufferSize(DMX_PID_TYPE_ES_AUDIO);
        }
        #endif

        if(u4DmxAvailSizeAudio > 0)
        {
           u4DmxAvailSizeAudio += (188*4 + 32);
        }

        if(!_SWDMX_GetAudioFifo(u1SrcId, &u4Addr, &u4Size))
        {
            LOG(3, "_SWDMX_GetAudioFifo Fail\n");
            fgRet = FALSE;
        }

        u4BufSize = u4Size;
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize > (UINT64)(u4BufSize - u4DmxAvailSizeAudio))
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize - (UINT64)(u4BufSize - u4DmxAvailSizeAudio);
        }
        else
        {
          #if 0
           if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo) &&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst)&&
               (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst->u.pt_pb_idx_tbl_entry)
             )
           {//prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = 0;
              prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos =
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst->ui8_base_offset;
           }
           else
          #endif       
           {
               prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos =
               prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset;
           }
        }
         // for FR to file  begiainig DTV00090810, delete for DTV00098584
         /******************************************************
        if(( prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed < 0)&&
            (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8SendedSize == prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8FileSize))
        {
          #if 0
          if((prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq) &&
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo) &&
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst)&&
                (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst->u.pt_pb_idx_tbl_entry)
            )
            {//prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos = 0;
               prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos =
                 prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.prCurRangeReq->prDmxRangeInfo->pt_idxtbl_lst->ui8_base_offset;
            }
            else
           #endif 
           
            {
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos =
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8StartFileOffset;
            }
        }
        ********************************************************************/
        LOG(6,"_SWDMX_MpgGet play position =0x%x\n",prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u8PlayPos);
        return fgRet;
}

VOID SWDMX_DoubleDataSize(BOOL fgDouble)
{
    if (fgDouble)
    {
        _u4DoubleDataSize = 2;
    }
    else
    {
        _u4DoubleDataSize = 1;
    }
}

UINT32 SWDMX_QueryDataSize(VOID)
{
    UINT32 u4Size = 1;
    
    if (_u4DoubleDataSize == 2)
    {
        u4Size = 1;
    }
    else
    {
        u4Size = 2;    
    }
    LOG(3, "Data size is %d\n", u4Size);
    
    return u4Size;
}
INT32 _SWDMX_MpgHandleFifoEmpty(UINT8 u1SrcId)
{
    UINT32 u4DmxAvailSizeVideo = 0;
    UINT32 u4DmxAvailSizeAudio = 0;
    static UINT32 _ui4FifoCnt = 0;
    
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
    
    /* consume vfifo & afifo data */
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo)
    {                       
        u4DmxAvailSizeVideo = DMX_MUL_GetEmptySize(prSwdmxInst->u1DmxId,
            DMX_PID_TYPE_ES_VIDEO,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo);
            
        if (u4DmxAvailSizeVideo > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4DmxPreviousAvailSizeVideo)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4DmxPreviousAvailSizeVideo = u4DmxAvailSizeVideo;
            if (prSwdmxInst->u4LogFilter & check_fifo_data) 
            {
                if (_ui4FifoCnt >= 5)
                {
                    LOG(2,"consuming v data [Avail data size 0x%x],pls waiting...\n",u4DmxAvailSizeVideo);
                    _ui4FifoCnt = 0;
                }
            }
            _ui4FifoCnt++;              

            x_thread_delay(10);            
            return MPG_SEND_WAIT;
        }   
        else 
        {
            if (prSwdmxInst->u4LogFilter & check_fifo_data) 
            {
                if (_ui4FifoCnt >= 5)
                {
                    _ui4FifoCnt = 0;
                    LOG(2,"u4DmxAvailSizeVideo 0x%x u4DmxPreviousAvailSizeVideo 0x%x\n",
                        u4DmxAvailSizeVideo,        
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4DmxPreviousAvailSizeVideo);
                }
                _ui4FifoCnt++;                  
            }
        }
    }
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio)
    {
        u4DmxAvailSizeAudio = DMX_MUL_GetEmptySize(prSwdmxInst->u1DmxId,
            DMX_PID_TYPE_ES_AUDIO,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio);

        if (u4DmxAvailSizeAudio > prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4DmxPreviousAvailSizeAudio)
        {
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4DmxPreviousAvailSizeAudio = u4DmxAvailSizeAudio;
            if (prSwdmxInst->u4LogFilter & check_fifo_data) 
            {
                if (_ui4FifoCnt >= 5)
                {
                    _ui4FifoCnt = 0;            
                    LOG(2,"consuming a data [Avail data size 0x%x],pls waiting...\n",u4DmxAvailSizeAudio);
                }
                _ui4FifoCnt++;                  
            }
            x_thread_delay(10);              
            return MPG_SEND_WAIT;
        }     
        else 
        {
            if (prSwdmxInst->u4LogFilter & check_fifo_data) 
            {
                if (_ui4FifoCnt >= 5)
                {
                    _ui4FifoCnt = 0;   
                    LOG(2,"u4DmxAvailSizeAudio 0x%x u4DmxPreviousAvailSizeAudio 0x%x\n",
                        u4DmxAvailSizeAudio,        
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4DmxPreviousAvailSizeAudio);                    
                }
                _ui4FifoCnt++;                
            
            }
        }
    }
    
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFifoEmpty)
    {
      #if 0
        _SWDMX_MpgFlushAFifo(u1SrcId);
        _SWDMX_MpgFlushVFifo(u1SrcId);
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio != 0xFF)
        {
            UNUSED(DMX_MM_FlushBuffer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio));            
        }
        if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo != 0xFF)
        {
            UNUSED(DMX_MM_FlushBuffer(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxVideo));
        }   
      #endif
        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFifoEmpty = FALSE;

        LOG(2," fifo consumed\n");

        x_thread_delay(10); 
        
    }

    return MPG_SEND_OK;
    
}

INT32 _SWDMX_MpgHandlePidChg(UINT8 u1SrcId)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
    
    if (prSwdmxInst->u4LogFilter & check_fifo_data) 
    {
        LOG(2,"Pid is changing,waiting consume data to finish.\n");
    }
    
    {
        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidPidChg)
        {
            if (prSwdmxInst->pfnSwdmxVidPidChgCb && \
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidPidChgCb)
            {      
                prSwdmxInst->pfnSwdmxVidPidChgCb(
                    prSwdmxInst->pvSwdmxVidPidChgTag,
                    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdVidId,
                    0,0);                        
                LOG(5,"notify mw video pid chg \n");
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidPidChgCb = FALSE;
            }     
            
        }   
        if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudPidChg)
        {
            if (prSwdmxInst->pfnSwdmxAudPidChgCb && \
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudPidChgCb)
            {                
                prSwdmxInst->pfnSwdmxAudPidChgCb(
                        prSwdmxInst->pvSwdmxAudPidChgTag,
                        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdAudId,
                        0,0);
                LOG(5,"notify mw audio pid chg \n");
                
                prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudPidChgCb = FALSE;          
            }            
        }            

    }
    
    return MPG_SEND_SKIP;
    
}
INT32 _SWDMX_MpgHandleCodecChg(UINT8 u1SrcId)
{
    VDEC_PES_INFO_T rPesInfo;

    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidCodecChgCb)
    {
        /* notify vdec codec change & make virtual eos info to vdec */
        VDEC_SetMMParam(prSwdmxInst->u1VdecId, VDEC_MM_SWDMX_SEND_CHG, TRUE, prSwdmxInst->eUpdVideoType, 0);
        x_memset(&rPesInfo, 0, sizeof(VDEC_PES_INFO_T));
        rPesInfo.fgIBCEos = TRUE;
        rPesInfo.u4VideoType = prSwdmxInst->eUpdVideoType;        
        VDEC_SendEs((void*)&rPesInfo);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidCodecChgCb = FALSE;
        LOG(5,"[%s %d] notify vdec codec [%d] change  & make virtual eos info\n",
            __FUNCTION__,__LINE__,rPesInfo.u4VideoType);
    }  
    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudCodecChgCb)
    {
      #ifdef LINUX_TURNKEY_SOLUTION
        AUD_SetAudCodecChange(TRUE, prSwdmxInst->eUpdAudioType);
      #endif
        LOG(5,"[%s %d] notify audio codec [%d] change \n",
            __FUNCTION__,__LINE__,prSwdmxInst->eUpdAudioType);        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudCodecChgCb = FALSE;
    }
    return MPG_SEND_SKIP;
}
INT32 _SWDMX_MpgHandleStrmChg(UINT8 u1SrcId,SWDMX_BUF_AGT_CTRL_IBC_PARAM_STRM_INFO_T* prIBCStrmInfo)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
    if (prIBCStrmInfo == NULL)
    {
        return FALSE;
    }
    LOG(5,"[%s,%d]: ui4_aud_strm_id %d ,ui4_vid_strm_id id %d vdec type %d aud type %d\n",
        __FUNCTION__,__LINE__,
        prIBCStrmInfo->ui4_aud_strm_id,
        prIBCStrmInfo->ui4_vid_strm_id,
        prIBCStrmInfo->e_vid_enc,
        prIBCStrmInfo->e_aud_enc);
        
        prIBCStrmInfo->e_vid_enc = (UINT8)_SWDMX_MpgVidCodecConvert(prIBCStrmInfo->e_vid_enc);
        prIBCStrmInfo->e_aud_enc = (UINT8)_SWDMX_MpgAudCodecConvert(prIBCStrmInfo->e_aud_enc);        

    LOG(5,"after swdmx convert codec type [vid %d aud %d]\n",
        prIBCStrmInfo->e_vid_enc,
        prIBCStrmInfo->e_aud_enc);    
    
    if (prIBCStrmInfo->ui4_vid_strm_id != prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2VideoId)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdVidId = prIBCStrmInfo->ui4_vid_strm_id;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidPidChg = TRUE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidPidChgCb = TRUE;        
        LOG(5,"video stream id is changed ( old pid %d new pid %d )\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2VideoId,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdVidId);
        
    }
    if (prIBCStrmInfo->ui4_aud_strm_id != prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2AudioId)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdAudId = prIBCStrmInfo->ui4_aud_strm_id;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudPidChg = TRUE;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudPidChgCb = TRUE;        
        LOG(5,"aud stream id is changed ( old pid %d new pid %d )\n",
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2AudioId,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdAudId);
        
    }
    if (prSwdmxInst->eVideoType != prIBCStrmInfo->e_vid_enc)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidCodecChg = TRUE;
        prSwdmxInst->eUpdVideoType = (ENUM_SWDMX_VDEC_T)prIBCStrmInfo->e_vid_enc;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidCodecChgCb = TRUE;

        LOG(5,"vid codec is changed ( old codec %d new codec %d )\n",
                prSwdmxInst->eVideoType,prIBCStrmInfo->e_vid_enc);

    }
    
    if (prSwdmxInst->eAudioType != prIBCStrmInfo->e_aud_enc)
    {
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudCodecChg = TRUE;
        prSwdmxInst->eUpdAudioType = (ENUM_SWDMX_ADEC_T)prIBCStrmInfo->e_aud_enc;    
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudCodecChgCb = TRUE;
        
        LOG(5,"audio codec is changed ( old codec %d new codec %d )\n",
                prSwdmxInst->eAudioType,prIBCStrmInfo->e_aud_enc);                
    }

    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFifoEmpty = TRUE;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4DmxPreviousAvailSizeVideo = 0;
    prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4DmxPreviousAvailSizeAudio = 0;
    return TRUE;
}

BOOL _SWDMX_MpgCodecChgDone(UINT8 u1SrcId, UINT8 u1Type,VOID* pvCodecChg)
{
    SWDMX_INFO_T *prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
    if (pvCodecChg == NULL)
    {
        return FALSE;
    }

    prSwdmxInst->fgDataExhausted = TRUE;
    prSwdmxInst->fgSendUnderflow2MW = FALSE;

    if (u1Type == eSWDMX_TYPE_VID_CODEC_CHG_DONE)
    {
        LOG(5,"[%s %d]  eVideoType %d \n ",__FUNCTION__,__LINE__,prSwdmxInst->eUpdVideoType);             
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidCodecChg = FALSE;           
        prSwdmxInst->eVideoType = prSwdmxInst->eUpdVideoType;
        prSwdmxInst->eUpdVideoType = ENUM_SWDMX_VDEC_UNKNOWN;
            
    }
    else if (u1Type == eSWDMX_TYPE_AUD_CODEC_CHG_DONE)
    {

        LOG(5,"[%s %d] eAudioType %d\n ",__FUNCTION__,__LINE__,prSwdmxInst->eUpdAudioType);
            
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudCodecChg = FALSE;
        prSwdmxInst->eAudioType = prSwdmxInst->eUpdAudioType;
        prSwdmxInst->eUpdAudioType = ENUM_SWDMX_ADEC_UNKNOWN;   

    }

    return TRUE;
}
BOOL _SWDMX_MpgPidChgDone(UINT8 u1SrcId, UINT8 u1Type,VOID* pvPidChg)
{
    SWDMX_INFO_T *prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);
    if (pvPidChg == NULL)
    {
        return FALSE;
    }

    prSwdmxInst->fgDataExhausted = TRUE;
    prSwdmxInst->fgSendUnderflow2MW = FALSE;
    
    if (u1Type == eSWDMX_TYPE_VID_PID_CHG_DONE)
    {
        _SWDMX_MpgUpdateStrm(u1SrcId,eSWDMX_STRM_TYPE_VID,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdVidId );
        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidPidChg = FALSE;
        //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdVidId = ptPidChg->ui4_strm_pid;
        LOG(5,"%s u2UpdVidId %u,fgVidPidChg %d \n",__FUNCTION__,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdVidId,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgVidPidChg);
        
    }
    if (u1Type == eSWDMX_TYPE_AUD_PID_CHG_DONE)
    {
        _SWDMX_MpgUpdateStrm(u1SrcId,eSWDMX_STRM_TYPE_AUD,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdAudId );    
        
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudPidChg = FALSE;
        //prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdVidId = ptPidChg->ui4_strm_pid;
        LOG(5,"%s u2UpdAudId %u,fgAudPidChg %d \n",__FUNCTION__,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2UpdAudId,
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgAudPidChg);
    }

    return TRUE;
}

#ifdef HANDLE_CODEC_PID_CHG
VOID _SWDMX_MpgPvrHandleCodecPidChg(UINT8 u1SrcId)
{
    SWDMX_INFO_T* prSwdmxInst = _SWDMX_GetInst(u1SrcId);
    SWDMX_MPG_VERIFY_NULL(prSwdmxInst);

    if (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgAudio &&
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFlushAudData)
    {
        _SWDMX_MpgResetData(u1SrcId);
        AUD_DSPCmdStop(prSwdmxInst->u1AdecId);
        AUD_DSPCmdPlay(prSwdmxInst->u1AdecId);    
        LOG(0, "[Info] %s(%d):%u Codec or Pid change for Flush audio data.\n",
                __FUNCTION__, prSwdmxInst->u1SwdmxId, __LINE__);
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFlushAudData = FALSE;
    }
    
    if(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgVideo&&
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4VideoPTSKeeper != 0 &&
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFlushVidData )
    {
        LOG(0,"%s ready to flush video data! VDEC_SetRenderFromPts %u\n",__FUNCTION__,prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4VideoPTSKeeper);    
        MPV_FlushEsmQ(prSwdmxInst->u1VdecId, FALSE);
        UNUSED(VDEC_ReleaseDispQ(prSwdmxInst->u1VdecId));
        if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
           (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
        {
            MPV_FlushEsmQ(prSwdmxInst->u1Vdec2Id, FALSE);
            UNUSED(VDEC_ReleaseDispQ(prSwdmxInst->u1Vdec2Id));
        }

        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgNotStartToPlay = TRUE;
        
        UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
        UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1VdecId, FALSE, 0, 0, 0));
        UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1VdecId, FALSE, 0));
        UNUSED(VDEC_SetRenderFromPts(prSwdmxInst->u1VdecId, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4VideoPTSKeeper));
        if((prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MVC) ||
           (prSwdmxInst->eSubVideoType == ENUM_SWDMX_VDEC_MULTITRACK))
        {
            UNUSED(VDEC_SetRenderFromPos(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
            UNUSED(VDEC_SetRenderBackStep(prSwdmxInst->u1Vdec2Id, FALSE, 0, 0, 0));
            UNUSED(VDEC_SetRenderFromFirstPic(prSwdmxInst->u1Vdec2Id, FALSE, 0));
            UNUSED(VDEC_SetRenderFromPts(prSwdmxInst->u1Vdec2Id, prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4VideoPTSKeeper));
        }
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u4VideoPTSKeeper = 0;
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.fgFlushVidData = FALSE;
    }
    
}
#endif

static ENUM_SWDMX_VDEC_T _SWDMX_MpgVidCodecConvert(UINT8 e_vid_codec)
{
    ENUM_SWDMX_VDEC_T e_swdmx_vid_codec = ENUM_SWDMX_VDEC_UNKNOWN;
    switch(e_vid_codec)
    {
        case VID_DEC_CODEC_MPEG_1:
        case VID_DEC_CODEC_MPEG_2:   
        e_swdmx_vid_codec = ENUM_SWDMX_VDEC_MPEG1_MPEG2;
        break;
        case VID_DEC_CODEC_DIVX_311:   
        e_swdmx_vid_codec = ENUM_SWDMX_VDEC_DX311;
        break;
        case VID_DEC_CODEC_MPEG_4:   
        e_swdmx_vid_codec = ENUM_SWDMX_VDEC_MPEG4;
        break;
        case VID_DEC_CODEC_H263:   
        e_swdmx_vid_codec = ENUM_SWDMX_VDEC_H263;
        break;   
        case VID_DEC_CODEC_WVC1:   
        e_swdmx_vid_codec = ENUM_SWDMX_VDEC_VC1;
        break;
        case VID_DEC_CODEC_H264:   
        e_swdmx_vid_codec = ENUM_SWDMX_VDEC_H264;
        break;
        case VID_DEC_CODEC_AVS:   
        e_swdmx_vid_codec = ENUM_SWDMX_VDEC_AVS;
        break;         
        case VID_DEC_CODEC_H265:   
        e_swdmx_vid_codec = ENUM_SWDMX_VDEC_H265;
        break;
        default:
        e_swdmx_vid_codec = ENUM_SWDMX_VDEC_UNKNOWN;
        break;
    }
    
    return e_swdmx_vid_codec;
}

static ENUM_SWDMX_ADEC_T _SWDMX_MpgAudCodecConvert(UINT8 e_aud_codec)
{
    ENUM_SWDMX_ADEC_T e_swdmx_aud_codec = ENUM_SWDMX_ADEC_UNKNOWN;
    switch(e_aud_codec)
    {
        case AUD_DEC_FMT_MPEG:   
        e_swdmx_aud_codec = ENUM_SWDMX_ADEC_MPEG;
        break;
        case AUD_DEC_FMT_MP3:   
        e_swdmx_aud_codec = ENUM_SWDMX_ADEC_MP3;
        break;
        case AUD_DEC_FMT_AAC:   
        e_swdmx_aud_codec = ENUM_SWDMX_ADEC_AAC;
        break;
        case AUD_DEC_FMT_AC3:   
        e_swdmx_aud_codec = ENUM_SWDMX_ADEC_AC3;
        break;   
        case AUD_DEC_FMT_PCM:   
        e_swdmx_aud_codec = ENUM_SWDMX_ADEC_PCM;
        break;
        case AUD_DEC_FMT_DTS:   
        e_swdmx_aud_codec = ENUM_SWDMX_ADEC_DTS;
        break;
        case AUD_DEC_FMT_WMA:   
        e_swdmx_aud_codec = ENUM_SWDMX_ADEC_WMA;
        break;         
        default:
        e_swdmx_aud_codec = ENUM_SWDMX_ADEC_UNKNOWN;
        break;
    }
    
    return e_swdmx_aud_codec;
}
static BOOL _SWDMX_MpgInitPrebuffer(UINT8 u1SrcId)
{
    UINT32 i;
     UINT32 u4AudTrickSize = 0;
    UINT32 u4AudPreFifoAddr = 0;
    UINT32 u4AudPreFifoSize = 0;
    SWDMX_AUDIO_STREAM_T *pt_audio_stream = NULL;
    SWDMX_INFO_T *prSwdmxInst = _SWDMX_GetInst(u1SrcId);
	BOOL fgFound = FALSE;
    SWDMX_MPG_VERIFY_NULL_ERROR(prSwdmxInst);

  LOG(5,"%s Entry\n",__FUNCTION__);

    DMX_AudHandler_SetEnable(TRUE);
  
    DMX_AudHandler_Set(prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.u1PidxAudio,TRUE);
     
  pt_audio_stream = &prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.t_audio_stream_info;
    pt_audio_stream->u4_audio_pid_num = prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.t_audio_stream_info.u4_audio_pid_num;
    
    if (_SWDMX_GetAudioPreFifo(prSwdmxInst->u1SwdmxId, &u4AudPreFifoAddr, &u4AudPreFifoSize))
    {    

      //start address 16 bytes align
      if((u4AudPreFifoAddr%16))
      {
        u4AudPreFifoAddr = 16 - (u4AudPreFifoAddr%16) + u4AudPreFifoAddr;
        u4AudPreFifoSize = u4AudPreFifoSize - (16 - (u4AudPreFifoAddr%16));
      }
      
        if (pt_audio_stream->u4_audio_pid_num <= 8)
        {
            u4AudTrickSize = u4AudPreFifoSize / 8;
        }     
        else
        {
            u4AudTrickSize = u4AudPreFifoSize / pt_audio_stream->u4_audio_pid_num;
        }            
      //audio fifo size 16 bytes align
      u4AudTrickSize = u4AudTrickSize - u4AudTrickSize%16;
      
    }
    else
    {
        LOG(1, "%s:%d, _SWDMX_GetAudioPreFifo fail\n", __FUNCTION__, __LINE__);
    }   
    
    for (i = 0; i < pt_audio_stream->u4_audio_pid_num; i++)
    {       
        pt_audio_stream->t_audio_stream[i].u1Pidx = DMX_MUL_GetAvailablePidx(prSwdmxInst->u1DmxId);

        if (!DMX_AudHandler_Set( pt_audio_stream->t_audio_stream[i].u1Pidx, FALSE))
        {
            LOG(1, "%s:%d, DMX_AudHandler_Set fail\n", __FUNCTION__, __LINE__);
        }
        
        _SWDMX_MpgTsSetPreBuffer(u1SrcId,
                                pt_audio_stream->t_audio_stream[i].u1Pidx,
                                pt_audio_stream->t_audio_stream[i].u2StreamId,
                                pt_audio_stream->t_audio_stream[i].e_aud_dec_fmt,
                                u4AudPreFifoAddr,
                                u4AudTrickSize);
                                
        u4AudPreFifoAddr += u4AudTrickSize;
        
        SWDMX_DmxPesStart(pt_audio_stream->t_audio_stream[i].u1Pidx);
        
    LOG(5,"SeqNo %d Pidx %d SteamId %d\n",
        i,
        pt_audio_stream->t_audio_stream[i].u1Pidx,
        pt_audio_stream->t_audio_stream[i].u2StreamId);
        
    if (pt_audio_stream->t_audio_stream[i].u2StreamId == 
        prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u2AudioId)
    {
      prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1CurATrackIdx = i;
	  fgFound = TRUE;
      LOG(5, "defalt Cur Track Idx = %d\n", i);
    }   
    
    }
  
  if ((pt_audio_stream->u4_audio_pid_num > 0)&&
        (prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rVar.i4CurSpeed == 1000))
  {
    if(!fgFound)
	{
		prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgPendingATrackIdx = TRUE;
		LOG(1,"%s:cur stream id not match any scdb audio stream and pending\n",__FUNCTION__);
	}
	else
	{
	  	LOG(5,"%s:DMX_AudHandler_SetActivePidx pid %u pid index %u\n",__FUNCTION__,
			pt_audio_stream->t_audio_stream[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1CurATrackIdx].u1Pidx,
			prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1CurATrackIdx);
        DMX_AudHandler_SetActivePidx(pt_audio_stream->t_audio_stream[prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.u1CurATrackIdx].u1Pidx); 
            prSwdmxInst->rFmtInfo.rSwdmxMpgInfo.rFmt.fgSetActivePid = TRUE;
	}
  }

    return TRUE;
}
BOOL _SWDMX_MpgHDCP2SetRivPid(UINT16 Pidx)
{
    int i4Ret = FALSE;
    
#ifdef LINUX_TURNKEY_SOLUTION    
    MTDRM_HDCP2_RIV_T* Alligned_Riv = NULL;/*kernel data*/
    MTDRM_TZIF_HDCP2_SetRiv_Pid* Alligned_rHdcp2TzIfSetRivPid = NULL;
    
    Alligned_rHdcp2TzIfSetRivPid = (MTDRM_TZIF_HDCP2_SetRiv_Pid *)VIRTUAL(BSP_AllocAlignedDmaMemory(sizeof(MTDRM_TZIF_HDCP2_SetRiv_Pid), 32));/*kernel data*/
    if (!Alligned_rHdcp2TzIfSetRivPid)
    {
        printf("Allocate Alligned_rHdcp2TzIfSetRivPid failed\n");
        return FALSE;
    }

    Alligned_Riv = (MTDRM_HDCP2_RIV_T *)VIRTUAL(BSP_AllocAlignedDmaMemory(sizeof(MTDRM_HDCP2_RIV_T), 32));/*kernel data*/
    if (!Alligned_Riv)
    {
        printf("Allocate Alligned_Riv failed\n");
        return FALSE;
    }

    x_memcpy((VOID*)Alligned_Riv,(VOID*)g_ptHDCPKey,sizeof(MTDRM_HDCP2_RIV_T));

    LOG(0,"[WFD]Pidx %x [Key 0x%02x%02x%02x%02x%02x%02x%02x%02x]\n",
        Pidx,
        Alligned_Riv->au1Riv[0],
        Alligned_Riv->au1Riv[1],
        Alligned_Riv->au1Riv[2],
        Alligned_Riv->au1Riv[3],
        Alligned_Riv->au1Riv[4],
        Alligned_Riv->au1Riv[5],
        Alligned_Riv->au1Riv[6],
        Alligned_Riv->au1Riv[7]);
                
    Alligned_rHdcp2TzIfSetRivPid->pRiv = (VOID*)PHYSICAL((UINT32)Alligned_Riv->au1Riv);
    Alligned_rHdcp2TzIfSetRivPid->pid = Pidx;
    Alligned_rHdcp2TzIfSetRivPid->rRet = MTR_NOT_OK;

#if defined(CC_TRUSTZONE_SUPPORT)
    #ifdef CC_ENABLE_HDCP2
        TZ_NWD_BufferStart((UINT32)Alligned_Riv, TZ_CACHE_ALIGN(sizeof(MTDRM_HDCP2_RIV_T)));
        i4Ret = TZ_HDCP2_SetRiv_Pid(Alligned_rHdcp2TzIfSetRivPid, sizeof(MTDRM_TZIF_HDCP2_SetRiv_Pid));
        TZ_NWD_BufferEnd((UINT32)Alligned_Riv, TZ_CACHE_ALIGN(sizeof(MTDRM_HDCP2_RIV_T)));
        
        if (i4Ret != 0)
        {
            i4Ret = Alligned_rHdcp2TzIfSetRivPid->rRet;        
            LOG(0,"[WFD] Alligned_rHdcp2TzIfSetRivPid->rRet %d\n",i4Ret);        
        }
        else
        {  
            i4Ret = FALSE;
            LOG(0,"[WFD]i4Ret %d\n",i4Ret);            
        }
    #else
        LOG(0,"[WFD] please check define [CC_ENABLE_HDCP2 & CC_TRUSTZONE_SUPPORT]\n");
        i4Ret = FALSE;
    #endif
#endif
    LOG(0,"[WFD]_SWDMX_MpgHDCP2SetRivPid i4Ret %d Pidx %d pRiv 0x%x\n",i4Ret,Pidx,
            Alligned_rHdcp2TzIfSetRivPid->pRiv);
    

    BSP_FreeAlignedDmaMemory((UINT32)Alligned_rHdcp2TzIfSetRivPid);
    BSP_FreeAlignedDmaMemory((UINT32)Alligned_Riv);
#endif

    return i4Ret;
    
}

