/*----------------------------------------------------------------------------
 * No Warranty :  Except  as  may  be  otherwise  agreed  to  in  writing, no *
 * warranties  of  any  kind,  whether  express or  implied, are given by MTK *
 * with  respect  to  any  Confidential  Information  or any use thereof, and *
 * the  Confidential  Information  is  provided  on  an  "AS IS"  basis.  MTK *
 * hereby  expressly  disclaims  all  such  warranties, including any implied *
 * warranties   of  merchantability ,  non-infringement  and  fitness  for  a *
 * particular purpose and any warranties arising out of course of performance *
 * course  of dealing or usage of trade.  Parties further acknowledge that in *
 * connection  with  the Purpose, Company may, either presently and/or in the *
 * future,   instruct   MTK   to   assist  it  in  the  development  and  the *
 * implementation,  in accordance with Company's designs, of certain software *
 * relating  to  Company's  product(s)  (the  "Services").   Except as may be *
 * otherwise agreed to in writing, no warranties of any kind, whether express *
 * or  implied,  are  given by MTK with respect to the Services provided, and *
 * the  Services  are  provided  on  an  "AS  IS"  basis.   Company   further *
 * acknowledges  that  the  Services  may  contain  errors,  which testing is *
 * important  and  it  is  solely  responsible for fully testing the Services *
 * and/or   derivatives   thereof   before  they  are  used,  sublicensed  or *
 * distributed.   Should  there  be any third party action brought again MTK, *
 * arising  out  of  or  relating  to  the  Services,  Company agree to fully *
 * indemnify and hold MTK harmless.                                           *
 *---------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------
 * Copyright (c) 2004, CrystalMedia Technology, Inc.
 * All rights reserved.
 *
 * Unauthorized use, practice, perform, copy, distribution, reproduction,
 * or disclosure of this information in whole or in part is prohibited.
 *-----------------------------------------------------------------------------
 * $RCSfile: avs_mfmtrecg.c,v $
 * $Revision: #1 $ 1.0
 * $Date: 2010/05/26 $ 2004/11/26
 * $Author: guanghui.wang $
 * $CCRevision: /main/DTV_X_HQ_int/DTV_X_ATSC/3 $
 * $SWAuthor: Asa Wang $
 * $MD5HEX: 0a0e5908fac0e73885ce39efe82bcd61 $ Asa
 *
 * Description:
 *         This file contains all the media format recognizer public APIs
 *---------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
                    include files
 ----------------------------------------------------------------------------*/
#ifndef __KERNEL__

#ifdef _WIN32_
#include "inc/x_os.h"
#else
#include "os/inc/x_os.h"
#endif

#include "inc/x_common.h"
#include "handle/handle.h"
#include "handle/u_handle_grp.h"
#include "mutil/mfmtrecg/u_mfmtrecg.h"
#include "dbg/x_dbg.h"
#ifndef __NO_FM__
#include "file_mngr/x_fm.h"
#endif
#include "util/x_lnk_list.h"
#include "inc/x_mm_common.h"
#include "mutil/mm_util_input.h"

#else

#include "x_os.h"
#include "x_common.h"
#include "handle.h"
#include "u_handle_grp.h"
#include "../u_mfmtrecg.h"
#include "x_dbg.h"
#include "x_lnk_list.h"
#include "../../mm_util.h"
#include "../../mm_util_input.h"
#include "x_mm_common.h"

#endif

/*-----------------------------------------------------------------------------
                    macros, defines, typedefs, enums
 ----------------------------------------------------------------------------*/
#define MFMTRRECG_AVS_MAX_PARSING_LEN   (5*1024)
/*-----------------------------------------------------------------------------
                    data declarations
 ----------------------------------------------------------------------------*/

const static UINT8 au1_SEQ[]   = {0x00, 0x00, 0x10, 0xB0};
const static UINT8 au1_IFRM[]  = {0x00, 0x00, 0x10, 0xB3};
const static UINT8 au1_PBFRM[] = {0x00, 0x00, 0x10, 0xB6};
const static UINT8 au1_FLAG[]  = {0x00, 0x00, 0x10, 0x00};

/*-----------------------------------------------------------------------------
                    functions declarations
 ----------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------
 * Name:  avs_read_n_byte_to_buf
 *
 * Description: this function will get n byte from handle
 *
 * Inputs:  h_file         specify the handle of the file
 *          i8_offset      start position
 *          ui2_read_size  read size
 *          b_is_mem       false:file  true:mem
 *
 * Outputs: pv_buff        output data
 *
 * Returns: MFMTRECGR_OK    Success. The routine was successful and the operation has been completed.
 ----------------------------------------------------------------------------*/
static INT32 avs_read_n_byte_to_buf(
                                    HANDLE_T        h_file,
                                    const VOID*     pv_mem_data,
                                    SIZE_T          z_mem_leng,
                                    INT64           i8_offset,
                                    VOID*           pv_output_buff,
                                    UINT16          ui2_read_size,
                                    UINT32*         pui4_read_succ_size,
                                    BOOL            b_is_mem)
{
    INT32           i4_ret;
    UINT64          ui8_pos = 0;
    MEDIA_FEEDER_T* pt_src_feeder = NULL;

    if(b_is_mem)
    {
        if (pv_mem_data == NULL)
        {
            return MFMTRECGR_INTERNAL_ERR;
        }
        if (z_mem_leng == 0)
        {
            pt_src_feeder = (MEDIA_FEEDER_T*)pv_mem_data;
            i4_ret = pt_src_feeder->t_feeder_le_fct_tbl.pf_set_pos(
                                    &pt_src_feeder->h_feeder,
                                    i8_offset,
                                    MEDIA_SEEK_BGN);
            if (i4_ret != INPUTR_OK)
            {
                return MFMTRECGR_INTERNAL_ERR;
            }
            pt_src_feeder->t_feeder_le_fct_tbl.pf_copybytes(
                                    &pt_src_feeder->h_feeder,
                                    pv_output_buff,
                                    ui2_read_size,
                                    ui2_read_size,
                                    pui4_read_succ_size);
        }
        else
        {
            x_memcpy(pv_output_buff, pv_mem_data, ui2_read_size);
        }
    }
#ifndef __NO_FM__
    else
    {
        i4_ret = x_fm_lseek(h_file, i8_offset, FM_SEEK_BGN, &ui8_pos);
        if (i4_ret != FMR_OK)
        {
             return MFMTRECGR_FILE_ERR;
        }
        i4_ret = x_fm_read( h_file,
                            pv_output_buff,
                            ui2_read_size,
                            pui4_read_succ_size);
        if (i4_ret != FMR_OK)
        {
            return MFMTRECGR_FILE_ERR;
        }
    }
#endif
    return MFMTRECGR_OK;
}
/*-----------------------------------------------------------------------------
 * Name:  avs_handler_file_confirm_fct
 *
 * Description: this function will ask favor handler which match extension and favor
 *
 * Inputs:  h_file         specify the handle of the file
 *
 * Outputs: pt_format      retrieve the format of the file
 *
 * Returns: MFMTRECGR_OK    Success. The routine was successful and the operation has been completed.
 ----------------------------------------------------------------------------*/
static INT32 avs_check_format(HANDLE_T            h_file,
                              const VOID*         pv_mem_data,
                              SIZE_T              z_mem_leng,
                              MEDIA_FORMAT_T*     pt_format,
                              BOOL                b_is_mem)
{
    UCHAR     ac_tag[3];

    UCHAR     *ac_buff;
    UCHAR     ac_tmp[10];
    UINT32    ui4_actual_read;
    UINT32    ui4_idx;
    UINT32    ui4_frame_length;
    UINT8     ui1_rate_index;
    UINT32    ui4_bitrate = 0;
    UINT32    ui4_sample_rate = 0;
    UINT8     ui1_slot_bytes = 0;
    UINT32    ui4_frame_slots = 0;
    UINT8     ui1_padding = 0;

    UINT8     ui1_layer, ui1_version;
    UINT32    ui4_read;

    UINT32    ui4_id3v2_offset = 0;
    INT32     i4_ret = 0;
    /************************************************************************/
    /* Check parameter                                                      */
    /************************************************************************/
    if ((pt_format == NULL)
        || ((h_file == NULL_HANDLE) && !b_is_mem)
        || ((pv_mem_data == NULL) && b_is_mem))
    {
        return MFMTRECGR_INTERNAL_ERR;
    }
    /************************************************************************/
    /* do                                                                   */
    /************************************************************************/

    ac_buff = (UCHAR*)x_mem_alloc(sizeof(UCHAR) * MFMTRRECG_AVS_MAX_PARSING_LEN);
    if (ac_buff == NULL)
    {
        return MFMTRECGR_INTERNAL_ERR;
    }
    if((i4_ret = mp3_read_n_byte_to_buf(h_file,
                              pv_mem_data,
                              z_mem_leng,
                              (INT64)ui4_id3v2_offset,
                              ac_buff,
                              MFMTRRECG_AVS_MAX_PARSING_LEN,
                              &ui4_read,
                              b_is_mem)) != MFMTRECGR_OK)
    {
        if (ac_buff != NULL)
        {
            x_mem_free(ac_buff);
        }
        return i4_ret;
    }

    ui4_actual_read = ui4_read;
    ui4_idx = 0;
    /* find a possible audio frame header */
    while (ui4_idx < ui4_actual_read)
    {
        if ((ac_buff[ui4_idx] != 0xFF)
            || ((ac_buff[ui4_idx + 1] & 0xE0) != 0xE0)
            || ((ac_buff[ui4_idx + 1] & 0x18) >> 3 == 1)      /* version description is set to reserved */
            || ((ac_buff[ui4_idx + 1] & 0x06) >> 1 == 0)      /* layer description is set to reserved */
            || ((ac_buff[ui4_idx + 2] >> 4) == 0)
            || ((ac_buff[ui4_idx + 2] >> 4) == 15))
        {
            ui4_idx++;
        }
        else
        {
            x_memcpy(ac_tag, ac_buff + ui4_idx, 3);
            ui1_version = ((ac_tag[1] & 0x18) >> 3);
            ui1_layer = ((ac_tag[1] & 0x6) >> 1);

            /* bitrate index */
            ui1_rate_index = ac_tag[2] >> 4;
            MP3_GET_BITRATE(ui4_bitrate, ui1_version, ui1_layer, ui1_rate_index);            

            /* sampling frequency index */
            ui1_rate_index = ((ac_tag[2] & 0xc) >> 2);
            ui4_sample_rate = 0;
            if (ui1_rate_index != 3)    /* not reserved */
            {
                ui4_sample_rate = MPEG_SAMPLERATE_TAB[ui1_rate_index];
            }
            switch (ui1_version)
            {
                case 2: /* Version 2 */
                    ui4_sample_rate >>= 1;
                    break;
                case 0: /* Version 2.5 */
                    ui4_sample_rate >>= 2;
                    break;
            }
            if (ui4_sample_rate == 0)
            {
                /* read next 1 byte */
                ui4_idx++;
                continue;
            }
            /* padding bit */
            ui1_padding = ((ac_tag[2] & 0x2)>>1);

            /* calculate frame length */
            ui4_frame_length = 0;
            if (ui4_bitrate != 0)
            {
                ui1_slot_bytes = 1;
                if (ui1_layer == 3)         /* Layer 1 */
                {
                    ui4_frame_slots = 12;
                    ui1_slot_bytes = 4;
                }
                else if ((ui1_layer == 1)   /* Layer 3 */
                    /* Version 2 or Version 2.5 */
                    && (ui1_version == 2 || ui1_version == 0))
                {
                    ui4_frame_slots = 72;
                }
                else
                {
                    ui4_frame_slots = 144;
                }
                if (ui4_sample_rate != 0)
                {
                    ui4_frame_length = (ui4_frame_slots * ui4_bitrate / ui4_sample_rate + ui1_padding) * ui1_slot_bytes;
                }
            }
            
            /* jump to check next frame header file is valid or invalid */
            if (ui4_idx + ui4_frame_length < ui4_actual_read)
            {
                x_memcpy(ac_tmp, (ac_buff + ui4_idx + ui4_frame_length), 3);
            }
            else
            {
                if((i4_ret = mp3_read_n_byte_to_buf(h_file,
                                          pv_mem_data,
                                          z_mem_leng,
                                          (INT64)(ui4_id3v2_offset + ui4_idx + ui4_frame_length),
                                          ac_tmp,
                                          3,
                                          &ui4_read,
                                          b_is_mem)) != MFMTRECGR_OK)
                {
                    if (ac_buff != NULL)
                    {
                        x_mem_free(ac_buff);
                    }
                    return i4_ret;
                }
            }
            
            /* next frame header is also valid */
            if (IS_MP3_HEADER(ac_tmp))
            {
                /*read one more frame to avoid error recgnize*/
                if (ui4_idx + ui4_frame_length < ui4_actual_read)
                {
                    ui4_idx += ui4_frame_length;
                }
                else /*already read for the 2nd frame*/
                {
                    ui4_id3v2_offset += ui4_idx;
                    ui4_idx = 0;
                    ui4_actual_read = ui4_read;
                }

                /* bitrate index */
                ui1_rate_index = ac_tmp[2] >> 4;

                MP3_GET_BITRATE(ui4_bitrate, ui1_version, ui1_layer, ui1_rate_index);              

                /* padding bit */
                ui1_padding = ((ac_tmp[2] & 0x2)>>1);

                if(0 != ui4_bitrate)
                {
                    ui4_frame_length = 
                        (ui4_frame_slots * ui4_bitrate / ui4_sample_rate + ui1_padding) * 
                          ui1_slot_bytes;
                }
                else
                {   /*error */
                    if (ac_buff != NULL)
                    {
                        x_mem_free(ac_buff);
                    }
                    return MFMTRECGR_INTERNAL_ERR;
                }
                /* jump to check next frame header file is valid or invalid */
                if (ui4_idx + ui4_frame_length < ui4_actual_read)
                {
                    x_memcpy(ac_tmp, (ac_buff + ui4_idx + ui4_frame_length), 3);
                }
                else
                {
                    if((i4_ret = mp3_read_n_byte_to_buf(h_file,
                                              pv_mem_data,
                                              z_mem_leng,
                                              (INT64)(ui4_id3v2_offset + ui4_idx + ui4_frame_length),
                                              ac_tmp,
                                              3,
                                              &ui4_read,
                                              b_is_mem)) != MFMTRECGR_OK)
                    {
                        if (ac_buff != NULL)
                        {
                            x_mem_free(ac_buff);
                        }
                        return i4_ret;
                    }
                }

                /* next frame header is also valid */
                if (IS_MP3_HEADER(ac_tmp))
                {
                    /* then the media type & subtype can be set correctly */
                    if ((ui1_version == 0)
                        || (ui1_version == 2)
                        || (ui1_version == 3))
                    {
                        if ((ui1_layer == 3)        /* Layer 1 */
                            || (ui1_layer == 2))    /* Layer 2 */
                        {
                            pt_format->e_media_type = MEDIA_TYPE_AUDIO_ES;
                            pt_format->t_media_subtype.u.e_aud_subtype = MEDIA_AUD_SUBTYPE_MP2;
                        }
                        else if (ui1_layer == 1)    /* Layer 3 */
                        {
                            pt_format->e_media_type = MEDIA_TYPE_AUDIO_ES;
                            pt_format->t_media_subtype.u.e_aud_subtype = MEDIA_AUD_SUBTYPE_MP3;
                        }
                        else
                        {
                            if (ac_buff)
                            {
                                x_mem_free(ac_buff);
                            }
                            return MFMTRECGR_INTERNAL_ERR;
                        }
                    }
                    if (ac_buff)
                    {
                        x_mem_free(ac_buff);
                    }    
                    return MFMTRECGR_OK;
                }
            }                

            /* read next 1 byte */
            ui4_idx++;
        }
    }
    if (ac_buff)
    {
        x_mem_free(ac_buff);
    }
    return MFMTRECGR_INTERNAL_ERR;
}

/*-----------------------------------------------------------------------------
 * Name:  avs_handler_file_confirm_fct
 *
 * Description: this function will ask favor handler which match extension and favor
 *
 * Inputs:  h_file         specify the handle of the file
 *
 * Outputs: pt_format      retrieve the format of the file
 *
 * Returns: MFMTRECGR_OK    Success. The routine was successful and the operation has been completed.
 ----------------------------------------------------------------------------*/
INT32 avs_handler_file_confirm_fct(
                                    HANDLE_T           h_file,
                                    MEDIA_FORMAT_T*    pt_format)
{

#ifndef __NO_FM__
    return avs_check_format(h_file, NULL, 0, pt_format, FALSE);
#else
    return MFMTRECGR_INTERNAL_ERR;
#endif
}

/*-----------------------------------------------------------------------------
 * Name:  avs_handler_mem_confirm_fct
 *
 * Description: this function will ask all handler
 *
 * Inputs:  pv_mem_data     specify the address of memory buffer which want to retrieve the format.
 *          z_mem_leng      specify the length of memory buffer which want to retrieve the format.
 *
 * Outputs: pt_format       retrieve the format of the media memory buffer.
 *
 * Returns: MFMTRECGR_OK    Success. The routine was successful and the operation has been completed.
 ----------------------------------------------------------------------------*/
INT32 avs_handler_mem_confirm_fct(
                        const VOID*       pv_mem_data,
                        SIZE_T            z_mem_leng,
                        MEDIA_FORMAT_T*   pt_format)
{
    return avs_check_format(NULL_HANDLE, pv_mem_data, z_mem_leng, pt_format, TRUE);
}




