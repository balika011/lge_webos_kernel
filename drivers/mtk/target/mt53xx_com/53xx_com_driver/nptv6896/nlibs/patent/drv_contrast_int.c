/*----------------------------------------------------------------------------*
 * Copyright Statement:                                                       *
 *                                                                            *
 *   This software/firmware and related documentation ("MediaTek Software")   *
 * are protected under international and related jurisdictions'copyright laws *
 * as unpublished works. The information contained herein is confidential and *
 * proprietary to MediaTek Inc. Without the prior written permission of       *
 * MediaTek Inc., any reproduction, modification, use or disclosure of        *
 * MediaTek Software, and information contained herein, in whole or in part,  *
 * shall be strictly prohibited.                                              *
 * MediaTek Inc. Copyright (C) 2010. All rights reserved.                     *
 *                                                                            *
 *   BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND     *
 * AGREES TO THE FOLLOWING:                                                   *
 *                                                                            *
 *   1)Any and all intellectual property rights (including without            *
 * limitation, patent, copyright, and trade secrets) in and to this           *
 * Software/firmware and related documentation ("MediaTek Software") shall    *
 * remain the exclusive property of MediaTek Inc. Any and all intellectual    *
 * property rights (including without limitation, patent, copyright, and      *
 * trade secrets) in and to any modifications and derivatives to MediaTek     *
 * Software, whoever made, shall also remain the exclusive property of        *
 * MediaTek Inc.  Nothing herein shall be construed as any transfer of any    *
 * title to any intellectual property right in MediaTek Software to Receiver. *
 *                                                                            *
 *   2)This MediaTek Software Receiver received from MediaTek Inc. and/or its *
 * representatives is provided to Receiver on an "AS IS" basis only.          *
 * MediaTek Inc. expressly disclaims all warranties, expressed or implied,    *
 * including but not limited to any implied warranties of merchantability,    *
 * non-infringement and fitness for a particular purpose and any warranties   *
 * arising out of course of performance, course of dealing or usage of trade. *
 * MediaTek Inc. does not provide any warranty whatsoever with respect to the *
 * software of any third party which may be used by, incorporated in, or      *
 * supplied with the MediaTek Software, and Receiver agrees to look only to   *
 * such third parties for any warranty claim relating thereto.  Receiver      *
 * expressly acknowledges that it is Receiver's sole responsibility to obtain *
 * from any third party all proper licenses contained in or delivered with    *
 * MediaTek Software.  MediaTek is not responsible for any MediaTek Software  *
 * releases made to Receiver's specifications or to conform to a particular   *
 * standard or open forum.                                                    *
 *                                                                            *
 *   3)Receiver further acknowledge that Receiver may, either presently       *
 * and/or in the future, instruct MediaTek Inc. to assist it in the           *
 * development and the implementation, in accordance with Receiver's designs, *
 * of certain softwares relating to Receiver's product(s) (the "Services").   *
 * Except as may be otherwise agreed to in writing, no warranties of any      *
 * kind, whether express or implied, are given by MediaTek Inc. with respect  *
 * to the Services provided, and the Services are provided on an "AS IS"      *
 * basis. Receiver further acknowledges that the Services may contain errors  *
 * that testing is important and it is solely responsible for fully testing   *
 * the Services and/or derivatives thereof before they are used, sublicensed  *
 * or distributed. Should there be any third party action brought against     *
 * MediaTek Inc. arising out of or relating to the Services, Receiver agree   *
 * to fully indemnify and hold MediaTek Inc. harmless.  If the parties        *
 * mutually agree to enter into or continue a business relationship or other  *
 * arrangement, the terms and conditions set forth herein shall remain        *
 * effective and, unless explicitly stated otherwise, shall prevail in the    *
 * event of a conflict in the terms in any agreements entered into between    *
 * the parties.                                                               *
 *                                                                            *
 *   4)Receiver's sole and exclusive remedy and MediaTek Inc.'s entire and    *
 * cumulative liability with respect to MediaTek Software released hereunder  *
 * will be, at MediaTek Inc.'s sole discretion, to replace or revise the      *
 * MediaTek Software at issue.                                                *
 *                                                                            *
 *   5)The transaction contemplated hereunder shall be construed in           *
 * accordance with the laws of Singapore, excluding its conflict of laws      *
 * principles.  Any disputes, controversies or claims arising thereof and     *
 * related thereto shall be settled via arbitration in Singapore, under the   *
 * then current rules of the International Chamber of Commerce (ICC).  The    *
 * arbitration shall be conducted in English. The awards of the arbitration   *
 * shall be final and binding upon both parties and shall be entered and      *
 * enforceable in any court of competent jurisdiction.                        *
 *---------------------------------------------------------------------------*/
// === INCLUDE =========================================================================
#ifndef CC_MTK_LOADER
#include "drv_contrast.h"
#include "nptv_debug.h"
#include "hw_sw.h"
#include "drv_meter.h"
#include "x_typedef.h"
#include "drv_pq_cust.h"
#include "hw_ycproc.h"
#include "vdo_misc.h"

// === DEFINE =============================================================================
#define AL_LOW_START    (64	 >> 3)//<< AL_HIST_SFT)
#define AL_LOW_END      (256 >> 3)//<< AL_HIST_SFT)
#define	AL_HIGH_START   (256 >> 3)//<< AL_HIST_SFT)
#define	AL_HIGH_END     (416 >> 3)//<< AL_HIST_SFT)
#define	AL_HIST_STEP	(32  >> 5)//<< AL_HIST_SFT)
#define	AL_LOW_BIN      9
#define	AL_HIGH_BIN     9

#define FIR_NUM				9
#define FIR_NUM_TRUNCATE	9
#define FIR_NUM_WEIGHT		8

#define AbsDiff(a, b)   (((a)>(b))?((a)-(b)):((b)-(a)))
#define CLIP(val, min, max) ((val>=max) ? max : ((val<=min) ? min : val)) 

#ifndef MAX
#define MAX(a,b) (((a) > (b)) ? (a) : (b))
#endif

#ifndef MIN
#define MIN(a,b) (((a) < (b)) ? (a) : (b))
#endif

// ADL Debug Mode define
#define	AL_DBG_ADAPGAIN	    (1<<0)
#define	AL_DBG_EQUALIZATION (1<<1)
#define	AL_DBG_BWS	        (1<<1)
#define	AL_DBG_BP_WP	    (1<<2)
#define	AL_DBG_BI_WI	    (1<<2)
#define	AL_DBG_DYN_BS	    (1<<2)
#define	AL_DBG_YGAMMA	    (1<<3)
#define	AL_DBG_HIST_FIR	    (1<<4)
#define	AL_DBG_HIST_LPF	    (1<<5)
#define	AL_DBG_SCENE_CHANGE	(1<<6)
#define	AL_DBG_LUMA_CURVE1  (1<<7)
#define	AL_DBG_FINAL	    (1<<7)
#define	AL_DBG_LUMA_CURVE2  (1<<8)
#define	AL_DBG_LUMA_CURVE3  (1<<9)
#define	AL_DBG_SKIN_CURVE   (1<<10)
#define	AL_DBG_DYN_OFFSET   (1<<11)
#define	AL_DBG_DYN_LIMIT	(1<<12)
#define	AL_DBG_INC_PATTERN	(1<<13)
#define	AL_DBG_CG_PROT      (1<<13)
#define	AL_DBG_ADAP_YGAMMA  (1<<14)
#define	AL_3D_LUMA  	    (1<<15)

#define ADL_LOG_CHECK(x)    ((bDbgCur==bDbgCount) && (bDbgIndex & x))
#define ADL_LOG_CHECK2(x)   (bDbgIndex & x)

// === FUNCTION PROTOTYPE =================================================================
// === EXTERN FUNCTION ====================================================================
// === GLOBAL VARIABLE ====================================================================
UINT8 bALOnOff = 1;
//Adaptive Luma Version 1 parameter
UINT8 bAdapLumaGain = 0x40;
UINT8 bAdapLumaOffset = 0x08;
UINT8 bAdapLumaLimit = 0xC0;

UINT8 bBSOnOff = 1;
UINT8 bBSLevel = 4;
UINT8 bBSGain = 0x40;
UINT8 bBSOffset = 0x10;
UINT8 bBSRatio = 0x60;
UINT8 bBSLimit = 0x08;

UINT8 bWSOnOff = 1;
UINT8 bWSLevel = 4;
UINT8 bWSGain = 0x60;
UINT8 bWSOffset = 0x08;
UINT8 bWSRatio = 0x40 ;
UINT8 bWSLimit = 0x00;

UINT8 bBWSKeepMidOnOff;
UINT8 bBWSKeepMidX;
UINT16 wBWSKeepMidY;

UINT8 bDynamicBSRange;
UINT8 bDynamicBSOnOff;
UINT8 bDBSPxlThd1;
UINT8 bDBSPxlThd2;
UINT8 bDBSDistThdH;
UINT8 bDBSDistThdL;

UINT8 bDBSLmtBtm;
UINT8 bDBSLmtTop;
UINT8 bDBSGainBtm;
UINT8 bDBSGainTop;
UINT8 bDBSOfstBtm;
UINT8 bDBSOfstTop;

UINT8 bDBSGain;
UINT8 bDBSOffset;
UINT8 bDBSLimit;

//Adaptive Luma Version 2 parameter
UINT8 bMIDACGain = 0x30;
UINT8 bMIDDCGain = 0x30;

UINT8 bBSDCGain = 0x20;
UINT8 bBSDCGainRatio = 0x55;
UINT8 bBSOffsetL = 0x28;
UINT8 bBSOffsetH = 0x68;
UINT8 bBSACGain = 0x40;
UINT8 bBSACGainRatio = 0xAA;
UINT8 bStrongBSOffset = 1;
UINT8 bBSAdaptiveLmt = 1;
UINT8 bBSOffsetThL = 0x40;
UINT8 bBSOffsetThH = 0x80;

UINT8 bWSDCGain = 0x30;
UINT8 bWSDCGainRatio = 0x80;
UINT8 bWSOffsetL = 0x20;
UINT8 bWSOffsetH = 0x40;
UINT8 bWSACGain = 0x30;
UINT8 bWSACGainRatio = 0x80;
UINT8 bStrongWSOffset = 0;
UINT8 bWSAdaptiveLmt = 1;
UINT8 bWSOffsetThL = 0x1B;
UINT8 bWSOffsetThH = 0x3B;

UINT32 bADLWeight1=0x06;
UINT32 bADLWeight2=0x12;
UINT32 bADLWeight3=0x12;
UINT8 bParamChange;	

UINT8 bIncPatProtEn = 0;
UINT8 bIncPatCntTh = 4;
UINT8 bAplDiffTh = 4;

UINT8 bCGProtTh = 205;
UINT8 bCGProtGain = 3;
UINT8 bCGProtEn = 0;

//Common
UINT8 bMaxDiffThreshold = 0x0A;
UINT8 bTotalDiffThreshold = 0x30;

UINT8 bYGammaDecayL;
UINT8 bYGammaDecayH;
UINT8 bYGammaSel;
UINT8 bDarkSceneBrit;

UINT8 bYGammaUI = 0;
UINT8 bForceScenceChange = 0;
UINT8 bALUpdateCount = 0;
UINT8 bADLSceneChange = SV_FALSE;
UINT32 u4AdapYGammaGain = 0;
UINT32 u4AdapYGammaTh = 0;

UINT8 bSkinLumaOnOff;
UINT8 bSkinWeight;
UINT8 bSkinBlendmethod;
UINT8 bAdapSkinBlend;
UINT8 bAdapSkinConfUpSlope;
UINT8 bAdapSkinConfDownSlope;

UINT8 bBlackPercentage = 0;
UINT8 bWhitePercentage = 0;
UINT8 bBlackIndex = 0;
UINT8 bWhiteIndex = 0;

UINT8 bCurveProtect = 0;
UINT8 bHistogramMode = 0;

UINT8 bYGammaMID = 0;
UINT8 bYGammaMIDSKIN = 0;

UINT8 bAdlVersion = 0;
UINT8 bAdl3DEnable = 0;

UINT8 bIIRStrength = 0;

const UINT16 GAMMA_100_TABLE[257]=
{
    0,      4,      8,      12,     16,     20,     24,     28,     32,     36,     40,     44,     48,     52,     56,     60,    
    64,     68,     72,     76,     80,     84,     88,     92,     96,     100,    104,    108,    112,    116,    120,    124,    
    128,    132,    136,    140,    144,    148,    152,    156,    160,    164,    168,    172,    176,    180,    184,    188,    
    192,    196,    200,    204,    208,    212,    216,    220,    224,    228,    232,    236,    240,    244,    248,    252,    
    256,    260,    264,    268,    272,    276,    280,    284,    288,    292,    296,    300,    304,    308,    312,    316,    
    320,    324,    328,    332,    336,    340,    344,    348,    352,    356,    360,    364,    368,    372,    376,    380,    
    384,    388,    392,    396,    400,    404,    408,    412,    416,    420,    424,    428,    432,    436,    440,    444,    
    448,    452,    456,    460,    464,    468,    472,    476,    480,    484,    488,    492,    496,    500,    504,    508,    
    512,    516,    520,    524,    528,    532,    536,    540,    544,    548,    552,    556,    560,    564,    568,    572,    
    576,    580,    584,    588,    592,    596,    600,    604,    608,    612,    616,    620,    624,    628,    632,    636,    
    640,    644,    648,    652,    656,    660,    664,    668,    672,    676,    680,    684,    688,    692,    696,    700,    
    704,    708,    712,    716,    720,    724,    728,    732,    736,    740,    744,    748,    752,    756,    760,    764,    
    768,    772,    776,    780,    784,    788,    792,    796,    800,    804,    808,    812,    816,    820,    824,    828,    
    832,    836,    840,    844,    848,    852,    856,    860,    864,    868,    872,    876,    880,    884,    888,    892,    
    896,    900,    904,    908,    912,    916,    920,    924,    928,    932,    936,    940,    944,    948,    952,    956,    
    960,    964,    968,    972,    976,    980,    984,    988,    992,    996,    1000,  1004,   1008,   1012,   1016,   1020,    1024
};

const UINT16 GAMMA_105_TABLE[257]=
{
    0,      4,      8,      12,     16,     20,     24,     28,     32,     36,     40,     44,     48,     52,     56,     60,    
    64,     67,     70,     74,     77,     81,     84,     88,     91,     95,     98,     102,    106,    109,    113,    116,
    120,    124,    128,    131,    135,    139,    142,    146,    150,    154,    157,    161,    165,    169,    173,    176,    
    180,    184,    188,    192,    196,    199,    203,    207,    211,    215,    219,    223,    226,    230,    234,    238,
    242,    246,    250,    254,    258,    261,    265,    269,    273,    277,    281,    285,    289,    293,    297,    301,
    305,    309,    313,    317,    321,    325,    328,    332,    336,    340,    344,    348,    352,    356,    360,    364,
    368,    372,    376,    380,    384,    388,    392,    396,    400,    404,    408,    412,    416,    420,    424,    428,
    432,    437,    441,    445,    449,    453,    457,    461,    465,    469,    473,    477,    481,    485,    489,    493,
    497,    501,    505,    509,    513,    518,    522,    526,    530,    534,    538,    542,    546,    550,    554,    558,
    562,    567,    571,    575,    579,    583,    587,    591,    595,    599,    603,    608,    612,    616,    620,    624,
    628,    632,    636,    640,    645,    649,    653,    657,    661,    665,    669,    673,    678,    682,    686,    690,
    694,    698,    702,    706,    711,    715,    719,    723,    727,    731,    735,    740,    744,    748,    752,    756,
    760,    765,    769,    773,    777,    781,    785,    789,    794,    798,    802,    806,    810,    814,    819,    823,
    827,    831,    835,    839,    844,    848,    852,    856,    860,    865,    869,    873,    877,    881,    885,    890,
    894,    898,    902,    906,    911,    915,    919,    923,    927,    932,    936,    940,    944,    948,    952,    956,
    960,    964,    968,    972,    976,    980,    984,    988,    992,    996,    1000,   1004,   1008,   1012,   1016,   1020,   1024
};

const UINT16 GAMMA_110_TABLE[257]=
{
    0,      4,      8,      12,     16,     20,     24,     28,     32,     36,     40,     44,     48,     52,     56,     60,    
    64,     66,     69,     72,     75,     78,     81,     84,     87,     90,     93,     97,     100,    103,    107,    110,
    113,    117,    120,    124,    127,    130,    134,    137,    141,    144,    148,    152,    155,    159,    162,    166,
    170,    173,    177,    181,    184,    188,    192,    195,    199,    203,    206,    210,    214,    218,    221,    225,
    229,    233,    237,    240,    244,    248,    252,    256,    259,    263,    267,    271,    275,    279,    283,    286,
    290,    294,    298,    302,    306,    310,    314,    318,    322,    326,    330,    334,    337,    341,    345,    349,
    353,    357,    361,    365,    369,    373,    377,    381,    385,    389,    393,    397,    401,    405,    410,    414,
    418,    422,    426,    430,    434,    438,    442,    446,    450,    454,    458,    462,    467,    471,    475,    479,
    483,    487,    491,    495,    499,    504,    508,    512,    516,    520,    524,    528,    533,    537,    541,    545,
    549,    553,    558,    562,    566,    570,    574,    578,    583,    587,    591,    595,    599,    604,    608,    612,
    616,    621,    625,    629,    633,    637,    642,    646,    650,    654,    659,    663,    667,    671,    676,    680,
    684,    688,    693,    697,    701,    706,    710,    714,    718,    723,    727,    731,    736,    740,    744,    748,
    753,    757,    761,    766,    770,    774,    779,    783,    787,    792,    796,    800,    805,    809,    813,    818,
    822,    826,    831,    835,    839,    844,    848,    852,    857,    861,    865,    870,    874,    879,    883,    887,
    892,    896,    900,    905,    909,    914,    918,    922,    927,    931,    936,    940,    944,    948,    952,    956,
    960,    964,    968,    972,    976,    980,    984,    988,    992,    996,    1000,   1004,   1008,   1012,   1016,   1020,   1024	
};

const UINT16 GAMMA_115_TABLE[257]=
{
    0,      4,      8,      12,     16,     20,     24,     28,     32,     36,     40,     44,     48,     52,     56,     60,    
    64,     66,     68,     70,     73,     75,     78,     81,     83,     86,     89,     92,     95,     98,     101,    104,
    107,    110,    113,    117,    120,    123,    126,    130,    133,    136,    140,    143,    146,    150,    153,    156,
    160,    163,    167,    170,    174,    177,    181,    184,    188,    192,    195,    199,    202,    206,    210,    213,
    217,    221,    224,    228,    232,    235,    239,    243,    247,    250,    254,    258,    262,    265,    269,    273,
    277,    281,    285,    288,    292,    296,    300,    304,    308,    312,    316,    319,    323,    327,    331,    335,
    339,    343,    347,    351,    355,    359,    363,    367,    371,    375,    379,    383,    387,    391,    395,    399,
    403,    407,    411,    416,    420,    424,    428,    432,    436,    440,    444,    448,    453,    457,    461,    465,
    469,    473,    477,    482,    486,    490,    494,    498,    503,    507,    511,    515,    519,    524,    528,    532,
    536,    541,    545,    549,    553,    558,    562,    566,    570,    575,    579,    583,    588,    592,    596,    601,
    605,    609,    614,    618,    622,    627,    631,    635,    640,    644,    648,    653,    657,    661,    666,    670,
    675,    679,    683,    688,    692,    697,    701,    705,    710,    714,    719,    723,    728,    732,    736,    741,
    745,    750,    754,    759,    763,    768,    772,    777,    781,    786,    790,    794,    799,    803,    808,    812,
    817,    822,    826,    831,    835,    840,    844,    849,    853,    858,    862,    867 ,   871,    876,    880,    885,
    890,    894,    899,    903,    908,    912,    917,    922,    926,    931,    935,    940,    944,    948,    952,    956,
    960,    964,    968,    972,    976,    980,    984,    988,    992,    996,    1000,	  1004,	 1008,	  1012,	  1016,	  1020,    1024	
};

const UINT16 GAMMA_950_TABLE[257]=
{
    0,      4,      8,      12,     16,     20,     24,     28,     32,     36,     40,     44,     48,     52,     56,     60,    
    64,     69,     74,     79,     84,     88,     93,     97,     102,    106,    111,    115,    120,    124,    128,    133,
    137,    141,    146,    150,    154,    158,    163,    167,    171,    175,    180,    184,    188,    192,    197,    201,
    205,    209,    213,    217,    222,    226,    230,    234,    238,    242,    246,    251,    255,    259,    263,    267,
    271,    275,    279,    283,    288,    292,    296,    300,    304,    308,    312,    316,    320,    324,    328,    332,
    336,    340,    344,    348,    352,    356,    360,    364,    368,    372,    377,    381,    385,    389,    393,    397,
    401,    405,    409,    413,    416,    420,    424,    428,    432,    436,    440,    444,    448,    452,    456,    460,
    464,    468,    472,    476,    480,    484,    488,    492,    496,    500,    504,    508,    512,    515,    519,    523,
    527,    531,    535,    539,    543,    547,    551,    555,    559,    563,    566,    570,    574,    578,    582,    586,
    590,    594,    598,    602,    606,    609,    613,    617,    621,    625,    629,    633,    637,    641,    644,    648,
    652,    656,    660,    664,    668,    672,    675,    679,    683,    687,    691,    695,    699,    703,    706,    710,
    714,    718,    722,    726,    730,    733,    737,    741,    745,    749,    753,    757,    760,    764,    768,    772,
    776,    780,    783,    787,    791,    795,    799,    803,    806,    810,    814,    818,    822,    826,    829,    833,
    837,    841,    845,    849,    852,    856,    860,    864,    868,    871,    875,    879,    883,    887,    891,    894,
    898,    902,    906,    910,    913,    917,    921,    925,    929,    932,    936,    940,    944,    948,    952,    956,
    960,    964,    968,    972,    976,    980,    984,    988,    992,    996,    1000, 	1004, 	1008, 	1012, 	1016, 	1020,    1024
};

const UINT16  GAMMA_925_TABLE[257]=
{
    0,      4,      8,      12,     16,     20,     24,     28,     32,     36,     40,     44,     48,     52,     56,     60,    
    64,     70,     75,     81,     86,     91,     95,     100,    105,    110,    114,    119,    124,    128,    133,    137,
    142,    146,    151,    155,    160,    164,    169,    173,    177,    182,    186,    190,    195,    199,    203,    208,
    212,    216,    220,    225,    229,    233,    237,    242,    246,    250,    254,    258,    263,    267,    271,    275,
    279,    283,    287,    292,    296,    300,    304,    308,    312,    316,    320,    324,    328,    333,    337,    341,
    345,    349,    353,    357,    361,    365,    369,    373,    377,    381,    385,    389,    393,    397,    401,    405,
    409,    413,    417,    421,    425,    429,    433,    437,    441,    445,    449,    453,    457,    461,    465,    469,
    473,    476,    480,    484,    488,    492,    496,    500,    504,    508,    512,    516,    520,    523,    527,    531,
    535,    539,    543,    547,    551,    555,    558,    562,    566,    570,    574,    578,    582,    585,    589,    593,
    597,    601,    605,    609,    612,    616,    620,    624,    628,    632,    635,    639,    643,    647,    651,    655,
    658,    662,    666,    670,    674,    677,    681,    685,    689,    693,    696,    700,    704,    708,    712,    715,
    719,    723,    727,    731,    734,    738,    742,    746,    749,    753,    757,    761,    765,    768,    772,    776,
    780,    783,    787,    791,    795,    798,    802,    806,    810,    813,    817,    821,    825,    828,    832,    836,
    840,    843,    847,    851,    855,    858,    862,    866,    869,    873,    877,    881,    884,    888,    892,    896,
    899,    903,    907,    910,    914,    918,    921,    925,    929,    933,    936,    940,    944,    948,    952,    956,
    960,    964,    968,    972,    976,    980,    984,    988,    992,    996,    1000, 	1004, 	1008, 	1012, 	1016, 	1020,    1024
};

const UINT16  GAMMA_900_TABLE[257]=
{
    0,      4,      8,      12,     16,     20,     24,     28,     32,     36,     40,     44,     48,     52,     56,     60,    
    64,     71,     77,     82,     88,     93,     98,     104,    109,    114,    118,    123,    128,    133,    138,    142,
    147,    152,    156,    161,    166,    170,    175,    179,    184,    188,    193,    197,    202,    206,    210,    215,
    219,    224,    228,    232,    236,    241,    245,    249,    254,    258,    262,    266,    271,    275,    279,    283,
    287,    292,    296,    300,    304,    308,    312,    317,    321,    325,    329,    333,    337,    341,    345,    349,
    354,    358,    362,    366,    370,    374,    378,    382,    386,    390,    394,    398,    402,    406,    410,    414,
    418,    422,    426,    430,    434,    438,    442,    446,    450,    454,    457,    461,    465,    469,    473,    477,
    481,    485,    489,    493,    497,    501,    504,    508,    512,    516,    520,    524,    528,    532,    535,    539,
    543,    547,    551,    555,    558,    562,    566,    570,    574,    578,    581,    585,    589,    593,    597,    600,
    604,    608,    612,    616,    619,    623,    627,    631,    635,    638,    642,    646,    650,    653,    657,    661,
    665,    668,    672,    676,    680,    683,    687,    691,    695,    698,    702,    706,    710,    713,    717,    721,
    724,    728,    732,    736,    739,    743,    747,    750,    754,    758,    761,    765,    769,    773,    776,    780,
    784,    787,    791,    795,    798,    802,    806,    809,    813,    817,    820,    824,    828,    831,    835,    839,
    842,    846,    849,    853,    857,    860,    864,    868,    871,    875,    879,    882,    886,    889,    893,    897,
    900,    904,    908,    911,    915,    918,    922,    926,    929,    933,    936,    940,    944,    948,    952,    956,
    960,    964,    968,    972,    976,    980,    984,    988,    992,    996,    1000,   1004,   1008,   1012,   1016,   1020,    1024
};

const UINT16  GAMMA_875_TABLE[257]=
{
    0,      4,      8,      12,     16,     20,     24,     28,     32,     36,     40,     44,     48,     52,     56,     60,    
    64,     72,     78,     85,     90,     96,     102,    107,    112,    118,    123,    128,    133,    138,    143,    148,
    153,    158,    162,    167,    172,    177,    181,    186,    191,    195,    200,    204,    209,    213,    218,    222,
    227,    231,    236,    240,    244,    249,    253,    258,    262,    266,    271,    275,    279,    283,    288,    292,
    296,    300,    305,    309,    313,    317,    321,    325,    330,    334,    338,    342,    346,    350,    354,    358,
    363,    367,    371,    375,    379,    383,    387,    391,    395,    399,    403,    407,    411,    415,    419,    423,
    427,    431,    435,    439,    443,    447,    451,    455,    458,    462,    466,    470,    474,    478,    482,    486,
    490,    494,    497,    501,    505,    509,    513,    517,    521,    524,    528,    532,    536,    540,    544,    547,
    551,    555,    559,    563,    566,    570,    574,    578,    581,    585,    589,    593,    597,    600,    604,    608,
    612,    615,    619,    623,    626,    630,    634,    638,    641,    645,    649,    653,    656,    660,    664,    667,
    671,    675,    678,    682,    686,    689,    693,    697,    700,    704,    708,    711,    715,    719,    722,    726,
    730,    733,    737,    741,    744,    748,    751,    755,    759,    762,    766,    769,    773,    777,    780,    784,
    788,    791,    795,    798,    802,    805,    809,    813,    816,    820,    823,    827,    830,    834,    838,    841,
    845,    848,    852,    855,    859,    862,    866,    870,    873,    877,    880,    884,    887,    891,    894,    898,
    901,    905,    908,    912,    915,    919,    922,    926,    929,    933,    936,    940,    944,    948,    952,    956,
    960,    964,    968,    972,    976,    980,    984,    988,    992,    996,    1000,   1004,   1008,   1012,   1016,   1020,    1024
};

const UINT16  GAMMA_850_TABLE[257]=
{
    0,      4,      8,      12,     16,     20,     24,     28,     32,     36,     40,     44,     48,     52,     56,     60,    
    64,     73,     80,     87,     93,     99,     105,    111,    117,    122,    128,    133,    138,    143,    149,    154,
    159,    164,    169,    174,    179,    183,    188,    193,    198,    202,    207,    212,    216,    221,    226,    230,
    235,    239,    244,    248,    253,    257,    262,    266,    270,    275,    279,    284,    288,    292,    297,    301,
    305,    309,    314,    318,    322,    326,    330,    335,    339,    343,    347,    351,    355,    360,    364,    368,
    372,    376,    380,    384,    388,    392,    396,    400,    404,    408,    412,    416,    420,    424,    428,    432,
    436,    440,    444,    448,    452,    456,    460,    464,    468,    471,    475,    479,    483,    487,    491,    495,
    499,    502,    506,    510,    514,    518,    522,    525,    529,    533,    537,    541,    544,    548,    552,    556,
    559,    563,    567,    571,    574,    578,    582,    586,    589,    593,    597,    600,    604,    608,    612,    615,
    619,    623,    626,    630,    634,    637,    641,    645,    648,    652,    656,    659,    663,    667,    670,    674,
    677,    681,    685,    688,    692,    695,    699,    703,    706,    710,    713,    717,    721,    724,    728,    731,
    735,    738,    742,    746,    749,    753,    756,    760,    763,    767,    770,    774,    777,    781,    784,    788,
    791,    795,    798,    802,    805,    809,    812,    816,    819,    823,    826,    830,    833,    837,    840,    844,
    847,    851,    854,    858,    861,    865,    868,    872,    875,    878,    882,    885,    889,    892,    896,    899,
    902,    906,    909,    913,    916,    920,    923,    926,    930,    933,    937,    940,    944,    948,    952,    956,
    960,    964,    968,    972,    976,    980,    984,    988,    992,    996,    1000,   1004,   1008,   1012,   1016,   1020,    1024
};

const UINT16  GAMMA_825_TABLE[257]=
{
    0,      4,      8,      12,     16,     20,     24,     28,     32,     36,     40,     44,     48,     52,     56,     60,    
    64,     74,     82,     89,     96,     103,    109,    115,    121,    127,    133,    138,    144,    149,    155,    160,
    165,    170,    175,    181,    186,    191,    196,    200,    205,    210,    215,    220,    225,    229,    234,    239,
    243,    248,    252,    257,    262,    266,    271,    275,    279,    284,    288,    293,    297,    301,    306,    310,
    314,    319,    323,    327,    332,    336,    340,    344,    348,    353,    357,    361,    365,    369,    373,    377,
    381,    386,    390,    394,    398,    402,    406,    410,    414,    418,    422,    426,    430,    434,    438,    442,
    446,    450,    454,    457,    461,    465,    469,    473,    477,    481,    485,    488,    492,    496,    500,    504,
    508,    511,    515,    519,    523,    527,    530,    534,    538,    542,    545,    549,    553,    557,    560,    564,
    568,    571,    575,    579,    583,    586,    590,    594,    597,    601,    605,    608,    612,    616,    619,    623,
    626,    630,    634,    637,    641,    645,    648,    652,    655,    659,    662,    666,    670,    673,    677,    680,
    684,    687,    691,    694,    698,    702,    705,    709,    712,    716,    719,    723,    726,    730,    733,    737,
    740,    744,    747,    751,    754,    758,    761,    764,    768,    771,    775,    778,    782,    785,    789,    792,
    795,    799,    802,    806,    809,    813,    816,    819,    823,    826,    830,    833,    836,    840,    843,    847,
    850,    853,    857,    860,    863,    867,    870,    873,    877,    880,    884,    887,    890,    894,    897,    900,
    904,    907,    910,    914,    917,    920,    923,    927,    930,    933,    937,    940,    944,    948,    952,    956,
    960,    964,    968,    972,    976,    980,    984,    988,    992,    996,    1000,   1004,   1008,   1012,   1016,   1020,    1024
    };                                                                              

const UINT16  GAMMA_950_TABLE_MID[257]=
{
    0,      4,      8,      12,     16,     20,     24,     28,     32,     36,     40,     44,     48,     52,     56,     60,    
    64,     68,     72,     76,     80,     84,     88,     92,     96,     100,    104,    108,    112,    116,    120,    124,    
    128,    132,    136,    140,    144,    148,    152,    156,    160,    164,    168,    172,    176,    180,    184,    188,    
    192,    196,    200,    204,    208,    212,    216,    220,    224,    228,    232,    236,    240,    244,    248,    252,    
	256,    261,    266,    270,    275,    280,    284,    288,    293,    297,    301,    306,    310,    314,    319,    323,
	327,    331,    335,    340,    344,    348,    352,    356,    360,    365,    369,    373,    377,    381,    385,    389,
	393,    397,    401,    405,    409,    413,    418,    422,    426,    430,    434,    438,    442,    446,    450,    454,
	458,    462,    466,    470,    474,    478,    482,    485,    489,    493,    497,    501,    505,    509,    513,    517, 
	521,    525,    529,    533,    537,    541,    545,    548,    552,    556,    560,    564,    568,    572,    576,    580,
	584,    587,    591,    595,    599,    603,    607,    611,    615,    619,    622,    626,    630,    634,    638,    642,
	646,    649,    653,    657,    661,    665,    669,    673,    676,    680,    684,    688,    692,    696,    699,    703,
	707,    711,    715,    718,    722,    726,    730,    734,    738,    741,    745,    749,    753,    757,    760,    764,
    768,    772,    776,    780,    784,    788,    792,    796,    800,    804,    808,    812,    816,    820,    824,    828,    
    832,    836,    840,    844,    848,    852,    856,    860,    864,    868,    872,    876,    880,    884,    888,    892,    
    896,    900,    904,    908,    912,    916,    920,    924,    928,    932,    936,    940,    944,    948,    952,    956,    
    960,    964,    968,    972,    976,    980,    984,    988,    992,    996,    1000,  1004,   1008,   1012,   1016,   1020,    1024
};

const UINT16  GAMMA_900_TABLE_MID[257]=
{
    0,      4,      8,      12,     16,     20,     24,     28,     32,     36,     40,     44,     48,     52,     56,     60,    
    64,     68,     72,     76,     80,     84,     88,     92,     96,     100,    104,    108,    112,    116,    120,    124,    
    128,    132,    136,    140,    144,    148,    152,    156,    160,    164,    168,    172,    176,    180,    184,    188,    
    192,    196,    200,    204,    208,    212,    216,    220,    224,    228,    232,    236,    240,    244,    248,    252,    
	256,    262,	268,	273,	279,	284,	289,	293,	298,	303,	308,	312,	317,	321,	326,	330,
	335,	339,	344,	348,	352,	357,	361,	365,	369,	374,	378,	382,	386,	391,	395,	399,
	403,	407,	411,	415,	419,	424,	428,	432,	436,	440,	444,	448,	452,	456,	460,	464,
	468,	472,	476,	480,	484,	488,	491,	495,	499,	503,	507,	511,	515,	519,	523,	527,
	530,	534,	538,	542,	546,	550,	553,	557,	561,	565,	569,	572,	576,	580,	584,	588,
	591,	595,	599,	603,	606,	610,	614,	618,	621,	625,	629,	633,	636,	640,	644,	648,
	651,	655,	659,	662,	666,	670,	673,	677,	681,	684,	688,	692,	695,	699,	703,	706,
	710,	714,	717,	721,	725,	728,	732,	735,	739,	743,	746,	750,	754,	757,	761,	764,
    768,    772,    776,    780,    784,    788,    792,    796,    800,    804,    808,    812,    816,    820,    824,    828,    
    832,    836,    840,    844,    848,    852,    856,    860,    864,    868,    872,    876,    880,    884,    888,    892,    
    896,    900,    904,    908,    912,    916,    920,    924,    928,    932,    936,    940,    944,    948,    952,    956,    
    960,    964,    968,    972,    976,    980,    984,    988,    992,    996,    1000,  1004,   1008,   1012,   1016,   1020,    1024
};

const UINT16  GAMMA_850_TABLE_MID[257]=
{
    0,      4,      8,      12,     16,     20,     24,     28,     32,     36,     40,     44,     48,     52,     56,     60,    
    64,     68,     72,     76,     80,     84,     88,     92,     96,     100,    104,    108,    112,    116,    120,    124,    
    128,    132,    136,    140,    144,    148,    152,    156,    160,    164,    168,    172,    176,    180,    184,    188,    
    192,    196,    200,    204,    208,    212,    216,    220,    224,    228,    232,    236,    240,    244,    248,    252,    
	256,    264,    271,    277,    283,    289,    294,    299,    305,    310,    315,    320,    324,    329,    334,    339,
	343,    348,    353,    357,    362,    366,    371,    375,    379,    384,    388,    392,    397,    401,    405,    409,
	414,    418,    422,    426,    430,    434,    438,    442,    446,    451,    455,    459,    463,    467,    471,    474,
	478,    482,    486,    490,    494,    498,    502,    506,    510,    513,    517,    521,    525,    529,    532,    536,
	540,    544,    548,    551,    555,    559,    563,    566,    570,    574,    577,    581,    585,    588,    592,    596,
	599,    603,    607,    610,    614,    618,    621,    625,    628,    632,    636,    639,    643,    646,    650,    653,
	657,    660,    664,    668,    671,    675,    678,    682,    685,    689,    692,    696,    699,    703,    706,    710,
	713,    717,    720,    723,    727,    730,    734,    737,    741,    744,    748,    751,    754,    758,    761,    765,
    768,    772,    776,    780,    784,    788,    792,    796,    800,    804,    808,    812,    816,    820,    824,    828,    
    832,    836,    840,    844,    848,    852,    856,    860,    864,    868,    872,    876,    880,    884,    888,    892,    
    896,    900,    904,    908,    912,    916,    920,    924,    928,    932,    936,    940,    944,    948,    952,    956,    
    960,    964,    968,    972,    976,    980,    984,    988,    992,    996,    1000,  1004,   1008,   1012,   1016,   1020,    1024
};

const UINT16  GAMMA_800_TABLE_MID[257]=
{
    0,      4,      8,      12,     16,     20,     24,     28,     32,     36,     40,     44,     48,     52,     56,     60,    
    64,     68,     72,     76,     80,     84,     88,     92,     96,     100,    104,    108,    112,    116,    120,    124,    
    128,    132,    136,    140,    144,    148,    152,    156,    160,    164,    168,    172,    176,    180,    184,    188,    
    192,    196,    200,    204,    208,    212,    216,    220,    224,    228,    232,    236,    240,    244,    248,    252,    
	256,    267,    274,    281,    288,    294,    300,    306,    312,    317,    323,    328,    333,    338,    343,    348,
	353,    358,    363,    367,    372,    377,    381,    386,    390,    395,    399,    403,    408,    412,    416,    421,
	425,    429,    433,    437,    442,    446,    450,    454,    458,    462,    466,    470,    474,    478,    482,    486,
	490,    493,    497,    501,    505,    509,    513,    516,    520,    524,    528,    532,    535,    539,    543,    546,
	550,    554,    557,    561,    565,    568,    572,    576,    579,    583,    586,    590,    593,    597,    600,    604,
	608,    611,    615,    618,    622,    625,    628,    632,    635,    639,    642,    646,    649,    653,    656,    659,
	663,    666,    670,    673,    676,    680,    683,    686,    690,    693,    696,    700,    703,    706,    710,    713,
	716,    719,    723,    726,    729,    732,    736,    739,    742,    745,    749,    752,    755,    758,    762,    765,
	768,    772,    776,    780,    784,    788,    792,    796,    800,    804,    808,    812,    816,    820,    824,    828,    
    832,    836,    840,    844,    848,    852,    856,    860,    864,    868,    872,    876,    880,    884,    888,    892,    
    896,    900,    904,    908,    912,    916,    920,    924,    928,    932,    936,    940,    944,    948,    952,    956,    
    960,    964,    968,    972,    976,    980,    984,    988,    992,    996,    1000,  1004,   1008,   1012,   1016,   1020,    1024
};

const UINT16  GAMMA_950_TABLE_MIDH[257]=
{
    0,      4,      8,      12,     16,     20,     24,     28,     32,     36,     40,     44,     48,     52,     56,     60,    
    64,     68,     72,     76,     80,     84,     88,     92,     96,     100,    104,    108,    112,    116,    120,    124,    
    128,    132,    136,    140,    144,    148,    152,    156,    160,    164,    168,    172,    176,    180,    184,    188,    
    192,    196,    200,    204,    208,    212,    216,    220,    224,    228,    232,    236,    240,    244,    248,    252,    
	256,    260,    264,    268,    272,    276,    280,    284,    288,    292,    296,    300,    304,    308,    312,    316,
	320,    324,    328,    332,    336,    340,    344,    348,    352,    356,    360,    364,    368,    372,    376,    380,
	384,    388,    392,    396,    400,    404,    408,    412,    416,    420,    424,    428,    432,    436,    440,    444,
	448,    452,    456,    460,    464,    468,    472,    476,    480,    484,    488,    492,    496,    500,    504,    508,
	512,    517,    522,    526,    530,    535,    539,    543,    548,    552,    556,    560,    564,    568,    572,    577,
	581,    585,    589,    593,    597,    601,    605,    609,    613,    617,    621,    625,    629,    633,    637,    641,
	645,    648,    652,    656,    660,    664,    668,    672,    676,    680,    684,    687,    691,    695,    699,    703,
	707,    711,    714,    718,    722,    726,    730,    734,    738,    741,    745,    749,    753,    757,    760,    764,
	768,    772,    776,    780,    784,    788,    792,    796,    800,    804,    808,    812,    816,    820,    824,    828,    
    832,    836,    840,    844,    848,    852,    856,    860,    864,    868,    872,    876,    880,    884,    888,    892,    
    896,    900,    904,    908,    912,    916,    920,    924,    928,    932,    936,    940,    944,    948,    952,    956,    
    960,    964,    968,    972,    976,    980,    984,    988,    992,    996,    1000,  1004,   1008,   1012,   1016,   1020,    1024
};

const UINT16  GAMMA_900_TABLE_MIDH[257]=
{
    0,      4,      8,      12,     16,     20,     24,     28,     32,     36,     40,     44,     48,     52,     56,     60,    
    64,     68,     72,     76,     80,     84,     88,     92,     96,     100,    104,    108,    112,    116,    120,    124,    
    128,    132,    136,    140,    144,    148,    152,    156,    160,    164,    168,    172,    176,    180,    184,    188,    
    192,    196,    200,    204,    208,    212,    216,    220,    224,    228,    232,    236,    240,    244,    248,    252,    
	256,    260,    264,    268,    272,    276,    280,    284,    288,    292,    296,    300,    304,    308,    312,    316,
	320,    324,    328,    332,    336,    340,    344,    348,    352,    356,    360,    364,    368,    372,    376,    380,
	384,    388,    392,    396,    400,    404,    408,    412,    416,    420,    424,    428,    432,    436,    440,    444,
	448,    452,    456,    460,    464,    468,    472,    476,    480,    484,    488,    492,    496,    500,    504,    508,
	512,    518,    523,    528,    533,    538,    542,    547,    551,    556,    560,    564,    569,    573,    577,    581,
	586,    590,    594,    598,    602,    606,    610,    614,    618,    622,    626,    630,    634,    638,    641,    645,
	649,    653,    657,    661,    665,    668,    672,    676,    680,    683,    687,    691,    695,    698,    702,    706,
	710,    713,    717,    721,    724,    728,    732,    735,    739,    743,    746,    750,    754,    757,    761,    764,
	768,    772,    776,    780,    784,    788,    792,    796,    800,    804,    808,    812,    816,    820,    824,    828,    
    832,    836,    840,    844,    848,    852,    856,    860,    864,    868,    872,    876,    880,    884,    888,    892,    
    896,    900,    904,    908,    912,    916,    920,    924,    928,    932,    936,    940,    944,    948,    952,    956,    
    960,    964,    968,    972,    976,    980,    984,    988,    992,    996,    1000,  1004,   1008,   1012,   1016,   1020,    1024
};

const UINT16  GAMMA_850_TABLE_MIDH[257]=
{
    0,      4,      8,      12,     16,     20,     24,     28,     32,     36,     40,     44,     48,     52,     56,     60,    
    64,     68,     72,     76,     80,     84,     88,     92,     96,     100,    104,    108,    112,    116,    120,    124,    
    128,    132,    136,    140,    144,    148,    152,    156,    160,    164,    168,    172,    176,    180,    184,    188,    
    192,    196,    200,    204,    208,    212,    216,    220,    224,    228,    232,    236,    240,    244,    248,    252,    
	256,    260,    264,    268,    272,    276,    280,    284,    288,    292,    296,    300,    304,    308,    312,    316,
	320,    324,    328,    332,    336,    340,    344,    348,    352,    356,    360,    364,    368,    372,    376,    380,
	384,    388,    392,    396,    400,    404,    408,    412,    416,    420,    424,    428,    432,    436,    440,    444,
	448,    452,    456,    460,    464,    468,    472,    476,    480,    484,    488,    492,    496,    500,    504,    508,
	512,    519,    525,    531,    536,    541,    546,    551,    556,    560,    565,    569,    574,    578,    582,    587,
	591,    595,    599,    603,    607,    611,    615,    619,    623,    627,    631,    635,    639,    643,    646,    650,
	654,    658,    662,    665,    669,    673,    676,    680,    684,    687,    691,    695,    698,    702,    705,    709,
	712,    716,    720,    723,    727,    730,    734,    737,    741,    744,    747,    751,    754,    758,    761,    765,
	768,    772,    776,    780,    784,    788,    792,    796,    800,    804,    808,    812,    816,    820,    824,    828,    
    832,    836,    840,    844,    848,    852,    856,    860,    864,    868,    872,    876,    880,    884,    888,    892,    
    896,    900,    904,    908,    912,    916,    920,    924,    928,    932,    936,    940,    944,    948,    952,    956,    
    960,    964,    968,    972,    976,    980,    984,    988,    992,    996,    1000,  1004,   1008,   1012,   1016,   1020,    1024
};

const UINT16  GAMMA_800_TABLE_MIDH[257]=
{
    0,      4,      8,      12,     16,     20,     24,     28,     32,     36,     40,     44,     48,     52,     56,     60,    
    64,     68,     72,     76,     80,     84,     88,     92,     96,     100,    104,    108,    112,    116,    120,    124,    
    128,    132,    136,    140,    144,    148,    152,    156,    160,    164,    168,    172,    176,    180,    184,    188,    
    192,    196,    200,    204,    208,    212,    216,    220,    224,    228,    232,    236,    240,    244,    248,    252,    
	256,    260,    264,    268,    272,    276,    280,    284,    288,    292,    296,    300,    304,    308,    312,    316,
	320,    324,    328,    332,    336,    340,    344,    348,    352,    356,    360,    364,    368,    372,    376,    380,
	384,    388,    392,    396,    400,    404,    408,    412,    416,    420,    424,    428,    432,    436,    440,    444,
	448,    452,    456,    460,    464,    468,    472,    476,    480,    484,    488,    492,    496,    500,    504,    508,
	512,    521,    528,    534,    540,    545,    551,    556,    561,    565,    570,    575,    579,    584,    588,    592,
	596,    601,    605,    609,    613,    617,    621,    625,    629,    633,    637,    640,    644,    648,    652,    655,
	659,    663,    666,    670,    674,    677,    681,    684,    688,    691,    695,    698,    702,    705,    709,    712,
	715,    719,    722,    725,    729,    732,    735,    739,    742,    745,    749,    752,    755,    758,    762,    765,
	768,    772,    776,    780,    784,    788,    792,    796,    800,    804,    808,    812,    816,    820,    824,    828,    
    832,    836,    840,    844,    848,    852,    856,    860,    864,    868,    872,    876,    880,    884,    888,    892,    
    896,    900,    904,    908,    912,    916,    920,    924,    928,    932,    936,    940,    944,    948,    952,    956,    
    960,    964,    968,    972,    976,    980,    984,    988,    992,    996,    1000,  1004,   1008,   1012,   1016,   1020,    1024
};

const UINT16  GAMMA_950_105_TABLE_MIDS[257]=
{
    0,      4,      8,      12,     16,     20,     24,     28,     32,     36,     40,     44,     48,     52,     56,     60,    
    64,     68,     72,     76,     80,     84,     88,     92,     96,     100,    104,    108,    112,    116,    120,    124,
    128,    132,    136,    140,    144,    148,    152,    156,    160,    164,    168,    172,    176,    180,    184,    188,
    192,    196,    200,    204,    208,    212,    216,    220,    224,    228,    232,    236,    240,    244,    248,    252,
    256,    259,    263,    266,    270,    274,    277,    281,    285,    289,    292,    296,    300,    304,    308,    312,
    316,    320,    324,    328,    331,    335,    339,    343,    347,    351,    355,    359,    363,    367,    372,    376,
    380,    384,    388,    392,    396,    400,    404,    408,    412,    416,    420,    425,    429,    433,    437,    441,
    445,    449,    454,    458,    462,    466,    470,    474,    479,    483,    487,    491,    495,    499,    504,    508,
    512,    517,    522,    526,    530,    535,    539,    543,    548,    552,    556,    560,    564,    568,    572,    577,
    581,    585,    589,    593,    597,    601,    605,    609,    613,    617,    621,    625,    629,    633,    637,    641,
    645,    648,    652,    656,    660,    664,    668,    672,    676,    680,    684,    687,    691,    695,    699,    703,
    707,    711,    714,    718,    722,    726,    730,    734,    738,    741,    745,    749,    753,    757,    760,    764,
    768,    772,    776,    780,    784,    788,    792,    796,    800,    804,    808,    812,    816,    820,    824,    828,
    832,    836,    840,    844,    848,    852,    856,    860,    864,    868,    872,    876,    880,    884,    888,    892,
    896,    900,    904,    908,    912,    916,    920,    924,    928,    932,    936,    940,    944,    948,    952,    956,    
    960,    964,    968,    972,    976,    980,    984,    988,    992,    996,    1000,  1004,   1008,   1012,   1016,   1020,    1024
};

const UINT16  GAMMA_900_110_TABLE_MIDS[257]=
{
    0,      4,      8,      12,     16,     20,     24,     28,     32,     36,     40,     44,     48,     52,     56,     60,    
    64,     68,     72,     76,     80,     84,     88,     92,     96,     100,    104,    108,    112,    116,    120,    124,
    128,    132,    136,    140,    144,    148,    152,    156,    160,    164,    168,    172,    176,    180,    184,    188,
    192,    196,    200,    204,    208,    212,    216,    220,    224,    228,    232,    236,    240,    244,    248,    252,
    256,    259,    262,    265,    268,    271,    275,    278,    282,    286,    289,    293,    297,    300,    304,    308,
    312,    316,    319,    323,    327,    331,    335,    339,    343,    347,    351,    355,    359,    363,    367,    371,
    375,    380,    384,    388,    392,    396,    400,    404,    409,    413,    417,    421,    426,    430,    434,    438,
    443,    447,    451,    455,    460,    464,    468,    473,    477,    481,    486,    490,    494,    499,    503,    508,
    512,    518,    523,    528,    533,    538,    542,    547,    551,    556,    560,    564,    569,    573,    577,    581,
    586,    590,    594,    598,    602,    606,    610,    614,    618,    622,    626,    630,    634,    638,    641,    645,
    649,    653,    657,    661,    665,    668,    672,    676,    680,    683,    687,    691,    695,    698,    702,    706,
    710,    713,    717,    721,    724,    728,    732,    735,    739,    743,    746,    750,    754,    757,    761,    764,
    768,    772,    776,    780,    784,    788,    792,    796,    800,    804,    808,    812,    816,    820,    824,    828,
    832,    836,    840,    844,    848,    852,    856,    860,    864,    868,    872,    876,    880,    884,    888,    892,
    896,    900,    904,    908,    912,    916,    920,    924,    928,    932,    936,    940,    944,    948,    952,    956,    
    960,    964,    968,    972,    976,    980,    984,    988,    992,    996,    1000,  1004,   1008,   1012,   1016,   1020,    1024
};

const UINT16  GAMMA_850_115_TABLE_MIDS[257]=
{
    0,      4,      8,      12,     16,     20,     24,     28,     32,     36,     40,     44,     48,     52,     56,     60,    
    64,     68,     72,     76,     80,     84,     88,     92,     96,     100,    104,    108,    112,    116,    120,    124,
    128,    132,    136,    140,    144,    148,    152,    156,    160,    164,    168,    172,    176,    180,    184,    188,
    192,    196,    200,    204,    208,    212,    216,    220,    224,    228,    232,    236,    240,    244,    248,    252,
    256,    258,    261,    264,    267,    270,    273,    276,    279,    283,    286,    290,    293,    297,    301,    304,
    308,    312,    316,    319,    323,    327,    331,    335,    339,    343,    347,    351,    355,    359,    363,    367,
    371,    376,    380,    384,    388,    392,    397,    401,    405,    409,    414,    418,    422,    427,    431,    435,
    440,    444,    449,    453,    458,    462,    467,    471,    476,    480,    485,    489,    494,    498,    503,    507,
    512,    519,    525,    531,    536,    541,    546,    551,    556,    560,    565,    569,    574,    578,    582,    587,
    591,    595,    599,    603,    607,    611,    615,    619,    623,    627,    631,    635,    639,    643,    646,    650,
    654,    658,    662,    665,    669,    673,    676,    680,    684,    687,    691,    695,    698,    702,    705,    709,
    712,    716,    720,    723,    727,    730,    734,    737,    741,    744,    747,    751,    754,    758,    761,    765,
    768,    772,    776,    780,    784,    788,    792,    796,    800,    804,    808,    812,    816,    820,    824,    828,
    832,    836,    840,    844,    848,    852,    856,    860,    864,    868,    872,    876,    880,    884,    888,    892,
    896,    900,    904,    908,    912,    916,    920,    924,    928,    932,    936,    940,    944,    948,    952,    956,    
    960,    964,    968,    972,    976,    980,    984,    988,    992,    996,    1000,  1004,   1008,   1012,   1016,   1020,    1024
};

const UINT16  GAMMA_800_120_TABLE_MIDS[257]=
{
    0,      4,      8,      12,     16,     20,     24,     28,     32,     36,     40,     44,     48,     52,     56,     60,    
    64,     68,     72,     76,     80,     84,     88,     92,     96,     100,    104,    108,    112,    116,    120,    124,
    128,    132,    136,    140,    144,    148,    152,    156,    160,    164,    168,    172,    176,    180,    184,    188,
    192,    196,    200,    204,    208,    212,    216,    220,    224,    228,    232,    236,    240,    244,    248,    252,
    256,    258,    260,    263,    265,    268,    271,    274,    277,    280,    284,    287,    290,    294,    297,    301,
    305,    308,    312,    316,    319,    323,    327,    331,    335,    339,    343,    347,    351,    355,    359,    363,
    367,    372,    376,    380,    384,    389,    393,    397,    402,    406,    410,    415,    419,    424,    428,    433,
    437,    442,    446,    451,    456,    460,    465,    469,    474,    479,    483,    488,    493,    498,    502,    507,
    512,    521,    528,    534,    540,    545,    551,    556,    561,    565,    570,    575,    579,    584,    588,    592,
    596,    601,    605,    609,    613,    617,    621,    625,    629,    633,    637,    640,    644,    648,    652,    655,
    659,    663,    666,    670,    674,    677,    681,    684,    688,    691,    695,    698,    702,    705,    709,    712,
    715,    719,    722,    725,    729,    732,    735,    739,    742,    745,    749,    752,    755,    758,    762,    765,
    768,    772,    776,    780,    784,    788,    792,    796,    800,    804,    808,    812,    816,    820,    824,    828,    
    832,    836,    840,    844,    848,    852,    856,    860,    864,    868,    872,    876,    880,    884,    888,    892,    
    896,    900,    904,    908,    912,    916,    920,    924,    928,    932,    936,    940,    944,    948,    952,    956,    
    960,    964,    968,    972,    976,    980,    984,    988,    992,    996,    1000,  1004,   1008,   1012,   1016,   1020,    1024
};

//////////////////////////////////////////////////////////////////////////////////////////
static UINT16 bDbgIndex;
static UINT8 bDbgCount;
static UINT8 bDbgCur;

static UINT8 bAPLCount;
static UINT8 bAPLCountCur;

static UINT32 bCurGainL;
static UINT32 bCurGainM;
static UINT32 bCurGainH;
static UINT32 bValueL;
static UINT32 bValueH;

static UINT32 u4LumaAPL;
static UINT32 u4LumaAPLFullRange;

static UINT32 dwDistribution;
static UINT32 dwDarkPxlCount;

static UINT16 waTargetCurve[LUMA_CURVE_NUM];
static UINT16 waDynCurve[LUMA_CURVE_NUM];

static UINT16 waLumaArrayLR[2][LUMA_CURVE_NUM];

extern UINT8 bIsSrcLRflg;

void vDrvADLBuildDefault(UINT16 wCurve[LUMA_CURVE_NUM])
{
	UINT8 bi;

	for (bi = 0; bi < LUMA_CURVE_NUM-1; bi++)
	{
		wCurve[bi] = (UINT16) bi << 5;
	}

	wCurve[LUMA_CURVE_NUM-1] = 1023;
}

void vDrvADLParamConstrain(void)
{
    if(bAdlVersion == SV_OFF)   //Adaptive Luma Version 1
    {

    	bAdapLumaGain = (bAdapLumaGain > 0x80) ? 0x80 : bAdapLumaGain;
    	bAdapLumaOffset = (bAdapLumaOffset > 16) ? 16 : bAdapLumaOffset;

    	bBSLevel = (bBSLevel > 8) ? 8 : bBSLevel;
    	bBSGain = (bBSGain > 0x80) ? 0x80 : bBSGain;

    	bWSLevel = (bWSLevel > 8) ? 8 : bWSLevel;
    	bWSGain = (bWSGain > 0x80) ? 0x80 : bWSGain;

    	bDynamicBSRange = (bDynamicBSRange < 4) ? 4 : bDynamicBSRange;
        bDBSDistThdH = (bDBSDistThdH <= bDBSDistThdL) ? (bDBSDistThdL + 1) : bDBSDistThdH;    
        bDBSPxlThd2 = (bDBSPxlThd2 <= bDBSPxlThd1) ? (bDBSPxlThd1 + 1) : bDBSPxlThd2;    

        bHistogramMode	= 0;        
        vRegWriteFldAlign(SCE_CFG_MAIN, 0, COLOR_YHIST_WGT_EN);// use old mode, 32bin
    }
    else    //Adaptive Luma Version 2
    {
    	if(bBSOnOff == 0)
    	{
    		bBSLevel = 0;
        }
    	else
    	{
            bBSLevel = CLIP(bBSLevel, 0, 8);
    	}
    	bBSOffsetL = CLIP(bBSOffsetL, 0, (bBSLevel<<5));
    	bBSOffsetH = CLIP(bBSOffsetH, bBSOffsetL, (bBSLevel<<5));	
    	bBSOffset = bBSOffsetL;
    	bBSOffsetThL = CLIP(bBSOffsetThL, 1, 255);
    	bBSOffsetThH = CLIP(bBSOffsetThH, bBSOffsetThL, 255);

    	if(bWSOnOff == 0)
        {
    		bWSLevel = 0;
    	}
    	else
    	{
            bWSLevel = CLIP(bWSLevel, 0, 8);
    	}

    	bWSOffsetL = CLIP(bWSOffsetL, 0, (bWSLevel<<5));
    	bWSOffsetH = CLIP(bWSOffsetH, bWSOffsetL, (bWSLevel<<5));
    	bWSOffset = bWSOffsetL;
    	bWSOffsetThL = CLIP(bWSOffsetThL, 1, 255);
    	bWSOffsetThH = CLIP(bWSOffsetThH, bWSOffsetThL, 255);

    	if (bADLWeight1 + bADLWeight2 == 0)
    	{
    		bADLWeight1 = 1;
    	}
    	else
    	{
    		bADLWeight3 = 64 - bADLWeight1 - bADLWeight2;
    	}

    	bIncPatProtEn = ((bIncPatCntTh)? 1 : 0);
    	bIncPatCntTh = CLIP(bIncPatCntTh, 1, 15);

        if (ADL_LOG_CHECK(AL_DBG_ADAPGAIN))
        {
            LOG(2, "BSDCGain = %d, BSACGain = %d, WSDCGain = %d, WSACGain = %d, \n", bBSDCGain, bBSACGain, bWSDCGain, bWSACGain);
        }
    }
}

void vDrvADLGetAdaptiveLumaParam(void)
{
    bAdlVersion     = IO32ReadFldAlign(ADAP_LUMA2_00, ADL_VERSION);
    bHistogramMode  = RegReadFldAlign(SCE_CFG_MAIN, COLOR_YHIST_WGT_EN); 
    bAdl3DEnable    = IO32ReadFldAlign(ADAP_LUMA2_00, ADL_3D_LUMA_EN);
    bIIRStrength    = IO32ReadFldAlign(ADAP_LUMA_0D, ADL_IIR_STRENTH);

    if(bAdlVersion == SV_OFF)   //Adaptive Luma Version 1
    {
        bALOnOff        = IO32ReadFldAlign(ADAP_LUMA_04, SWREG_AL_ON_1_OFF_0);
        bBSOnOff        = IO32ReadFldAlign(ADAP_LUMA_04, SWREG_BWS_BLACK_ON_1_OFF_0);
        bWSOnOff        = IO32ReadFldAlign(ADAP_LUMA_04, SWREG_BWS_WHITE_ON_1_OFF_0);
        
        bAdapLumaGain   = IO32ReadFldAlign(ADAP_LUMA_03, SWREG_AL_GAIN);
        bAdapLumaOffset = IO32ReadFldAlign(ADAP_LUMA_03, SWREG_AL_OFFSET);
        bAdapLumaLimit  = IO32ReadFldAlign(ADAP_LUMA_03, SWREG_AL_LIMIT);
        
        bBSLevel        = IO32ReadFldAlign(ADAP_LUMA_04, SWREG_BWS_BLACK_LEVEL);
        bBSGain         = IO32ReadFldAlign(ADAP_LUMA_00, SWREG_BWS_BLACK_GAIN);
        bBSOffset       = IO32ReadFldAlign(ADAP_LUMA_00, SWREG_BWS_BLACK_OFFSET);
        bBSRatio        = IO32ReadFldAlign(ADAP_LUMA_00, SWREG_BWS_BLACK_RATIO);
        bBSLimit        = IO32ReadFldAlign(ADAP_LUMA_00, SWREG_BWS_BLACK_LIMIT);

        bWSLevel        = IO32ReadFldAlign(ADAP_LUMA_04, SWREG_BWS_WHITE_LEVEL);  
        bWSGain         = IO32ReadFldAlign(ADAP_LUMA_01, SWREG_BWS_WHITE_GAIN);
        bWSOffset       = IO32ReadFldAlign(ADAP_LUMA_01, SWREG_BWS_WHITE_OFFSET);
        bWSRatio        = IO32ReadFldAlign(ADAP_LUMA_01, SWREG_BWS_WHITE_RATIO);
        bWSLimit        = IO32ReadFldAlign(ADAP_LUMA_01, SWREG_BWS_WHITE_LIMIT);    

        bDynamicBSOnOff = IO32ReadFldAlign(ADAP_LUMA_04, SWREG_DYNBS_ONOFF);
        bDynamicBSRange = IO32ReadFldAlign(ADAP_LUMA_04, SWREG_DYNBS_RANGE);
        bDBSPxlThd1     = IO32ReadFldAlign(ADAP_LUMA_02, SWREG_DYNBS_PXL_THD1);  
        bDBSPxlThd2     = IO32ReadFldAlign(ADAP_LUMA_02, SWREG_DYNBS_PXL_THD2);  
        bDBSDistThdL    = IO32ReadFldAlign(ADAP_LUMA_02, SWREG_DYNBS_DIST_THDL);  
        bDBSDistThdH    = IO32ReadFldAlign(ADAP_LUMA_02, SWREG_DYNBS_DIST_THDH);      
        bDBSLmtBtm      = IO32ReadFldAlign(ADAP_LUMA_05, SWREG_DYNBS_LMT_BTM);
        bDBSLmtTop      = IO32ReadFldAlign(ADAP_LUMA_05, SWREG_DYNBS_LMT_TOP);
        bDBSGainBtm     = IO32ReadFldAlign(ADAP_LUMA_05, SWREG_DYNBS_GAIN_BTM);
        bDBSGainTop     = IO32ReadFldAlign(ADAP_LUMA_05, SWREG_DYNBS_GAIN_TOP);
        bDBSOfstBtm     = IO32ReadFldAlign(ADAP_LUMA_06, SWREG_DYNBS_OFST_BTM);
        bDBSOfstTop     = IO32ReadFldAlign(ADAP_LUMA_06, SWREG_DYNBS_OFST_TOP);

        bBWSKeepMidOnOff= IO32ReadFldAlign(ADAP_LUMA_0D, SWREG_BWS_KEEP_MID_ON_OFF);
        bBWSKeepMidX    = IO32ReadFldAlign(ADAP_LUMA_0D, SWREG_BWS_KEEP_MID_X);
        wBWSKeepMidY    = (IO32ReadFldAlign(ADAP_LUMA_0D, SWREG_BWS_KEEP_MID_Y)<<2);
    }
    else
    {
        bALOnOff 		= IO32ReadFldAlign(ADAP_LUMA2_05, ADL_ON_1_OFF_0);
        bBSOnOff 		= IO32ReadFldAlign(ADAP_LUMA2_05, ADL_BWS_BLACK_ON_1_OFF_0);
        bWSOnOff 		= IO32ReadFldAlign(ADAP_LUMA2_05, ADL_BWS_WHITE_ON_1_OFF_0);

        bMIDACGain 		= IO32ReadFldAlign(ADAP_LUMA2_00, ADL_MID_AC_GAIN);
        bMIDDCGain 		= IO32ReadFldAlign(ADAP_LUMA2_00, ADL_MID_DC_GAIN);
        
        bBSDCGainRatio	= IO32ReadFldAlign(ADAP_LUMA2_01, ADL_BWS_BLACK_DC_GAIN_RATIO);
        bBSOffsetL 		= IO32ReadFldAlign(ADAP_LUMA2_02, ADL_BWS_BLACK_OFFSET_L);
        bBSOffsetH 		= IO32ReadFldAlign(ADAP_LUMA2_02, ADL_BWS_BLACK_OFFSET_H);	
        bBSRatio 		= IO32ReadFldAlign(ADAP_LUMA2_01, ADL_BWS_BLACK_RATIO);
        bBSACGainRatio	= IO32ReadFldAlign(ADAP_LUMA2_01, ADL_BWS_BLACK_AC_GAIN_RATIO);
        bBSLevel 		= IO32ReadFldAlign(ADAP_LUMA2_01, ADL_BWS_BLACK_LEVEL);
    	bStrongBSOffset = IO32ReadFldAlign(ADAP_LUMA2_05, ADL_BWS_BLACK_STRONG_OFFSET_EN);
    	bBSAdaptiveLmt	= IO32ReadFldAlign(ADAP_LUMA2_05, ADL_BWS_BLACK_ADPT_LMT_EN);
    	bBSOffsetThL	= IO32ReadFldAlign(ADAP_LUMA2_02, ADL_BWS_BLACK_OFT_TH_L);
    	bBSOffsetThH	= IO32ReadFldAlign(ADAP_LUMA2_02, ADL_BWS_BLACK_OFT_TH_H);
    	bBSDCGain		= (UINT8)CLIP(((UINT16)bBSDCGainRatio*bMIDDCGain>>7), 0, 255);
    	bBSACGain		= (UINT8)CLIP(((UINT16)bBSACGainRatio*bMIDACGain>>7), 0, 255);
    		
        bWSDCGainRatio	= IO32ReadFldAlign(ADAP_LUMA2_03, ADL_BWS_WHITE_DC_GAIN_RATIO);
        bWSOffsetL 		= IO32ReadFldAlign(ADAP_LUMA2_04, ADL_BWS_WHITE_OFFSET_L);
        bWSOffsetH 		= IO32ReadFldAlign(ADAP_LUMA2_04, ADL_BWS_WHITE_OFFSET_H);	
        bWSRatio 		= IO32ReadFldAlign(ADAP_LUMA2_03, ADL_BWS_WHITE_RATIO);
        bWSACGainRatio	= IO32ReadFldAlign(ADAP_LUMA2_03, ADL_BWS_WHITE_AC_GAIN_RATIO);
        bWSLevel 		= IO32ReadFldAlign(ADAP_LUMA2_03, ADL_BWS_WHITE_LEVEL);
    	bStrongWSOffset = IO32ReadFldAlign(ADAP_LUMA2_05, ADL_BWS_WHITE_STRONG_OFFSET_EN);
    	bWSAdaptiveLmt	= IO32ReadFldAlign(ADAP_LUMA2_05, ADL_BWS_WHITE_ADPT_LMT_EN);	
    	bWSOffsetThL	= IO32ReadFldAlign(ADAP_LUMA2_04, ADL_BWS_WHITE_OFT_TH_L);
    	bWSOffsetThH	= IO32ReadFldAlign(ADAP_LUMA2_04, ADL_BWS_WHITE_OFT_TH_H);
    	bWSDCGain		= (UINT8)CLIP(((UINT16)bWSDCGainRatio*bMIDDCGain>>7), 0, 255);
    	bWSACGain		= (UINT8)CLIP(((UINT16)bWSACGainRatio*bMIDACGain>>7), 0, 255);

        bADLWeight1 	= IO32ReadFldAlign(ADAP_LUMA2_05, ADL_WEIGHT1);
        bADLWeight2 	= IO32ReadFldAlign(ADAP_LUMA2_05, ADL_WEIGHT2);

    	bIncPatCntTh	= IO32ReadFldAlign(ADAP_LUMA2_07, ADL_INCPAT_CNT_TH);
    	bAplDiffTh		= IO32ReadFldAlign(ADAP_LUMA2_07, ADL_APL_DIFF_TH);
        bAPLCount 		= IO32ReadFldAlign(ADAP_LUMA2_07, ADL_APL_DBG_COUNT);

        bCGProtTh       = IO32ReadFldAlign(ADAP_LUMA2_07, ADL_CG_PAT_PROT_TH);
        bCGProtGain     = IO32ReadFldAlign(ADAP_LUMA2_07, ADL_CG_PAT_PROT_GAIN);
        bCGProtEn       = IO32ReadFldAlign(ADAP_LUMA2_07, ADL_CG_PAT_PROT_EN);
    }

        bDbgIndex       = IO32ReadFldAlign(ADAP_LUMA_08, ADL_DEBUG_INDEX);    
        bDbgCount       = IO32ReadFldAlign(ADAP_LUMA_08, ADL_DEBUG_COUNT);
        bDbgCur         = (bDbgCur<bDbgCount) ? (bDbgCur+1) : 0;     
        
        bYGammaUI       = IO32ReadFldAlign(ADAP_LUMA_09, ADL_UI_YGAMMA); 
        bYGammaSel      = IO32ReadFldAlign(ADAP_LUMA_0C, Y_GAMMA_SEL);        
        bYGammaDecayH   = IO32ReadFldAlign(ADAP_LUMA_0C, Y_GAMMA_DECAY_H);
        bYGammaDecayL   = IO32ReadFldAlign(ADAP_LUMA_0C, Y_GAMMA_DECAY_L);
        bDarkSceneBrit  = IO32ReadFldAlign(ADAP_LUMA_0C, Y_BRIGHT);
        u4AdapYGammaGain= IO32ReadFldAlign(ADAP_LUMA_09, ADL_ADAP_YGAMMA_GAIN);
        u4AdapYGammaTh  = IO32ReadFldAlign(ADAP_LUMA_09, ADL_ADAP_YGAMMA_TH);
        
        bYGammaMID      = IO32ReadFldAlign(ADAP_LUMA_08, Y_GAMMA_MID_SEL); 
        bYGammaMIDSKIN  = IO32ReadFldAlign(ADAP_LUMA_08, Y_GAMMA_MID_SEL_SKIN); 
        
        bSkinLumaOnOff  = IO32ReadFldAlign(ADAP_LUMA_0A, ADL_SECOND_LUMA_EN);
        bSkinWeight     = IO32ReadFldAlign(ADAP_LUMA_0A, ADL_SECOND_CURVE_WEIGHT);
        bSkinBlendmethod= IO32ReadFldAlign(ADAP_LUMA_0A, ADL_SECOND_LUMA_BLEND_METHOD);
        bAdapSkinBlend  = IO32ReadFldAlign(ADAP_LUMA_0A, ADL_SECOND_LUMA_BLEND_ADAP);        
        bAdapSkinConfUpSlope = IO32ReadFldAlign(ADAP_LUMA_0A, ADL_SECOND_LUMA_CONF_UP_SLOPE);
        bAdapSkinConfDownSlope = IO32ReadFldAlign(ADAP_LUMA_0A, ADL_SECOND_LUMA_CONF_DOWN_SLOPE);

        bForceScenceChange = IO32ReadFldAlign(ADAP_LUMA2_05, ADL_FORCE_SCENE_CHANGE);
        bALUpdateCount  = IO32ReadFldAlign(ADAP_LUMA_09, ADL_UPDATE_COUNT);    

        vDrvADLParamConstrain();
}

BOOL bDrvADLDetectSceneChanged(const UINT16 wHistCur[LUMA_HIST_NUM_WEIGHT])
{
	UINT32 i, u4MaxDiff = 0, u4TotalDiff = 0, u4Diff = 0, u4AplDiff;
    static UINT32 u4PreAPLLR[2];
    static UINT16 waHistRecLR[2][LUMA_HIST_NUM_WEIGHT]; 
    BOOL LRflag = (bIsSrcLRflg || bAdl3DEnable) ? 1: 0;
	UINT32 dwLumaSum = u4RegRead4B(LUMA_SUM_MAIN);

    u4AplDiff = AbsDiff(u4PreAPLLR[LRflag], u4LumaAPL);
    for (i = 0; i < LUMA_HIST_NUM_WEIGHT; i++)
    {
        u4Diff = AbsDiff(wHistCur[i], waHistRecLR[LRflag][i]);
        u4MaxDiff = (u4MaxDiff < u4Diff) ? u4Diff : u4MaxDiff;
        u4TotalDiff += u4Diff;
    }    
    
    if(bIsSrcLRflg || bAdl3DEnable)  //FS content
    {
        // Save previous data
        u4PreAPLLR[1] = u4PreAPLLR[0];
        x_memcpy(waHistRecLR[1], waHistRecLR[0], LUMA_HIST_NUM_WEIGHT*sizeof(UINT16));
    }
        u4PreAPLLR[0] = u4LumaAPL;
        x_memcpy(waHistRecLR[0], wHistCur, LUMA_HIST_NUM_WEIGHT*sizeof(UINT16));    
  

    if (bForceScenceChange)
    {        
        if (ADL_LOG_CHECK2(AL_DBG_SCENE_CHANGE))
        {
            LOG(2, "Force Scene Changed\n");
        }
        
        bForceScenceChange = 0;
		return SV_TRUE;
    }
	else if ((u4MaxDiff > bMaxDiffThreshold) && ((u4TotalDiff >> 2) > bTotalDiffThreshold) && (u4AplDiff > 10))
	{           
        if (ADL_LOG_CHECK2(AL_DBG_SCENE_CHANGE))
        {
            LOG(2, "Scene Changed : MaxDiff = %d, TotalDiff = %d, APLDdiff = %d, APL = %d, LumaSum = %4d\n", 
                u4MaxDiff, u4TotalDiff, u4AplDiff, u4LumaAPL, dwLumaSum);
        }
		return SV_TRUE;
	}
	else
	{
		return SV_FALSE;
	}
}

const UINT16* u2DrvGetYGamma(UINT8 bIndex)
{    
	switch (bIndex)
	{
        case 1:
        	return GAMMA_950_TABLE;
        case 2:
        	return GAMMA_925_TABLE;
        case 3:
        	return GAMMA_900_TABLE;
        case 4:
        	return GAMMA_875_TABLE;
        case 5:
        	return GAMMA_850_TABLE;
        case 6:
        	return GAMMA_825_TABLE;
        case 7:
            return GAMMA_105_TABLE;
        case 8:
        	return GAMMA_110_TABLE;
        case 9:
        	return GAMMA_115_TABLE;
        default:
            return GAMMA_100_TABLE;        
	}
}

void vDrvApplyYGamma(UINT16* waFinalCurve)
{
    UINT32 i,u4Index,u4IndexNxt;	
    UINT32 u4Tmp;
    const UINT16* b2PQYGammaSelTbl;//Y Gamma Select By Quality Item
    const UINT16* b2UIYGammaSelTbl;//Y Gamma Select By Men UI
    static UINT16 u2CURRENT_Y_GAMMA_TABLE[257];
    UINT8 bDecay;
    UINT8 bDarkSceneBrightRaise;//Raising the Brightness for Dark Scene
    UINT32 u4RemapedAPL;
    UINT16 u2RemapIndex;
    
    b2PQYGammaSelTbl = u2DrvGetYGamma(bYGammaSel);

    //Boundary Protection
    bYGammaDecayH = MIN(bYGammaDecayH, 0x80);
    bYGammaDecayL = MIN(bYGammaDecayL, 0x80);

    u4RemapedAPL = u4LumaAPLFullRange;
    if(u4RemapedAPL < 0x40)
    {        
        bDecay = u4RemapedAPL * (0x80 - bYGammaDecayL) / 0x40 + bYGammaDecayL;
        bDarkSceneBrightRaise = (0x40 - u4RemapedAPL) * bDarkSceneBrit / 0x40;        
    }
    else if(u4RemapedAPL > 0xC0)
    {    
        bDecay = (0x100-u4RemapedAPL) * (0x80 - bYGammaDecayH) /(0x100-0xC0) + bYGammaDecayH;
        bDarkSceneBrightRaise = 0;
    }
    else
    {
        bDecay = 0x80;
        bDarkSceneBrightRaise = 0;
    }

    if (ADL_LOG_CHECK(AL_DBG_YGAMMA))
    {        
        LOG(2, "Y Gamma : UI Gamma  %d  PQ   %d \n", bYGammaUI, bYGammaSel);
        LOG(2, "APL %d   Decay %d  BrightRise %d \n", u4LumaAPLFullRange, bDecay, bDarkSceneBrightRaise);
    }

    b2UIYGammaSelTbl = u2DrvGetYGamma(bYGammaUI);
 
    for (i=0; i<257; ++i)
    {      
        u4Tmp = MIN(((INT32)(b2PQYGammaSelTbl[i])-(INT32)i*4) * bDecay / 0x80 + i*4+bDarkSceneBrightRaise,0x400);

        //Original Range Already do Boundary Protection
        u4Index = u4Tmp >> 2;
        u4IndexNxt = u4Index + 1;
        
        u2CURRENT_Y_GAMMA_TABLE[i] = (UINT16)((b2UIYGammaSelTbl[u4Index]*(4-(u4Tmp&3))
                                    +b2UIYGammaSelTbl[u4IndexNxt]*(u4Tmp&3)+2)>>2);
    }

	for (i = 3; i < LUMA_CURVE_NUM - 3; i++)
	{
        u2RemapIndex = MIN((waFinalCurve[i]>>2), 0x100);
        waFinalCurve[i] = MIN(u2CURRENT_Y_GAMMA_TABLE[u2RemapIndex], 0x3FF);
	}
	
	if (ADL_LOG_CHECK(AL_DBG_LUMA_CURVE2))
	{
		LOG(2, "Luma curve after YGamma:\n");
	
		for (i=0; i < LUMA_CURVE_NUM; i++)	
		{
			LOG(2, "%d, ", waFinalCurve[i]);
		}
		LOG(2, "\n");
	}		
}

void vDrvApplyUserCurve(UINT16* waFinalCurve, UINT8 bSel)
{
	UINT8 bi;
	const UINT16* wTbl;

	switch (bSel)
	{
    	case 1:
    		wTbl = GAMMA_950_TABLE_MID;
    		break;
    	case 2:
    		wTbl = GAMMA_900_TABLE_MID;
    		break;
    	case 3:
    		wTbl = GAMMA_850_TABLE_MID;
    		break;
    	case 4:
    		wTbl = GAMMA_800_TABLE_MID;
    		break;
    	case 5:
    		wTbl = GAMMA_950_TABLE_MIDH;
    		break;		
    	case 6:
    		wTbl = GAMMA_900_TABLE_MIDH;
    		break;
    	case 7:
    		wTbl = GAMMA_850_TABLE_MIDH;
    		break;		
    	case 8:
    		wTbl = GAMMA_800_TABLE_MIDH;
    		break;			
    	case 9:
    		wTbl = GAMMA_950_105_TABLE_MIDS;
    		break;		
    	case 10:
    		wTbl = GAMMA_900_110_TABLE_MIDS;
    		break;		
    	case 11:
    		wTbl = GAMMA_850_115_TABLE_MIDS;
    		break;		
    	case 12:
    		wTbl = GAMMA_800_120_TABLE_MIDS;
    		break;			
    	default:
            wTbl = GAMMA_100_TABLE;
    		return;
	}

	for (bi = 0; bi < LUMA_CURVE_NUM; bi++)
	{
		waFinalCurve[bi] = wTbl[(waFinalCurve[bi]>>2)];
	}
}

void vDrvApplyAdapYGamma(UINT16* waFinalCurve)
{
    UINT32 bi;
    INT32 i4DiffLeft, i4DiffRight;
    INT32 i4APLMapping = 0;
    UINT32 u4Index = u4LumaAPLFullRange>>3;
    INT32 i4Remain = (((u4Index+1)<<3) - u4LumaAPLFullRange)<<2;
    UINT32 u4Blending = 0;
    INT32 i4APLYIncrease = 0;
    UINT16 u2RemapIndex;    
    static UINT32 u4BlendingPre = 0;    
    static UINT16 u2AdapYGammaTbl[257];

    if(u4AdapYGammaGain == 0)
    {
        return;
    }
    
    i4DiffLeft = ((u4Index) << 5) - waFinalCurve[u4Index];
    i4DiffRight = ((u4Index + 1) << 5) - waFinalCurve[u4Index + 1];
    i4APLMapping = i4DiffRight + ((i4DiffLeft - i4DiffRight)*i4Remain>> 5) ;

    if(ADL_LOG_CHECK(AL_DBG_ADAP_YGAMMA))
    {
        LOG(2, "u4LumaAPLFullRange = %4d, i4APLMapping = %4d\n", u4LumaAPLFullRange, i4APLMapping);
    }
   
    if(i4APLMapping <= 0)
    {
        return;
    }
    else
    {
        u4Blending = ((UINT32)i4APLMapping * (128-AbsDiff(u4LumaAPLFullRange,128)) * u4AdapYGammaGain) >> 12;        
        if(u4Blending != u4BlendingPre)
        {
            for (bi = 0; bi < 257; bi++)
            {      
                u2AdapYGammaTbl[bi] = ((GAMMA_850_TABLE[bi] - (bi<<2)) * u4Blending >> 7) + (bi<<2);
            }
            u4BlendingPre = u4Blending;
        }
        
        if(u4Blending > u4AdapYGammaTh)
        {
        	for (bi = 3; bi < LUMA_CURVE_NUM-3; bi++)
        	{
                u2RemapIndex = MIN((waFinalCurve[bi]>>2), 0x100);
                if(u2RemapIndex > 0x100) //Fix klock warning
                {
                    u2RemapIndex = 0x100;
                }                
        		waFinalCurve[bi] = u2AdapYGammaTbl[u2RemapIndex];
        	}        
        }
        
    	if(ADL_LOG_CHECK(AL_DBG_ADAP_YGAMMA))
    	{
            i4DiffLeft = ((u4Index) << 5) - waFinalCurve[u4Index];
            i4DiffRight = ((u4Index + 1) << 5) - waFinalCurve[u4Index + 1];

            i4APLYIncrease = i4APLMapping - (i4DiffRight + ((i4DiffLeft - i4DiffRight)*i4Remain>> 5));

            LOG(2, "u4Blending = %d\n", u4Blending);
            LOG(2, "Y increase @ APL = %d\n", i4APLYIncrease);
    		LOG(2, "Luma curve after Adap YGamma:\n");
    	
    		for (bi=0; bi < LUMA_CURVE_NUM; bi++)	
    		{
    			LOG(2, "%d, ", waFinalCurve[bi]);
    		}
    		LOG(2, "\n");
    	}        
    }
}

void vAdapSecondLumaWeight(void)
{
    UINT16 u2Base = 4096;
    static UINT32 u4SkinPxlCntPre = 0;
    UINT32 u4SkinPxlCntCur = u4DrvGetSatHue2DWindowResult(0, u2Base);
    static UINT32 u4SkinConfidence = 0xFF;
    UINT32 u4DiffThd = 0;
    
    if(!bAdapSkinBlend)
    {
        u4SkinConfidence = 0xFF;
        return;
    }
    
	if (ADL_LOG_CHECK(AL_DBG_SKIN_CURVE))
	{
		LOG(2, "SkinPxlCntCur = %d, SkinPxlCntPre = %d\n", u4SkinPxlCntCur, u4SkinPxlCntPre);
	}       

    u4DiffThd = (u4SkinPxlCntPre>>6) ? (u4SkinPxlCntPre>>6): 1;
        
    if(bADLSceneChange == SV_FALSE)
    {
        if(AbsDiff(u4SkinPxlCntCur ,u4SkinPxlCntPre) <= u4DiffThd)
        {
            if(u4SkinConfidence <= (255 - bAdapSkinConfUpSlope))
            {
                u4SkinConfidence = u4SkinConfidence + bAdapSkinConfUpSlope;
            }
            u4SkinPxlCntPre = (u4SkinPxlCntCur + u4SkinPxlCntPre*7)>>3;
        }
        else
        {
            if(u4SkinConfidence >= bAdapSkinConfDownSlope)
            {
                u4SkinConfidence = u4SkinConfidence - bAdapSkinConfDownSlope;
            }
            u4SkinPxlCntPre = u4SkinPxlCntCur;
        }
    }
    else
    {
        u4SkinConfidence = 0xFF;
    }
    u4SkinConfidence = CLIP(u4SkinConfidence, 0, 255);

    bSkinWeight = (UINT8)((u4SkinConfidence * bSkinWeight + (1<<7))>>8);

	if (ADL_LOG_CHECK(AL_DBG_SKIN_CURVE))
	{
		LOG(2, "SkinConfidence = %d\n", u4SkinConfidence);
	}    

}

void vBuildSecondLumaCurve(const UINT16 waCurCurve[LUMA_CURVE_NUM], UINT16 waLumaCurve[LUMA_CURVE_NUM])
{
	UINT8 bi;
	UINT16 waLumaDft[LUMA_CURVE_NUM];
	UINT16 wDiff;
	UINT8 bSkinBlending = 0;
	vDrvADLBuildDefault(waLumaDft);

    vAdapSecondLumaWeight();
   
	for (bi = 3; bi < 30; bi++)
	{
		switch(bSkinBlendmethod)
		{
			case 0:
		        bSkinBlending = (UINT8)CLIP((((UINT16)bSkinWeight*(LUMA_CURVE_NUM-bi) + (1<<3))>>4),0,255);
			break;
			case 1:
				bSkinBlending = (UINT8)CLIP((((UINT16)bSkinWeight*bi + (1<<3))>>4),0,255);				
			break;			
			default:
				bSkinBlending = (UINT8)CLIP((UINT16)bSkinWeight ,0,255);				
			break;			
		}

		wDiff = AbsDiff(waLumaDft[bi],waCurCurve[bi]);
		if(waLumaDft[bi] >=waCurCurve[bi])
		{
			waLumaCurve[bi] = waCurCurve[bi] + ((wDiff * bSkinBlending + (1<<7))>>8);
		}
		else
		{
			waLumaCurve[bi] = waCurCurve[bi] - ((wDiff * bSkinBlending + (1<<7))>>8);
		}
	}
	waLumaCurve[0] = 0;
	waLumaCurve[1] = 32;
	waLumaCurve[2] = 64;
	waLumaCurve[30] = 960;
	waLumaCurve[31] = 992;
	waLumaCurve[32] = 1023;

	vDrvApplyUserCurve(waLumaCurve, bYGammaMIDSKIN);

	if (ADL_LOG_CHECK(AL_DBG_SKIN_CURVE))
	{
		LOG(2, "Skin Luma curve, Skin Weight = %d\n", bSkinWeight);
		for (bi=0; bi < LUMA_CURVE_NUM; bi++)	
		{
			LOG(2, "%d, ", waLumaCurve[bi]);
		}
		LOG(2, "\n");
	}
}

//Adaptive Luma version 1 Algorithm
void vDrvGetDistribution(const UINT16 * waHistCur)
{
	UINT8 bi;

	for (bi = 0, dwDistribution = 0; bi < LUMA_HIST_NUM; bi++)
	{
		dwDistribution += AbsDiff(bi * 8, u4LumaAPL) * waHistCur[bi];
	}

	// shift 8 bits to make distribution a 8 bits value
	dwDistribution = dwDistribution >> 8;
	vIO32WriteFldAlign(ADAP_LUMA_06, dwDistribution, SWREG_AL_DIST);
}

void vDrvGetDrkArea(const UINT16 waHistCur[LUMA_HIST_NUM])
{
	UINT8 bi;
    static UINT32 bPreDarkPixlCnt = 0;

	if (bDynamicBSRange < 32)
	{
		for (bi = 0, dwDarkPxlCount = 0; bi <= bDynamicBSRange; bi++)
		{
			dwDarkPxlCount += waHistCur[bi];
		}
	}

	// quality table use 8 bit resolution, but histogram was normalized to 512,
	// so we need to shift 1 bit.
	dwDarkPxlCount >>= 1;

	if (!bADLSceneChange)
	{
		dwDarkPxlCount = (bPreDarkPixlCnt*7 + dwDarkPxlCount) >> 3;
	}

	bPreDarkPixlCnt = dwDarkPxlCount;
	vIO32WriteFldAlign(ADAP_LUMA_06, dwDarkPxlCount, SWREG_AL_DRK_PXL);
}

void vDynamicBlackStretch(const UINT16 waHistCur[LUMA_HIST_NUM])
{    
    UINT8 bDBSLimitStep, bDBSGainStep, bDBSOffsetStep;
    
	bDBSOffset = bBSOffset ;
	bDBSGain = bBSGain;

	vDrvGetDistribution(waHistCur);
	vDrvGetDrkArea(waHistCur);
    
	if (bDynamicBSOnOff)
	{
		// 1. Dynamic BSLimit
		if (dwDarkPxlCount > bDBSPxlThd2)
		{
			if(bDBSLmtTop > 0x80)
			{
				bDBSLimit = bBSLimit + (bDBSLmtTop - 0x80);
			}
			else
			{
				bDBSLimit = (bBSLimit > (0x80 - bDBSLmtTop)) ? bBSLimit - (0x80 - bDBSLmtTop) : 0;
			}
		}
		else if (dwDarkPxlCount > bDBSPxlThd1)
		{
			// interpolate between top / bottom
			if(bDBSPxlThd2 == bDBSPxlThd1)
			{
    			bDBSLimitStep =  bDBSLmtBtm;    			
            }
            else
            {            
			    bDBSLimitStep = (((bDBSLmtTop - bDBSLmtBtm)*(dwDarkPxlCount - bDBSPxlThd1))/(bDBSPxlThd2 - bDBSPxlThd1)) + bDBSLmtBtm;
            }

			if (bDBSLimitStep > 0x80)
			{
				bDBSLimit = bBSLimit + (bDBSLimitStep - 0x80);
			}
			else
			{
				bDBSLimit = (bBSLimit > (0x80 - bDBSLimitStep) ) ? bBSLimit - (0x80 - bDBSLimitStep) : 0;
			}
		}
		else
		{
			if (bDBSLmtBtm > 0x80)
			{
				bDBSLimit = bBSLimit + (bDBSLmtBtm - 0x80);
			}
			else
			{
				bDBSLimit = (bBSLimit > (0x80 - bDBSLmtBtm) ) ? bBSLimit - (0x80 - bDBSLmtBtm) : 0;
			}
		}

		// 2. Dynamic BSGain / BSOffset
		if (dwDistribution > bDBSDistThdH)
		{
			if (bDBSOfstBtm > 0x80)
			{
				bDBSOffset = bBSOffset + (bDBSOfstBtm - 0x80);
			}
			else
			{
				bDBSOffset = (bBSOffset > (0x80 - bDBSOfstBtm) ) ? bBSOffset - (0x80 - bDBSOfstBtm) : 0;
			}

			bDBSGain = bBSGain + (bDBSGainTop - 0x80);
		}
		else if (dwDistribution < bDBSDistThdL)
		{
			bDBSOffset = bBSOffset + (bDBSOfstTop - 0x80);

			if (bDBSGainBtm > 0x80)
			{
				bDBSGain = bBSGain + (bDBSGainBtm - 0x80);
			}
			else
			{
				bDBSGain = (bBSGain > (0x80 - bDBSGainBtm) ) ? bBSGain - (0x80 - bDBSGainBtm) : 0;
			}
		}
		else
		{
		    if(bDBSDistThdH == bDBSDistThdL)
		    {
    			bDBSOffsetStep =  bDBSOfstBtm;
    			bDBSGainStep   =  bDBSGainBtm;	
            }
            else
            {            
    			bDBSOffsetStep = (((bDBSOfstTop - bDBSOfstBtm)*(bDBSDistThdH - dwDistribution))/(bDBSDistThdH - bDBSDistThdL)) + bDBSOfstBtm;
    			bDBSGainStep = (((bDBSGainTop - bDBSGainBtm)*(dwDistribution- bDBSDistThdL))/(bDBSDistThdH - bDBSDistThdL)) + bDBSGainBtm;
            }

			// interpolate dynamic bs offset
			if (bDBSOffsetStep > 0x80)
			{
				bDBSOffset = bBSOffset+ (bDBSOffsetStep - 0x80);
			}
			else
			{
				bDBSOffset = (bBSOffset > (0x80 - bDBSOffsetStep) ) ? bBSOffset - (0x80 - bDBSOffsetStep) : 0;
			}

			// interpolate dynamic bs gain
			if (bDBSGainStep > 0x80)
			{
				bDBSGain = bBSGain + (bDBSGainStep - 0x80);
			}
			else
			{
				bDBSGain = (bBSGain > (0x80 - bDBSGainStep) ) ? bBSGain - (0x80 - bDBSGainStep) : 0;
			}
		}
	}
    
    if (ADL_LOG_CHECK(AL_DBG_DYN_BS))
    {        
    	LOG(2, "DarkPxl = %d, Distribution = %d\n", dwDarkPxlCount, dwDistribution);        
    	LOG(2, "BSGain =  %d, BSOffset =  %d, BSLimit =  %d\n", bBSGain, bBSOffset, bBSLimit);
    	LOG(2, "DBSGain = %d, DBSOffset = %d, DBSLimit = %d\n", bDBSGain, bDBSOffset, bDBSLimit);
    }
}
// ---------------------------------------------------------------------------------
void vDrvADLGetApdaptiveGain(const UINT16 wHistCur[LUMA_HIST_NUM])
{
	UINT32  bi;
	UINT32  bCountL = 0, bCountM = 0, bCountH = 0;
	UINT32  bDiffCur;
	UINT32  bDynGain = (bAdapLumaGain * (255 - u4LumaAPLFullRange)) >> 8;
	UINT32  bGainL = (16 + bAdapLumaOffset) * bDynGain; // need >>7 
	UINT32  bGainM = (8 + bAdapLumaOffset) * bDynGain; 
	UINT32  bGainH = bGainL;
        
	bGainL = (bGainL > (16<<7)) ? (16<<7) : bGainL;
    
	for (bValueL = AL_LOW_START; bValueL < AL_LOW_END; bValueL += AL_HIST_STEP)
	{
		bCountL = 0;

		for (bi = 2; bi < LUMA_HIST_NUM-2; bi++)
		{
			if (wHistCur[bi] < bValueL)
			{
				bCountL++;
			}
		}

		if (bCountL >= AL_LOW_BIN)
		{
			break;
		}
	}

	for (bValueH = AL_HIGH_START; bValueH < AL_HIGH_END; bValueH += AL_HIST_STEP)
	{
		bCountH = 0;

		for (bi = 2; bi < LUMA_HIST_NUM-2; bi++)
		{
			if (wHistCur[bi] >= bValueH)
			{
				bCountH++;
			}
		}

		if (bCountH <= AL_HIGH_BIN)
		{
			break;
		}
	}

	bCountM = LUMA_HIST_NUM - 4 - (bCountH + bCountL);
    
    if (ADL_LOG_CHECK(AL_DBG_ADAPGAIN))
    {
    	LOG(2, "DynGain %d  ValueL %d  ValueH %d \n", bDynGain, bValueL, bValueH);
    }
    
	bDiffCur = AL_LOW_END - bValueL;

	bCurGainL = bGainL;
	bCurGainM = (bGainM * bDiffCur) / (AL_LOW_END - AL_LOW_START);
	bCurGainH = (bGainH * bDiffCur) / (AL_LOW_END - AL_LOW_START);
    
    if (ADL_LOG_CHECK(AL_DBG_ADAPGAIN))
    {
	    LOG(2, "CurGainL %d  CurGainM %d  CurGainH %d \n", bCurGainL, bCurGainM, bCurGainH);
    }
    
	if (bCountL != 0) 
	{
		bCurGainL = ((bCurGainH * bCountH) + (bCurGainM * bCountM) +
		            (bCountL >> 1)) / bCountL;

		if (bCurGainL > bGainL)
		{
            bCurGainM = ((bGainL * bCurGainM) + (bCurGainL >> 1)) / bCurGainL;
            bCurGainL = bGainL;
            
            if ((bGainL * bCountL) > (bCurGainM * bCountM))
            {
                bCurGainH = (bCountH == 0) ? 0 
                            : ((bGainL * bCountL) - (bCurGainM * bCountM) + (bCountH >> 1)) / bCountH ;                    
            }
            else
            {                
                bCurGainH = 0;
            }
		}
	}
	else
	{
		bCurGainL = 0;
		bCurGainM = 0;
		bCurGainH = 0;
	}
    
    if (ADL_LOG_CHECK(AL_DBG_ADAPGAIN))
    {
	    LOG(2, "CurGainL %d  CurGainM %d  CurGainH  %d \n", bCurGainL, bCurGainM, bCurGainH);         
    	LOG(2, "CountL   %d  CountM   %d  CountH    %d \n", bCountL, bCountM, bCountH);
	    LOG(2, "APL  %d ==> Neg %d   Pos %d \n", u4LumaAPL, bCurGainL*bCountL, bCurGainM*bCountM+bCurGainH*bCountH);
    }
}

// ---------------------------------------------------------------------------------
void vDrvADLBuildDynCurve(const UINT16 waHistCur[LUMA_HIST_NUM], UINT16 waDynCurve[LUMA_CURVE_NUM])
{
	UINT32 bi, bGainH, bGainM, bGainL;
    UINT32 u4AccCurve[LUMA_HIST_NUM-4], u4Sum = 0;

	if (waHistCur == NULL)
	{
		return;
	}  
    
	vDrvADLBuildDefault(waDynCurve);     
	vDrvADLGetApdaptiveGain(waHistCur);

    if (bALOnOff == SV_TRUE)
    {
        bGainL = (32<<7) - bCurGainL;
        bGainM = (32<<7) + bCurGainM;
        bGainH = (32<<7) + bCurGainH;
	    
        for (bi = 0; bi < (LUMA_HIST_NUM-4); bi++)
	    {
            if (waHistCur[bi+2] < bValueL)
		    {
                u4Sum += bGainL;
		    }
            else if (waHistCur[bi+2] >= bValueH)
		    {
                u4Sum += bGainH;		    
		    }
		    else
		    {
                u4Sum += bGainM;		    
            }
            
            u4AccCurve[bi] = u4Sum;            
        }                
        
        for (bi = 3; bi < (LUMA_HIST_NUM - 2); bi++)
	    {
	        waDynCurve[bi] = 0x40+(u4AccCurve[bi-3]>>7);
	    }
    }
}

UINT32 bDrvADLGetBSGain(UINT32 u4APL)
{
    if (u4APL < 0x40)
	{
		return ((bBSRatio * u4APL) / 0x40);
	}
	else if (u4APL < bAdapLumaLimit)
	{
		return (((0xFF - bBSRatio) * (u4APL - 0x40)) / (bAdapLumaLimit - 0x40) + bBSRatio);
	}
	else
	{
		return 0xFF;
	}
}

UINT32 bDrvADLGetWSGain(UINT32 u4APL)
{
	if (u4APL < 192)
	{
		return (((255 - bWSRatio) * u4APL) / 192);
	}
	else
	{
		return (((bWSRatio * (u4APL - 192)) >> 6) + (255 - bWSRatio));
	}
}

void vDrvADLBuildTargetCurve(const UINT16 waHistCur[LUMA_HIST_NUM], UINT16 waTargetCurve[LUMA_CURVE_NUM])
{
	UINT32 bi;
	UINT32 wDiff;
	UINT32 bStep;
	UINT32 bBsGainMap, bWsGainMap;
	UINT32 bWSAdjustGain, bBSAdjustGain;
	UINT32 bWSAdjustOffset, bBSAdjustOffset;
	UINT32 bBSGainApplied = bBSGain;
	UINT32 bBSOffsetApplied = bBSOffset;
	UINT32 bBSLimitApplied = bBSLimit;	
    UINT32 bEnd;
    UINT16 wBDiff, wWDiff;
    
	vDrvADLBuildDefault(waTargetCurve);
	vDynamicBlackStretch(waHistCur);
    
	if (bDynamicBSOnOff)
	{
		bBSGainApplied = bDBSGain;
		bBSOffsetApplied = bDBSOffset;
		bBSLimitApplied = bDBSLimit;
	}

	bBsGainMap = bDrvADLGetBSGain(u4LumaAPLFullRange);
	bWsGainMap = bDrvADLGetWSGain(u4LumaAPLFullRange);

	// BSGain
	wDiff = AbsDiff(bBSGainApplied, 0x80 + bBSLimitApplied);
	bBSAdjustGain = bBSGainApplied + ((wDiff * (0xFF - bBsGainMap)) >> 8);

	// WS Gain
	wDiff = AbsDiff(bWSGain, 0x80 + bWSLimit);
	bWSAdjustGain = bWSGain + ((wDiff * bWsGainMap) >> 8);

	bBSAdjustOffset = (bBSOffsetApplied * bBsGainMap) >> 8;
	bWSAdjustOffset = (bWSOffset * (0xFF - bWsGainMap)) >> 8;

    if (ADL_LOG_CHECK(AL_DBG_BWS))
    {
    	LOG(2, "APL %d  bBsGainMap %d  bWsGainMap %d\n", u4LumaAPLFullRange, bBsGainMap, bWsGainMap);
    	LOG(2, "BS Gain %d  Offset %d  \n", bBSAdjustGain, bBSAdjustOffset);
    	LOG(2, "WS Gain %d  Offset %d  \n", bWSAdjustGain, bWSAdjustOffset);
    }

	if (bBSOnOff == SV_TRUE)
	{
        bEnd = MIN(bBSLevel, 8);        
		for (bi = 0; bi < bEnd; bi++)
		{
			bStep = (bBSAdjustGain >> 2);
			if (bStep > bBSAdjustOffset)
			{
				bStep -= bBSAdjustOffset;
				bBSAdjustOffset = 0;
			}
			else
			{
				bBSAdjustOffset -= bStep;
				bStep = 0;
			}

			waTargetCurve[bi+3] = waTargetCurve[bi+2] + bStep;

            if (ADL_LOG_CHECK(AL_DBG_BWS))
            {
                LOG(2, "BS[%d] =  %d  \n", (bi+3), waTargetCurve[bi+3]);
            }
		}
	}

	if (bWSOnOff == SV_TRUE)
	{
	    bEnd = MIN(bWSLevel, 8);
		for (bi = 0; bi < bEnd; bi++)
		{
			bStep = (bWSAdjustGain >> 2);
			if (bStep > bWSAdjustOffset)
			{
				bStep -= bWSAdjustOffset;
				bWSAdjustOffset = 0;
			}
			else
			{
				bWSAdjustOffset -= bStep;
				bStep = 0;
			}

			assert(bi <= 29);
			waTargetCurve[29-bi] = waTargetCurve[30-bi] - bStep;
           
            if (ADL_LOG_CHECK(AL_DBG_BWS))
            {
                LOG(2, "WS[%d] =  %d  \n", (29-bi), waTargetCurve[29-bi]);
            }
		}
	}

	// Keep BWS Mid Point
	if (bBWSKeepMidOnOff)
	{
	    bi = MIN((2 + bBSLevel), (LUMA_CURVE_NUM-1));
		wBDiff = (wBWSKeepMidY - waTargetCurve[bi]) / (bBWSKeepMidX - bBSLevel);        
        bEnd = MIN((bBWSKeepMidX + 2), (LUMA_CURVE_NUM-1));//Fix klock warning
        
		for (bi = (bBSLevel + 3); bi < bEnd ; bi++)
		{
			waTargetCurve[bi] = waTargetCurve[bi - 1] + wBDiff;
		}
        if(bWSLevel > 30) //Fix klock warning
        {
            bWSLevel = 30;
        }
        bEnd = MIN((30 - bWSLevel), 30);//Fix klock warning
		wWDiff = (waTargetCurve[bEnd] - wBWSKeepMidY) / (28 - (bWSLevel + bBWSKeepMidX));
		
		for (bi = bBWSKeepMidX + 3; bi < bEnd; bi++)
		{
			waTargetCurve[bi] = waTargetCurve[bi - 1] + wWDiff;
		}
	}
	else
	{
        bi = MIN((2 + bBSLevel), (LUMA_CURVE_NUM-1));
        if(bWSLevel > 30) //Fix klock warning
        {
            bWSLevel = 30;
        }
        bEnd = MIN((30 - bWSLevel), 30);//Fix klock warning		  
        
        wDiff = ((waTargetCurve[bEnd] - waTargetCurve[bi]) + ((28 - (bWSLevel + bBSLevel)) / 2))
            / (28 - (bWSLevel + bBSLevel));

    	for (bi = (bBSLevel + 3); bi < bEnd; bi++)
    	{
    		waTargetCurve[bi] = waTargetCurve[bi - 1] + wDiff;
    	}
	}
}

// ---------------------------------------------------------------------------------
void vDrvADLBuildLumaCurve(const UINT16 waDynCurve[LUMA_CURVE_NUM],
                            const UINT16 waTargetCurve[LUMA_CURVE_NUM], 
                            UINT16 waTCurve[LUMA_CURVE_NUM],
                            UINT8 SceneChanged)
{
	UINT8 bi, bIndex;
    // previous luma curve : 10+4 bit to prevent quantization error 

    vDrvADLBuildDefault(waTCurve);

	for (bi = 3; bi < 30; bi++)
	{
		bIndex = waTargetCurve[bi] >> 5;
        bIndex = MIN(bIndex, (LUMA_CURVE_NUM-2));
        
		waTCurve[bi] = ((waDynCurve[bIndex + 1] * (waTargetCurve[bi] - (bIndex << 5))) +
		     (waDynCurve[bIndex] * (((bIndex + 1) << 5) - waTargetCurve[bi])) + 16) >> 5;
	}

    if (ADL_LOG_CHECK(AL_DBG_FINAL))
    {                
        LOG(2, "Dynamic   BWS    Final \n");
		for (bi = 0; bi < LUMA_CURVE_NUM; bi++)
		{
			LOG(2, "  %04d    %04d    %04d \n", waDynCurve[bi], waTargetCurve[bi], waTCurve[bi]);
		}        
    }
}

//Adaptive Luma Version 2 Algorithm
/* Get Black / White Level Percentage from Normalized Histogram */
void vDrvGetBlackWhitePercentage(const UINT16 * waHistCur, UINT8 bMode)
{
	UINT8 i;
	UINT32 dwBlackPixelCnt = 0;
	UINT32 dwWhitePixelCnt = 0;	
	UINT8 bLumaHistNum = (bMode) ? LUMA_HIST_NUM_WEIGHT : LUMA_HIST_NUM;
	
	for(i = 0; i < (bBSLevel + 2); i++)
	{
		dwBlackPixelCnt += waHistCur[i];
	}

	bBlackPercentage = (UINT8)CLIP((((dwBlackPixelCnt<<8) + (1<<(LUMA_HIST_NORM_BASE_BIT-1)))>>LUMA_HIST_NORM_BASE_BIT), 0, 255);

	for(i = 0; i < (bWSLevel + 2); i++)
	{
		dwWhitePixelCnt += waHistCur[bLumaHistNum - 1 - i];
	}

	bWhitePercentage = (UINT8)CLIP((((dwWhitePixelCnt<<8) + (1<<(LUMA_HIST_NORM_BASE_BIT-1)))>>LUMA_HIST_NORM_BASE_BIT), 0, 255);

    if (ADL_LOG_CHECK(AL_DBG_BP_WP))
    {
        LOG(2, "Black Percentage = %d, Black Pixel = %4d\n", bBlackPercentage, dwBlackPixelCnt);
        LOG(2, "White Percentage = %d, White Pixel = %4d\n", bWhitePercentage, dwWhitePixelCnt);		
    }	
	vIO32WriteFldAlign(ADAP_LUMA2_06, bBlackPercentage, ADL_BLACK_PERCENTAGE);	
	vIO32WriteFldAlign(ADAP_LUMA2_06, bWhitePercentage, ADL_WHITE_PERCENTAGE);		
}

void vDrvGetBlackWhiteIndex(const UINT16 * waHistCur, UINT8 bMode)
{
	UINT8 i;
	UINT32 dwBlackPxlIdx = 0;
	UINT32 dwWhitePxlIdx = 0;	
	UINT8 bLumaHistNum = (bMode) ? LUMA_HIST_NUM_WEIGHT : LUMA_HIST_NUM;
	UINT16 wBlackWeighting[16] = {24, 24, 24 ,24, 16, 12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
	UINT16 wWhiteWeighting[16] = {16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};

	for(i = 0; i < 16; i++)
	{
		dwBlackPxlIdx += waHistCur[i]*wBlackWeighting[i];
	}
	bBlackIndex = (UINT8)CLIP((((dwBlackPxlIdx<<8) + (LUMA_HIST_NORM_BASE*wBlackWeighting[0]>>1))/(LUMA_HIST_NORM_BASE*wBlackWeighting[0])), 0, 255);

	for(i = 0; i < 16; i++)
	{
		dwWhitePxlIdx += waHistCur[bLumaHistNum - 1 - i]*wWhiteWeighting[i];

	}
	bWhiteIndex = (UINT8)CLIP((((dwWhitePxlIdx<<8) + (LUMA_HIST_NORM_BASE*wWhiteWeighting[0]>>1))/(LUMA_HIST_NORM_BASE*wBlackWeighting[0])), 0, 255);

	if (ADL_LOG_CHECK(AL_DBG_BI_WI))
	{
		LOG(2, "Black Index = %d, Black Pixel Index= %4d\n", bBlackIndex, dwBlackPxlIdx);
		LOG(2, "White Index = %d, White Pixel Index= %4d\n", bWhiteIndex, dwWhitePxlIdx);		
	}	
	vIO32WriteFldAlign(ADAP_LUMA2_06, bBlackIndex, ADL_BLACK_INDEX);	
	vIO32WriteFldAlign(ADAP_LUMA2_06, bWhiteIndex, ADL_WHITE_INDEX);	

}

void vDrvGetBlackWhite2BinSum(const UINT16 * waHistCur, UINT8 bMode)
{
	UINT32 dwBlackPixelCnt = 0;
	UINT32 dwWhitePixelCnt = 0;
    UINT32 dwBlackPercentage = 0;
    UINT32 dwWhitePercentage = 0;
	UINT8 bLumaHistNum = (bMode) ? LUMA_HIST_NUM_WEIGHT : LUMA_HIST_NUM;

    INT32 i, j;
    INT32 iMax;
    INT32 iMaxIdx;
    INT32 iCm[3];

    iCm[0] = iCm[1] = iCm[2] = -1;
    
    for (j = 0; j < 3; j++)
    {
        iMax = -1;
        iMaxIdx = 0;
        for (i = 0; i < bLumaHistNum; i++)
        {
            if (waHistCur[i] > iMax)
            {
                // 0 is 1st largest bin
                // 1 is 2nd largest bin
                // 2 is 3rd largest bin
                if (i == iCm[0] || i == iCm[1])
                {
                    continue;
                }
                iMax = waHistCur[i];
                iMaxIdx = i;
            }
        }
        iCm[j] = iMaxIdx;
    }

    if (iCm[0] < iCm[1])
    {
        for (i = MAX((INT32)(iCm[0] - 1), 0); i <= MIN((INT32)(iCm[0] + 1), (INT32)bLumaHistNum-1); i++)
            dwBlackPixelCnt += waHistCur[i];

        for (i = MAX((INT32)(iCm[1] - 1), 0); i <= MIN((INT32)(iCm[1] + 1), (INT32)bLumaHistNum-1); i++)
            dwWhitePixelCnt += waHistCur[i];
    }
    else
    {
        for (i = MAX((INT32)(iCm[0] - 1), 0); i <= MIN((INT32)(iCm[0] + 1), (INT32)bLumaHistNum-1); i++)
            dwWhitePixelCnt += waHistCur[i];
        
        for (i = MAX((INT32)(iCm[1] - 1), 0); i <= MIN((INT32)(iCm[1] + 1), (INT32)bLumaHistNum-1); i++)
            dwBlackPixelCnt += waHistCur[i];
    }

    dwBlackPercentage = (UINT8)CLIP((((dwBlackPixelCnt<<8) + (1<<(LUMA_HIST_NORM_BASE_BIT-1)))>>LUMA_HIST_NORM_BASE_BIT), 0, 255);
    dwWhitePercentage = (UINT8)CLIP((((dwWhitePixelCnt<<8) + (1<<(LUMA_HIST_NORM_BASE_BIT-1)))>>LUMA_HIST_NORM_BASE_BIT), 0, 255);

    if (ADL_LOG_CHECK(AL_DBG_BI_WI))
    {
        LOG(2, "[0] => %d, %d, [1] => %d, %d, [2] => %d, %d\n", iCm[0], waHistCur[iCm[0]],
            iCm[1], waHistCur[iCm[1]], iCm[2], waHistCur[iCm[2]]);
        LOG(2, "White Cnt = %d, Black Cnt = %4d\n", dwWhitePixelCnt, dwBlackPixelCnt);       
    }
    
	vIO32WriteFldAlign(ADAP_LUMA2_08, dwBlackPercentage, ADL_BLACK_PERCENTAGE_2);	
	vIO32WriteFldAlign(ADAP_LUMA2_08, dwWhitePercentage, ADL_WHITE_PERCENTAGE_2);		    
}

void vDrvDynamicBSOffset(void)
{
	UINT8 bBSOffsetHigh, bBSOffsetLow, bBSOftThHigh, bBSOftThLow;
	UINT8 bThDiff = 0;
	bBSOffsetHigh = MAX(bBSOffsetH, bBSOffsetL);
	bBSOffsetLow = MIN(bBSOffsetH, bBSOffsetL);
	bBSOftThHigh = MAX(bBSOffsetThH, bBSOffsetThL);
	bBSOftThLow = MIN(bBSOffsetThH, bBSOffsetThL);

	bThDiff = bBSOftThHigh - bBSOftThLow;

	if(bBlackIndex <= bBSOftThLow)
	{
		bBSOffset = bBSOffsetHigh;
	}
	else if(bBlackIndex >= bBSOftThHigh)
	{
		bBSOffset = bBSOffsetLow;
	}
	else
	{
		bBSOffset = (UINT8)(((UINT32)bThDiff*bBSOffsetHigh - (UINT32)(bBlackIndex - bBSOftThLow)*(bBSOffsetHigh - bBSOffsetLow) + (bThDiff>>1)) / bThDiff);
	}

	if (ADL_LOG_CHECK(AL_DBG_DYN_OFFSET))
	{
		LOG(2, "BSOffsetHighTH= %d, BSOffsetLowTH= %d, BSOffsetHigh= %d, BSOffsetLow= %d, BSOffset= %d\n", 
			bBSOftThHigh, bBSOftThLow, bBSOffsetHigh, bBSOffsetLow, bBSOffset);
	}		
}

void vDrvDynamicWSOffset(void)
{
	UINT8 bWSOffsetHigh, bWSOffsetLow, bWSOftThHigh, bWSOftThLow;
	UINT8 bThDiff = 0;
	bWSOffsetHigh = MAX(bWSOffsetH, bWSOffsetL);
	bWSOffsetLow = MIN(bWSOffsetH, bWSOffsetL);
	bWSOftThHigh = MAX(bWSOffsetThH, bWSOffsetThL);
	bWSOftThLow = MIN(bWSOffsetThH, bWSOffsetThL);

	bThDiff = bWSOftThHigh - bWSOftThLow;

	if(bWhiteIndex <= bWSOftThLow)
	{
		bWSOffset = bWSOffsetHigh;
	}
	else if(bWhiteIndex >= bWSOftThHigh)
	{
		bWSOffset = bWSOffsetLow;
	}
	else
	{
		bWSOffset = (UINT8)(((UINT32)bThDiff*bWSOffsetHigh - (UINT32)(bWhiteIndex - bWSOftThLow)*(bWSOffsetHigh - bWSOffsetLow) + (bThDiff>>1)) / bThDiff);
	}

	if (ADL_LOG_CHECK(AL_DBG_DYN_OFFSET))
	{
		LOG(2, "WSOffsetHighTH= %d, WSOffsetLowTH= %d, WSOffsetHigh= %d, WSOffsetLow= %d, WSOffset= %d\n", 
			bWSOftThHigh, bWSOftThLow, bWSOffsetHigh, bWSOffsetLow, bWSOffset);

	}		
}

void vDrvIncPatProt(void)
{
	static UINT8 bIncPatCnt = 0;
	static UINT8 bIncPatSignPre = 0;
    static UINT32 u4PreAPL;    
	UINT8 bIncPatSign = 0;
	UINT32 u4APLDiff;
	UINT32 u4Div = 0;
    u4APLDiff = AbsDiff(u4PreAPL, u4LumaAPL);
	bIncPatSign = ((u4LumaAPL >= u4PreAPL) ? 1 : 0);

    bAPLCountCur = ((bAPLCountCur < bAPLCount) ? (bAPLCountCur+1) : 0); 
	
	if(bAPLCountCur == bAPLCount)
	{
		if((u4APLDiff != 0) && (u4APLDiff <= (UINT32)bAplDiffTh) && (bIncPatSign == bIncPatSignPre))
		{
			bIncPatCnt += 1;
	        if (ADL_LOG_CHECK2(AL_DBG_INC_PATTERN))
	        {
	            LOG(2, "Increase Pattern, Count = %d, APLCur = %4d, APLPre = %4d\n", bIncPatCnt, u4LumaAPL, u4PreAPL);
	        }			
		}
		else
		{
	        if (ADL_LOG_CHECK(AL_DBG_INC_PATTERN))
	        {
	            LOG(2, "IncPat Count Abort, APLCur = %4d, APLPre = %4d, Sign = %d\n", u4LumaAPL, u4PreAPL, bIncPatSign);
	        }					
			bIncPatCnt = 0;
		}
		
		u4PreAPL = u4LumaAPL;
		bIncPatSignPre = bIncPatSign;
		
		if(bIncPatCnt >= bIncPatCntTh)
		{
	        if (ADL_LOG_CHECK2(AL_DBG_INC_PATTERN))
	        {
	            LOG(2, "Original para , bMIDACGain = %d, bBSOffset = %d, bBSACGain = %d, bWSEqGain = %d, bWSACGain = %d\n", 
					bMIDACGain, bBSOffset, bBSACGain, bWSOffset, bWSACGain);
	        }				

			if(bIncPatCnt >= (bIncPatCntTh<<2))
			{
				bMIDACGain = (bMIDACGain + 2) >>2;
				bBSOffset = (bBSOffset + 2) >>2;
				bBSACGain = (bBSACGain + 2) >>2;			
				bWSOffset = (bWSOffset + 2) >>2;
				bWSACGain = (bWSACGain + 2) >>2;
			}
			else
			{
				u4Div = ((((UINT32)bIncPatCntTh*5 - bIncPatCnt)<<4) + (bIncPatCntTh >>1))/bIncPatCntTh;
				bMIDACGain = (UINT8)((u4Div * bMIDACGain + (1<<5)) >> 6);
				bBSOffset = (UINT8)((u4Div * bBSOffset + (1<<5)) >> 6);
				bBSACGain = (UINT8)((u4Div * bBSACGain + (1<<5)) >> 6);
				bWSOffset = (UINT8)((u4Div * bWSOffset + (1<<5)) >> 6);
				bWSACGain = (UINT8)((u4Div * bWSACGain + (1<<5)) >> 6);				
			}

			bALUpdateCount = 0;
			
	        if (ADL_LOG_CHECK2(AL_DBG_INC_PATTERN))
	        {
	            LOG(2, "Para update, bMIDACGain = %d, bBSOffset = %d, bBSACGain = %d, bWSOffset = %d, bWSACGain = %d\n", 
					bMIDACGain, bBSOffset, bBSACGain, bWSOffset, bWSACGain);
	        }				
		}
	}
}

/* Specific pattern detect and parameter update */
void vDrvDynamicADLPara(void)
{
	if(bIncPatProtEn == SV_TRUE)
	{
		vDrvIncPatProt();
	}
	vDrvDynamicBSOffset();
	vDrvDynamicWSOffset();
}

/*Histogram FIR, input: 33 or 32 bins, output 32 bins */
void HistFIR(const UINT16 waHistCur[LUMA_HIST_NUM_WEIGHT], UINT16 waLowPass[LUMA_HIST_NUM], UINT32 u4FIR[FIR_NUM], UINT8 bMode)
{
	static UINT32 u4Div;
	UINT32 Sum, FIRSum=0;	
	INT32 i, j, k, js, je;	

	if((bADLWeight2 == 0) && (bADLWeight3 == 0)) 
	{
        x_memcpy(waLowPass, waHistCur, sizeof(UINT16)*LUMA_HIST_NUM);
	}
    else
    {
    	if(bMode == SV_TRUE)	//Weighting mode, use FIR 8 and 33 bin
    	{
		if (bParamChange == SV_TRUE)
    		{		
    			for (i=0; i < FIR_NUM_WEIGHT; i++)	
    			{		
    				FIRSum += u4FIR[i]; 
    			}
    		
    			// Save computing power
    			u4Div = (0x10000+FIRSum/2)/FIRSum;
    		}
    		
    		for (i=0; i < LUMA_HIST_NUM; i++)
    		{
    			Sum=0;
    		
    			js = MAX(i-(FIR_NUM_WEIGHT/2-1), 0);
    			je = MIN(i+(FIR_NUM_WEIGHT/2), LUMA_HIST_NUM_WEIGHT-1);
    		
    			for (j=js; j<=je; j++)
    			{
    				k = CLIP((j-i+(FIR_NUM_WEIGHT/2-1)), 0, FIR_NUM_WEIGHT-1);
    				
    				Sum += waHistCur[j]*u4FIR[k];
    			}	
    		
    			waLowPass[i] = (Sum*u4Div+0x8000)>>16;
    		}	
    	}
    	else					//Truncate mode, use FIR 9 and 32 bin
    	{
		    if (bParamChange == SV_TRUE)
    		{		
    			for (i=0; i < FIR_NUM_TRUNCATE; i++)	
    			{		
    				FIRSum += u4FIR[i]; 
    			}
    		
    			// Save computing power
    			u4Div = (0x10000+FIRSum/2)/FIRSum;
    		}
    		
    		for (i=0; i < LUMA_HIST_NUM; i++)
    		{
    			Sum=0;
    		
    			js = MAX(i-(FIR_NUM_TRUNCATE/2), 0);
    			je = MIN(i+(FIR_NUM_TRUNCATE/2), LUMA_HIST_NUM_TRUNCATE-1);	//truncate mode only use 32 bin histogram
    		
    			for (j=js; j<=je; j++)
    			{
    				k = CLIP((j-i+(FIR_NUM_TRUNCATE/2)), 0, FIR_NUM_TRUNCATE-1);
    				
    				Sum += waHistCur[j]*u4FIR[k];
    			}	
    		
    			waLowPass[i] = (Sum*u4Div+0x8000)>>16;
    		}	
    	}
    }    
    if (ADL_LOG_CHECK(AL_DBG_HIST_LPF))
    {
        LOG(2, "FIR Sum = %d, Div = %d\n", FIRSum, u4Div);
        
        LOG(2, "Luma Histogram, Mode = %d\n", bMode);

		for (i=0; i < LUMA_HIST_NUM; i++)	
		{
	        LOG(2, "%d, ", waHistCur[i]);
		}

        LOG(2, "Luma Histogram after FIR, Mode = %d\n", bMode);

		for (i=0; i < LUMA_HIST_NUM; i++)	
		{
	        LOG(2, "%d, ", waLowPass[i]);
		}
        LOG(2, "\n");
    }	
}

void LowPassFilter(UINT32 u4FIR[FIR_NUM], UINT8 bMode)
{
    static UINT32 Weighting[3] = {0,0,0};
    UINT32 i, j; 
    UINT32 index, taps, w;
	static UINT8 bModeRec = 0;

	// Create FIR Low Pass only when parameter change
	if ((Weighting[0] == bADLWeight1) && (Weighting[1] == bADLWeight2) 
	    && (Weighting[2] == bADLWeight3) && (bModeRec == bMode))
	{
        bParamChange = SV_FALSE;
        return;
	}
	else
	{
        Weighting[0] = bADLWeight1;
        Weighting[1] = bADLWeight2;
        Weighting[2] = bADLWeight3;
        bModeRec = bMode;

		x_memset(u4FIR, 0, sizeof(UINT32)*FIR_NUM);

        bParamChange = SV_TRUE;
	}

	if(bMode == SV_TRUE)
	{
		// Taps 2/4/8
		for (i=0; i < 3; i++)
		{		
			taps = (1 << (i+1));		
			w = Weighting[i]/taps;
			
			for (j=0; j < taps; j++)		
			{
				index =  (FIR_NUM_WEIGHT/2) - (taps>>1) + j;			
				u4FIR[index] += w;		
			}
		}
	}
	else
	{
		// Taps 1/3/9
		u4FIR[(FIR_NUM-1)/2] = Weighting[0];
		for (i=1; i < 3; i++)
		{		
			taps = (1 << (2*i-1)) + 1;		
			w = Weighting[i]/taps;
			
			for (j=0; j < taps; j++)		
			{
				index =  ((FIR_NUM_TRUNCATE-1)/2) - (taps>>1) + j;			
				u4FIR[index] += w;		
			}
		}	
	}	

    if (ADL_LOG_CHECK2(AL_DBG_HIST_FIR))
    {
        LOG(2, "Luma Histogram FIR\n");
        LOG(2, "Weight1 = %d, Weight12 = %d, Weight3 = %d\n", Weighting[0], Weighting[1], Weighting[2]);

		for (j=0; j < FIR_NUM; j++)		
		{
	        LOG(2, "%d, ", u4FIR[j]);
		}
        LOG(2, "\n");
    }	
}

void LocalHistEqualized(const UINT16 waHist[LUMA_HIST_NUM_WEIGHT], UINT16 waLumaCurve[LUMA_CURVE_NUM])
{
	UINT16 u1Offset[LUMA_CURVE_NUM-1];
	UINT16 u1OffsetAcc[LUMA_CURVE_NUM-1];	
	UINT16 waLowPass[LUMA_CURVE_NUM-1];
	static UINT32 u4FIR[FIR_NUM];
	UINT16 wDiff;	
	UINT32 TotalSum = 0;
	UINT32 BSIndex, WSIndex, MIDIndex;
	UINT32 i;
	UINT32 u4MIDEqGain, u4MIDEqOffset;
	UINT32 u4BSGain, u4BSOffset, u4BSLevel, u4BSLimit, u4BSEqGain, u4BSEqOffset, u4BSBlending;
	UINT32 u4WSGain, u4WSOffset, u4WSLevel, u4WSLimit, u4WSEqGain, u4WSEqOffset, u4WSBlending;
	UINT32 u4BSAdjustOffset = 0;
	UINT32 u4WSAdjustOffset = 0;
	UINT32 u4BSStep1, u4BSStep2, u4WSStep1, u4WSStep2;	
    UINT32 u4Normization = 0;
	UINT8 bStrBSOft = 0;
	UINT8 bStrWSOft = 0;

	vDrvDynamicADLPara();

	u4MIDEqGain = bMIDACGain;
	u4MIDEqOffset = bMIDDCGain;

	u4BSGain = bBSDCGain;
	u4BSOffset = bBSOffset;
	u4BSLevel = bBSLevel+2;
	u4BSLimit = bBSRatio;
	u4BSEqGain = bBSACGain;
	u4BSEqOffset = bBSDCGain;
	bStrBSOft = bStrongBSOffset;

	u4WSGain = bWSDCGain;
	u4WSOffset = bWSOffset;
	u4WSLevel = bWSLevel+2;
	u4WSLimit = bWSRatio;
	u4WSEqGain = bWSACGain;
	u4WSEqOffset = bWSDCGain;	
	bStrWSOft = bStrongWSOffset;	

	if(bBSAdaptiveLmt == SV_TRUE)
	{
		u4BSBlending =CLIP( u4BSLimit*(0xFF-bBlackIndex)>>7, 0, 255);

	}
	else
	{
		u4BSBlending = u4BSLimit;	
	}
	if(bWSAdaptiveLmt == SV_TRUE)
	{
		u4WSBlending = CLIP(u4WSLimit*(0xFF-bWhiteIndex)>>7, 0, 255);

	}
	else
	{
		u4WSBlending = u4WSLimit;	
	}	
	if(ADL_LOG_CHECK(AL_DBG_DYN_LIMIT))
	{
 		  LOG(2, "Black Index = %d, Black Limit = %4d, Black Blending = %4d\n", bBlackIndex, u4BSLimit, u4BSBlending);
		  LOG(2, "White Index = %d, White Limit = %4d, White Blending = %4d\n", bWhiteIndex, u4WSLimit, u4WSBlending);
	}

	vDrvADLBuildDefault(waLumaCurve);
	if(bALOnOff == 0)
	{
		return;
	}
	x_memset(u1Offset, 0, sizeof(u1Offset));
	x_memset(u1OffsetAcc, 0, sizeof(u1OffsetAcc));	
	x_memset(waLowPass, 0, sizeof(waLowPass));
	
/* Apply Low Pass Filter */
	LowPassFilter(u4FIR, bHistogramMode);
	HistFIR(waHist, waLowPass, u4FIR, bHistogramMode);

	if(bStrBSOft != SV_TRUE)
	{
		u4BSAdjustOffset = (u4BSOffset*u4BSGain)>>7;
	}
	if(bStrWSOft != SV_TRUE)	
	{
		u4WSAdjustOffset = (u4WSOffset*u4WSGain)>>7;	//0x80 mean slope1, offset 0x20
	}
	
/* BS Region */
	if((u4BSLevel < LUMA_CURVE_NUM) && (bBSOnOff == 1))
	{
		for(BSIndex=3; BSIndex <= u4BSLevel; BSIndex++)
		{
			//build curve 1
			u4BSStep1 = u4BSGain>>2;	//0x80 mean slope1
			if(bStrBSOft != SV_TRUE)
			{
				if(u4BSStep1 > u4BSAdjustOffset)
				{
					u4BSStep1 -= u4BSAdjustOffset;
					u4BSAdjustOffset = 0;
				}
				else
				{
					u4BSAdjustOffset -= u4BSStep1;
					u4BSStep1 = 0;
				}
			}
			
			//build curve 2
			u4BSStep2 = CLIP(((u4BSEqOffset+((waLowPass[BSIndex-1]*u4BSEqGain)>>7))>>2), 0, 1023);

			//blending
			wDiff = AbsDiff(u4BSStep1, u4BSStep2);
			if(u4BSStep1 >= u4BSStep2)
			{
				u1Offset[BSIndex-1] = CLIP(u4BSStep2 + ((wDiff * u4BSBlending + (1<<7))>>8), 0, 255);
			}
			else
			{
				u1Offset[BSIndex-1] = CLIP(u4BSStep2 - ((wDiff * u4BSBlending + (1<<7))>>8), 0, 255);
			}
			
			if(bStrBSOft != SV_FALSE)
			{
				if(u4BSOffset >= 0x20)
				{
					u4BSOffset -= 0x20;
					u1Offset[BSIndex-1] = 0;
				}
				else
				{
					u4BSAdjustOffset = (u4BSOffset*u1Offset[BSIndex-1]+(1<<4))>>5;
					u1Offset[BSIndex-1] -= u4BSAdjustOffset;
					u4BSAdjustOffset = 0;
					u4BSOffset = 0;
				}
			}
		}
	}
/* WS Region */
	if((u4WSLevel < LUMA_CURVE_NUM) && (bWSOnOff == 1))
	{
		for(WSIndex=3; WSIndex <= u4WSLevel; WSIndex++)
		{
			//build curve 1
			u4WSStep1 = u4WSGain>>2;	//0x80 mean slope1
			if(bStrWSOft != SV_TRUE)
			{
				if(u4WSStep1 > u4WSAdjustOffset)
				{
					u4WSStep1 -= u4WSAdjustOffset;
					u4WSAdjustOffset = 0;
				}
				else
				{
					u4WSAdjustOffset -= u4WSStep1;
					u4WSStep1 = 0;
				}
			}
			
			//build curve 2
			u4WSStep2 = CLIP(((u4WSEqOffset+((waLowPass[LUMA_CURVE_NUM-1-WSIndex]*u4WSEqGain)>>7))>>2), 0, 1023);

			//blending
			wDiff = AbsDiff(u4WSStep1, u4WSStep2);
			if(u4WSStep1 >= u4WSStep2)
			{
				u1Offset[LUMA_CURVE_NUM-1-WSIndex] = CLIP(u4WSStep2 + ((wDiff * u4WSBlending + (1<<7))>>8), 0, 255);
			}
			else
			{
				u1Offset[LUMA_CURVE_NUM-1-WSIndex] = CLIP(u4WSStep2 - ((wDiff * u4WSBlending + (1<<7))>>8), 0, 255);
			}
			if(bStrWSOft != SV_FALSE)
			{
				if(u4WSOffset >= 0x20)
				{
					u4WSOffset -= 0x20;
					u1Offset[LUMA_CURVE_NUM-1-WSIndex] = 0;
				}
				else
				{
					u4WSAdjustOffset = (u4WSOffset*u1Offset[LUMA_CURVE_NUM-1-WSIndex]+(1<<4))>>5;
					u1Offset[LUMA_CURVE_NUM-1-WSIndex] -= u4WSAdjustOffset;
					u4WSAdjustOffset = 0;
					u4WSOffset = 0;
				}
			}			
		}
	}

	u4BSLevel = (u4BSLevel >= 2) ? u4BSLevel : 2;
	u4WSLevel = (u4WSLevel >= 2) ? (LUMA_CURVE_NUM - 1 - u4WSLevel) : 30;


/* MID Region */
	for(MIDIndex = u4BSLevel + 1; MIDIndex <= u4WSLevel ; MIDIndex++)
	{
		u1Offset[MIDIndex-1] = CLIP(((u4MIDEqOffset+((waLowPass[MIDIndex-1]*u4MIDEqGain)>>7))>>2), 0, 255);
	}

/* Offset Normalization */
	for(i = 2; i < LUMA_CURVE_NUM - 3; i++)
	{
		TotalSum += u1Offset[i];
		u1OffsetAcc[i] = TotalSum;
	}
	if(TotalSum == 0)
	{
		return;
	}

	if (ADL_LOG_CHECK(AL_DBG_EQUALIZATION))
	{
		LOG(2, "Luma curve equalization, TotalSum = %d\n", TotalSum);
		for (i=0; i < (LUMA_CURVE_NUM-1); i++)	
		{
			LOG(2, "%d, ", u1Offset[i]);
		}
		LOG(2, "\n");		
	}	
	u4Normization = ((896<<10)+(TotalSum>>1))/TotalSum;
	if (ADL_LOG_CHECK(AL_DBG_EQUALIZATION))
	{
		LOG(2, "Luma curve equalization accumulate\n");
		for (i=0; i < (LUMA_CURVE_NUM-1); i++)	
		{
			LOG(2, "%d, ", u1OffsetAcc[i]);
		}
		LOG(2, "\n");		
	}	

/* Luma Curve Accumulate */
	waLumaCurve[0] = 0; 	
	waLumaCurve[1] = 32; 	
	waLumaCurve[2] = 64;
	waLumaCurve[30]= 960;	
	waLumaCurve[31]= 992;	
	waLumaCurve[32]= 1023;

	for(i = 2; i < LUMA_CURVE_NUM - 3; i++)
	{
		u1OffsetAcc[i] = ((u1OffsetAcc[i]*u4Normization)>>10);
	}

	for(i = 3; i < LUMA_CURVE_NUM - 3; i++)
	{
		waLumaCurve[i] = MIN((UINT16)(waLumaCurve[2] + u1OffsetAcc[i-1]), 940);
	}

	if (ADL_LOG_CHECK(AL_DBG_LUMA_CURVE1))
	{
		LOG(2, "Luma curve accumulate normalized:, Normalization = %d \n", u4Normization);
		for (i=0; i < (LUMA_CURVE_NUM-1); i++)	
		{
			LOG(2, "%d, ", u1OffsetAcc[i]);
		}
		LOG(2, "\n");
	}	

	if (ADL_LOG_CHECK(AL_DBG_LUMA_CURVE1))
	{
		LOG(2, "Luma curve 1:\n");
		for (i=0; i < LUMA_CURVE_NUM; i++)	
		{
			LOG(2, "%d, ", waLumaCurve[i]);
		}
		LOG(2, "\n");
	}		
}

void vDrvADLLumaCurveLowPass(const UINT16 waCurCurve[LUMA_CURVE_NUM], UINT16 waLumaCurve[LUMA_CURVE_NUM])
{	
	UINT8 bi;
    // previous luma curve : 10+4 bit to prevent quantization error 	
    static UINT16 waTCurvePre[LUMA_CURVE_NUM];
    static UINT16 waTCurvePre2[LUMA_CURVE_NUM];    //Store previous 2 frame curve for 3D FS content: R frame

    if(bIsSrcLRflg || bAdl3DEnable)  //FS content
    {
        if(u43DGetOutputLR() == 0)
        {
            if (bADLSceneChange != SV_TRUE)
            {
                for (bi = 3; bi < LUMA_CURVE_NUM-3; bi++)
                {
        		    if(bIIRStrength == 1)
        		    {
                        waTCurvePre[bi] = (((UINT32)waTCurvePre[bi] * 31 + 16) >> 5) + waCurCurve[bi];
                        waLumaCurve[bi] = (waTCurvePre[bi] + 16) >> 5;                        

        		    }
        		    else if(bIIRStrength == 2)
        		    {
                        waTCurvePre[bi] = (((UINT32)waTCurvePre[bi] * 7 + 4) >> 3) + waCurCurve[bi];
                        waLumaCurve[bi] = (waTCurvePre[bi] + 4) >> 3;
        		    }                    
        		    else if(bIIRStrength == 3)
        		    {
                        waTCurvePre[bi] = (((UINT32)waTCurvePre[bi] * 63 + 32) >> 6) + waCurCurve[bi];
                        waLumaCurve[bi] = (waTCurvePre[bi] + 32) >> 6;
        		    }                       
        		    else
        		    {
                        waTCurvePre[bi] = (((UINT32)waTCurvePre[bi] * 15 + 8) >> 4) + waCurCurve[bi];
                        waLumaCurve[bi] = (waTCurvePre[bi] + 8) >> 4;
                    }
                }
            }
            else
            {
                x_memcpy(waLumaCurve, waCurCurve, sizeof(UINT16)*LUMA_CURVE_NUM);    
                for (bi = 3; bi < LUMA_CURVE_NUM-3; bi++)
                {
                    if(bIIRStrength == 1)
                    {
                        waTCurvePre[bi] = waLumaCurve[bi] << 5;
                    }
                    else if(bIIRStrength == 2)
                    {
                        waTCurvePre[bi] = waLumaCurve[bi] << 3;
                    }
                    else if(bIIRStrength == 3)
                    {
                        waTCurvePre[bi] = waLumaCurve[bi] << 6;
                    }                    
                    else
                    {
                        waTCurvePre[bi] = waLumaCurve[bi] << 4;
                    }
                }
            }
        }
        else
        {
            if (bADLSceneChange != SV_TRUE)
            {
                for (bi = 3; bi < LUMA_CURVE_NUM-3; bi++)
                {
                    if(bIIRStrength == 1)
                    {
                        waTCurvePre2[bi] = (((UINT32)waTCurvePre2[bi] * 31 + 16) >> 5) + waCurCurve[bi];
                        waLumaCurve[bi] = (waTCurvePre2[bi] + 16) >> 5;                        
                    }
                    else if(bIIRStrength == 2)
                    {
                        waTCurvePre2[bi] = (((UINT32)waTCurvePre2[bi] * 7 + 4) >> 3) + waCurCurve[bi];
                        waLumaCurve[bi] = (waTCurvePre2[bi] + 4) >> 3;
                    }  
                    else if(bIIRStrength == 3)
                    {
                        waTCurvePre2[bi] = (((UINT32)waTCurvePre2[bi] * 63 + 32) >> 6) + waCurCurve[bi];
                        waLumaCurve[bi] = (waTCurvePre2[bi] + 32) >> 6;
                    }                      
                    else
                    {
                        waTCurvePre2[bi] = (((UINT32)waTCurvePre2[bi] * 15 + 8) >> 4) + waCurCurve[bi];
                        waLumaCurve[bi] = (waTCurvePre2[bi] + 8) >> 4;
                    }
                }
            }
            else
            {
                x_memcpy(waLumaCurve, waCurCurve, sizeof(UINT16)*LUMA_CURVE_NUM);    
                for (bi = 3; bi < LUMA_CURVE_NUM-3; bi++)
                {
                    if(bIIRStrength == 1)
                    {
                        waTCurvePre2[bi] = waLumaCurve[bi] << 5;
                    }
                    else if(bIIRStrength == 2)
                    {
                        waTCurvePre2[bi] = waLumaCurve[bi] << 3;
                    }
                    else if(bIIRStrength == 3)
                    {
                        waTCurvePre2[bi] = waLumaCurve[bi] << 6;
                    }                    
                    else
                    {
                        waTCurvePre2[bi] = waLumaCurve[bi] << 4;
                    }
                }
            }
        }
    }
    else
    {
    	if (bADLSceneChange != SV_TRUE)
    	{
    		for (bi = 3; bi < LUMA_CURVE_NUM-3; bi++)
    		{
                if(bIIRStrength == 1)
                {
                    waTCurvePre[bi] = (((UINT32)waTCurvePre[bi] * 31 + 16) >> 5) + waCurCurve[bi];
                    waLumaCurve[bi] = (waTCurvePre[bi] + 16) >> 5;                        
                }
                else if(bIIRStrength == 2)
                {
                    waTCurvePre[bi] = (((UINT32)waTCurvePre[bi] * 7 + 4) >> 3) + waCurCurve[bi];
                    waLumaCurve[bi] = (waTCurvePre[bi] + 4) >> 3;
                }  
                else if(bIIRStrength == 3)
                {
                    waTCurvePre[bi] = (((UINT32)waTCurvePre[bi] * 63 + 32) >> 6) + waCurCurve[bi];
                    waLumaCurve[bi] = (waTCurvePre[bi] + 32) >> 6;
                }                  
                else
                {
        			waTCurvePre[bi] = (((UINT32)waTCurvePre[bi] * 15 + 8) >> 4) + waCurCurve[bi];
                    waLumaCurve[bi] = (waTCurvePre[bi] + 8) >> 4;
    		    }
    	    }
    	}
        else
        {
    		x_memcpy(waLumaCurve, waCurCurve, sizeof(UINT16)*LUMA_CURVE_NUM);    
            for (bi = 3; bi < LUMA_CURVE_NUM-3; bi++)
    		{
                if(bIIRStrength == 1)
                {
                    waTCurvePre[bi] = waLumaCurve[bi] << 5;
                }
                else if(bIIRStrength == 2)
                {
                    waTCurvePre[bi] = waLumaCurve[bi] << 3;
                }
                else if(bIIRStrength == 3)
                {
                    waTCurvePre[bi] = waLumaCurve[bi] << 6;
                }                
                else
                {
    			    waTCurvePre[bi] = waLumaCurve[bi] << 4;
        		}
        	}
        }
    }

	waLumaCurve[0] = 0; 	
	waLumaCurve[1] = 32; 	
	waLumaCurve[2] = 64;
	waLumaCurve[30]= 960;	
	waLumaCurve[31]= 992;	
	waLumaCurve[32]= 1023;
    
	if (ADL_LOG_CHECK(AL_DBG_LUMA_CURVE3))
	{
		LOG(2, "Luma curve low pass:\n");
	
		for (bi=0; bi < LUMA_CURVE_NUM; bi++)	
		{
			LOG(2, "%d, ", waLumaCurve[bi]);
		}
		LOG(2, "\n");
	}
}

void vDrvADLCGPatProt(UINT16 waLumaCurve[LUMA_CURVE_NUM])
{
    UINT8 bi;
    UINT8 bCGBlending = 0;
    UINT16 u2MaxHueHist = 0;
    UINT16 waLumaDft[LUMA_CURVE_NUM];
    UINT16 wDiff;
    UINT16 u2HueHist[HUE_HIST_NUM];
    UINT32 u4HuePxlCnt = 0;
    
    vDrvADLBuildDefault(waLumaDft);
    u1DrvGetHueHist(u2HueHist, &u4HuePxlCnt, HUE_HIST_NORM_BASE);    
    
    for(bi = 0; bi < HUE_HIST_NUM; bi++)
    {
        u2MaxHueHist = (u2HueHist[bi] > u2MaxHueHist)? u2HueHist[bi] : u2MaxHueHist;   
    }

    if (ADL_LOG_CHECK(AL_DBG_CG_PROT))
    {
   		LOG(2, "Hue Hist:\n");
		for (bi=0; bi < HUE_HIST_NUM; bi++)	
		{
			LOG(2, "%d, ", u2HueHist[bi]);
		}
		LOG(2, "\n");
        LOG(2, "Max Hue = %d \n", u2MaxHueHist);
        LOG(2, "HuePxlCnt (@NormBase 512) = %d \n", u4HuePxlCnt);        
    }


    if((u2MaxHueHist == 0) || (u4HuePxlCnt < (UINT32)(HUE_HIST_NORM_BASE>>1)))
    {
        return;
    }

    if(u2MaxHueHist > ((HUE_HIST_NORM_BASE*bCGProtTh)>>8))
    {
        bCGBlending = CLIP((UINT8)(u2MaxHueHist - ((HUE_HIST_NORM_BASE*bCGProtTh)>>8))*bCGProtGain, 0, 255);    //blending from 80%
    }
    
    for (bi = 3; bi < 30; bi++)
    {
        wDiff = AbsDiff(waLumaDft[bi],waLumaCurve[bi]);
        if(waLumaDft[bi] >=waLumaCurve[bi])
        {
            waLumaCurve[bi] = waLumaCurve[bi] + ((wDiff * bCGBlending + (1<<7))>>8);
        }
        else
        {
            waLumaCurve[bi] = waLumaCurve[bi] - ((wDiff * bCGBlending + (1<<7))>>8);
        }
    }

    waLumaCurve[0] = 0;
    waLumaCurve[1] = 32;
    waLumaCurve[2] = 64;
    waLumaCurve[30] = 960;
    waLumaCurve[31] = 992;
    waLumaCurve[32] = 1023;

    if (ADL_LOG_CHECK(AL_DBG_CG_PROT))
    {
        LOG(2, "CG Blending Ratio = %d \n", bCGBlending);

		LOG(2, "CG Protect Luma curve:\n");
		for (bi=0; bi < LUMA_CURVE_NUM; bi++)	
		{
			LOG(2, "%d, ", waLumaCurve[bi]);
		}
		LOG(2, "\n");        
    }    
}

void vDrvADLLumaCurve3D(UINT16 waLumaCurve[LUMA_CURVE_NUM])
{
    UINT8 bi;

    if(bIsSrcLRflg || bAdl3DEnable)  //FS content
    {
        x_memcpy(waLumaArrayLR[((u43DGetOutputLR() == 0) ? 0: 1)], waLumaCurve, LUMA_CURVE_NUM*sizeof(UINT16));
        x_memcpy(waLumaCurve, waLumaArrayLR[((u43DGetOutputLR() == 0) ? 1: 0)], LUMA_CURVE_NUM*sizeof(UINT16));        
        
        if (ADL_LOG_CHECK(AL_3D_LUMA))
        {
            LOG(2, "Current LR frame = %d \n", u43DGetOutputLR());

            LOG(2, "LumaArray L = \n");
    		for(bi=0; bi < (LUMA_CURVE_NUM-1); bi++)	
    		{
                LOG(2, "%d, ", waLumaArrayLR[0][bi]);

    		}
    		LOG(2, "\n");            
            LOG(2, "LumaArray R = \n");            
            for(bi=0; bi < (LUMA_CURVE_NUM-1); bi++)	
    		{
    			LOG(2, "%d, ", waLumaArrayLR[1][bi]);                
    		}
    		LOG(2, "\n");
        }   
    }
}

// ---------------------------------------------------------------------------------
//	Main Loop
// ---------------------------------------------------------------------------------
void vDrvADLProc_int(const UINT16 waHist[LUMA_HIST_NUM_WEIGHT], UINT32 u4APL)
{
	UINT16 waCurCurve[LUMA_CURVE_NUM];	
    UINT16 waHist32[LUMA_HIST_NUM];

    vDrvADLGetAdaptiveLumaParam();	  

    u4LumaAPL = u4APL;
    u4LumaAPLFullRange = (u4APL < 0x10) ? 0 : (MIN((u4APL-0x10)*0x12A/0x100, 0xFF));

	bADLSceneChange = bDrvADLDetectSceneChanged(waHist);

    if(bAdlVersion == SV_OFF)
    {
        // Adaptive Luma Version 1 Algorithm
        x_memcpy(waHist32, waHist, LUMA_HIST_NUM*sizeof(UINT16)); //version 1 only use 32 bin
        vDrvADLBuildDynCurve(waHist32, waDynCurve);
        vDrvADLBuildTargetCurve(waHist32, waTargetCurve);
        vDrvADLBuildLumaCurve(waDynCurve, waTargetCurve, waCurCurve, bADLSceneChange);
    }
    else
    {
        // Adaptive Luma Version 2 Algorithm
        UNUSED(vDrvGetBlackWhitePercentage(waHist, bHistogramMode));
        vDrvGetBlackWhiteIndex(waHist, bHistogramMode);
        
        LocalHistEqualized(waHist, waCurCurve);

        if(bCGProtEn == SV_ON)
        {
            vDrvADLCGPatProt(waCurCurve);
        }
    }

    vDrvGetBlackWhite2BinSum(waHist, bHistogramMode);

	vDrvApplyYGamma(waCurCurve);
	vDrvApplyUserCurve(waCurCurve, bYGammaMID);
    vDrvApplyAdapYGamma(waCurCurve);
	// Apply 2 tap IIR filter to Luma Curve
	vDrvADLLumaCurveLowPass(waCurCurve, waLumaArray);
    vDrvADLLumaCurve3D(waLumaArray);
    
	if(bSkinLumaOnOff)
	{
		vBuildSecondLumaCurve(waLumaArray, waSecondLumaArray);
	}	
}

#endif //CC_MTK_LOADER
