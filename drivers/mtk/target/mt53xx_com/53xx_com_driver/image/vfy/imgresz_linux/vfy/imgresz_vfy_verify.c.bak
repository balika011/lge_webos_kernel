/********************************************************************************************
 *     LEGAL DISCLAIMER
 *
 *     (Header of MediaTek Software/Firmware Release or Documentation)
 *
 *     BY OPENING OR USING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
 *     THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE") RECEIVED
 *     FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON AN "AS-IS" BASIS
 *     ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES, EXPRESS OR IMPLIED,
 *     INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR
 *     A PARTICULAR PURPOSE OR NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY
 *     WHATSOEVER WITH RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
 *     INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK
 *     ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
 *     NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S SPECIFICATION
 *     OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
 *
 *     BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE LIABILITY WITH
 *     RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION,
 *     TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE
 *     FEES OR SERVICE CHARGE PAID BY BUYER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
 *
 *     THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE WITH THE LAWS
 *     OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF LAWS PRINCIPLES.
 ************************************************************************************************/

#if 0
#include "x_typedef.h"
#include "x_rtos.h"
#include "x_stl_lib.h"
#include "x_bim.h"
#include "x_mem_phase2.h"
//#include "drv_img_dec.h"   ////
#include "x_drv_map.h"
#include "x_assert.h"
#include "imgresz_hal_if.h"
#include "imgresz_hal.h"
#include "rvd_util.h"
#include "x_ckgen.h"
#include "x_printf.h"
#include "x_debug.h"
#include <stdio.h>
#include "x_hal_1176.h"
#include "x_timer.h"
#include "x_drv_cli.h"
#if CONFIG_DRV_LINUX
#include "x_os.h"
#else
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#endif

#else
#include "x_rand.h"
#include "x_bim_8580.h"
#include "x_drv_map.h"
#include "imgresz_hal_if.h"
#include "imgresz_hal.h"
#include <asm/system.h>
#include <asm/system.h>

#include "x_assert.h"
#include "drv_config.h"

//#include "x_hal_8520.h"
#include "x_hal_5381.h"
#include "x_typedef.h"
//#include "x_rtos.h"
#include "x_stl_lib.h"
#include "x_bim.h"
//#include "file_io.h"
//#include <stdio.h>
#if CONFIG_DRV_LINUX
#include "x_os.h"
#include <linux/string.h>
#include <linux/kernel.h>

#else
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#endif
#include "x_assert.h"
//#include "rvd_util.h"
#include "x_printf.h"
//#include "x_hal_1176.h"
//#include "jdec_drv.h"
#include "x_ckgen.h"
//#include "chip_ver.h"
#include "x_debug.h"
#include "x_drv_cli.h"
#if PERFORMANCE_TEST
#include "x_timer.h"
#endif
//#include "drv_img_dec.h"
#include "x_common.h"

#endif


//#include "sys_config.h"
#if CONFIG_SYS_MEM_PHASE2
#include "x_mem_phase2.h"
#elif CONFIG_SYS_MEM_PHASE3
#include "x_kmem.h"
#endif
#if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8560) //chunze
#include "x_iommu.h"
#endif


#define CONFIG_FATS_SUPPORT 0






#if CONFIG_FATS_SUPPORT
#include "UDVT_IF.h"
#if 0
UINT32  UDVT_IF_OpenFile(char* file,char* mode)
{
   return 0;
}

UINT32 UDVT_IF_WriteFile(void *u4FileBufSa,UINT32 n,UINT32 u4BufSize,UINT32 fp)
{
  return 0;
}

INT32  UDVT_IF_CloseFile(UINT32 fp)
{
  return 0 ;
}

UINT32 UDVT_IF_ReadFile(void *u4FileBufSa,UINT32 n,UINT32 u4BufSize,UINT32 fp)
{
  return 0;
}
#endif
#endif



//extern int rand(void);
//extern void srand(int seed);
//extern void x_memset(void *pv_to, UINT8 ui1_c, SIZE_T z_l);

IMGRESZ_HAL_IMG_INFO_T rBlBufnfo;
#if CONFIG_DRV_LINUX
extern long simple_strtol(const char *,char **,unsigned int);
#define strstr  x_strstr
#define strcpy  x_strcpy
#define strlen  x_strlen
#define strncpy x_strncpy
#define strcat  x_strcat
#define sprintf x_sprintf
#define strcmp  x_strcmp
#define strtol  simple_strtol

//UINT32 strtol(char *pcStr,char **stopstr,UINT32 base)
//{
//  return 0;
//}


#if 1
void x_memsett(void *pv_to, UINT8 ui1_c, SIZE_T z_l)
{
    UINT32 u4I = 0;

    for(u4I=0; u4I<z_l; u4I++)
        *(((BYTE *)pv_to) + u4I) = (BYTE)ui1_c;
}

#endif
#define memset  x_memsett

#endif



#define imgreszvfy_alloc_mem_aligned      x_alloc_aligned_dma_mem
#define imgreszvfy_free_mem_aligned       x_free_aligned_dma_mem


//modify by chunze.zhao 2010.11.17
#define imgreszvfy_src_alloc_mem_aligned imgreszvfy_alloc_mem_aligned
#define imgreszvfy_dst_alloc_mem_aligned imgreszvfy_alloc_mem_aligned
#define imgreszvfy_src_free_mem_aligned  imgreszvfy_free_mem_aligned
#define imgreszvfy_dst_free_mem_aligned  imgreszvfy_free_mem_aligned



#define DMXCMD_READ32(offset)			IO_READ32(DEMUX0_BASE, ((offset) * 4))


BOOL _fgOpenAddressSwap = FALSE;
BOOL _fgLumakeyTest = FALSE;
BOOL _fg4to1Test = FALSE;

#define IMG_RESZ_VFY_FILE_IO_SEMI_HOSTING 0
#define IMG_RESZ_VFY_FILE_IO_RVD_UTILITY  1
#define IMG_RESZ_VFY_FILE_IO_UDVT_USBRW   2
#define IMG_RESZ_VFY_FILE_IO_HDD_USBRW    3

#if CONFIG_FATS_SUPPORT
#define IMG_RESZ_VFY_FILE_IO_TYPE IMG_RESZ_VFY_FILE_IO_UDVT_USBRW //IMG_RESZ_VFY_FILE_IO_SEMI_HOSTING
#else
#define IMG_RESZ_VFY_FILE_IO_TYPE  IMG_RESZ_VFY_FILE_IO_HDD_USBRW//IMG_RESZ_VFY_FILE_IO_SEMI_HOSTING
#endif

#if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
#include "../../../../../../mt5880/diag/UDVT_IF.h"

#endif
//#define IMG_RESZ_8_LEVEL_ALPHA_BLENDING_TEST

#ifdef IMG_RESZ_8_LEVEL_ALPHA_BLENDING_TEST
UINT32 _u4PreloadBufSA1 = 0;
UINT32 _u4PreloadBufSA2 = 0;

extern INT32 i4HwImgReszSetAlphaBlendingLevel(UINT32 u4HwId,UINT32 u4Alpha);
extern INT32 i4HwImgReszSetAlphaBlendingPreloadBufAddr(UINT32 u4HwId,UINT32 u4BufSA1,UINT32 u4BufSA2);
#endif
extern INLINE UINT32 u4HwImgReszRead32(UINT32 u4HwId,UINT32 addr);

UINT32 u4SwapMode;
UINT32 _u4ImgReszAlphaLevel = 0;
#define CRC_Compare
UINT32 u4ImgReszCheckSum = 0;
UINT32 u4ImgReszCheckSumGolden = 0;

UINT32 _u4ImgReszVfyTimeOut = 0;

BOOL _fgImgReszVfyBimAddrSwap = TRUE;

#define IMG_RESZ_VFY_HW_NUM 2
BOOL _afgImgReszVfyHwEnable[IMG_RESZ_VFY_HW_NUM] = {TRUE, FALSE};

UINT32 _u4LumaKeyScalingType = 0;
BOOL   _fgBilinearBoundary = FALSE;
BOOL   _fgYUVMode = FALSE;
BOOL _fgScalingchange = FALSE;
UINT32 _u4AlphaScalingType;
BOOL   _fgOnlyDistinquishAlpha;
BOOL _fgAlphaB = FALSE;

UINT32 _u4ImgReszFileListMax = 64;



#define IMGRESZ_DRAMBUSY_TEST     0


#if IMGRESZ_PERFORMANCE_TEST
HAL_TIME_T _rImgreszStart = {0};
HAL_TIME_T _rImgreszEnd = {0};
//HAL_TIME_T _rTest = {0};
HAL_TIME_T _rImgreszTime = {0};
extern void HAL_GetTime(HAL_TIME_T* pTime);
extern void HAL_GetDeltaTime(HAL_TIME_T * pResult, HAL_TIME_T * pOlder, HAL_TIME_T * pNewer);
#endif

#if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8560) //chunze, test resume break
    #define IMGRESZ_RESUME_BREAK   0
#else
    #define IMGRESZ_RESUME_BREAK   0
#endif

///////////////////////////////////////////////////
//add by chunze
UINT32 _u4MaxImg8192HVMode = 0; //0: normal, 1: 8192*100, 2: 100*8192

#if IMGRESZ_IO_MMU_TEST
//extern void vIIOMMU_Init(void);
//extern void *IOMMU_get_fragment_vmem(UINT32 u4Size); 

//extern void* x_alloc_vmem(UINT32 u4Size);
#define  GGT_get_vmem   x_alloc_vmem
//#define  IOMMU_get_fragment_vmem  x_alloc_vmem
//#define  GGT_get_vmem   IOMMU_get_fragment_vmem

extern void  vIOMMU_OverRead_Protection(UINT32 ui4_Agent,
                                        UINT32 ui4_Mode,
	                                                                       UINT32 ui4_StartAddr0,
	                                                                       UINT32 ui4_Buff_sz0,
	                                                                       UINT32 ui4_StartAddr1,
	                                                                       UINT32 ui4_Buff_sz1);
#endif


#if (IMG_RESZ_VFY_FILE_IO_TYPE == IMG_RESZ_VFY_FILE_IO_HDD_USBRW)
#define IMGRZ_LOAD_FILE_LIST_FUNCTION i4ImgReszVfyLoadFileList("/mnt/usb/IMG_RESZ/imgreszlist.txt",u4FileListSA,u4FileListBufSize,ppbFileList,&u4FileListNum);
#else
#define IMGRZ_LOAD_FILE_LIST_FUNCTION i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,ppbFileList,&u4FileListNum);

#endif






#if(IMG_RESZ_VFY_FILE_IO_TYPE == IMG_RESZ_VFY_FILE_IO_SEMI_HOSTING)
INT32 i4ImgReszVfyReadFile(char *pcFileName,UINT32 u4FileBufSa,UINT32 u4BufSize)
{
    FILE *fp;
    INT32 i4RealReadSize;

    if((fp = fopen(pcFileName,"rb")) != 0)
    {
        i4RealReadSize = fread((void *)u4FileBufSa,sizeof(char),u4BufSize,fp);

        fclose(fp);
    } else
    {
        i4RealReadSize = -1;
    }

    return i4RealReadSize;
}

INT32 i4ImgReszVfyWriteFile(char *pcFileName,UINT32 u4FileBufSa,UINT32 u4BufSize)
{
    FILE *fp;
    INT32 i4RealReadSize;

    if((fp = fopen(pcFileName,"wb")) != 0)
    {
        i4RealReadSize = fwrite((void *)u4FileBufSa,sizeof(char),u4BufSize,fp);

        fclose(fp);
    } else
    {
        i4RealReadSize = -1;
    }

    return i4RealReadSize;
}


INT32 i4ImgReszVfyFopen(char *pcFileName,char *pcMode)
{
    FILE *fp;
    fp = fopen(pcFileName,pcMode);

    return (INT32)fp;
}


char _abImgReszPrintMsg[256];
INT32 i4ImgReszVfyFprintf(INT32 i4FileHandle,const char *format, ...)
{
#if 0
    va_list ap;

    // Parameter setting
    va_start(ap, format);
    vsprintf(_abImgReszPrintMsg, format, ap);
    va_end(ap);

    return fprintf((FILE *)i4FileHandle,_abImgReszPrintMsg,"");
#else
    sprintf(_abImgReszPrintMsg,format);
    fwrite((void *)_abImgReszPrintMsg,sizeof(char),strlen(_abImgReszPrintMsg),(FILE *)i4FileHandle);

    return 0;
#endif
}


INT32 i4ImgReszVfyFclose(INT32 i4FileHandle)
{
    return fclose((FILE *)i4FileHandle);
}


#define i4ImgReszVfyPrintf UTIL_Printf

#elif(IMG_RESZ_VFY_FILE_IO_TYPE == IMG_RESZ_VFY_FILE_IO_RVD_UTILITY)
#define i4ImgReszVfyReadFile i4RvdReadFile
#define i4ImgReszVfyWriteFile i4RvdWriteFile
#define i4ImgReszVfyFopen i4RvdFopen
#define i4ImgReszVfyFprintf i4RvdFprintf
#define i4ImgReszVfyFclose i4RvdFclose
#define i4ImgReszVfyPrintf UTIL_Printf

#elif(IMG_RESZ_VFY_FILE_IO_TYPE == IMG_RESZ_VFY_FILE_IO_UDVT_USBRW)


INT32 i4ImgReszVfyReadFile(char *pcFileName,UINT32 u4FileBufSa,UINT32 u4BufSize)
{
    UINT32 fp;
    INT32 i4RealReadSize;

    if((fp = UDVT_IF_OpenFile(pcFileName,"rb")) != 0)
    {
        i4RealReadSize = UDVT_IF_ReadFile((void *)u4FileBufSa,sizeof(char),u4BufSize,fp);

        UDVT_IF_CloseFile(fp);
    } else
    {
        i4RealReadSize = -1;
    }

    return i4RealReadSize;
}

INT32 i4ImgReszVfyWriteFile(char *pcFileName,UINT32 u4FileBufSa,UINT32 u4BufSize)
{
    UINT32 fp;
    INT32 i4RealReadSize;

    if((fp = UDVT_IF_OpenFile(pcFileName,"wb")) != 0)
    {
        i4RealReadSize = UDVT_IF_WriteFile((void *)u4FileBufSa,sizeof(char),u4BufSize,fp);

        UDVT_IF_CloseFile(fp);
    } else
    {
        i4RealReadSize = -1;
    }

    return i4RealReadSize;
}


UINT32 i4ImgReszVfyFopen(char *pcFileName,char *pcMode)
{
    UINT32 fp;
    fp = UDVT_IF_OpenFile(pcFileName,pcMode);

    return (UINT32)fp;
}


char _abImgReszPrintMsg[256];
INT32 i4ImgReszVfyFprintf(UINT32 i4FileHandle,const char *format, ...)
{
#if 0
    va_list ap;

    // Parameter setting
    va_start(ap, format);
    vsprintf(_abImgReszPrintMsg, format, ap);
    va_end(ap);

    return fprintf((FILE *)i4FileHandle,_abImgReszPrintMsg,"");
#else
    sprintf(_abImgReszPrintMsg,format);
    UDVT_IF_WriteFile((void *)_abImgReszPrintMsg,sizeof(char),strlen(_abImgReszPrintMsg),i4FileHandle);

    return 0;
#endif
}


INT32 i4ImgReszVfyFclose(INT32 i4FileHandle)
{
    return UDVT_IF_CloseFile(i4FileHandle);
}


#define i4ImgReszVfyPrintf UTIL_Printf

#elif(IMG_RESZ_VFY_FILE_IO_TYPE == IMG_RESZ_VFY_FILE_IO_HDD_USBRW)
#if 0
#define DRV_FS_RDONLY 0
#define DRV_FS_W_C 1
#define DRV_FS_RW_C 2
#define MAX_FILENAME_SZ 50
#define MAX_READ_BYTES  32*1024
#define DRV_FSR_SUCCESS 0
#define DRV_FSR_FAIL    -1
#define DRV_FSR_NULL_POINT            -2
#define DRV_FSR_BUF_ADDR_ALIGN_ERR    -3
#define DRV_FSR_ONLY_SUPPORT_RDONLY   -4
#define DRV_FSR_PARAMETER_ERR         -5
//extern INT32 DrvFSUSBMount(UINT32 dwDriveNo, UINT32 *pu4DrvFSTag);
//extern INT32 DrvFSUSBUnMount(void);

extern INT32 DrvFSUSBOpenFile(char* pcDirFileName, UINT32 dwFlags, INT32* piFd);
extern INT32 DrvFSUSBGetFileSize(INT32 iFd, UINT32 *pu4FileSize);
extern INT32 DrvFSUSBSeekFile(INT32 iFd, INT64 iOffset, INT32 iOrigin);
extern INT32 DrvFSUSBReadFile(INT32 iFd, void* pbBuf, UINT32 u4Count);
extern INT32 DrvFSUSBWriteFile(INT32 iFd, const void *pbBuf, DWRD dwSize);
extern INT32 DrvFSUSBCloseFile(INT32 iFd);
#endif


INT32 i4ImgReszVfyReadFile(char *pcFileName,UINT32 u4FileBufSa,UINT32 u4BufSize)
{
    INT32 fp;
    INT32 i4RealReadSize;

    if((DrvFSUSBOpenFile(pcFileName,0, &fp)) == 0)
    {
        i4RealReadSize = DrvFSUSBReadFile(fp,(void *)u4FileBufSa,u4BufSize);

        DrvFSUSBCloseFile(fp);
    } else
    {
        i4RealReadSize = -1;
    }

    return i4RealReadSize;
}

INT32 i4ImgReszVfyWriteFile(char *pcFileName,UINT32 u4FileBufSa,UINT32 u4BufSize)
{
    INT32 fp;
    INT32 i4RealReadSize;

    if((DrvFSUSBOpenFile(pcFileName,1, &fp)) == 0)
    {
        i4RealReadSize = DrvFSUSBWriteFile(fp, (void *)u4FileBufSa,u4BufSize);

        DrvFSUSBCloseFile(fp);
    } else
    {
        i4RealReadSize = -1;
    }

    return i4RealReadSize;
}


INT32 i4ImgReszVfyFopen(char *pcFileName,char *pcMode)
{
    INT32 fp;
    INT32 u4OpenMode;
    if(*pcMode == 'w')
    {
       u4OpenMode = 1;
    }else
    {
       u4OpenMode = 0;
    }
    DrvFSUSBOpenFile(pcFileName,u4OpenMode, &fp);

    return fp;
}


char _abImgReszPrintMsg[256];
INT32 i4ImgReszVfyFprintf(INT32 i4FileHandle,const char *format, ...)
{
#if 0
    va_list ap;

    // Parameter setting
    va_start(ap, format);
    vsprintf(_abImgReszPrintMsg, format, ap);
    va_end(ap);

    return fprintf((FILE *)i4FileHandle,_abImgReszPrintMsg,"");
#else
    sprintf(_abImgReszPrintMsg,format);
    DrvFSUSBWriteFile(i4FileHandle, (void *)_abImgReszPrintMsg,strlen(_abImgReszPrintMsg));
    return 0;
#endif
}
INT32 i4ImgReszVfyFclose(INT32 i4FileHandle)
{
    return DrvFSUSBCloseFile(i4FileHandle);
}


#define i4ImgReszVfyPrintf UTIL_Printf

#endif

#if IMGRESZ_IO_MMU_TEST
  void vMMUDebug(UINT32 u4Sa)
  {
      

   }
#endif

void vImgreszVfyTestWriteTestDoneSignal(void)
{
    ////////////
	//autotest,save complete signal
	INT32 i4FileHandle;

	i4FileHandle = i4ImgReszVfyFopen("d:\\ImageTool\\img.txt","w");
	i4ImgReszVfyFprintf(i4FileHandle,"complete");
	i4ImgReszVfyFclose(i4FileHandle);
}

INT32 i4ImgReszStrToInt(UCHAR *ucStr)
{
    UINT32 u4I = 0;
    INT32 i4Value = 0;

    if(ucStr == 0)
        return 0;

    while((*(ucStr + u4I) >= '0') && (*(ucStr + u4I) <= '9'))
    {
        i4Value *= 10;
        i4Value += (INT32)(*(ucStr + u4I) - '0');
        u4I++;
    }

    return i4Value;
}


UINT32 u4ImgReszVfyGotoStrEnd(UINT32 u4Sa,char *pcStrTarget)
{
    char *pcStr;

    pcStr = strstr((char *)u4Sa,pcStrTarget);
    if(pcStr == 0)
        return 0;
    else
        return (UINT32)(pcStr + strlen(pcStrTarget));
}


INT32 i4ImgReszVfyGetLine(UINT32 u4Sa,char *pcLine)
{
    UINT32 u4I = 0;

    while(TRUE)
    {
        if(*(char *)(u4Sa + u4I) == 0x0)
            break;
        if(*(char *)(u4Sa + u4I) == 0xD)
            break;
        if(*(char *)(u4Sa + u4I) == 0xA)
            break;

        pcLine[u4I] = *(char *)(u4Sa + u4I);
        u4I++;
    }

    pcLine[u4I] = 0;

    return 0;
}


INT32 i4ImgReszVfyGetPath(char *pbPath,char *pbPathAndFileName)
{
    UINT32 u4Len,u4I;

    u4Len = strlen(pbPathAndFileName);

    for(u4I = u4Len; u4I>0; u4I--)
    {
        if(*(pbPathAndFileName + u4I - 1) == '\\')
            break;
    }

    if(u4I > 0)
        strncpy(pbPath,(char *)pbPathAndFileName,u4I);

    pbPath[u4I] = 0;

    return 0;
}


INT32 i4ImgReszVfyGetFileName(char *pbFileName,char *pbPathAndFileName)
{
    UINT32 u4Len,u4I;

    u4Len = strlen(pbPathAndFileName);

    for(u4I = u4Len; u4I>0; u4I--)
    {
        if(*(pbPathAndFileName + u4I - 1) == '\\')
            break;
    }

    strcpy(pbFileName,(char *)(pbPathAndFileName + u4I));

    return 0;

}


UINT32 u4ImgReszVfyCalBufFormatBits(IMGRESZ_HAL_IMG_BUF_FORMAT_T *prBufferFormat)
{
    UINT32 u4Bits = 0;

    if((prBufferFormat->eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER) ||
       (prBufferFormat->eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER))
    {
        switch(prBufferFormat->eARGBBufferFormat)
        {
            case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_0565:
            case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_1555:
            case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_4444:
                u4Bits = 16;
                break;
            case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888:
                u4Bits = 32;
                break;
        }
    } else if(prBufferFormat->eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_INDEX_BUFFER)
    {
        switch(prBufferFormat->eIndexBufferFormat)
        {
            case IMGRESZ_HAL_INDEX_BUFFER_FORMAT_2BPP:
                u4Bits = 2;
                break;
            case IMGRESZ_HAL_INDEX_BUFFER_FORMAT_4BPP:
                u4Bits = 4;
                break;
            case IMGRESZ_HAL_INDEX_BUFFER_FORMAT_8BPP:
                u4Bits = 8;
                break;
        }
    } else
    {
        u4Bits = 8;
    }

    return u4Bits;
}


INT32 i4ImgReszVfyLoadFileList(char *pcFileListFileName,UINT32 u4FileListSA,UINT32 u4FileListSize,
                               BYTE **ppbFileList,UINT32 *pu4FileListNum)
{
    INT32 i4FileSize;
    UINT32 u4I;
    BOOL fgInFileName;

    i4FileSize = i4ImgReszVfyReadFile(pcFileListFileName,u4FileListSA,u4FileListSize);
    VERIFY(i4FileSize>0);

    u4I = 0;
    *pu4FileListNum = 0;
    fgInFileName = FALSE;
    while(*(UCHAR *)(u4FileListSA + u4I) != 0)
    {
        if(!fgInFileName)
        {
            ppbFileList[*pu4FileListNum] = (BYTE *)(u4FileListSA + u4I);
            (*pu4FileListNum)++;
            fgInFileName = TRUE;
        }

        if(*(UCHAR *)(u4FileListSA + u4I) == 0x0D)
            *(UCHAR *)(u4FileListSA + u4I) = 0;

        if(*(UCHAR *)(u4FileListSA + u4I) == 0x0A)
        {
            *(UCHAR *)(u4FileListSA + u4I) = 0;
            fgInFileName = FALSE;
        }

        u4I++;
        if((u4I == u4FileListSize) || (u4I == i4FileSize))
            break;
    }

    return 0;
}


INT32 i4ImgReszVfyLoadBufInfo(BYTE *pbFileName,IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfo)
{
    INT32 i4Ret;
    char bFileName[256];
    char bValue[64];
    char *pcStr,*stopstring;
    UINT32 u4SrcBufInfoSA;
    UINT32 u4ImgReszFileInfoLen = 65536;

    u4SrcBufInfoSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4ImgReszFileInfoLen,1);

    strcpy(bFileName,(char *)pbFileName);
    strcat(bFileName,".inf");
    i4ImgReszVfyPrintf("[ImgResz][Verify] Load Buffer Info File %s\n",bFileName);
    i4Ret = i4ImgReszVfyReadFile(bFileName,(UINT32)u4SrcBufInfoSA,u4ImgReszFileInfoLen);
    VERIFY(i4Ret>0);

    pcStr = strstr((char *)u4SrcBufInfoSA,"ImageWidth=");
    if(pcStr != 0)
    {
        pcStr += strlen("ImageWidth=");
/*
        strtol(pcStr,&stopstring,10);
        strncpy(bValue,pcStr,(int)(stopstring-pcStr));
        bValue[(int)(stopstring-pcStr)] = 0;
        _u4SrcImageWidth = StrToInt(bValue);
*/
        prSrcImgInfo->u4ImgWidth = (UINT32)i4ImgReszStrToInt((UCHAR *)pcStr);
    }
    pcStr = strstr((char *)u4SrcBufInfoSA,"ImageHeight=");
    if(pcStr != 0)
    {
        pcStr += strlen("ImageHeight=");
/*
        strtol(pcStr,&stopstring,10);
        strncpy(bValue,pcStr,(int)(stopstring-pcStr));
        bValue[(int)(stopstring-pcStr)] = 0;
        _u4SrcImageHeight = StrToInt(bValue);
*/
        prSrcImgInfo->u4ImgHeight = (UINT32)i4ImgReszStrToInt((UCHAR *)pcStr);
    }

    i4ImgReszVfyPrintf("[ImgResz][Verify] Load Buffer size (%d,%d)\n",prSrcImgInfo->u4ImgWidth,prSrcImgInfo->u4ImgHeight);

    pcStr = strstr((char *)u4SrcBufInfoSA,"BufWidth=");
    if(pcStr != 0)
    {
        pcStr += strlen("BufWidth=");
/*
        strtol(pcStr,&stopstring,10);
        strncpy(bValue,pcStr,(int)(stopstring-pcStr));
        bValue[(int)(stopstring-pcStr)] = 0;
        _u4SrcBufWidth = StrToInt(bValue);
*/
        prSrcImgInfo->u4BufWidth = (UINT32)i4ImgReszStrToInt((UCHAR *)pcStr);
    }
    pcStr = strstr((char *)u4SrcBufInfoSA,"BufferMainFormat=");
    if(pcStr != 0)
    {
        pcStr += strlen("BufferMainFormat=");
        {
            UINT32 u4I = 0;

            while(TRUE)
            {
                if(pcStr[u4I] == 0x0)
                    break;
                if(pcStr[u4I] == 0xD)
                    break;
                if(pcStr[u4I] == 0xA)
                    break;

                bValue[u4I] = pcStr[u4I];
                u4I++;
            }

            bValue[u4I] = 0;
        }
        if(strcmp(bValue,"Y_C_BUFFER") == 0)
        {
            prSrcImgInfo->rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER;
        } else if(strcmp(bValue,"Y_CB_CR_BUFFER") == 0)
        {
            prSrcImgInfo->rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER;
        } else if(strcmp(bValue,"ARGB_BUFFER") == 0)
        {
            prSrcImgInfo->rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
        } else if(strcmp(bValue,"AYUV_BUFFER") == 0)
        {
            prSrcImgInfo->rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
        } else if(strcmp(bValue,"INDEX_BUFFER") == 0)
        {
            prSrcImgInfo->rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_INDEX_BUFFER;
        }
        i4ImgReszVfyPrintf("[ImgResz][Verify] Buf Main Format %s\n",bValue);
    }

    switch(prSrcImgInfo->rBufferFormat.eBufferMainFormat)
    {
        case IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER:
            pcStr = strstr((char *)u4SrcBufInfoSA,"YUVFormat=");
            if(pcStr != 0)
            {
                UINT32 u4Ret;

                pcStr += strlen("YUVFormat=");
                strtol(pcStr,&stopstring,10);
                strncpy(bValue,pcStr,(int)(stopstring-pcStr));
                bValue[(int)(stopstring-pcStr)] = 0;
                u4Ret = StrToInt(bValue);
                switch(u4Ret)
                {
                    case 420:
                        prSrcImgInfo->rBufferFormat.eYUVFormat = IMGRESZ_HAL_IMG_YUV_FORMAT_420;
                        break;
                    case 422:
                        prSrcImgInfo->rBufferFormat.eYUVFormat = IMGRESZ_HAL_IMG_YUV_FORMAT_422;
                        break;
                }
                i4ImgReszVfyPrintf("[ImgResz][Verify] YUV Format %d\n",u4Ret);
            }
            break;
        case IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER:
            pcStr = strstr((char *)u4SrcBufInfoSA,"HSampleFactor0=");
            if(pcStr != 0)
            {
                pcStr += strlen("HSampleFactor0=");
                strtol(pcStr,&stopstring,10);
                strncpy(bValue,pcStr,(int)(stopstring-pcStr));
                bValue[(int)(stopstring-pcStr)] = 0;
                prSrcImgInfo->rBufferFormat.u4HSampleFactor[0] = StrToInt(bValue);
            }
            pcStr = strstr((char *)u4SrcBufInfoSA,"VSampleFactor0=");
            if(pcStr != 0)
            {
                pcStr += strlen("VSampleFactor0=");
                strtol(pcStr,&stopstring,10);
                strncpy(bValue,pcStr,(int)(stopstring-pcStr));
                bValue[(int)(stopstring-pcStr)] = 0;
                prSrcImgInfo->rBufferFormat.u4VSampleFactor[0] = StrToInt(bValue);
            }
            pcStr = strstr((char *)u4SrcBufInfoSA,"HSampleFactor1=");
            if(pcStr != 0)
            {
                pcStr += strlen("HSampleFactor1=");
                strtol(pcStr,&stopstring,10);
                strncpy(bValue,pcStr,(int)(stopstring-pcStr));
                bValue[(int)(stopstring-pcStr)] = 0;
                prSrcImgInfo->rBufferFormat.u4HSampleFactor[1] = StrToInt(bValue);
            }
            pcStr = strstr((char *)u4SrcBufInfoSA,"VSampleFactor1=");
            if(pcStr != 0)
            {
                pcStr += strlen("VSampleFactor1=");
                strtol(pcStr,&stopstring,10);
                strncpy(bValue,pcStr,(int)(stopstring-pcStr));
                bValue[(int)(stopstring-pcStr)] = 0;
                prSrcImgInfo->rBufferFormat.u4VSampleFactor[1] = StrToInt(bValue);
            }
            pcStr = strstr((char *)u4SrcBufInfoSA,"HSampleFactor2=");
            if(pcStr != 0)
            {
                pcStr += strlen("HSampleFactor2=");
                strtol(pcStr,&stopstring,10);
                strncpy(bValue,pcStr,(int)(stopstring-pcStr));
                bValue[(int)(stopstring-pcStr)] = 0;
                prSrcImgInfo->rBufferFormat.u4HSampleFactor[2] = StrToInt(bValue);
            }
            pcStr = strstr((char *)u4SrcBufInfoSA,"VSampleFactor2=");
            if(pcStr != 0)
            {
                pcStr += strlen("VSampleFactor2=");
                strtol(pcStr,&stopstring,10);
                strncpy(bValue,pcStr,(int)(stopstring-pcStr));
                bValue[(int)(stopstring-pcStr)] = 0;
                prSrcImgInfo->rBufferFormat.u4VSampleFactor[2] = StrToInt(bValue);
            }
            i4ImgReszVfyPrintf("[ImgResz][Verify] Sample Factor (%d,%d,%d,%d,%d,%d)\n",prSrcImgInfo->rBufferFormat.u4HSampleFactor[0],
                                                                              prSrcImgInfo->rBufferFormat.u4VSampleFactor[0],
                                                                              prSrcImgInfo->rBufferFormat.u4HSampleFactor[1],
                                                                              prSrcImgInfo->rBufferFormat.u4VSampleFactor[1],
                                                                              prSrcImgInfo->rBufferFormat.u4HSampleFactor[2],
                                                                              prSrcImgInfo->rBufferFormat.u4VSampleFactor[2]);
            break;
        case IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER:
            pcStr = strstr((char *)u4SrcBufInfoSA,"ARGB=");
            if(pcStr != 0)
            {
                UINT32 u4Ret;

                pcStr += strlen("ARGB=");
                strtol(pcStr,&stopstring,10);
                strncpy(bValue,pcStr,(int)(stopstring-pcStr));
                bValue[(int)(stopstring-pcStr)] = 0;
                u4Ret = StrToInt(bValue);
                switch(u4Ret)
                {
                    case 565:
                        prSrcImgInfo->rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_0565;
                        break;
                    case 1555:
                        prSrcImgInfo->rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_1555;
                        break;
                    case 4444:
                        prSrcImgInfo->rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_4444;
                        break;
                    case 8888:
                        prSrcImgInfo->rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
                        break;
                }
                i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB Format %d\n",u4Ret);
            }

            {
                UINT32 u4Bits = 0;

                switch(prSrcImgInfo->rBufferFormat.eARGBBufferFormat)
                {
                    case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_0565:
                    case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_1555:
                    case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_4444:
                        u4Bits = 16;
                        break;
                    case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888:
                        u4Bits = 32;
                        break;
                }

                prSrcImgInfo->u4BufWidth = prSrcImgInfo->u4ImgWidth * u4Bits / 8;
                prSrcImgInfo->u4BufHeight = prSrcImgInfo->u4ImgHeight;
            }
            break;
        case IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER:
            prSrcImgInfo->rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
            prSrcImgInfo->u4BufWidth = prSrcImgInfo->u4ImgWidth * 4;
            prSrcImgInfo->u4BufHeight = prSrcImgInfo->u4ImgHeight;
            break;
        case IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_INDEX_BUFFER:
            pcStr = strstr((char *)u4SrcBufInfoSA,"Bits=");
            if(pcStr != 0)
            {
                UINT32 u4Ret;

                pcStr += strlen("Bits=");
                strtol(pcStr,&stopstring,10);
                strncpy(bValue,pcStr,(int)(stopstring-pcStr));
                bValue[(int)(stopstring-pcStr)] = 0;
                u4Ret = StrToInt(bValue);
                switch(u4Ret)
                {
                    case 8:
                        prSrcImgInfo->rBufferFormat.eIndexBufferFormat = IMGRESZ_HAL_INDEX_BUFFER_FORMAT_8BPP;
                        break;
                    case 4:
                        prSrcImgInfo->rBufferFormat.eIndexBufferFormat = IMGRESZ_HAL_INDEX_BUFFER_FORMAT_4BPP;
                        break;
                    case 2:
                        prSrcImgInfo->rBufferFormat.eIndexBufferFormat = IMGRESZ_HAL_INDEX_BUFFER_FORMAT_2BPP;
                        break;
                }
                i4ImgReszVfyPrintf("[ImgResz][Verify] Index Format %d bpp\n",u4Ret);

                {
                    UINT32 u4I;
                    UINT32 u4IndexNum = 1<<u4Ret;
                    UINT8 u1A,u1R,u1G,u1B;

                    pcStr = strstr((char *)u4SrcBufInfoSA,"IndexColor=");

                    prSrcImgInfo->rBufferFormat.prColorPallet =
                        (IMGRESZ_HAL_ARGB_COLOR_T *)imgreszvfy_alloc_mem_aligned(sizeof(IMGRESZ_HAL_ARGB_COLOR_T)*u4IndexNum,1);

                    for(u4I=0; u4I<u4IndexNum; u4I++)
                    {
                        u1A = 0;
                        u1R = 0;
                        u1G = 0;
                        u1B = 0;

                        pcStr = strstr(pcStr,"A=");
                        if(pcStr != 0)
                        {
                            pcStr += strlen("A=");
                            strtol(pcStr,&stopstring,10);
                            strncpy(bValue,pcStr,(int)(stopstring-pcStr));
                            bValue[(int)(stopstring-pcStr)] = 0;
                            u1A = (StrToInt(bValue) & 0xFF);
                        }
                        pcStr = strstr(pcStr,"R=");
                        if(pcStr != 0)
                        {
                            pcStr += strlen("R=");
                            strtol(pcStr,&stopstring,10);
                            strncpy(bValue,pcStr,(int)(stopstring-pcStr));
                            bValue[(int)(stopstring-pcStr)] = 0;
                            u1R = (StrToInt(bValue) & 0xFF);
                        }
                        pcStr = strstr(pcStr,"G=");
                        if(pcStr != 0)
                        {
                            pcStr += strlen("G=");
                            strtol(pcStr,&stopstring,10);
                            strncpy(bValue,pcStr,(int)(stopstring-pcStr));
                            bValue[(int)(stopstring-pcStr)] = 0;
                            u1G = (StrToInt(bValue) & 0xFF);
                        }
                        pcStr = strstr(pcStr,"B=");
                        if(pcStr != 0)
                        {
                            pcStr += strlen("B=");
                            strtol(pcStr,&stopstring,10);
                            strncpy(bValue,pcStr,(int)(stopstring-pcStr));
                            bValue[(int)(stopstring-pcStr)] = 0;
                            u1B = (StrToInt(bValue) & 0xFF);
                        }

                        prSrcImgInfo->rBufferFormat.prColorPallet[u4I].u1A = u1A;
                        prSrcImgInfo->rBufferFormat.prColorPallet[u4I].u1R = u1R;
                        prSrcImgInfo->rBufferFormat.prColorPallet[u4I].u1G = u1G;
                        prSrcImgInfo->rBufferFormat.prColorPallet[u4I].u1B = u1B;
                    }
                }

                prSrcImgInfo->u4BufWidth = prSrcImgInfo->u4ImgWidth *
                                           u4ImgReszVfyCalBufFormatBits(&(prSrcImgInfo->rBufferFormat)) /
                                           8;
            }
            break;
    }

    if(prSrcImgInfo->u4BufWidth == 0)
    {
        if((prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER) ||
           (prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER))
        {
            UINT32 u4Bits = 0;

            switch(prSrcImgInfo->rBufferFormat.eARGBBufferFormat)
            {
                case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_0565:
                case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_1555:
                case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_4444:
                    u4Bits = 16;
                    break;
                case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888:
                    u4Bits = 32;
                    break;
            }

            prSrcImgInfo->u4BufWidth = prSrcImgInfo->u4ImgWidth * u4Bits / 8;
        } else
        {
            prSrcImgInfo->u4BufWidth = prSrcImgInfo->u4ImgWidth;
        }
    }
    prSrcImgInfo->u4BufHeight = prSrcImgInfo->u4ImgHeight;

    imgreszvfy_free_mem_aligned((void *)u4SrcBufInfoSA);

    return 0;
}


INT32 i4ImgReszVfyLoadBuf(BYTE *pbFileName,IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfo,UINT32 u4BufSize)
{
    char bFileName[256];
    INT32 i4Ret;

    switch(prSrcImgInfo->rBufferFormat.eBufferMainFormat)
    {
        case IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER:
            strcpy(bFileName,(char *)pbFileName);
            strcat(bFileName,".frame.y.bin");
            i4ImgReszVfyPrintf("[ImgResz][Verify] Load Buffer File %s\n",bFileName);
            i4Ret = i4ImgReszVfyReadFile(bFileName,prSrcImgInfo->u4BufSA1,u4BufSize);
            VERIFY(i4Ret>0);

            strcpy(bFileName,(char *)pbFileName);
            strcat(bFileName,".frame.c.bin");
            i4ImgReszVfyPrintf("[ImgResz][Verify] Load Buffer File %s\n",bFileName);
            i4Ret = i4ImgReszVfyReadFile(bFileName,prSrcImgInfo->u4BufSA2,u4BufSize);
            VERIFY(i4Ret>0);

            break;
        case IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER:
            strcpy(bFileName,(char *)pbFileName);
            strcat(bFileName,".color.y.bin");
            i4ImgReszVfyPrintf("[ImgResz][Verify] Load Buffer File %s\n",bFileName);
            i4Ret = i4ImgReszVfyReadFile(bFileName,prSrcImgInfo->u4BufSA1,u4BufSize);
            VERIFY(i4Ret>0);

            strcpy(bFileName,(char *)pbFileName);
            strcat(bFileName,".color.cb.bin");
            i4ImgReszVfyPrintf("[ImgResz][Verify] Load Buffer File %s\n",bFileName);
            i4Ret = i4ImgReszVfyReadFile(bFileName,prSrcImgInfo->u4BufSA2,u4BufSize);
            VERIFY(i4Ret>0);

            strcpy(bFileName,(char *)pbFileName);
            strcat(bFileName,".color.cr.bin");
            i4ImgReszVfyPrintf("[ImgResz][Verify] Load Buffer File %s\n",bFileName);
            i4Ret = i4ImgReszVfyReadFile(bFileName,prSrcImgInfo->u4BufSA3,u4BufSize);
            VERIFY(i4Ret>0);

            break;
        case IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER:
            strcpy(bFileName,(char *)pbFileName);
            strcat(bFileName,".argb.bin");
            i4ImgReszVfyPrintf("[ImgResz][Verify] Load Buffer File %s\n",bFileName);
            i4Ret = i4ImgReszVfyReadFile(bFileName,prSrcImgInfo->u4BufSA1,u4BufSize);
            VERIFY(i4Ret>0);

            break;
        case IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER:
            strcpy(bFileName,(char *)pbFileName);
            strcat(bFileName,".ayuv.bin");
            i4ImgReszVfyPrintf("[ImgResz][Verify] Load Buffer File %s\n",bFileName);
            i4Ret = i4ImgReszVfyReadFile(bFileName,prSrcImgInfo->u4BufSA1,u4BufSize);
            VERIFY(i4Ret>0);

            break;
        case IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_INDEX_BUFFER:
            strcpy(bFileName,(char *)pbFileName);
            strcat(bFileName,".index.bin");
            i4ImgReszVfyPrintf("[ImgResz][Verify] Load Buffer File %s\n",bFileName);
            i4Ret = i4ImgReszVfyReadFile(bFileName,prSrcImgInfo->u4BufSA1,u4BufSize);
            VERIFY(i4Ret>0);

            break;
    }

    return 0;
}

INT32 i4ImgReszVfySaveWTBuf(BYTE *pbFileName,UINT32 u4Num,IMGRESZ_HAL_IMG_INFO_T *prDestImgInfo)
{
    INT32 i4Ret = 0;
    char bFileName[256];
    //INT32 i4FileHandle;
    //UINT32 u4Size = 0;

    switch(prDestImgInfo->rBufferFormat.eBufferMainFormat)
    {

        case IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER:
            {
                UINT32 u4Bits = 0;

                switch(prDestImgInfo->rBufferFormat.eARGBBufferFormat)
                {
                    case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_0565:
                    case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_1555:
                    case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_4444:
                        u4Bits = 16;
                        break;
                    case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888:
                        u4Bits = 32;
                        break;
                }
                sprintf(bFileName,"%s.%04d.wt.raw",(char *)pbFileName,(int)u4Num);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Save WT Buffer File %s\n",bFileName);
		  i4ImgReszVfyPrintf("[ImgResz][Verify] WT Buffer width is %d\n",(prDestImgInfo->u4BufWidth*8/u4Bits));
		  i4ImgReszVfyPrintf("[ImgResz][Verify] WT Buffer height is %d\n",prDestImgInfo->u4BufHeight);
                i4Ret = i4ImgReszVfyWriteFile(bFileName,prDestImgInfo->u4BufSA1,(prDestImgInfo->u4BufWidth*prDestImgInfo->u4BufHeight));
                VERIFY(i4Ret >= 0);
            }
            break;
        case IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER:
            {
                //UINT32 u4Bits = 32;

                sprintf(bFileName,"%s.%04d.wt.bin",(char *)pbFileName,(int)u4Num);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Save Dest Buffer File %s\n",bFileName);
                i4Ret = i4ImgReszVfyWriteFile(bFileName,prDestImgInfo->u4BufSA1,(prDestImgInfo->u4BufWidth*prDestImgInfo->u4BufHeight));
                VERIFY(i4Ret >= 0);

            }
            break;
	  case IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER: //for test
	      {
		  UINT32 u4CbufWidth;
		  u4CbufWidth = ((prDestImgInfo->u4BufWidth/2 + 15) /16)*16;
		  sprintf(bFileName,"%s.%04d.y.bin",(char *)pbFileName,(int)u4Num);
		  i4ImgReszVfyPrintf("[ImgResz][Verify] Save test File %s\n",bFileName);
                i4Ret = i4ImgReszVfyWriteFile(bFileName,prDestImgInfo->u4BufSA1,(prDestImgInfo->u4BufWidth*prDestImgInfo->u4ImgHeight));
		  sprintf(bFileName,"%s.%04d.cb.bin",(char *)pbFileName,(int)u4Num);
		  i4ImgReszVfyPrintf("[ImgResz][Verify] Save test File %s\n",bFileName);
                i4Ret = i4ImgReszVfyWriteFile(bFileName,prDestImgInfo->u4BufSA2,(u4CbufWidth*prDestImgInfo->u4ImgHeight));
		  sprintf(bFileName,"%s.%04d.cr.bin",(char *)pbFileName,(int)u4Num);
		  i4ImgReszVfyPrintf("[ImgResz][Verify] Save test File %s\n",bFileName);
                i4Ret = i4ImgReszVfyWriteFile(bFileName,prDestImgInfo->u4BufSA3,(u4CbufWidth*prDestImgInfo->u4ImgHeight));
                VERIFY(i4Ret >= 0);
	  	}
	    default:
	     break;
    }

    return i4Ret;

}

INT32 i4ImgReszVfySaveDestBuf(BYTE *pbFileName,UINT32 u4Num,IMGRESZ_HAL_IMG_INFO_T *prDestImgInfo)
{
    INT32 i4Ret = 0;
    char bFileName[256];
    INT32 i4FileHandle;
    UINT32 u4Size = 0;

    switch(prDestImgInfo->rBufferFormat.eBufferMainFormat)
    {
        case IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER:
            sprintf(bFileName,"%s.%04d.frame.y.bin",(char *)pbFileName,(int)u4Num);
            i4ImgReszVfyPrintf("[ImgResz][Verify] Save Dest Buffer File %s\n",bFileName);
            i4Ret = i4ImgReszVfyWriteFile(bFileName,prDestImgInfo->u4BufSA1,(prDestImgInfo->u4BufWidth*prDestImgInfo->u4BufHeight));
            VERIFY(i4Ret >= 0);

            sprintf(bFileName,"%s.%04d.frame.c.bin",(char *)pbFileName,(int)u4Num);
            i4ImgReszVfyPrintf("[ImgResz][Verify] Save Dest Buffer File %s\n",bFileName);
            switch(prDestImgInfo->rBufferFormat.eYUVFormat)
            {
                case IMGRESZ_HAL_IMG_YUV_FORMAT_420:
                    u4Size = (prDestImgInfo->u4BufWidth*prDestImgInfo->u4BufHeight)/2;
                    break;
                case IMGRESZ_HAL_IMG_YUV_FORMAT_422:
                    u4Size = (prDestImgInfo->u4BufWidth*prDestImgInfo->u4BufHeight);
                    break;
			    default:
				    break;
            }
            i4Ret = i4ImgReszVfyWriteFile(bFileName,prDestImgInfo->u4BufSA2,u4Size);
            VERIFY(i4Ret >= 0);

            sprintf(bFileName,"%s.%04d.inf",(char *)pbFileName,(int)u4Num);
            i4ImgReszVfyPrintf("[ImgResz][Verify] Save Dest Buffer Info File %s\n",bFileName);
            i4FileHandle = i4ImgReszVfyFopen(bFileName,"w");
            i4ImgReszVfyFprintf(i4FileHandle,"ImageWidth=%d\n",prDestImgInfo->u4BufWidth);
            i4ImgReszVfyFprintf(i4FileHandle,"ImageHeight=%d\n",prDestImgInfo->u4BufHeight);
            i4ImgReszVfyFprintf(i4FileHandle,"BufferMainFormat=%s\n","Y_C_BUFFER");
            switch(prDestImgInfo->rBufferFormat.eYUVFormat)
            {
                case IMGRESZ_HAL_IMG_YUV_FORMAT_420:
                    i4ImgReszVfyFprintf(i4FileHandle,"YUVFormat=%s\n","420");
                    break;
                case IMGRESZ_HAL_IMG_YUV_FORMAT_422:
                    i4ImgReszVfyFprintf(i4FileHandle,"YUVFormat=%s\n","422");
                    break;
				default:
					break;
            }
            i4ImgReszVfyFclose(i4FileHandle);
            break;
        case IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER:
            {
                UINT32 u4Bits = 0;

                switch(prDestImgInfo->rBufferFormat.eARGBBufferFormat)
                {
                    case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_0565:
                    case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_1555:
                    case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_4444:
                        u4Bits = 16;
                        break;
                    case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888:
                        u4Bits = 32;
                        break;
                }

                sprintf(bFileName,"%s.%04d.argb.bin",(char *)pbFileName,(int)u4Num);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Save Dest Buffer File %s\n",bFileName);
                i4Ret = i4ImgReszVfyWriteFile(bFileName,prDestImgInfo->u4BufSA1,(prDestImgInfo->u4BufWidth*prDestImgInfo->u4BufHeight));
                VERIFY(i4Ret >= 0);

                sprintf(bFileName,"%s.%04d.inf",(char *)pbFileName,(int)u4Num);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Save Dest Buffer Info File %s\n",bFileName);
                i4FileHandle = i4ImgReszVfyFopen(bFileName,"w");
                i4ImgReszVfyFprintf(i4FileHandle,"ImageWidth=%d\n",prDestImgInfo->u4BufWidth*8/u4Bits);
                i4ImgReszVfyFprintf(i4FileHandle,"ImageHeight=%d\n",prDestImgInfo->u4BufHeight);
                i4ImgReszVfyFprintf(i4FileHandle,"BufferMainFormat=%s\n","ARGB_BUFFER");
                switch(prDestImgInfo->rBufferFormat.eARGBBufferFormat)
                {
                    case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_0565:
                        i4ImgReszVfyFprintf(i4FileHandle,"ARGB=0565\n");
                        break;
                    case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_1555:
                        i4ImgReszVfyFprintf(i4FileHandle,"ARGB=1555\n");
                        break;
                    case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_4444:
                        i4ImgReszVfyFprintf(i4FileHandle,"ARGB=4444\n");
                        break;
                    case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888:
                        i4ImgReszVfyFprintf(i4FileHandle,"ARGB=8888\n");
                        break;
                }
                i4ImgReszVfyFclose(i4FileHandle);
            }
            break;
        case IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER:
            {
                UINT32 u4Bits = 32;

                sprintf(bFileName,"%s.%04d.ayuv.bin",(char *)pbFileName,(int)u4Num);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Save Dest Buffer File %s\n",bFileName);
                i4Ret = i4ImgReszVfyWriteFile(bFileName,prDestImgInfo->u4BufSA1,(prDestImgInfo->u4BufWidth*prDestImgInfo->u4BufHeight));
                VERIFY(i4Ret >= 0);

                sprintf(bFileName,"%s.%04d.inf",(char *)pbFileName,(int)u4Num);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Save Dest Buffer Info File %s\n",bFileName);
                i4FileHandle = i4ImgReszVfyFopen(bFileName,"w");
                i4ImgReszVfyFprintf(i4FileHandle,"ImageWidth=%d\n",prDestImgInfo->u4BufWidth*8/u4Bits);
                i4ImgReszVfyFprintf(i4FileHandle,"ImageHeight=%d\n",prDestImgInfo->u4BufHeight);
                i4ImgReszVfyFprintf(i4FileHandle,"BufferMainFormat=%s\n","AYUV_BUFFER");
                i4ImgReszVfyFclose(i4FileHandle);
            }
            break;
	    default:
			break;
    }

    return i4Ret;

}


INT32 i4ImgReszVfyOpenCaseInfoFile(BYTE *pbFileName)
{
    char bFileName[256];
    INT32 i4FileHandle;

    i4ImgReszVfyGetPath(bFileName,(char *)pbFileName);
    strcat(bFileName,"imgresz_case.inf");

    i4FileHandle = i4ImgReszVfyFopen(bFileName,"w");

    return i4FileHandle;
}


INT32 i4ImgReszOutputCaseInfo(INT32 i4ReszInfoFileHandle,BYTE *pbFileName,UINT32 u4Num,
                              IMGRESZ_HAL_RESIZE_MODE_T eResizeMode,
                              IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,
                              IMGRESZ_HAL_RESAMPLE_METHOD_T eVResampleMethod,
                              BOOL fgInterlaced,
                              BOOL fgPreloadBuf,UINT32 u4Alpha,
                              UINT32 u4AlphaScalingType)
{
    char bFileName[256];
    char bFileName2[256];

    i4ImgReszVfyFprintf(i4ReszInfoFileHandle,"[CASE DESCRIPTION]\n");

    // Resize parameter
    switch(eResizeMode)
    {
        case IMGRESZ_HAL_RESIZE_MODE_FRAME:
            i4ImgReszVfyFprintf(i4ReszInfoFileHandle,"ResizeMode=FRAME\n");
            break;
        case IMGRESZ_HAL_RESIZE_MODE_PARTIAL:
            i4ImgReszVfyFprintf(i4ReszInfoFileHandle,"ResizeMode=PARTIAL\n");
            break;
    }
    switch(eHResampleMethod)
    {
        case IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR:
            i4ImgReszVfyFprintf(i4ReszInfoFileHandle,"HResampleMethod=BILINEAR\n");
            break;
        case IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP:
            i4ImgReszVfyFprintf(i4ReszInfoFileHandle,"HResampleMethod=4_TAP\n");
            break;
        case IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP:
            i4ImgReszVfyFprintf(i4ReszInfoFileHandle,"HResampleMethod=8_TAP\n");
            break;
    }
    switch(eVResampleMethod)
    {
        case IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR:
            i4ImgReszVfyFprintf(i4ReszInfoFileHandle,"VResampleMethod=BILINEAR\n");
            break;
        case IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP:
            i4ImgReszVfyFprintf(i4ReszInfoFileHandle,"VResampleMethod=4_TAP\n");
            break;
        case IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP:
            i4ImgReszVfyFprintf(i4ReszInfoFileHandle,"VResampleMethod=8_TAP\n");
            break;
    }
    // Progressive or interlaced
    if(fgInterlaced)
    {
            i4ImgReszVfyFprintf(i4ReszInfoFileHandle,"I_P_Mode=INTERLACED\n");
    } else
    {
            i4ImgReszVfyFprintf(i4ReszInfoFileHandle,"I_P_Mode=PROGRESSIVE\n");
    }
    // Alfa
    if(fgPreloadBuf)
    {
#ifdef IMGRESZ_HAL_MT8530
        i4ImgReszVfyFprintf(i4ReszInfoFileHandle,"ALPHA_MAX=128\n");
#else
        i4ImgReszVfyFprintf(i4ReszInfoFileHandle,"ALPHA_MAX=8\n");
#endif
        i4ImgReszVfyFprintf(i4ReszInfoFileHandle,"ALPHA_VALUE=%d\n",u4Alpha);
    }
    // Alpha scaling type
    switch(u4AlphaScalingType)
    {
        case 0:
            i4ImgReszVfyFprintf(i4ReszInfoFileHandle,"ALPHA_SCALING_TYPE=GENERAL\n");
            break;
        case 1:
            i4ImgReszVfyFprintf(i4ReszInfoFileHandle,"ALPHA_SCALING_TYPE=REFER_TO_LEFT\n");
            break;
        case 2:
            i4ImgReszVfyFprintf(i4ReszInfoFileHandle,"ALPHA_SCALING_TYPE=REFER_TO_NEAREST\n");
            break;
    }

    i4ImgReszVfyFprintf(i4ReszInfoFileHandle,"CRC=%u\n",u4ImgReszCheckSum);
    // Source buffer info
    i4ImgReszVfyGetFileName(bFileName,(char *)pbFileName);
    sprintf(bFileName2,"SOURCE_FILE=%s\n",bFileName);
    i4ImgReszVfyFprintf(i4ReszInfoFileHandle,"%s",bFileName2);

    // Destination buffer info
    i4ImgReszVfyGetFileName(bFileName,(char *)pbFileName);
    sprintf(bFileName2,"DESTINATION_FILE=%s.%04d\n",bFileName,(int)u4Num);
    i4ImgReszVfyFprintf(i4ReszInfoFileHandle,"%s",bFileName2);

    return 0;
}


void vImgReszVfyImageCopy(IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfo,IMGRESZ_HAL_IMG_INFO_T *prDestImgInfo,
	                                                BOOL fgJpeg420)
{
    switch(prSrcImgInfo->rBufferFormat.eBufferMainFormat)
    {
        case IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER:
            {
                UINT32 u4Y;
                UINT32 u4SrcPos,u4DestPos;
                UINT32 u4XSample = 0,u4YSample = 0;

                // Y
                for(u4Y=0; u4Y<prSrcImgInfo->u4ImgHeight; u4Y++)
                {
                    u4SrcPos = prSrcImgInfo->u4BufSA1 + (prSrcImgInfo->u4ImgYOff + u4Y) * prSrcImgInfo->u4BufWidth + prSrcImgInfo->u4ImgXOff;
                    u4DestPos = prDestImgInfo->u4BufSA1 + (prDestImgInfo->u4ImgYOff + u4Y) * prDestImgInfo->u4BufWidth + prDestImgInfo->u4ImgXOff;
                    x_memcpy((void *)u4DestPos,(void *)u4SrcPos,prSrcImgInfo->u4ImgWidth);
#if 0
                    for(u4X=0; u4X<prSrcImgInfo->u4ImgWidth; u4X++)
                    {
                        *(UCHAR *)u4DestPos = *(UCHAR *)u4SrcPos;

                        u4SrcPos++;
                        u4DestPos++;
                    }
#endif
                }

                // C
                switch(prSrcImgInfo->rBufferFormat.eYUVFormat)
                {
                    case IMGRESZ_HAL_IMG_YUV_FORMAT_420:
                        u4XSample = 2;
                        u4YSample = 2;
                        break;
                    case IMGRESZ_HAL_IMG_YUV_FORMAT_422:
                        u4XSample = 2;
                        u4YSample = 1;
                        break;
                    case IMGRESZ_HAL_IMG_YUV_FORMAT_444:
                        u4XSample = 1;
                        u4YSample = 1;
                        break;
                }

                for(u4Y=0; u4Y<prSrcImgInfo->u4ImgHeight; u4Y+=u4YSample)
                {
                    u4SrcPos = prSrcImgInfo->u4BufSA2 + (((prSrcImgInfo->u4ImgYOff + u4Y) / u4YSample) * prSrcImgInfo->u4BufWidth + prSrcImgInfo->u4ImgXOff) * 2 / u4XSample;
                    u4DestPos = prDestImgInfo->u4BufSA2 + (((prDestImgInfo->u4ImgYOff + u4Y) / u4YSample) * prDestImgInfo->u4BufWidth + prDestImgInfo->u4ImgXOff) * 2 / u4XSample;
                    x_memcpy((void *)u4DestPos,(void *)u4SrcPos,(prSrcImgInfo->u4ImgWidth*2/u4XSample));
#if 0
                    for(u4X=0; u4X<prSrcImgInfo->u4ImgWidth; u4X+=u4XSample)
                    {
                        *(UCHAR *)u4DestPos = *(UCHAR *)u4SrcPos;

                        u4SrcPos++;
                        u4DestPos++;

                        *(UCHAR *)u4DestPos = *(UCHAR *)u4SrcPos;

                        u4SrcPos++;
                        u4DestPos++;
                    }
#endif
                }
            }
            break;
        case IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER:
            {
                UINT32 u4Y;
                UINT32 u4SrcPos,u4DestPos;
                UINT32 u4XSample,u4YSample;

                // Y
                for(u4Y=0; u4Y<prSrcImgInfo->u4ImgHeight; u4Y++)
                {
                    u4SrcPos = prSrcImgInfo->u4BufSA1 + (prSrcImgInfo->u4ImgYOff + u4Y) * prSrcImgInfo->u4BufWidth + prSrcImgInfo->u4ImgXOff;
                    u4DestPos = prDestImgInfo->u4BufSA1 + (prDestImgInfo->u4ImgYOff + u4Y) * prDestImgInfo->u4BufWidth + prDestImgInfo->u4ImgXOff;
                    x_memcpy((void *)u4DestPos,(void *)u4SrcPos,prSrcImgInfo->u4ImgWidth);
#if 0
                    for(u4X=0; u4X<prSrcImgInfo->u4ImgWidth; u4X++)
                    {
                        *(UCHAR *)u4DestPos = *(UCHAR *)u4SrcPos;

                        u4SrcPos++;
                        u4DestPos++;
                    }
#endif
                }
          	 if(fgJpeg420)
          	  {
			UINT32 u4CBufWidth;
			u4CBufWidth = prDestImgInfo->u4BufWidth/2;
			u4CBufWidth =((u4CBufWidth + 15) /16) * 16;
                    // Cb
                    u4XSample = prSrcImgInfo->rBufferFormat.u4HSampleFactor[0] / prSrcImgInfo->rBufferFormat.u4HSampleFactor[1];
                    u4YSample = prSrcImgInfo->rBufferFormat.u4VSampleFactor[0] / prSrcImgInfo->rBufferFormat.u4VSampleFactor[1];
                    for(u4Y=0; u4Y<prSrcImgInfo->u4ImgHeight; u4Y+=u4YSample)
                    {
                        u4SrcPos = prSrcImgInfo->u4BufSA2 + ((prSrcImgInfo->u4ImgYOff + u4Y) / u4YSample) * prSrcImgInfo->u4BufWidth + (prSrcImgInfo->u4ImgXOff / u4XSample);
                        u4DestPos = prDestImgInfo->u4BufSA2 + ((prDestImgInfo->u4ImgYOff + u4Y) / u4YSample) * u4CBufWidth + (prDestImgInfo->u4ImgXOff / u4XSample);
                        x_memcpy((void *)u4DestPos,(void *)u4SrcPos,(prSrcImgInfo->u4ImgWidth/u4XSample));
                    }

                    // Cr
                    u4XSample = prSrcImgInfo->rBufferFormat.u4HSampleFactor[0] / prSrcImgInfo->rBufferFormat.u4HSampleFactor[2];
                    u4YSample = prSrcImgInfo->rBufferFormat.u4VSampleFactor[0] / prSrcImgInfo->rBufferFormat.u4VSampleFactor[2];
                    for(u4Y=0; u4Y<prSrcImgInfo->u4ImgHeight; u4Y+=u4YSample)
                    {
                        u4SrcPos = prSrcImgInfo->u4BufSA3 + ((prSrcImgInfo->u4ImgYOff + u4Y) / u4YSample) * prSrcImgInfo->u4BufWidth + (prSrcImgInfo->u4ImgXOff / u4XSample);
                        u4DestPos = prDestImgInfo->u4BufSA3 + ((prDestImgInfo->u4ImgYOff + u4Y) / u4YSample) * u4CBufWidth + (prDestImgInfo->u4ImgXOff / u4XSample);
                        x_memcpy((void *)u4DestPos,(void *)u4SrcPos,(prSrcImgInfo->u4ImgWidth/u4XSample));

                    }

		   }
              else
               {
                // Cb
                u4XSample = prSrcImgInfo->rBufferFormat.u4HSampleFactor[0] / prSrcImgInfo->rBufferFormat.u4HSampleFactor[1];
                u4YSample = prSrcImgInfo->rBufferFormat.u4VSampleFactor[0] / prSrcImgInfo->rBufferFormat.u4VSampleFactor[1];
                for(u4Y=0; u4Y<prSrcImgInfo->u4ImgHeight; u4Y+=u4YSample)
                {
                    u4SrcPos = prSrcImgInfo->u4BufSA2 + ((prSrcImgInfo->u4ImgYOff + u4Y) / u4YSample) * prSrcImgInfo->u4BufWidth + (prSrcImgInfo->u4ImgXOff / u4XSample);
                    u4DestPos = prDestImgInfo->u4BufSA2 + ((prDestImgInfo->u4ImgYOff + u4Y) / u4YSample) * prDestImgInfo->u4BufWidth + (prDestImgInfo->u4ImgXOff / u4XSample);
                    x_memcpy((void *)u4DestPos,(void *)u4SrcPos,(prSrcImgInfo->u4ImgWidth/u4XSample));
#if 0
                    for(u4X=0; u4X<prSrcImgInfo->u4ImgWidth; u4X+=u4XSample)
                    {
                        *(UCHAR *)u4DestPos = *(UCHAR *)u4SrcPos;

                        u4SrcPos++;
                        u4DestPos++;
                    }
#endif
                }

                // Cr
                u4XSample = prSrcImgInfo->rBufferFormat.u4HSampleFactor[0] / prSrcImgInfo->rBufferFormat.u4HSampleFactor[2];
                u4YSample = prSrcImgInfo->rBufferFormat.u4VSampleFactor[0] / prSrcImgInfo->rBufferFormat.u4VSampleFactor[2];
                for(u4Y=0; u4Y<prSrcImgInfo->u4ImgHeight; u4Y+=u4YSample)
                {
                    u4SrcPos = prSrcImgInfo->u4BufSA3 + ((prSrcImgInfo->u4ImgYOff + u4Y) / u4YSample) * prSrcImgInfo->u4BufWidth + (prSrcImgInfo->u4ImgXOff / u4XSample);
                    u4DestPos = prDestImgInfo->u4BufSA3 + ((prDestImgInfo->u4ImgYOff + u4Y) / u4YSample) * prDestImgInfo->u4BufWidth + (prDestImgInfo->u4ImgXOff / u4XSample);
                    x_memcpy((void *)u4DestPos,(void *)u4SrcPos,(prSrcImgInfo->u4ImgWidth/u4XSample));
#if 0
                    for(u4X=0; u4X<prSrcImgInfo->u4ImgWidth; u4X+=u4XSample)
                    {
                        *(UCHAR *)u4DestPos = *(UCHAR *)u4SrcPos;

                        u4SrcPos++;
                        u4DestPos++;
                    }
#endif
                }
            }
            }

            break;
        case IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER:
        case IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER:
            {
                UINT32 u4Y;
                UINT32 u4SrcPos,u4DestPos;
                UINT32 u4Bits = 0;

                switch(prSrcImgInfo->rBufferFormat.eARGBBufferFormat)
                {
                    case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_0565:
                    case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_1555:
                    case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_4444:
                        u4Bits = 16;
                        break;
                    case IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888:
                        u4Bits = 32;
                        break;
                }

                if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER)
                    u4Bits = 32;

                for(u4Y=0; u4Y<prSrcImgInfo->u4ImgHeight; u4Y++)
                {
                    u4SrcPos = prSrcImgInfo->u4BufSA1 + (prSrcImgInfo->u4ImgYOff + u4Y) * prSrcImgInfo->u4BufWidth + prSrcImgInfo->u4ImgXOff * u4Bits / 8;
                    u4DestPos = prDestImgInfo->u4BufSA1 + (prDestImgInfo->u4ImgYOff + u4Y) * prDestImgInfo->u4BufWidth + prDestImgInfo->u4ImgXOff * u4Bits / 8;
                    x_memcpy((void *)u4DestPos,(void *)u4SrcPos,prSrcImgInfo->u4ImgWidth*u4Bits/8);
#if 0
                    for(u4X=0; u4X<prSrcImgInfo->u4ImgWidth; u4X++)
                    {
                        *(UCHAR *)u4DestPos = *(UCHAR *)u4SrcPos;
                        u4SrcPos++;
                        u4DestPos++;
                        *(UCHAR *)u4DestPos = *(UCHAR *)u4SrcPos;
                        u4SrcPos++;
                        u4DestPos++;

                        if(u4Bits == 32)
                        {
                            *(UCHAR *)u4DestPos = *(UCHAR *)u4SrcPos;
                            u4SrcPos++;
                            u4DestPos++;
                            *(UCHAR *)u4DestPos = *(UCHAR *)u4SrcPos;
                            u4SrcPos++;
                            u4DestPos++;
                        }
                    }
#endif
                }
            }
            break;
        case IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_INDEX_BUFFER:
            {
                UINT32 u4Y;
                UINT32 u4SrcPos,u4DestPos;
                UINT32 u4Bits = 0;

                switch(prSrcImgInfo->rBufferFormat.eIndexBufferFormat)
                {
                    case IMGRESZ_HAL_INDEX_BUFFER_FORMAT_8BPP:
                        u4Bits = 8;
                        break;
                    case IMGRESZ_HAL_INDEX_BUFFER_FORMAT_4BPP:
                        u4Bits = 4;
                        break;
                    case IMGRESZ_HAL_INDEX_BUFFER_FORMAT_2BPP:
                        u4Bits = 2;
                        break;
                }

                for(u4Y=0; u4Y<prSrcImgInfo->u4ImgHeight; u4Y++)
                {
                    u4SrcPos = prSrcImgInfo->u4BufSA1 + (prSrcImgInfo->u4ImgYOff + u4Y) * prSrcImgInfo->u4BufWidth + prSrcImgInfo->u4ImgXOff * u4Bits / 8;
                    u4DestPos = prDestImgInfo->u4BufSA1 + (prDestImgInfo->u4ImgYOff + u4Y) * prDestImgInfo->u4BufWidth + prDestImgInfo->u4ImgXOff * u4Bits / 8;
                    x_memcpy((void *)u4DestPos,(void *)u4SrcPos,prSrcImgInfo->u4ImgWidth*u4Bits/8);
#if 0
                    for(u4X=0; u4X<(prSrcImgInfo->u4ImgWidth*u4Bits/8); u4X++)
                    {
                        *(UCHAR *)u4DestPos = *(UCHAR *)u4SrcPos;
                        u4SrcPos++;
                        u4DestPos++;
                    }
#endif
                }
            }
            break;
    }
}


void vImgReszVfyBufEnBlock(UINT32 u4SrcBufSA,UINT32 u4DestBufSA,UINT32 u4BufWidth,UINT32 u4BufHeight,
                           UINT32 u4BlockWidth,UINT32 u4BlockHeight)
{
	UINT32 u4Addr;
	UINT32 u4Len;
	UINT32 u4X,u4Y;

    u4X = 0;
    u4Y = 0;
    u4Len = u4BufWidth*u4BufHeight;
    u4Addr = 0;

    while(u4Addr<u4Len)
    {
        *(UCHAR *)(u4DestBufSA + u4Addr) = *(UCHAR *)(u4SrcBufSA + u4Y*u4BufWidth + u4X);
        u4Addr++;
        u4X++;
        if((u4X % u4BlockWidth) == 0)
        {
            u4X -= u4BlockWidth;
            u4Y++;
            if((u4Y % u4BlockHeight) == 0)
            {
                u4Y -= u4BlockHeight;
                u4X += u4BlockWidth;

                if(u4X>=u4BufWidth)
                {
                    u4Y += u4BlockHeight;
                    u4X = 0;
                }
            }
        }
    }
}


void vImgReszVfyBufDeBlock(UINT32 u4SrcBufSA,UINT32 u4DestBufSA,UINT32 u4BufWidth,UINT32 u4BufHeight,
                           UINT32 u4BlockWidth,UINT32 u4BlockHeight)
{
	UINT32 u4Addr;
	UINT32 u4Len;
	UINT32 u4X,u4Y;

    u4X = 0;
    u4Y = 0;
    u4Len = u4BufWidth*u4BufHeight;
    u4Addr = 0;

    while(u4Addr<u4Len)
    {
        *(UCHAR *)(u4DestBufSA + u4Y*u4BufWidth + u4X) = *(UCHAR *)(u4SrcBufSA + u4Addr);
        u4Addr++;
        u4X++;
        if((u4X % u4BlockWidth) == 0)
        {
            u4X -= u4BlockWidth;
            u4Y++;
            if((u4Y % u4BlockHeight) == 0)
            {
                u4Y -= u4BlockHeight;
                u4X += u4BlockWidth;

                if(u4X>=u4BufWidth)
                {
                    u4Y += u4BlockHeight;
                    u4X = 0;
                }
            }
        }
    }
}


void vImgReszVfyBimAddrSwap(UINT32 u4Region,BOOL fgOn,UINT32 u4BeginAddr,UINT32 u4EndAddr,UINT32 u4SwapMode)
{
    UINT32 u4RegValue;

    if(fgOn)
    {
        switch(u4Region)
        {
            case 0:
                BIM_WRITE32(REG_RW_SWAP_RG0_BGN,u4BeginAddr);
                BIM_WRITE32(REG_RW_SWAP_RG0_END,u4EndAddr);
                BIM_WRITE32(REG_RW_SWAP_CTRL,SWP_RG0_WREN | SWP_RG0_RDEN | ((u4SwapMode&0x7)<<8));
                break;
            case 1:
                BIM_WRITE32(REG_RW_SWAP_RG1_BGN,u4BeginAddr);
                BIM_WRITE32(REG_RW_SWAP_RG1_END,u4EndAddr);
                BIM_WRITE32(REG_RW_SWAP_CTRL,SWP_RG1_WREN | SWP_RG1_RDEN | ((u4SwapMode&0x7)<<12));
                break;
            case 2:
                BIM_WRITE32(REG_RW_SWAP_RG2_BGN,u4BeginAddr);
                BIM_WRITE32(REG_RW_SWAP_RG2_END,u4EndAddr);
                BIM_WRITE32(REG_RW_SWAP_CTRL,SWP_RG2_WREN | SWP_RG2_RDEN | ((u4SwapMode&0x7)<<24));
                break;
            case 3:
                BIM_WRITE32(REG_RW_SWAP_RG3_BGN,u4BeginAddr);
                BIM_WRITE32(REG_RW_SWAP_RG3_END,u4EndAddr);
                BIM_WRITE32(REG_RW_SWAP_CTRL,SWP_RG3_WREN | SWP_RG3_RDEN | ((u4SwapMode&0x7)<<28));
                break;
        }
    } else
    {
        switch(u4Region)
        {
            case 0:
                u4RegValue = BIM_READ32(REG_RW_SWAP_CTRL);
                u4RegValue &= ~(SWP_RG0_RDEN | SWP_RG0_WREN);
                BIM_WRITE32(REG_RW_SWAP_CTRL,u4RegValue);
                break;
            case 1:
                u4RegValue = BIM_READ32(REG_RW_SWAP_CTRL);
                u4RegValue &= ~(SWP_RG1_RDEN | SWP_RG1_WREN);
                BIM_WRITE32(REG_RW_SWAP_CTRL,u4RegValue);
                break;
            case 2:
                u4RegValue = BIM_READ32(REG_RW_SWAP_CTRL);
                u4RegValue &= ~(SWP_RG2_RDEN | SWP_RG2_WREN);
                BIM_WRITE32(REG_RW_SWAP_CTRL,u4RegValue);
                break;
            case 3:
                u4RegValue = BIM_READ32(REG_RW_SWAP_CTRL);
                u4RegValue &= ~(SWP_RG3_RDEN | SWP_RG3_WREN);
                BIM_WRITE32(REG_RW_SWAP_CTRL,u4RegValue);
                break;
        }
    }
}


void vImgReszVfyBufEnAddrSwap(UINT32 u4SrcBufSA,UINT32 u4DestBufSA,UINT32 u4BufLen)
{
    UINT32 u4Addr;
    UINT32 u4AddrSwap;

    if(_fgImgReszVfyBimAddrSwap)
    {
        // Turn on address swap
        vImgReszVfyBimAddrSwap(0,TRUE,u4DestBufSA,u4DestBufSA+u4BufLen,1);

        for(u4Addr=0; u4Addr<u4BufLen; u4Addr+=4)
        {
            *(UINT32 *)(u4DestBufSA + u4Addr) = *(UINT32 *)(u4SrcBufSA + u4Addr);
        }

        // Turn off address swap
        vImgReszVfyBimAddrSwap(0,FALSE,0,0,0);
    } else
    {
    u4BufLen >>= 4;

    for(u4Addr=0; u4Addr<u4BufLen; u4Addr++)
    {
        u4AddrSwap = (u4Addr & 0xFFFFFFC0) | ((u4Addr&0x38) >> 3) | ((u4Addr&0x6) << 2) | ((u4Addr&0x1) << 5); // Address mode (1,0)
        //u4AddrSwap = (u4Addr & 0xFFFFFFE0) | ((u4Addr&0x1E) >> 1) | ((u4Addr&0x1) << 4);  // Address mode (1,1)
        *(UINT32 *)(u4DestBufSA + (u4AddrSwap<<4)) = *(UINT32 *)(u4SrcBufSA + (u4Addr<<4));
        *(UINT32 *)(u4DestBufSA + (u4AddrSwap<<4) + 4) = *(UINT32 *)(u4SrcBufSA + (u4Addr<<4) + 4);
        *(UINT32 *)(u4DestBufSA + (u4AddrSwap<<4) + 8) = *(UINT32 *)(u4SrcBufSA + (u4Addr<<4) + 8);
        *(UINT32 *)(u4DestBufSA + (u4AddrSwap<<4) + 12) = *(UINT32 *)(u4SrcBufSA + (u4Addr<<4) + 12);
    }
}
}


void vImgReszVfyBufDeAddrSwap(UINT32 u4SrcBufSA,UINT32 u4DestBufSA,UINT32 u4BufLen)
{
    UINT32 u4Addr;
    UINT32 u4AddrSwap;

    if(_fgImgReszVfyBimAddrSwap)
    {
        // Turn on address swap
        vImgReszVfyBimAddrSwap(0,TRUE,u4SrcBufSA,u4SrcBufSA+u4BufLen,1);

        for(u4Addr=0; u4Addr<u4BufLen; u4Addr+=4)
        {
            *(UINT32 *)(u4DestBufSA + u4Addr) = *(UINT32 *)(u4SrcBufSA + u4Addr);
        }

        // Turn off address swap
        vImgReszVfyBimAddrSwap(0,FALSE,0,0,0);
    } else
    {
    u4BufLen >>= 4;

    for(u4Addr=0; u4Addr<u4BufLen; u4Addr++)
    {
        u4AddrSwap = (u4Addr & 0xFFFFFFC0) | ((u4Addr&0x7) << 3) | ((u4Addr&0x18) >> 2) | ((u4Addr&0x20) >> 5); // Address mode (1,0)
        //u4AddrSwap = (u4Addr & 0xFFFFFFE0) | ((u4Addr&0xF) << 1) | ((u4Addr&0x10) >> 4);  // Address mode (1,1)
        *(UINT32 *)(u4DestBufSA + (u4AddrSwap<<4)) = *(UINT32 *)(u4SrcBufSA + (u4Addr<<4));
        *(UINT32 *)(u4DestBufSA + (u4AddrSwap<<4) + 4) = *(UINT32 *)(u4SrcBufSA + (u4Addr<<4) + 4);
        *(UINT32 *)(u4DestBufSA + (u4AddrSwap<<4) + 8) = *(UINT32 *)(u4SrcBufSA + (u4Addr<<4) + 8);
        *(UINT32 *)(u4DestBufSA + (u4AddrSwap<<4) + 12) = *(UINT32 *)(u4SrcBufSA + (u4Addr<<4) + 12);
    }
}
}

//sun new
UINT32 _u4ImgReszVfyRMModeTempLineBuf[2] = { 0 };
INT32 i4ImgReszVfyMiniTestRM(UINT32 u4HwId)
{
    INT32 i4Ret = 0;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;

    UINT32 u4SrcBufY;
    UINT32 u4SrcBufC;
    UINT32 u4DestBufY;
    UINT32 u4DestBufC;

    IMGRESZ_HAL_PARTIAL_BUF_INFO_T rSrcRowBufInfo = { 0 };
    IMGRESZ_HAL_RM_INFO_T  rRMInfo = { 0 };

    _u4ImgReszVfyRMModeTempLineBuf[0] = (UINT32)x_alloc_aligned_dma_mem(360*240,1024);
    _u4ImgReszVfyRMModeTempLineBuf[1] = (UINT32)x_alloc_aligned_dma_mem(360*240,1024);

    u4SrcBufY = (UINT32)imgreszvfy_alloc_mem_aligned(360 * 240,32);
    u4DestBufY = (UINT32)imgreszvfy_alloc_mem_aligned(360 * 240,32);
    u4SrcBufC = (UINT32)imgreszvfy_alloc_mem_aligned(180 * 240,32);
    u4DestBufC = (UINT32)imgreszvfy_alloc_mem_aligned(180 * 240,32);

    // Buffer init
    {
        UINT32 u4I;

        for(u4I=0; u4I<(360 * 240); u4I++)
            *(UINT8 *)(u4SrcBufY + u4I) = (UINT8)u4I;

        for(u4I=0; u4I<(180 * 240); u4I++)
            *(UINT8 *)(u4SrcBufC + u4I) = (UINT8)u4I;

        for(u4I=0; u4I<(360 * 240); u4I++)
            *(UINT8 *)(u4DestBufY + u4I) = 0;

        for(u4I=0; u4I<(180 * 240); u4I++)
            *(UINT8 *)(u4DestBufC + u4I) = 0;
    }

    i4ImgResz_HAL_Init(u4HwId);
    i4ImgResz_HAL_Set_Resize_Mode(u4HwId,IMGRESZ_HAL_RESIZE_MODE_FRAME);
    i4ImgResz_HAL_Set_Resample_Method(u4HwId,IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR,
                                             IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR);
    x_memset(&rSrcImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    rSrcImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER;
    rSrcImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_IMG_YUV_FORMAT_420;
    rSrcImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;
    rSrcImgInfo.u4BufWidth = 360;
    rSrcImgInfo.u4BufHeight = 240;
    rSrcImgInfo.u4ImgWidth = 160;
    rSrcImgInfo.u4ImgHeight = 80;
    rSrcImgInfo.u4ImgXOff = 0;
    rSrcImgInfo.u4ImgYOff = 0;
    rSrcImgInfo.u4BufSA1 = u4SrcBufY;
    rSrcImgInfo.u4BufSA2 = u4SrcBufC;
    rSrcImgInfo.u4BufSA3 = 0;
    rSrcImgInfo.rBufferFormat.fgBlockMode = TRUE;
    i4ImgResz_HAL_Set_Source_Image_Info(u4HwId,&rSrcImgInfo);
    x_memset(&rDestImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER;
    rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_IMG_YUV_FORMAT_420;
    rDestImgInfo.u4BufWidth = 360;
    rDestImgInfo.u4BufHeight = 240;
    rDestImgInfo.u4ImgWidth = 160;
    rDestImgInfo.u4ImgHeight = 80;
    rDestImgInfo.u4ImgXOff = 0;
    rDestImgInfo.u4ImgYOff = 0;
    rDestImgInfo.u4BufSA1 = u4DestBufY;
    rDestImgInfo.u4BufSA2 = u4DestBufC;
    rDestImgInfo.u4BufSA3 = 0;
    rDestImgInfo.rBufferFormat.fgBlockMode = TRUE;
    i4ImgResz_HAL_Set_Destination_Image_Info(u4HwId,&rDestImgInfo);

    rRMInfo.fgRPRMode = TRUE;
    rRMInfo.fgRPRRacingModeEnable = FALSE;
    i4ImgResz_HAL_Set_RM_Info(u4HwId,&rRMInfo);
    i4ImgResz_HAL_Set_Partial_Mode_Info(u4HwId,&rSrcRowBufInfo,_u4ImgReszVfyRMModeTempLineBuf[u4HwId]);

    i4ImgResz_HAL_Resize(u4HwId);
    while(TRUE)
    {
        if(i4ImgResz_HAL_Get_Resize_Status(u4HwId)>=0)
            break;
    }
    i4ImgResz_HAL_Uninit(u4HwId);



    imgreszvfy_free_mem_aligned((void *)u4SrcBufY);
    imgreszvfy_free_mem_aligned((void *)u4SrcBufC);
    imgreszvfy_free_mem_aligned((void *)u4DestBufY);
    imgreszvfy_free_mem_aligned((void *)u4DestBufC);

    return i4Ret;
}


INT32 i4ImgReszVfyMiniTestARGB(UINT32 u4HwId)
{
    INT32 i4Ret = 0;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    UINT32 u4SrcBuf;
    UINT32 u4DestBuf;


    u4SrcBuf = (UINT32)imgreszvfy_alloc_mem_aligned(64,32);
    u4DestBuf = (UINT32)imgreszvfy_alloc_mem_aligned(64,32);


    // Buffer init
    {
        UINT32 u4I;

        for(u4I=0; u4I<64; u4I++)
            *(UINT8 *)(u4SrcBuf + u4I) = (UINT8)u4I;

        for(u4I=0; u4I<64; u4I++)
            *(UINT8 *)(u4DestBuf + u4I) = 0;
    }

    i4ImgResz_HAL_Init(u4HwId);
    i4ImgResz_HAL_Set_Resize_Mode(u4HwId,IMGRESZ_HAL_RESIZE_MODE_FRAME);
    i4ImgResz_HAL_Set_Resample_Method(u4HwId,IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR,
                                             IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR);
    x_memset(&rSrcImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    rSrcImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
    rSrcImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
    rSrcImgInfo.u4BufWidth = 16;
    rSrcImgInfo.u4BufHeight = 4;
    rSrcImgInfo.u4ImgWidth = 4;
    rSrcImgInfo.u4ImgHeight = 4;
    rSrcImgInfo.u4ImgXOff = 0;
    rSrcImgInfo.u4ImgYOff = 0;
    rSrcImgInfo.u4BufSA1 = u4SrcBuf;
    rSrcImgInfo.u4BufSA2 = 0;
    rSrcImgInfo.u4BufSA3 = 0;
    i4ImgResz_HAL_Set_Source_Image_Info(u4HwId,&rSrcImgInfo);
    x_memset(&rDestImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
    rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
    rDestImgInfo.u4BufWidth = 16;
    rDestImgInfo.u4BufHeight = 4;
    rDestImgInfo.u4ImgWidth = 4;
    rDestImgInfo.u4ImgHeight = 4;
    rDestImgInfo.u4ImgXOff = 0;
    rDestImgInfo.u4ImgYOff = 0;
    rDestImgInfo.u4BufSA1 = u4DestBuf;
    rDestImgInfo.u4BufSA2 = 0;
    rDestImgInfo.u4BufSA3 = 0;
    i4ImgResz_HAL_Set_Destination_Image_Info(u4HwId,&rDestImgInfo);

    i4ImgResz_HAL_Resize(u4HwId);
    while(TRUE)
    {
        if(i4ImgResz_HAL_Get_Resize_Status(u4HwId)>=0)
            break;
    }
    i4ImgResz_HAL_Uninit(u4HwId);

    // Verify buffer data
    {
        UINT32 u4I;

        for(u4I=0; u4I<64; u4I++)
        {
            if(*(UINT8 *)(u4DestBuf + u4I) != (UINT8)u4I)
                i4Ret = -1;

         }
    }

    imgreszvfy_free_mem_aligned((void *)u4SrcBuf);
    imgreszvfy_free_mem_aligned((void *)u4DestBuf);

    return i4Ret;
}


INT32 i4ImgReszVfyMiniTestIndex(UINT32 u4HwId)
{
    INT32 i4Ret = 0;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    UINT32 u4SrcBuf;
    UINT32 u4DestBuf;
    UINT32 u4ColorPallet;

    u4SrcBuf = (UINT32)imgreszvfy_alloc_mem_aligned(64,16);
    u4DestBuf = (UINT32)imgreszvfy_alloc_mem_aligned(256,16);
    u4ColorPallet = (UINT32)imgreszvfy_alloc_mem_aligned(256*4,1);

    // Buffer init
    {
        UINT32 u4I;

        for(u4I=0; u4I<64; u4I++)
            *(UINT8 *)(u4SrcBuf + u4I) = (UINT8)u4I;

        for(u4I=0; u4I<256; u4I++)
            *(UINT8 *)(u4DestBuf + u4I) = 0;

        for(u4I=0; u4I<(256*4); u4I+=4)
        {
            *(UINT8 *)(u4ColorPallet + u4I) = (UINT8)((u4I + 3) & 0xFF);
            *(UINT8 *)(u4ColorPallet + u4I + 1) = (UINT8)((u4I + 2) & 0xFF);
            *(UINT8 *)(u4ColorPallet + u4I + 2) = (UINT8)((u4I + 1) & 0xFF);
            *(UINT8 *)(u4ColorPallet + u4I + 3) = (UINT8)(u4I & 0xFF);
        }
    }

    i4ImgResz_HAL_Init(u4HwId);
    i4ImgResz_HAL_Set_Resize_Mode(u4HwId,IMGRESZ_HAL_RESIZE_MODE_FRAME);
    i4ImgResz_HAL_Set_Resample_Method(u4HwId,IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR,
                                             IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR);
    x_memset(&rSrcImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    rSrcImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_INDEX_BUFFER;
    rSrcImgInfo.rBufferFormat.eIndexBufferFormat = IMGRESZ_HAL_INDEX_BUFFER_FORMAT_8BPP;
    rSrcImgInfo.rBufferFormat.prColorPallet = (IMGRESZ_HAL_ARGB_COLOR_T *)u4ColorPallet;
    rSrcImgInfo.u4BufWidth = 16;
    rSrcImgInfo.u4BufHeight = 4;
    rSrcImgInfo.u4ImgWidth = 16;
    rSrcImgInfo.u4ImgHeight = 4;
    rSrcImgInfo.u4ImgXOff = 0;
    rSrcImgInfo.u4ImgYOff = 0;
    rSrcImgInfo.u4BufSA1 = u4SrcBuf;
    rSrcImgInfo.u4BufSA2 = 0;
    rSrcImgInfo.u4BufSA3 = 0;
    i4ImgResz_HAL_Set_Source_Image_Info(u4HwId,&rSrcImgInfo);
    x_memset(&rDestImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
    rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
    rDestImgInfo.u4BufWidth = 64;
    rDestImgInfo.u4BufHeight = 4;
    rDestImgInfo.u4ImgWidth = 16;
    rDestImgInfo.u4ImgHeight = 4;
    rDestImgInfo.u4ImgXOff = 0;
    rDestImgInfo.u4ImgYOff = 0;
    rDestImgInfo.u4BufSA1 = u4DestBuf;
    rDestImgInfo.u4BufSA2 = 0;
    rDestImgInfo.u4BufSA3 = 0;
    i4ImgResz_HAL_Set_Destination_Image_Info(u4HwId,&rDestImgInfo);

    i4ImgResz_HAL_Resize(u4HwId);
    while(TRUE)
    {
        if(i4ImgResz_HAL_Get_Resize_Status(u4HwId)>=0)
            break;
    }
    i4ImgResz_HAL_Uninit(u4HwId);

    // Verify buffer data
    {
        UINT32 u4I;

        for(u4I=0; u4I<256; u4I++)
            if(*(UINT8 *)(u4DestBuf + u4I) != (UINT8)u4I)
                i4Ret = -1;
    }

    imgreszvfy_free_mem_aligned((void *)u4SrcBuf);
    imgreszvfy_free_mem_aligned((void *)u4DestBuf);
    imgreszvfy_free_mem_aligned((void *)u4ColorPallet);

    return i4Ret;
}


INT32 i4ImgReszVfyMiniTestJpeg(UINT32 u4HwId)
{
    INT32 i4Ret = 0;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    UINT32 u4SrcBufY;
    UINT32 u4SrcBufCb;
    UINT32 u4SrcBufCr;
    UINT32 u4DestBuf;

    u4SrcBufY = (UINT32)imgreszvfy_alloc_mem_aligned(1024,16);
    u4SrcBufCb = (UINT32)imgreszvfy_alloc_mem_aligned(1024,16);
    u4SrcBufCr = (UINT32)imgreszvfy_alloc_mem_aligned(1024,16);
    u4DestBuf = (UINT32)imgreszvfy_alloc_mem_aligned(4096,16);

    // Buffer init
    {
        UINT32 u4I;

        for(u4I=0; u4I<1024; u4I++)
            *(UINT8 *)(u4SrcBufY + u4I) = (UINT8)((u4I<<2) & 0xFF);

        for(u4I=0; u4I<1024; u4I++)
            *(UINT8 *)(u4SrcBufCb + u4I) = (UINT8)(((u4I<<2)+64) & 0xFF);

        for(u4I=0; u4I<1024; u4I++)
            *(UINT8 *)(u4SrcBufCr + u4I) = (UINT8)(((u4I<<2)+128) & 0xFF);

        for(u4I=0; u4I<4096; u4I++)
            *(UINT8 *)(u4DestBuf + u4I) = 0;
    }

    i4ImgResz_HAL_Init(u4HwId);
    i4ImgResz_HAL_Set_Resize_Mode(u4HwId,IMGRESZ_HAL_RESIZE_MODE_PARTIAL);
    i4ImgResz_HAL_Set_Resample_Method(u4HwId,IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR,
                                             IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR);
    x_memset(&rSrcImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    rSrcImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER;
    rSrcImgInfo.rBufferFormat.u4HSampleFactor[0] = 1;
    rSrcImgInfo.rBufferFormat.u4HSampleFactor[1] = 1;
    rSrcImgInfo.rBufferFormat.u4HSampleFactor[2] = 1;
    rSrcImgInfo.rBufferFormat.u4VSampleFactor[0] = 1;
    rSrcImgInfo.rBufferFormat.u4VSampleFactor[1] = 1;
    rSrcImgInfo.rBufferFormat.u4VSampleFactor[2] = 1;
    rSrcImgInfo.u4BufWidth = 16;
    rSrcImgInfo.u4BufHeight = 64;
    rSrcImgInfo.u4ImgWidth = 16;
    rSrcImgInfo.u4ImgHeight = 64;
    rSrcImgInfo.u4ImgXOff = 0;
    rSrcImgInfo.u4ImgYOff = 0;
    rSrcImgInfo.u4BufSA1 = u4SrcBufY;
    rSrcImgInfo.u4BufSA2 = u4SrcBufCb;
    rSrcImgInfo.u4BufSA3 = u4SrcBufCr;
    i4ImgResz_HAL_Set_Source_Image_Info(u4HwId,&rSrcImgInfo);
    x_memset(&rDestImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
    rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
    rDestImgInfo.u4BufWidth = 64;
    rDestImgInfo.u4BufHeight = 64;
    rDestImgInfo.u4ImgWidth = 16;
    rDestImgInfo.u4ImgHeight = 64;
    rDestImgInfo.u4ImgXOff = 0;
    rDestImgInfo.u4ImgYOff = 0;
    rDestImgInfo.u4BufSA1 = u4DestBuf;
    rDestImgInfo.u4BufSA2 = 0;
    rDestImgInfo.u4BufSA3 = 0;
    i4ImgResz_HAL_Set_Destination_Image_Info(u4HwId,&rDestImgInfo);

    // Partial mode resize
    {
        UINT32 u4RowBufHeight = 16;
        UINT32 u4RowBufY;
        IMGRESZ_HAL_PARTIAL_BUF_INFO_T rSrcRowBufInfo;
        UINT32 u4TempLineBuf;

        u4TempLineBuf = (UINT32)imgreszvfy_alloc_mem_aligned(rDestImgInfo.u4BufWidth*3,16);
        x_memset(&rSrcRowBufInfo,0,sizeof(IMGRESZ_HAL_PARTIAL_BUF_INFO_T));
        rSrcRowBufInfo.u4RowBufHeight = u4RowBufHeight;

        for(u4RowBufY=0; u4RowBufY<rSrcImgInfo.u4ImgHeight; u4RowBufY+=u4RowBufHeight)
        {
            if(u4RowBufY == 0)
                rSrcRowBufInfo.fgFirstRowBuf = TRUE;
            else
                rSrcRowBufInfo.fgFirstRowBuf = FALSE;

            if((u4RowBufY + u4RowBufHeight) < rSrcImgInfo.u4ImgHeight)
                rSrcRowBufInfo.fgLastRowBuf = FALSE;
            else
                rSrcRowBufInfo.fgLastRowBuf = TRUE;

            rSrcRowBufInfo.u4PrevRowBufSA1 = rSrcRowBufInfo.u4CurRowBufSA1;
            rSrcRowBufInfo.u4PrevRowBufSA2 = rSrcRowBufInfo.u4CurRowBufSA2;
            rSrcRowBufInfo.u4PrevRowBufSA3 = rSrcRowBufInfo.u4CurRowBufSA3;

            rSrcRowBufInfo.u4CurRowBufSA1 = rSrcImgInfo.u4BufSA1 + u4RowBufY * rSrcImgInfo.u4BufWidth;
            if(rSrcImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
            {
                rSrcRowBufInfo.u4CurRowBufSA2 = rSrcImgInfo.u4BufSA2 + (u4RowBufY
                                                                     * rSrcImgInfo.rBufferFormat.u4VSampleFactor[1]
                                                                     / rSrcImgInfo.rBufferFormat.u4VSampleFactor[0])
                                                                     * rSrcImgInfo.u4BufWidth;
                rSrcRowBufInfo.u4CurRowBufSA3 = rSrcImgInfo.u4BufSA3 + (u4RowBufY
                                                                     * rSrcImgInfo.rBufferFormat.u4VSampleFactor[2]
                                                                     / rSrcImgInfo.rBufferFormat.u4VSampleFactor[0])
                                                                     * rSrcImgInfo.u4BufWidth;
            }

            i4ImgResz_HAL_Set_Partial_Mode_Info(u4HwId,&rSrcRowBufInfo,u4TempLineBuf);
            i4ImgResz_HAL_Resize(u4HwId);
            while(TRUE)
            {
                if(i4ImgResz_HAL_Get_Resize_Status(u4HwId)>=0)
                    break;
            }
        }

        imgreszvfy_free_mem_aligned((void *)u4TempLineBuf);
    }

    i4ImgResz_HAL_Uninit(u4HwId);

    // Verify buffer data
    {
        UINT32 u4I;

        for(u4I=0; u4I<4096; u4I+=4)
        {
            if(*(UINT8 *)(u4DestBuf + u4I) != (UINT8)((u4I+128) & 0xFF))
                i4Ret = -1;
            if(*(UINT8 *)(u4DestBuf + u4I+1) != (UINT8)((u4I+64) & 0xFF))
                i4Ret = -1;
            if(*(UINT8 *)(u4DestBuf + u4I+2) != (UINT8)(u4I & 0xFF))
                i4Ret = -1;
            if(*(UINT8 *)(u4DestBuf + u4I+3) != 0xFF)
                i4Ret = -1;
        }
    }

    imgreszvfy_free_mem_aligned((void *)u4SrcBufY);
    imgreszvfy_free_mem_aligned((void *)u4SrcBufCb);
    imgreszvfy_free_mem_aligned((void *)u4SrcBufCr);
    imgreszvfy_free_mem_aligned((void *)u4DestBuf);

    return i4Ret;
}


INT32 i4ImgReszVfyMiniTestVideo(UINT32 u4HwId)
{
    INT32 i4Ret = 0;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    UINT32 u4SrcBufY;
    UINT32 u4SrcBufC;
    UINT32 u4DestBufY;
    UINT32 u4DestBufC;

    u4SrcBufY = (UINT32)imgreszvfy_alloc_mem_aligned(1024,16);
    u4SrcBufC = (UINT32)imgreszvfy_alloc_mem_aligned(512,16);
    u4DestBufY = (UINT32)imgreszvfy_alloc_mem_aligned(1024,16);
    u4DestBufC = (UINT32)imgreszvfy_alloc_mem_aligned(512,16);

    // Buffer init
    {
        UINT32 u4I;

        for(u4I=0; u4I<1024; u4I++)
            *(UINT8 *)(u4SrcBufY + u4I) = (UINT8)(u4I & 0xFF);

        for(u4I=0; u4I<512; u4I++)
            *(UINT8 *)(u4SrcBufC + u4I) = (UINT8)(u4I & 0xFF);

        for(u4I=0; u4I<1024; u4I++)
            *(UINT8 *)(u4DestBufY + u4I) = 0;

        for(u4I=0; u4I<512; u4I++)
            *(UINT8 *)(u4DestBufC + u4I) = 0;
    }

    i4ImgResz_HAL_Init(u4HwId);
    i4ImgResz_HAL_Set_Resize_Mode(u4HwId,IMGRESZ_HAL_RESIZE_MODE_FRAME);
    i4ImgResz_HAL_Set_Resample_Method(u4HwId,IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR,
                                             IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR);
    x_memset(&rSrcImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    rSrcImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER;
    rSrcImgInfo.rBufferFormat.fgProgressiveFrame = FALSE;
    rSrcImgInfo.rBufferFormat.eYUVFormat = IMGRESZ_HAL_IMG_YUV_FORMAT_420;
    rSrcImgInfo.rBufferFormat.fgBlockMode = TRUE;
    rSrcImgInfo.rBufferFormat.fgAddrSwap = FALSE;
    rSrcImgInfo.u4BufWidth = 32;
    rSrcImgInfo.u4BufHeight = 32;
    rSrcImgInfo.u4ImgWidth = 32;
    rSrcImgInfo.u4ImgHeight = 32;
    rSrcImgInfo.u4ImgXOff = 0;
    rSrcImgInfo.u4ImgYOff = 0;
    rSrcImgInfo.u4BufSA1 = u4SrcBufY;
    rSrcImgInfo.u4BufSA2 = u4SrcBufC;
    rSrcImgInfo.u4BufSA3 = 0;
    i4ImgResz_HAL_Set_Source_Image_Info(u4HwId,&rSrcImgInfo);
    x_memset(&rDestImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER;
    rDestImgInfo.rBufferFormat.fgProgressiveFrame = FALSE;
    rDestImgInfo.rBufferFormat.eYUVFormat = IMGRESZ_HAL_IMG_YUV_FORMAT_420;
    rDestImgInfo.rBufferFormat.fgBlockMode = TRUE;
    rDestImgInfo.rBufferFormat.fgAddrSwap = FALSE;
    rDestImgInfo.u4BufWidth = 32;
    rDestImgInfo.u4BufHeight = 32;
    rDestImgInfo.u4ImgWidth = 32;
    rDestImgInfo.u4ImgHeight = 32;
    rDestImgInfo.u4ImgXOff = 0;
    rDestImgInfo.u4ImgYOff = 0;
    rDestImgInfo.u4BufSA1 = u4DestBufY;
    rDestImgInfo.u4BufSA2 = u4DestBufC;
    rDestImgInfo.u4BufSA3 = 0;
    i4ImgResz_HAL_Set_Destination_Image_Info(u4HwId,&rDestImgInfo);

    // Interlace resize
    {
        rSrcImgInfo.rBufferFormat.fgProgressiveFrame = FALSE;
        rSrcImgInfo.u4ImgHeight >>= 1;
        rDestImgInfo.u4ImgHeight >>= 1;
        i4ImgResz_HAL_Set_Destination_Image_Info(u4HwId,&rDestImgInfo);

        // Top field resize
        rSrcImgInfo.rBufferFormat.fgTopField = TRUE;
        i4ImgResz_HAL_Set_Source_Image_Info(u4HwId,&rSrcImgInfo);
        i4ImgResz_HAL_Resize(u4HwId);
        while(TRUE)
        {
            if(i4ImgResz_HAL_Get_Resize_Status(u4HwId)>=0)
                break;
        }

        // Bottom field resize
        rSrcImgInfo.rBufferFormat.fgTopField = FALSE;
        i4ImgResz_HAL_Set_Source_Image_Info(u4HwId,&rSrcImgInfo);
        i4ImgResz_HAL_Resize(u4HwId);
        while(TRUE)
        {
            if(i4ImgResz_HAL_Get_Resize_Status(u4HwId)>=0)
                break;
        }
    }

    i4ImgResz_HAL_Uninit(u4HwId);

    // Verify buffer data
    {
        UINT32 u4I;

        for(u4I=0; u4I<1024; u4I++)
            if(*(UINT8 *)(u4DestBufY + u4I) != (UINT8)(u4I & 0xFF))
                i4Ret = -1;

        for(u4I=0; u4I<512; u4I++)
            if(*(UINT8 *)(u4DestBufC + u4I) != (UINT8)(u4I & 0xFF))
                i4Ret = -1;
    }

    imgreszvfy_free_mem_aligned((void *)u4SrcBufY);
    imgreszvfy_free_mem_aligned((void *)u4SrcBufC);
    imgreszvfy_free_mem_aligned((void *)u4DestBufY);
    imgreszvfy_free_mem_aligned((void *)u4DestBufC);

    return i4Ret;
}


#ifdef IMGRESZ_HAL_MT8530
void vImgReszMiniWTTest(UINT32 u4HwId)
{
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    UINT32 u4SrcBuf;
    UINT32 u4DestBuf;
    UINT32 u4WTBuf;
    UINT32 u4ImageWidth = 4, u4ImageHeight = 4;
    UINT32 u4BufWidth = u4ImageWidth * 4, u4BufHeight = u4ImageHeight;
    UINT32 u4BufSize = u4BufWidth*u4BufHeight;

    // Turn on WT
    *((volatile UINT32*)(0x70040800)) = (*((volatile UINT32*)(0x70040800))) & 0xFFFEFFFF;

    u4SrcBuf = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
    u4DestBuf = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
    u4WTBuf = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);

    {
        UINT32 u4I;

        for(u4I=0; u4I<u4BufSize; u4I++)
            *(UINT8 *)(u4SrcBuf + u4I) = (UINT8)u4I;

        for(u4I=0; u4I<u4BufSize; u4I++)
            *(UINT8 *)(u4DestBuf + u4I) = 0;

        for(u4I=0; u4I<u4BufSize; u4I++)
            *(UINT8 *)(u4WTBuf + u4I) = 0;
    }

    // Source buffer to WT buffer
    i4ImgResz_HAL_Init(u4HwId);
    i4ImgResz_HAL_Set_Resize_Mode(u4HwId,IMGRESZ_HAL_RESIZE_MODE_FRAME);
    i4ImgResz_HAL_Set_Resample_Method(u4HwId,IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR,
                                             IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR);
    memset(&rSrcImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    rSrcImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
    rSrcImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
    rSrcImgInfo.rBufferFormat.fgWT = FALSE;
    rSrcImgInfo.u4BufWidth = u4BufWidth;
    rSrcImgInfo.u4BufHeight = u4BufHeight;
    rSrcImgInfo.u4ImgWidth = u4ImageWidth;
    rSrcImgInfo.u4ImgHeight = u4ImageHeight;
    rSrcImgInfo.u4ImgXOff = 0;
    rSrcImgInfo.u4ImgYOff = 0;
    rSrcImgInfo.u4BufSA1 = u4SrcBuf;
    rSrcImgInfo.u4BufSA2 = 0;
    rSrcImgInfo.u4BufSA3 = 0;
    i4ImgResz_HAL_Set_Source_Image_Info(u4HwId,&rSrcImgInfo);
    memset(&rDestImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
    rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
    rDestImgInfo.rBufferFormat.fgWT = TRUE;
    rDestImgInfo.u4BufWidth = u4BufWidth;
    rDestImgInfo.u4BufHeight = u4BufHeight;
    rDestImgInfo.u4ImgWidth = u4ImageWidth;
    rDestImgInfo.u4ImgHeight = u4ImageHeight;
    rDestImgInfo.u4ImgXOff = 0;
    rDestImgInfo.u4ImgYOff = 0;
    rDestImgInfo.u4BufSA1 = u4WTBuf;
    rDestImgInfo.u4BufSA2 = 0;
    rDestImgInfo.u4BufSA3 = 0;
    i4ImgResz_HAL_Set_Destination_Image_Info(u4HwId,&rDestImgInfo);

    i4ImgResz_HAL_Resize(u4HwId);
    while(TRUE)
    {
        if(i4ImgResz_HAL_Get_Resize_Status(u4HwId)>=0)
            break;
    }

    i4ImgResz_HAL_Uninit(u4HwId);

    // WT buffer to destination buffer
    i4ImgResz_HAL_Init(u4HwId);
    i4ImgResz_HAL_Set_Resize_Mode(u4HwId,IMGRESZ_HAL_RESIZE_MODE_FRAME);
    i4ImgResz_HAL_Set_Resample_Method(u4HwId,IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR,
                                             IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR);
    memset(&rSrcImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    rSrcImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
    rSrcImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
    rSrcImgInfo.rBufferFormat.fgWT = TRUE;
    rSrcImgInfo.u4BufWidth = u4BufWidth;
    rSrcImgInfo.u4BufHeight = u4BufHeight;
    rSrcImgInfo.u4ImgWidth = u4ImageWidth;
    rSrcImgInfo.u4ImgHeight = u4ImageHeight;
    rSrcImgInfo.u4ImgXOff = 0;
    rSrcImgInfo.u4ImgYOff = 0;
    rSrcImgInfo.u4BufSA1 = u4WTBuf;
    rSrcImgInfo.u4BufSA2 = 0;
    rSrcImgInfo.u4BufSA3 = 0;
    i4ImgResz_HAL_Set_Source_Image_Info(u4HwId,&rSrcImgInfo);
    memset(&rDestImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
    rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
    rDestImgInfo.rBufferFormat.fgWT = FALSE;
    rDestImgInfo.u4BufWidth = u4BufWidth;
    rDestImgInfo.u4BufHeight = u4BufHeight;
    rDestImgInfo.u4ImgWidth = u4ImageWidth;
    rDestImgInfo.u4ImgHeight = u4ImageHeight;
    rDestImgInfo.u4ImgXOff = 0;
    rDestImgInfo.u4ImgYOff = 0;
    rDestImgInfo.u4BufSA1 = u4DestBuf;
    rDestImgInfo.u4BufSA2 = 0;
    rDestImgInfo.u4BufSA3 = 0;
    i4ImgResz_HAL_Set_Destination_Image_Info(u4HwId,&rDestImgInfo);

    i4ImgResz_HAL_Resize(u4HwId);
    while(TRUE)
    {
        if(i4ImgResz_HAL_Get_Resize_Status(u4HwId)>=0)
            break;
    }

    i4ImgResz_HAL_Uninit(u4HwId);


    imgreszvfy_free_mem_aligned((void *)u4SrcBuf);
    imgreszvfy_free_mem_aligned((void *)u4DestBuf);
    imgreszvfy_free_mem_aligned((void *)u4WTBuf);
}
#endif

INT32 i4ImgReszVfyTestBasicARGB(void);
INT32 i4ImgReszVfyResz(UINT32 u4HwId,
                       IMGRESZ_HAL_RESIZE_MODE_T eResizeMode,
                       IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,
                       IMGRESZ_HAL_RESAMPLE_METHOD_T eVResampleMethod,
                       IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfo,
                       IMGRESZ_HAL_IMG_INFO_T *prDestImgInfo,
                       IMGRESZ_HAL_JPEG_INFO_T *prJpegInfo)
{
    i4ImgResz_HAL_Init(u4HwId);
    i4ImgResz_HAL_Set_Resize_Mode(u4HwId,eResizeMode);
    i4ImgResz_HAL_Set_Resample_Method(u4HwId,eHResampleMethod,
                                             eVResampleMethod);
    i4ImgResz_HAL_Set_Source_Image_Info(u4HwId,prSrcImgInfo);
    i4ImgResz_HAL_Set_Destination_Image_Info(u4HwId,prDestImgInfo);
    if (_fgAlphaB)
        i4ImgResz_HAL_Set_Blending_Image_Info(u4HwId, &rBlBufnfo);
    if (_fgScalingchange)
    {
                i4HwImgReszSetAlphaChangeScalingType(u4HwId,_u4AlphaScalingType);
#if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8530)
                i4HwImgReszSetAlphaChangeBilinearBoundary(u4HwId,_fgBilinearBoundary);
                i4HwImgReszSetOnlyDistinguishAlpha(u4HwId,_fgOnlyDistinquishAlpha);
#endif
    }
    if(_fg4to1Test)
        i4ImgResz_HAL_Set_4to1_Scale_Info(u4HwId,TRUE);


    if(_fgLumakeyTest)  //sun for temp
    {
	    i4ImgResz_HAL_Set_LumaKey(u4HwId,TRUE,0);
	    i4HwImgReszSetLumaKeyScalingType(u4HwId,_u4LumaKeyScalingType);
#if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8530)
        i4HwImgReszSetLumaKeyBilinearBoundary(u4HwId,_fgBilinearBoundary);
#endif
#if(CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8560)
        i4HwImgReszSetLumaKeyYUVMode(u4HwId,_fgYUVMode);
 #endif
	}
    if(prJpegInfo != 0)
    {
        i4ImgResz_HAL_Set_Jpeg_Info(u4HwId,prJpegInfo);
    }
    if(eResizeMode == IMGRESZ_HAL_RESIZE_MODE_FRAME)
    {
        #if IMGRESZ_IO_MMU_TEST
    vIOMMU_OverRead_Protection(IOMMU_RESZ, 
                               1, 
                               prSrcImgInfo->u4BufSA1,
                               (prSrcImgInfo->u4BufWidth*prSrcImgInfo->u4BufHeight+1),
                               prDestImgInfo->u4BufSA1,
                               prDestImgInfo->u4BufWidth*prDestImgInfo->u4BufHeight+1);
#endif
        if((prSrcImgInfo->rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER) ||
           (prSrcImgInfo->rBufferFormat.fgProgressiveFrame))
        {
            // Progressive resize
            i4ImgResz_HAL_Resize(u4HwId);
#if IMGRESZ_PERFORMANCE_TEST
            HAL_GetTime(&_rImgreszStart);
#endif
            while(TRUE)
            {
                if(i4ImgResz_HAL_Get_Resize_Status(u4HwId)>=0)
                {
#if IMGRESZ_PERFORMANCE_TEST
                  HAL_GetTime(&_rImgreszEnd);
                  HAL_GetDeltaTime(&_rImgreszTime, &_rImgreszStart, &_rImgreszEnd);
	           i4ImgReszVfyPrintf ("[IMG_RESZ]Resize finish time=%d.%d\n",_rImgreszTime.u4Seconds,_rImgreszTime.u4Micros);
#endif
                    break;
            }
            }
        } else
        {
            // Interlace resize
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;

            x_memcpy(&rSrcImgInfo,prSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
            x_memcpy(&rDestImgInfo,prDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            rSrcImgInfo.u4ImgHeight >>= 1;
            rDestImgInfo.u4ImgHeight >>= 1;
            i4ImgResz_HAL_Set_Destination_Image_Info(u4HwId,&rDestImgInfo);

            // Top field resize
            rSrcImgInfo.rBufferFormat.fgTopField = TRUE;
            i4ImgResz_HAL_Set_Source_Image_Info(u4HwId,&rSrcImgInfo);
            i4ImgResz_HAL_Resize(u4HwId);
            while(TRUE)
            {
                if(i4ImgResz_HAL_Get_Resize_Status(u4HwId)>=0)
                    break;
            }

            // Bottom field resize
            rSrcImgInfo.rBufferFormat.fgTopField = FALSE;
            i4ImgResz_HAL_Set_Source_Image_Info(u4HwId,&rSrcImgInfo);
            i4ImgResz_HAL_Resize(u4HwId);
            while(TRUE)
            {
                if(i4ImgResz_HAL_Get_Resize_Status(u4HwId)>=0)
                {
                    break;
            }
        }
        }   
    } else if(eResizeMode == IMGRESZ_HAL_RESIZE_MODE_PARTIAL)
    {
        UINT32 u4RowBufHeight = 16;
        UINT32 u4RowBufY;
        IMGRESZ_HAL_PARTIAL_BUF_INFO_T rSrcRowBufInfo;
        UINT32 u4TempLineBuf;

//#if IMGRESZ_IO_MMU_TEST   //by chunze, 2010.11.19
//    u4TempLineBuf = (UINT32)GGT_get_vmem(prDestImgInfo->u4BufWidth*3);
//    i4ImgReszVfyPrintf("[ImgResz][Verify] templinebuf buffer size : %d,buf addr :%x.\n",prDestImgInfo->u4BufWidth*3,u4TempLineBuf);  
//#else
        u4TempLineBuf = (UINT32)imgreszvfy_alloc_mem_aligned(prDestImgInfo->u4BufWidth*6,16);
//#endif
        x_memset(&rSrcRowBufInfo,0,sizeof(IMGRESZ_HAL_PARTIAL_BUF_INFO_T));
        rSrcRowBufInfo.u4RowBufHeight = u4RowBufHeight;
#if IMGRESZ_IO_MMU_TEST
        vIOMMU_OverRead_Protection(IOMMU_RESZ, 
                               1, 
                               prSrcImgInfo->u4BufSA1,
                               (prSrcImgInfo->u4BufWidth*prSrcImgInfo->u4BufHeight+1),
                               prDestImgInfo->u4BufSA1,
                               prDestImgInfo->u4BufWidth*prDestImgInfo->u4BufHeight+1);
                               //u4TempLineBuf,
                               //prDestImgInfo->u4BufWidth*3+1);
#endif
        for(u4RowBufY=0; u4RowBufY<prSrcImgInfo->u4ImgHeight; u4RowBufY+=u4RowBufHeight)
        {
            if(u4RowBufY == 0)
                rSrcRowBufInfo.fgFirstRowBuf = TRUE;
            else
                rSrcRowBufInfo.fgFirstRowBuf = FALSE;

            if((u4RowBufY + u4RowBufHeight) < prSrcImgInfo->u4ImgHeight)
                rSrcRowBufInfo.fgLastRowBuf = FALSE;
            else
                rSrcRowBufInfo.fgLastRowBuf = TRUE;

            rSrcRowBufInfo.u4PrevRowBufSA1 = rSrcRowBufInfo.u4CurRowBufSA1;
            rSrcRowBufInfo.u4PrevRowBufSA2 = rSrcRowBufInfo.u4CurRowBufSA2;
            rSrcRowBufInfo.u4PrevRowBufSA3 = rSrcRowBufInfo.u4CurRowBufSA3;

            rSrcRowBufInfo.u4CurRowBufSA1 = prSrcImgInfo->u4BufSA1 + u4RowBufY * prSrcImgInfo->u4BufWidth;
            if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
            {
              UINT32 u4BufWidthC;
#if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8560)
               
    	        if((prSrcImgInfo->rBufferFormat.u4HSampleFactor[1] <prSrcImgInfo->rBufferFormat.u4HSampleFactor[0])
                 && (prSrcImgInfo->rBufferFormat.u4HSampleFactor[2] < prSrcImgInfo->rBufferFormat.u4HSampleFactor[0]))
    	        {
                 u4BufWidthC =((prSrcImgInfo->u4BufWidth/2 + 15) /16) * 16;
    	         }else
    	       {
    	          u4BufWidthC = prSrcImgInfo->u4BufWidth;
    	       }
#else
                u4BufWidthC = prSrcImgInfo->u4BufWidth;
#endif
                rSrcRowBufInfo.u4CurRowBufSA2 = prSrcImgInfo->u4BufSA2 + (u4RowBufY
                                                                     * prSrcImgInfo->rBufferFormat.u4VSampleFactor[1]
                                                                     / prSrcImgInfo->rBufferFormat.u4VSampleFactor[0])
                                                                     * u4BufWidthC;
                rSrcRowBufInfo.u4CurRowBufSA3 = prSrcImgInfo->u4BufSA3 + (u4RowBufY
                                                                     * prSrcImgInfo->rBufferFormat.u4VSampleFactor[2]
                                                                     / prSrcImgInfo->rBufferFormat.u4VSampleFactor[0])
                                                                     * u4BufWidthC;
            }

            i4ImgResz_HAL_Set_Partial_Mode_Info(u4HwId,&rSrcRowBufInfo,u4TempLineBuf);
            i4ImgResz_HAL_Resize(u4HwId);
            while(TRUE)
            {
                if(i4ImgResz_HAL_Get_Resize_Status(u4HwId)>=0)
                {                    
                    break;
            }
            }
            #if IMGRESZ_RESUME_BREAK
            {
                IMGRESZ_HAL_HW_STATUS_T rHwStatus;
                i4ImgReszVfyPrintf("[ImgResz][Verify] start break resume.\n");
                memset(&rHwStatus, 0x0, sizeof(IMGRESZ_HAL_HW_STATUS_T));
                i4ImgResz_HAL_Get_HW_Status(u4HwId, &rHwStatus);
                i4ImgResz_HAL_Uninit(u4HwId);
                //TBD
                //i4ImgReszVfyTestBasicARGB();
                i4ImgReszVfyMiniTestARGB(u4HwId);
                i4ImgResz_HAL_Init(u4HwId);
                i4ImgResz_HAL_Set_Resize_Mode(u4HwId, IMGRESZ_HAL_RESIZE_MODE_PARTIAL);
                i4ImgResz_HAL_Set_Resample_Method(u4HwId, eHResampleMethod, eVResampleMethod);
                i4ImgResz_HAL_Set_Source_Image_Info(u4HwId, prSrcImgInfo);
                i4ImgResz_HAL_Set_Destination_Image_Info(u4HwId, prDestImgInfo);
                i4ImgResz_HAL_Set_HW_Status(u4HwId, &rHwStatus);
            }
            #endif
        }
        UTIL_Printf("[ImgreszVfy]Partial mode Imgresz done\n");
//#if IMGRESZ_IO_MMU_TEST
     //   x_free_vmem((void *)u4TempLineBuf); 
//#else
        imgreszvfy_free_mem_aligned((void *)u4TempLineBuf);
//#endif

    }
#if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8580) 
    u4ImgReszCheckSum = i4HwImgReszGetHwCRC(u4HwId);
#endif    
    i4ImgResz_HAL_Uninit(u4HwId);

    return 0;
}

INT32 i4ImgReszVfyReszForFrame(UINT32 u4HwId,
                               IMGRESZ_HAL_RESIZE_MODE_T eResizeMode,
                               IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,
                               IMGRESZ_HAL_RESAMPLE_METHOD_T eVResampleMethod,
                               IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfo,
                               IMGRESZ_HAL_IMG_INFO_T *prDestImgInfo,
                               IMGRESZ_HAL_JPEG_INFO_T *prJpegInfo)
{
    i4ImgResz_HAL_Init(u4HwId);
    i4ImgResz_HAL_Set_Resize_Mode(u4HwId,eResizeMode);
    i4ImgResz_HAL_Set_Resample_Method(u4HwId,eHResampleMethod,
                                             eVResampleMethod);
    i4ImgResz_HAL_Set_Source_Image_Info(u4HwId,prSrcImgInfo);
    i4ImgResz_HAL_Set_Destination_Image_Info(u4HwId,prDestImgInfo);
    if(prJpegInfo != NULL)
    {
        i4ImgResz_HAL_Set_Jpeg_Info(u4HwId,prJpegInfo);
    }
    if(eResizeMode == IMGRESZ_HAL_RESIZE_MODE_FRAME)
    {
        if((prSrcImgInfo->rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER) ||
           (prSrcImgInfo->rBufferFormat.fgProgressiveFrame))
        {
            // Progressive resize
            i4ImgResz_HAL_Resize(u4HwId);
            while(TRUE)
            {
                if(i4ImgResz_HAL_Get_Resize_Status(u4HwId)>=0)
                    break;
            }
        } else
        {
            // Interlace resize
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;

            x_memcpy(&rSrcImgInfo,prSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
            x_memcpy(&rDestImgInfo,prDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            rSrcImgInfo.u4ImgHeight >>= 1;
            rDestImgInfo.u4ImgHeight >>= 1;
            i4ImgResz_HAL_Set_Destination_Image_Info(u4HwId,&rDestImgInfo);

            // Top field resize
            rSrcImgInfo.rBufferFormat.fgTopField = TRUE;
            i4ImgResz_HAL_Set_Source_Image_Info(u4HwId,&rSrcImgInfo);
            i4ImgResz_HAL_Resize(u4HwId);
            while(TRUE)
            {
                if(i4ImgResz_HAL_Get_Resize_Status(u4HwId)>=0)
                    break;
            }

            // Bottom field resize
            rSrcImgInfo.rBufferFormat.fgTopField = FALSE;
            i4ImgResz_HAL_Set_Source_Image_Info(u4HwId,&rSrcImgInfo);
            i4ImgResz_HAL_Resize(u4HwId);
            while(TRUE)
            {
                if(i4ImgResz_HAL_Get_Resize_Status(u4HwId)>=0)
                    break;
            }
        }
    } else if(eResizeMode == IMGRESZ_HAL_RESIZE_MODE_PARTIAL)
    {
        UINT32 u4RowBufHeight = 16;
        UINT32 u4RowBufY;
        IMGRESZ_HAL_PARTIAL_BUF_INFO_T rSrcRowBufInfo;
        UINT32 u4TempLineBuf;

        u4TempLineBuf = (UINT32)imgreszvfy_alloc_mem_aligned(prDestImgInfo->u4BufWidth*3,16);
        x_memset(&rSrcRowBufInfo,0,sizeof(IMGRESZ_HAL_PARTIAL_BUF_INFO_T));
        rSrcRowBufInfo.u4RowBufHeight = u4RowBufHeight;

        for(u4RowBufY=0; u4RowBufY<prSrcImgInfo->u4ImgHeight; u4RowBufY+=u4RowBufHeight)
        {
            if(u4RowBufY == 0)
                rSrcRowBufInfo.fgFirstRowBuf = TRUE;
            else
                rSrcRowBufInfo.fgFirstRowBuf = FALSE;

            if((u4RowBufY + u4RowBufHeight) < prSrcImgInfo->u4ImgHeight)
                rSrcRowBufInfo.fgLastRowBuf = FALSE;
            else
                rSrcRowBufInfo.fgLastRowBuf = TRUE;

            rSrcRowBufInfo.u4PrevRowBufSA1 = rSrcRowBufInfo.u4CurRowBufSA1;
            rSrcRowBufInfo.u4PrevRowBufSA2 = rSrcRowBufInfo.u4CurRowBufSA2;
            rSrcRowBufInfo.u4PrevRowBufSA3 = rSrcRowBufInfo.u4CurRowBufSA3;

            rSrcRowBufInfo.u4CurRowBufSA1 = prSrcImgInfo->u4BufSA1 + u4RowBufY * prSrcImgInfo->u4BufWidth;
            if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
            {
                rSrcRowBufInfo.u4CurRowBufSA2 = prSrcImgInfo->u4BufSA2 + (u4RowBufY
                                                                     * prSrcImgInfo->rBufferFormat.u4VSampleFactor[1]
                                                                     / prSrcImgInfo->rBufferFormat.u4VSampleFactor[0])
                                                                     * prSrcImgInfo->u4BufWidth;
                rSrcRowBufInfo.u4CurRowBufSA3 = prSrcImgInfo->u4BufSA3 + (u4RowBufY
                                                                     * prSrcImgInfo->rBufferFormat.u4VSampleFactor[2]
                                                                     / prSrcImgInfo->rBufferFormat.u4VSampleFactor[0])
                                                                     * prSrcImgInfo->u4BufWidth;
            }

            i4ImgResz_HAL_Set_Partial_Mode_Info(u4HwId,&rSrcRowBufInfo,u4TempLineBuf);
            i4ImgResz_HAL_Resize(u4HwId);
            while(TRUE)
            {
                if(i4ImgResz_HAL_Get_Resize_Status(u4HwId)>=0)
                    break;
            }
        }

        imgreszvfy_free_mem_aligned((void *)u4TempLineBuf);
    }
    i4ImgResz_HAL_Uninit(u4HwId);

    return 0;
}
INT32 i4ImgReszVfyGenerateBasicCase(UINT32 u4TestCase,
                                    IMGRESZ_HAL_RESIZE_MODE_T *peResizeMode,
                                    IMGRESZ_HAL_RESAMPLE_METHOD_T *peHResampleMethod,
                                    IMGRESZ_HAL_RESAMPLE_METHOD_T *peVResampleMethod,
                                    IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfo,
                                    IMGRESZ_HAL_IMG_INFO_T *prDestImgInfo)
{
    UINT32 u4Case;
    //UINT32 u4SrcBufWidth = 1920, u4SrcBufHeight = 1080;
    //UINT32 u4DestBufWidth = 1920, u4DestBufHeight = 1080;
	UINT32 u4SrcBufWidth = 800, u4SrcBufHeight = 800;
	   UINT32 u4DestBufWidth = 800, u4DestBufHeight = 800;

    if((prSrcImgInfo->u4ImgWidth > u4SrcBufWidth) || (prSrcImgInfo->u4ImgHeight > u4SrcBufHeight))
    {
     return -1;
    }

    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
        u4SrcBufHeight = ((u4SrcBufHeight + 31)/ 32) * 32; // Align to 32
    }

    if(prDestImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4DestBufWidth = ((u4DestBufWidth + 15) / 16) * 16;  // Align to 16
        u4DestBufHeight = ((u4DestBufHeight + 31)/ 32) * 32; // Align to 32
    }

    prSrcImgInfo->u4BufWidth = u4SrcBufWidth * u4ImgReszVfyCalBufFormatBits(&(prSrcImgInfo->rBufferFormat)) / 8;
    prSrcImgInfo->u4BufWidth = ((prSrcImgInfo->u4BufWidth + 15) / 16 ) * 16;
    prSrcImgInfo->u4BufHeight = u4SrcBufHeight;
    prDestImgInfo->u4BufWidth = u4DestBufWidth * u4ImgReszVfyCalBufFormatBits(&(prDestImgInfo->rBufferFormat)) / 8;
    prDestImgInfo->u4BufHeight = u4DestBufHeight;

    // Resize mode variation and Resize method variation
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= 2;
    } else
    {
        UINT32 u4CaseNum = 6;

        // Y/C buffer has only frame mode, no partial mode.
        if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            u4CaseNum = 4;

        u4Case = u4TestCase % u4CaseNum;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 2:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 3:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 4:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 5:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= u4CaseNum;
    }

    // Progressive frame or interlaced frame
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                break;
            case 1:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                break;
        }
        u4TestCase /= 2;
    }

    // Destination size variation
    u4Case = u4TestCase % 9;
    switch(u4Case)
    {
        case 0:
            prDestImgInfo->u4ImgWidth = 352;
            prDestImgInfo->u4ImgHeight = 240;
            break;
        case 1:
            prDestImgInfo->u4ImgWidth = 720;
            prDestImgInfo->u4ImgHeight = 480;
            break;
        case 2:
            prDestImgInfo->u4ImgWidth =  600;//1280;
            prDestImgInfo->u4ImgHeight = 720;
            break;
        case 3:
            prDestImgInfo->u4ImgWidth = 500;//1920;
            prDestImgInfo->u4ImgHeight = 400;//1080;
            break;
        case 4:
            prDestImgInfo->u4ImgWidth = 32;
            prDestImgInfo->u4ImgHeight = 32;
            break;
        case 5:
            prDestImgInfo->u4ImgWidth =  688;
            prDestImgInfo->u4ImgHeight = 88;
            break;
        case 6:
            prDestImgInfo->u4ImgWidth = 400;//998;
            prDestImgInfo->u4ImgHeight = 312;
            break;
        case 7:
            prDestImgInfo->u4ImgWidth = 576;
            prDestImgInfo->u4ImgHeight = 604;
            break;
        case 8:
            prDestImgInfo->u4ImgWidth = 134;
            prDestImgInfo->u4ImgHeight =700;// 916;
            break;
    }
    u4TestCase /= 9;
    if(_fgOpenAddressSwap)
    {
        u4Case = u4TestCase % 8;
        u4SwapMode= u4Case ;
        u4TestCase /= 8;
    }
    if(u4TestCase > 0)
        return -1;

    return 0;
}

//[20110822][YgLi]8580 E2IC drv_verify
INT32 i4ImgReszVfyGenerate4To1BasicCase(UINT32 u4TestCase,
                                    IMGRESZ_HAL_RESIZE_MODE_T *peResizeMode,
                                    IMGRESZ_HAL_RESAMPLE_METHOD_T *peHResampleMethod,
                                    IMGRESZ_HAL_RESAMPLE_METHOD_T *peVResampleMethod,
                                    IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfo,
                                    IMGRESZ_HAL_IMG_INFO_T *prDestImgInfo)
{
    UINT32 u4Case;
    UINT32 u4SrcBufWidth = 1920, u4SrcBufHeight = 1080;
    UINT32 u4DestBufWidth = 1920, u4DestBufHeight = 1080;

    if((prSrcImgInfo->u4ImgWidth > u4SrcBufWidth) || (prSrcImgInfo->u4ImgHeight > u4SrcBufHeight))
    {
     return -1;
    }

    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
        u4SrcBufHeight = ((u4SrcBufHeight + 31)/ 32) * 32; // Align to 32
    }

    if(prDestImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4DestBufWidth = ((u4DestBufWidth + 15) / 16) * 16;  // Align to 16
        u4DestBufHeight = ((u4DestBufHeight + 31)/ 32) * 32; // Align to 32
    }

    prSrcImgInfo->u4BufWidth = u4SrcBufWidth * u4ImgReszVfyCalBufFormatBits(&(prSrcImgInfo->rBufferFormat)) / 8;
    prSrcImgInfo->u4BufWidth = ((prSrcImgInfo->u4BufWidth + 15) / 16 ) * 16;
    prSrcImgInfo->u4BufHeight = u4SrcBufHeight;
    prDestImgInfo->u4BufWidth = u4DestBufWidth * u4ImgReszVfyCalBufFormatBits(&(prDestImgInfo->rBufferFormat)) / 8;
    prDestImgInfo->u4BufHeight = u4DestBufHeight;

    // Resize mode variation and Resize method variation
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= 2;
    } else
    {
        UINT32 u4CaseNum = 6;

        // Y/C buffer has only frame mode, no partial mode.
        if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            u4CaseNum = 2;

        u4Case = u4TestCase % u4CaseNum;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 2:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 3:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 4:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 5:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= u4CaseNum;
    }

    // Progressive frame or interlaced frame
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                break;
            case 1:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                break;
        }
        u4TestCase /= 2;
    }

    // Destination size variation
    u4Case = u4TestCase % 1;
    switch(u4Case)
    {
        case 0:
            prDestImgInfo->u4ImgWidth = 720;
            prDestImgInfo->u4ImgHeight = 480;
            break;
        case 1:
            prDestImgInfo->u4ImgWidth = 720;
            prDestImgInfo->u4ImgHeight = 480;
            break;
        case 2:
            prDestImgInfo->u4ImgWidth = 1280;
            prDestImgInfo->u4ImgHeight = 720;
            break;
        case 3:
            prDestImgInfo->u4ImgWidth = 1920;
            prDestImgInfo->u4ImgHeight = 1080;
            break;
        case 4:
            prDestImgInfo->u4ImgWidth = 32;
            prDestImgInfo->u4ImgHeight = 32;
            break;
        case 5:
            prDestImgInfo->u4ImgWidth =  688;
            prDestImgInfo->u4ImgHeight = 88;
            break;
        case 6:
            prDestImgInfo->u4ImgWidth = 998;
            prDestImgInfo->u4ImgHeight = 312;
            break;
        case 7:
            prDestImgInfo->u4ImgWidth = 576;
            prDestImgInfo->u4ImgHeight = 604;
            break;
        case 8:
            prDestImgInfo->u4ImgWidth = 134;
            prDestImgInfo->u4ImgHeight = 916;
            break;
    }
    u4TestCase /= 1;
    u4Case = u4TestCase % 8;
    switch(u4Case)
    {
        case 0:
            prSrcImgInfo->u4ImgHeight = 480;
            break;
        case 1:
            prSrcImgInfo->u4ImgHeight = 478;
            break;
        case 2:
            prSrcImgInfo->u4ImgHeight = 476;
            break;
        case 3:
            prSrcImgInfo->u4ImgHeight = 474;
            break;
        case 4:
            prSrcImgInfo->u4ImgHeight = 472;
            break;
        case 5:
            prSrcImgInfo->u4ImgHeight = 470;
            break;
        case 6:
            prSrcImgInfo->u4ImgHeight = 468;
            break;
        case 7:
            prSrcImgInfo->u4ImgHeight = 466;
            break;
    }
    u4TestCase /= 16;
    if(_fgOpenAddressSwap)
    {
        u4Case = u4TestCase % 8;
        u4SwapMode= u4Case ;
        u4TestCase /= 8;
    }
    if(u4TestCase > 0)
        return -1;

    return 0;
}

INT32 i4ImgReszVfyTestBasicARGB(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
	
   // i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
     //                        ppbFileList,&u4FileListNum);
   IMGRZ_LOAD_FILE_LIST_FUNCTION;

    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
		i4ImgReszVfyPrintf("IMGRESZ 111====\n");
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);
        i4ImgReszVfyPrintf("IMGRESZ 222====\n");
        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not ARGB.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        u4TestCase = 0;
		i4ImgReszVfyPrintf("IMGRESZ 555====\n");

        while(i4ImgReszVfyGenerateBasicCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
				i4ImgReszVfyPrintf("IMGRESZ 333====\n");
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
				i4ImgReszVfyPrintf("IMGRESZ 444====\n");
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Copy source fit buffer to source buffer
            u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
            rSrcImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
            i4ImgReszVfyPrintf("[ImgResz][Verify] SRC buffer size : %d,Src addr :%x.\n",u4BufSize,rSrcImgInfo.u4BufSA1);
#else
            rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_src_alloc_mem_aligned(u4BufSize,16);
#endif
            VERIFY(rSrcImgInfo.u4BufSA1 != 0);
            vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

            // Destination buffer
            u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
            rDestImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
            i4ImgReszVfyPrintf("[ImgResz][Verify] DST buffer size : %d,DST addr :%x.\n",u4BufSize,rDestImgInfo.u4BufSA1);  
#else
           i4ImgReszVfyPrintf("IMGRESZ 111====\n");
            rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_dst_alloc_mem_aligned(u4BufSize,16);
			i4ImgReszVfyPrintf("IMGRESZ 555====\n");
#endif      
            VERIFY(rDestImgInfo.u4BufSA1 != 0);
			i4ImgReszVfyPrintf("IMGRESZ 666====\n");

            // Generate destination fit buffer info
            x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
            rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
            rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
            rDestFitImgInfo.u4ImgXOff = 0;
            rDestFitImgInfo.u4ImgYOff = 0;
            u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
		 i4ImgReszVfyPrintf("IMGRESZ 222====\n");
            rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
			i4ImgReszVfyPrintf("IMGRESZ 33====\n");
            VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
			i4ImgReszVfyPrintf("IMGRESZ 444====\n");

            for(u4HwId=0; u4HwId<=IMG_RESZ_VFY_HW_NUM; u4HwId++)
            {
                if(!_afgImgReszVfyHwEnable[u4HwId])
                    continue;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
					i4ImgReszVfyPrintf("IMGRESZ 555====\n");
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,FALSE,
                                            FALSE,0,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr1 = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr1 = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr1) != *(UINT8 *)(u4DestGoldAddr1))
                            VERIFY(FALSE);

                        u4DestFitAddr1++;
                        u4DestGoldAddr1++;
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }
            }

#if IMGRESZ_IO_MMU_TEST
            i4ImgReszVfyPrintf("[ImgResz][Verify] free src mmu mem.\n");
            x_free_vmem((void *)rSrcImgInfo.u4BufSA1);  
            i4ImgReszVfyPrintf("[ImgResz][Verify] free dst mmu mem.\n");
            //imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);       
            x_free_vmem((void *)rDestImgInfo.u4BufSA1);        
#else
            imgreszvfy_src_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_dst_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
#endif
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);

    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyTestBasicIndex(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
    #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
    #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
    #endif  

    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

      /*  if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_INDEX_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Index.\n");
            continue;
        }*/

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
        rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateBasicCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Copy source fit buffer to source buffer
            u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
             rSrcImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
             x_memset((void *)rSrcImgInfo.u4BufSA1, 0, u4BufSize);
             i4ImgReszVfyPrintf("[ImgResz][Verify] SRC buffer size : %d,Src addr :%x.\n",u4BufSize,rSrcImgInfo.u4BufSA1);
#else
            rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
#endif
            VERIFY(rSrcImgInfo.u4BufSA1 != 0);
            vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

            // Destination buffer
            u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
             rDestImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
             x_memset((void *)rDestImgInfo.u4BufSA1, 0, u4BufSize);
             i4ImgReszVfyPrintf("[ImgResz][Verify] DST buffer size : %d,DST addr :%x.\n",u4BufSize,rDestImgInfo.u4BufSA1);
#else
            rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
#endif
            VERIFY(rDestImgInfo.u4BufSA1 != 0);

            // Generate destination fit buffer info
            x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
            rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
            rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
            rDestFitImgInfo.u4ImgXOff = 0;
            rDestFitImgInfo.u4ImgYOff = 0;
            u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
            rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
            VERIFY(rDestFitImgInfo.u4BufSA1 != 0);

            for(u4HwId=0; u4HwId<=IMG_RESZ_VFY_HW_NUM; u4HwId++)
            {
                if(!_afgImgReszVfyHwEnable[u4HwId])
                    continue;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
 #if !IMGRESZ_PERFORMANCE_TEST
                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,FALSE,
                                            FALSE,0,0);
#endif
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr1 = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr1 = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr1) != *(UINT8 *)(u4DestGoldAddr1))
                            VERIFY(FALSE);

                        u4DestFitAddr1++;
                        u4DestGoldAddr1++;
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }
            }
#if IMGRESZ_IO_MMU_TEST
            x_free_vmem((void *)rSrcImgInfo.u4BufSA1);
            x_free_vmem((void *)rDestImgInfo.u4BufSA1);
#else
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
#endif
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.rBufferFormat.prColorPallet != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.rBufferFormat.prColorPallet);
    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}



INT32 i4ImgReszVfyTestBasicJpegToVideo(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
	IMGRZ_LOAD_FILE_LIST_FUNCTION;

    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Jpeg.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER;
        rDestImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateBasicCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
                rSrcFitImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA3 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Copy source fit buffer to source buffer
            u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
            rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_src_alloc_mem_aligned(u4BufSize,16);
            VERIFY(rSrcImgInfo.u4BufSA1 != 0);
            rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_src_alloc_mem_aligned(u4BufSize,16);
            VERIFY(rSrcImgInfo.u4BufSA2 != 0);
            rSrcImgInfo.u4BufSA3 = (UINT32)imgreszvfy_src_alloc_mem_aligned(u4BufSize,16);
            VERIFY(rSrcImgInfo.u4BufSA3 != 0);
#if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8560)
           if((rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[1] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0])
		&&(rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[2] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0]))
               vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,TRUE);
	    else
	        vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#else
            vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#endif

            // Destination buffer
            if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            {
                u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_dst_alloc_mem_aligned(u4BufSize,1024);
                VERIFY(rDestImgInfo.u4BufSA1 != 0);
                rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_dst_alloc_mem_aligned(u4BufSize,1024);
                VERIFY(rDestImgInfo.u4BufSA2 != 0);
            } else if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER)
            {
                u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_dst_alloc_mem_aligned(u4BufSize,16);
                VERIFY(rDestImgInfo.u4BufSA1 != 0);
            }

            // Generate destination fit buffer info
            x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
            rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
            rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
            rDestFitImgInfo.u4ImgXOff = 0;
            rDestFitImgInfo.u4ImgYOff = 0;
            u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
            rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
            VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
            if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            {
                rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rDestFitImgInfo.u4BufSA2 != 0);
            }

            for(u4HwId=0; u4HwId<=IMG_RESZ_VFY_HW_NUM; u4HwId++)
            {
                if(!_afgImgReszVfyHwEnable[u4HwId])
                    continue;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                    if(rDestGoldImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        rDestGoldImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                        VERIFY(rDestGoldImgInfo.u4BufSA2 != 0);
                        x_memcpy((void *)rDestGoldImgInfo.u4BufSA2,(void *)rDestFitImgInfo.u4BufSA2,u4BufSize);
                    }

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            FALSE,0,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }
            }

            imgreszvfy_src_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_dst_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_src_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            if(rDestImgInfo.u4BufSA2 != 0)
                imgreszvfy_dst_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            if(rDestFitImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            if(rDestGoldImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            imgreszvfy_src_free_mem_aligned((void *)rSrcImgInfo.u4BufSA3);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
        if(rSrcFitImgInfo.u4BufSA3 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA3);
    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyTestBasicJpegToAYUV(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
       #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
 i4ImgReszVfyPrintf("[ImgResz][Verify] 11111===.\n");
    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);
 i4ImgReszVfyPrintf("[ImgResz][Verify] 5555===.\n");
        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Jpeg.\n");
            continue;
        }
 i4ImgReszVfyPrintf("[ImgResz][Verify] 22222===.\n");
        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
        rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;

        u4TestCase = 0;
 i4ImgReszVfyPrintf("[ImgResz][Verify] 333===.\n");
        while(i4ImgReszVfyGenerateBasicCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;
 i4ImgReszVfyPrintf("[ImgResz][Verify] 4444===.\n");
            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
                rSrcFitImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA3 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Copy source fit buffer to source buffer
            u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
            rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
            VERIFY(rSrcImgInfo.u4BufSA1 != 0);
            rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
            VERIFY(rSrcImgInfo.u4BufSA2 != 0);
            rSrcImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
            VERIFY(rSrcImgInfo.u4BufSA3 != 0);
  #if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8560)
             if((rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[1] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0])
		   &&(rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[2] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0]))
                   vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,TRUE);
	      else
	            vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#else
            vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#endif

            // Destination buffer
            if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            {
                u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                VERIFY(rDestImgInfo.u4BufSA1 != 0);
                rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                VERIFY(rDestImgInfo.u4BufSA2 != 0);
            } else if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER)
            {
                u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                VERIFY(rDestImgInfo.u4BufSA1 != 0);
            }

            // Generate destination fit buffer info
            x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
            rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
            rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
            rDestFitImgInfo.u4ImgXOff = 0;
            rDestFitImgInfo.u4ImgYOff = 0;
            u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
            rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
            VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
            if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            {
                rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rDestFitImgInfo.u4BufSA2 != 0);
            }

            for(u4HwId=0; u4HwId<=IMG_RESZ_VFY_HW_NUM; u4HwId++)
            {
                if(!_afgImgReszVfyHwEnable[u4HwId])
                    continue;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                    if(rDestGoldImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        rDestGoldImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                        VERIFY(rDestGoldImgInfo.u4BufSA2 != 0);
                        x_memcpy((void *)rDestGoldImgInfo.u4BufSA2,(void *)rDestFitImgInfo.u4BufSA2,u4BufSize);
                    }

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            FALSE,0,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            if(rDestImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            if(rDestFitImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            if(rDestGoldImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA3);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
        if(rSrcFitImgInfo.u4BufSA3 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA3);
    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyTestBasicVideo(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
    #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  

    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Video.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateBasicCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Copy source fit buffer to source buffer
            u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
            u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
            rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_src_alloc_mem_aligned(u4BufSize,1024);
            VERIFY(rSrcImgInfo.u4BufSA1 != 0);
            x_memset((void *)rSrcImgInfo.u4BufSA1,0,u4BufSize);
            rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_src_alloc_mem_aligned(u4BufSize,1024);
            VERIFY(rSrcImgInfo.u4BufSA2 != 0);
            x_memset((void *)rSrcImgInfo.u4BufSA2,0,u4BufSize);

            vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

            // Destination buffer
            u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
            u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
            rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_dst_alloc_mem_aligned(u4BufSize,1024);
            VERIFY(rDestImgInfo.u4BufSA1 != 0);
            x_memset((void *)rDestImgInfo.u4BufSA1,0,u4BufSize);
            rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_dst_alloc_mem_aligned(u4BufSize,1024);
            VERIFY(rDestImgInfo.u4BufSA2 != 0);
            x_memset((void *)rDestImgInfo.u4BufSA2,0,u4BufSize);
            // Generate destination fit buffer info
            x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
            rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth;
            rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
            rDestFitImgInfo.u4ImgXOff = 0;
            rDestFitImgInfo.u4ImgYOff = 0;
            u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
            rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
            VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
            rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
            VERIFY(rDestFitImgInfo.u4BufSA2 != 0);

            for(u4HwId=0; u4HwId<=IMG_RESZ_VFY_HW_NUM; u4HwId++)
            {
                if(!_afgImgReszVfyHwEnable[u4HwId])
                    continue;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                    rDestGoldImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA2 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA2,(void *)rDestFitImgInfo.u4BufSA2,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            FALSE,0,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;
                   // HalFlushInvalidateDCache();
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }
            }

            imgreszvfy_src_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_dst_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_src_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            imgreszvfy_dst_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}

INT32 i4ImgReszVfyTestVideo4to1Scale(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode = 0;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;
    UINT32 i;

    UINT32 u4WorkBufSa = 0;

    u4WorkBufSa = (UINT32)imgreszvfy_alloc_mem_aligned(1920*1088,1024);

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
      #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    _fg4to1Test = TRUE;
    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Video.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        u4TestCase = 0;

        for (i = 0; i < 2; i++)
        {
            if (0 == i)
            {
                rSrcImgInfo.rBufferFormat.fgBlockMode = TRUE;
                rDestImgInfo.rBufferFormat.fgBlockMode = TRUE;
            }
            else
            {
                rSrcImgInfo.rBufferFormat.fgBlockMode = FALSE;
                rDestImgInfo.rBufferFormat.fgBlockMode = FALSE;
            }
            while(i4ImgReszVfyGenerate4To1BasicCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
            {
                BOOL fgGenGolden = FALSE;

                // Load source file
                if(u4TestCase == 0)
                {
                    u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                    rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                    rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
                    i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
                }

                // Copy source fit buffer to source buffer
                u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
                u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                VERIFY(rSrcImgInfo.u4BufSA1 != 0);
                rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                VERIFY(rSrcImgInfo.u4BufSA2 != 0);
                vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

                if(rSrcImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                {
                    // EnBlock
                    if(rSrcImgInfo.rBufferFormat.fgBlockMode)
                    {
                           // Y
                        vImgReszVfyBufEnBlock(rSrcImgInfo.u4BufSA1,u4WorkBufSa,
                                                  rSrcImgInfo.u4BufWidth,rSrcImgInfo.u4BufHeight,16,32);
                        x_memcpy((void *)rSrcImgInfo.u4BufSA1,(void *)u4WorkBufSa,rSrcImgInfo.u4BufWidth*rSrcImgInfo.u4BufHeight);
                        // C
                        vImgReszVfyBufEnBlock(rSrcImgInfo.u4BufSA2,u4WorkBufSa,
                                              rSrcImgInfo.u4BufWidth,rSrcImgInfo.u4BufHeight,16,16);
                        x_memcpy((void *)rSrcImgInfo.u4BufSA2,(void *)u4WorkBufSa,rSrcImgInfo.u4BufWidth*rSrcImgInfo.u4BufHeight);
                    }
                }

                // Destination buffer
                
                u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                VERIFY(rDestImgInfo.u4BufSA1 != 0);
                rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                VERIFY(rDestImgInfo.u4BufSA2 != 0);

                // Generate destination fit buffer info
                x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth;
                rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                rDestFitImgInfo.u4ImgXOff = 0;
                rDestFitImgInfo.u4ImgYOff = 0;
                u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
                rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rDestFitImgInfo.u4BufSA2 != 0);

                for(u4HwId=0; u4HwId<=IMG_RESZ_VFY_HW_NUM; u4HwId++)
                {
                    if(!_afgImgReszVfyHwEnable[u4HwId])
                        continue;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);

                    // Resize
                    i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                     &rSrcImgInfo,&rDestImgInfo,0);

                    if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                    // DeAddressSwap
                    if(rDestImgInfo.rBufferFormat.fgAddrSwap)
                    {
                        // Y
                        vImgReszVfyBufDeAddrSwap(rDestImgInfo.u4BufSA1,u4WorkBufSa,
                                                 rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                        x_memcpy((void *)rDestImgInfo.u4BufSA1,(void *)u4WorkBufSa,rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                        // C
                        vImgReszVfyBufDeAddrSwap(rDestImgInfo.u4BufSA2,u4WorkBufSa,
                                                 rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                        x_memcpy((void *)rDestImgInfo.u4BufSA2,(void *)u4WorkBufSa,rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                    }

                    // DeBlock
                    if(rDestImgInfo.rBufferFormat.fgBlockMode)
                    {
                        // Y
                        vImgReszVfyBufDeBlock(rDestImgInfo.u4BufSA1,u4WorkBufSa,
                                              rDestImgInfo.u4BufWidth,rDestImgInfo.u4BufHeight,16,32);
                        x_memcpy((void *)rDestImgInfo.u4BufSA1,(void *)u4WorkBufSa,rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                        // C
                        vImgReszVfyBufDeBlock(rDestImgInfo.u4BufSA2,u4WorkBufSa,
                                              rDestImgInfo.u4BufWidth,rDestImgInfo.u4BufHeight,16,16);
                        x_memcpy((void *)rDestImgInfo.u4BufSA2,(void *)u4WorkBufSa,rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                    }
                    }
                

                    // Copy destination buffer to destination fit buffer
                    vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                    if(!fgGenGolden)
                    {
                        // Copy destination fit buffer to destination golden buffer
                        x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                        VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                        x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                        rDestGoldImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                        VERIFY(rDestGoldImgInfo.u4BufSA2 != 0);
                        x_memcpy((void *)rDestGoldImgInfo.u4BufSA2,(void *)rDestFitImgInfo.u4BufSA2,u4BufSize);

                        // Save destination file
                        i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                        // Output case info to resize info file
                        i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                                eResizeMode,eHResampleMethod,eVResampleMethod,
                                                !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                                FALSE,0,0);
                        fgGenGolden = TRUE;
                    } else
                    {
                        UINT32 u4I;
                        UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                        UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                        i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);

            u4TestCase++;
        }
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);
     _fg4to1Test = FALSE;
    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyGenerateScalingRatioCase(UINT32 u4TestCase,
                                           IMGRESZ_HAL_RESIZE_MODE_T *peResizeMode,
                                           IMGRESZ_HAL_RESAMPLE_METHOD_T *peHResampleMethod,
                                           IMGRESZ_HAL_RESAMPLE_METHOD_T *peVResampleMethod,
                                           IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfo,
                                           IMGRESZ_HAL_IMG_INFO_T *prDestImgInfo)
{
    UINT32 u4Case;
    UINT32 u4SrcBufWidth = 1920, u4SrcBufHeight = 1080;
    UINT32 u4DestBufWidth = 1920, u4DestBufHeight = 1080;

    ///////////////////////
    //add by chunze. 2010.11.17

    if(_u4MaxImg8192HVMode == 1)
	{
	    u4SrcBufWidth = 8256;
		u4SrcBufHeight = 500;
		u4DestBufWidth = 9000;
		u4DestBufHeight = 500;		
	}else if(_u4MaxImg8192HVMode == 2)
	{
        u4SrcBufWidth = 448;
		u4SrcBufHeight = 8256;
		u4DestBufWidth = 400;
		u4DestBufHeight = 9000;		
	}
    
    if((prSrcImgInfo->u4ImgWidth > u4SrcBufWidth) || (prSrcImgInfo->u4ImgHeight > u4SrcBufHeight))
    {
        u4SrcBufWidth = prSrcImgInfo->u4ImgWidth;
        u4SrcBufHeight = prSrcImgInfo->u4ImgHeight;

        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
    }

    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
        u4SrcBufHeight = ((u4SrcBufHeight + 31)/ 32) * 32; // Align to 32
    }

    if(prDestImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4DestBufWidth = ((u4DestBufWidth + 15) / 16) * 16;  // Align to 16
        u4DestBufHeight = ((u4DestBufHeight + 31)/ 32) * 32; // Align to 32
    }

    prSrcImgInfo->u4BufWidth = u4SrcBufWidth * u4ImgReszVfyCalBufFormatBits(&(prSrcImgInfo->rBufferFormat)) / 8;
    prSrcImgInfo->u4BufHeight = u4SrcBufHeight;
    prDestImgInfo->u4BufWidth = u4DestBufWidth * u4ImgReszVfyCalBufFormatBits(&(prDestImgInfo->rBufferFormat)) / 8;
    prDestImgInfo->u4BufHeight = u4DestBufHeight;

    // Resize mode variation and Resize method variation
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= 2;
    } else
    {
        UINT32 u4CaseNum = 6;

        // Y/C buffer has only frame mode, no partial mode.
        if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            u4CaseNum = 4;

        u4Case = u4TestCase % u4CaseNum;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 2:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 3:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 4:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 5:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= u4CaseNum;
    }

    // Progressive frame or interlaced frame
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                break;
            case 1:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                break;
        }
        u4TestCase /= 2;
    }

    // Destination size variation
    if(_u4MaxImg8192HVMode == 0)
	{
	    
       // Destination size variation
    u4Case = u4TestCase % 8;
    switch(u4Case)
    {
        case 0:
            prDestImgInfo->u4ImgWidth = 1840;
            prDestImgInfo->u4ImgHeight = 320;//322;
            break;
        case 1:
            prDestImgInfo->u4ImgWidth = 800;
            prDestImgInfo->u4ImgHeight = 532;
            break;
        case 2:
            prDestImgInfo->u4ImgWidth = 360;
            prDestImgInfo->u4ImgHeight = 712;//710
            break;
        case 3:
            prDestImgInfo->u4ImgWidth = 742;
            prDestImgInfo->u4ImgHeight = 480;
            break;
        case 4:
            prDestImgInfo->u4ImgWidth = 340;
            prDestImgInfo->u4ImgHeight = 1016;//1018
            break;
        case 5:
            prDestImgInfo->u4ImgWidth = 746;
            prDestImgInfo->u4ImgHeight = 908;
            break;
        case 6:
            prDestImgInfo->u4ImgWidth = 480;
            prDestImgInfo->u4ImgHeight = 672;//670
            break;
        case 7:
            prDestImgInfo->u4ImgWidth = 32;
            prDestImgInfo->u4ImgHeight = 32;
            break;
    }
    u4TestCase /= 8;
	}
    else if(_u4MaxImg8192HVMode == 1)
	{
	    u4Case = u4TestCase % 4; 
        switch(u4Case)
        {
            case 0:
                prDestImgInfo->u4ImgWidth = 8192;
                prDestImgInfo->u4ImgHeight = 100;
                break;
            case 1:
                prDestImgInfo->u4ImgWidth = 742;
                prDestImgInfo->u4ImgHeight = 200;
                break;
            case 2:
                prDestImgInfo->u4ImgWidth = 316;
                prDestImgInfo->u4ImgHeight = 56;//50
                break;            
            case 3:
                prDestImgInfo->u4ImgWidth = 4020;
                prDestImgInfo->u4ImgHeight = 196;//198
                break;     
        }
		u4TestCase /= 4;
	}
	else if(_u4MaxImg8192HVMode == 2)
	{
	    u4Case = u4TestCase % 4; 
        switch(u4Case)
        {
            case 0:
                prDestImgInfo->u4ImgWidth = 100;
                prDestImgInfo->u4ImgHeight = 8192;
                break;
            case 1:
                prDestImgInfo->u4ImgWidth = 200;
                prDestImgInfo->u4ImgHeight = 800;//
                break;
            case 2:
                prDestImgInfo->u4ImgWidth = 50;
                prDestImgInfo->u4ImgHeight = 316;
                break;            
            case 3:
                prDestImgInfo->u4ImgWidth = 198;
                prDestImgInfo->u4ImgHeight = 4020;
                break;     
        }
		u4TestCase /= 4;
	}

    if(u4TestCase > 0)
        return -1;

    return 0;
}


INT32 i4ImgReszVfyTestScalingRatioARGB(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
       #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  

    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

       if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not ARGB.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateScalingRatioCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,32);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Copy source fit buffer to source buffer
            u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;

#if IMGRESZ_IO_MMU_TEST
            rSrcImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
            i4ImgReszVfyPrintf("[ImgResz][Verify] SRC buffer size : %d,Src addr :%x.\n",u4BufSize,rSrcImgInfo.u4BufSA1);
#else
            rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,32);
#endif
            VERIFY(rSrcImgInfo.u4BufSA1 != 0);
            vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

            // Destination buffer
            u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
            rDestImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
            i4ImgReszVfyPrintf("[ImgResz][Verify] DST buffer size : %d,DST addr :%x.\n",u4BufSize,rDestImgInfo.u4BufSA1);  
#else
            rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,32);
#endif      
            // Generate destination fit buffer info
            x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
            rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
            rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
            rDestFitImgInfo.u4ImgXOff = 0;
            rDestFitImgInfo.u4ImgYOff = 0;
            u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
            rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,32);
            VERIFY(rDestFitImgInfo.u4BufSA1 != 0);

            for(u4HwId=0; u4HwId<=IMG_RESZ_VFY_HW_NUM; u4HwId++)
            {
                if(!_afgImgReszVfyHwEnable[u4HwId])
                    continue;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,32);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,FALSE,
                                            FALSE,0,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr1 = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr1 = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr1) != *(UINT8 *)(u4DestGoldAddr1))
                            VERIFY(FALSE);

                        u4DestFitAddr1++;
                        u4DestGoldAddr1++;
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }
            }

#if IMGRESZ_IO_MMU_TEST
            i4ImgReszVfyPrintf("[ImgResz][Verify] free src mmu mem.\n");
            x_free_vmem((void *)rSrcImgInfo.u4BufSA1);  
            i4ImgReszVfyPrintf("[ImgResz][Verify] free dst mmu mem.\n");
            //imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);       
            x_free_vmem((void *)rDestImgInfo.u4BufSA1);        
#else
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
#endif
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);

    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyTestScalingRatioIndex(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
      #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

      /*  if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_INDEX_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Index.\n");
            continue;
        }*/

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
        rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateScalingRatioCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Copy source fit buffer to source buffer
            u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
             rSrcImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
             i4ImgReszVfyPrintf("[ImgResz][Verify] SRC buffer size : %d,Src addr :%x.\n",u4BufSize,rSrcImgInfo.u4BufSA1);
#else
            rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
#endif
            VERIFY(rSrcImgInfo.u4BufSA1 != 0);
	     x_memset((void *)rSrcImgInfo.u4BufSA1,0,u4BufSize);
            vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

            // Destination buffer
            u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
             rDestImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
             i4ImgReszVfyPrintf("[ImgResz][Verify] DST buffer size : %d,DST addr :%x.\n",u4BufSize,rDestImgInfo.u4BufSA1);
#else
            rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
#endif
            VERIFY(rDestImgInfo.u4BufSA1 != 0);
            x_memset((void *)rDestImgInfo.u4BufSA1,0,u4BufSize);

            // Generate destination fit buffer info
            x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
            rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
            rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
            rDestFitImgInfo.u4ImgXOff = 0;
            rDestFitImgInfo.u4ImgYOff = 0;
            u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
            rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
            VERIFY(rDestFitImgInfo.u4BufSA1 != 0);

            for(u4HwId=0; u4HwId<=IMG_RESZ_VFY_HW_NUM; u4HwId++)
            {
                if(!_afgImgReszVfyHwEnable[u4HwId])
                    continue;
                 i4HwImgReszSetAlphaChangeScalingType(u4HwId,0);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);

#if !IMGRESZ_PERFORMANCE_TEST
                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,FALSE,
                                            FALSE,0,0);
#endif
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr1 = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr1 = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr1) != *(UINT8 *)(u4DestGoldAddr1))
                            VERIFY(FALSE);

                        u4DestFitAddr1++;
                        u4DestGoldAddr1++;
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }
            }
#if IMGRESZ_IO_MMU_TEST
            x_free_vmem((void *)rSrcImgInfo.u4BufSA1);
            x_free_vmem((void *)rDestImgInfo.u4BufSA1);
#else
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
#endif
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.rBufferFormat.prColorPallet != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.rBufferFormat.prColorPallet);
    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyTestScalingRatioJpegToVideo(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
      #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  

    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Jpeg.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER;
        rDestImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateScalingRatioCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
                rSrcFitImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA3 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Copy source fit buffer to source buffer
            u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
            rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
            VERIFY(rSrcImgInfo.u4BufSA1 != 0);
	    // x_memset((void *)rSrcImgInfo.u4BufSA1,0,u4BufSize);
            rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
            VERIFY(rSrcImgInfo.u4BufSA2 != 0);
	    // x_memset((void *)rSrcImgInfo.u4BufSA2,0,u4BufSize);
            rSrcImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
            VERIFY(rSrcImgInfo.u4BufSA3 != 0);
	     //x_memset((void *)rSrcImgInfo.u4BufSA3,0,u4BufSize);
 #if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8560)
           if((rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[1] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0])
		&&(rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[2] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0]))
               vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,TRUE);
	    else
	        vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#else
            vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#endif

            // Destination buffer
            if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            {
                u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                VERIFY(rDestImgInfo.u4BufSA1 != 0);
		  //x_memset((void *)rDestImgInfo.u4BufSA1,0,u4BufSize);
                rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                VERIFY(rDestImgInfo.u4BufSA2 != 0);
		  //x_memset((void *)rDestImgInfo.u4BufSA2,0,u4BufSize);
            } else if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER)
            {
                u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                VERIFY(rDestImgInfo.u4BufSA1 != 0);
		  //x_memset((void *)rDestImgInfo.u4BufSA1,0,u4BufSize);
            }

            // Generate destination fit buffer info
            x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
            rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
            rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
            rDestFitImgInfo.u4ImgXOff = 0;
            rDestFitImgInfo.u4ImgYOff = 0;
            u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
            rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
            VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
            if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            {
                rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rDestFitImgInfo.u4BufSA2 != 0);
            }

            for(u4HwId=0; u4HwId<=IMG_RESZ_VFY_HW_NUM; u4HwId++)
            {
                if(!_afgImgReszVfyHwEnable[u4HwId])
                    continue;
               // i4HwImgReszSetAlphaChangeScalingType(u4HwId,0);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                    if(rDestGoldImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        rDestGoldImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                        VERIFY(rDestGoldImgInfo.u4BufSA2 != 0);
                        x_memcpy((void *)rDestGoldImgInfo.u4BufSA2,(void *)rDestFitImgInfo.u4BufSA2,u4BufSize);
                    }

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            FALSE,0,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            if(rDestImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            if(rDestFitImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            if(rDestGoldImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA3);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
        if(rSrcFitImgInfo.u4BufSA3 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA3);
    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyTestScalingRatioJpegToAYUV(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
      #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Jpeg.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
        rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateScalingRatioCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
                rSrcFitImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA3 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Copy source fit buffer to source buffer
            u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
            rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
            VERIFY(rSrcImgInfo.u4BufSA1 != 0);
            rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
            VERIFY(rSrcImgInfo.u4BufSA2 != 0);
            rSrcImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
            VERIFY(rSrcImgInfo.u4BufSA3 != 0);
#if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8560)
             if((rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[1] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0])
		   &&(rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[2] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0]))
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,TRUE);
	       else
            vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#else
                 vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#endif

            // Destination buffer
            if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            {
                u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                VERIFY(rDestImgInfo.u4BufSA1 != 0);
                rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                VERIFY(rDestImgInfo.u4BufSA2 != 0);
            } else if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER)
            {
                u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                VERIFY(rDestImgInfo.u4BufSA1 != 0);
            }

            // Generate destination fit buffer info
            x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
            rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
            rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
            rDestFitImgInfo.u4ImgXOff = 0;
            rDestFitImgInfo.u4ImgYOff = 0;
            u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
            rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
            VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
            if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            {
                rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rDestFitImgInfo.u4BufSA2 != 0);
            }

            for(u4HwId=0; u4HwId<=IMG_RESZ_VFY_HW_NUM; u4HwId++)
            {
                if(!_afgImgReszVfyHwEnable[u4HwId])
                    continue;
               // i4HwImgReszSetAlphaChangeScalingType(u4HwId,0);

                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                    if(rDestGoldImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        rDestGoldImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                        VERIFY(rDestGoldImgInfo.u4BufSA2 != 0);
                        x_memcpy((void *)rDestGoldImgInfo.u4BufSA2,(void *)rDestFitImgInfo.u4BufSA2,u4BufSize);
                    }

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            FALSE,0,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            if(rDestImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            if(rDestFitImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            if(rDestGoldImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA3);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
        if(rSrcFitImgInfo.u4BufSA3 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA3);
    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}



INT32 i4ImgReszVfyTestScalingRatioVideo(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
       #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Video.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateScalingRatioCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Copy source fit buffer to source buffer
            u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
            u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
            rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
            VERIFY(rSrcImgInfo.u4BufSA1 != 0);
	     x_memset((void *)rSrcImgInfo.u4BufSA1,0,u4BufSize);
            rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
            VERIFY(rSrcImgInfo.u4BufSA2 != 0);
	     x_memset((void *)rSrcImgInfo.u4BufSA2,0,u4BufSize);
            vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

            // Destination buffer
            u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
            u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
            rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
            VERIFY(rDestImgInfo.u4BufSA1 != 0);
	    x_memset((void *)rDestImgInfo.u4BufSA1,0,u4BufSize); 
            rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
            VERIFY(rDestImgInfo.u4BufSA2 != 0);
            x_memset((void *)rDestImgInfo.u4BufSA2,0,u4BufSize); 


            // Generate destination fit buffer info
            x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
            rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth;
            rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
            rDestFitImgInfo.u4ImgXOff = 0;
            rDestFitImgInfo.u4ImgYOff = 0;
            u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
            rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
            VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
            rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
            VERIFY(rDestFitImgInfo.u4BufSA2 != 0);

            for(u4HwId=0; u4HwId<=IMG_RESZ_VFY_HW_NUM; u4HwId++)
            {
                if(!_afgImgReszVfyHwEnable[u4HwId])
                    continue;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                    rDestGoldImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA2 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA2,(void *)rDestFitImgInfo.u4BufSA2,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            FALSE,0,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyGenerateScalingRatioOddCase(UINT32 u4TestCase,
                                              IMGRESZ_HAL_RESIZE_MODE_T *peResizeMode,
                                              IMGRESZ_HAL_RESAMPLE_METHOD_T *peHResampleMethod,
                                              IMGRESZ_HAL_RESAMPLE_METHOD_T *peVResampleMethod,
                                              IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfo,
                                              IMGRESZ_HAL_IMG_INFO_T *prDestImgInfo)
{
    UINT32 u4Case;
    UINT32 u4SrcBufWidth = 1920, u4SrcBufHeight = 1080;
    UINT32 u4DestBufWidth = 1920, u4DestBufHeight = 1080;

    ///////////////////////
    //add by chunze

    if(_u4MaxImg8192HVMode == 1)
	{
	    u4SrcBufWidth = 8256;
		u4SrcBufHeight = 500;
		u4DestBufWidth = 9000;
		u4DestBufHeight = 400;		
	}else if(_u4MaxImg8192HVMode == 2)
	{
        u4SrcBufWidth = 448;
		u4SrcBufHeight = 8256;
		u4DestBufWidth = 400;
		u4DestBufHeight = 9000;		
	}
    
    if((prSrcImgInfo->u4ImgWidth > u4SrcBufWidth) || (prSrcImgInfo->u4ImgHeight > u4SrcBufHeight))
    {
        u4SrcBufWidth = prSrcImgInfo->u4ImgWidth;
        u4SrcBufHeight = prSrcImgInfo->u4ImgHeight;

        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
    }

    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
        u4SrcBufHeight = ((u4SrcBufHeight + 31)/ 32) * 32; // Align to 32
    }

    if(prDestImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4DestBufWidth = ((u4DestBufWidth + 15) / 16) * 16;  // Align to 16
        u4DestBufHeight = ((u4DestBufHeight + 31)/ 32) * 32; // Align to 32
    }

    prSrcImgInfo->u4BufWidth = u4SrcBufWidth * u4ImgReszVfyCalBufFormatBits(&(prSrcImgInfo->rBufferFormat)) / 8;
    prSrcImgInfo->u4BufHeight = u4SrcBufHeight;
    prDestImgInfo->u4BufWidth = u4DestBufWidth * u4ImgReszVfyCalBufFormatBits(&(prDestImgInfo->rBufferFormat)) / 8;
    prDestImgInfo->u4BufHeight = u4DestBufHeight;

    // Resize mode variation and Resize method variation
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
    {
        u4Case = u4TestCase % 1;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= 1;
    } else
    {
        UINT32 u4CaseNum = 6;

        // Y/C buffer has only frame mode, no partial mode.
        if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            u4CaseNum = 1;

        u4Case = u4TestCase % u4CaseNum;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 2:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 3:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 4:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 5:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= u4CaseNum;
    }

    // Progressive frame or interlaced frame
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                break;
            case 1:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                break;
        }
        u4TestCase /= 2;
    }

    // Destination size variation
    if(_u4MaxImg8192HVMode == 0)
	{
    u4Case = u4TestCase % 8;
    switch(u4Case)
    {
        case 0:
            prDestImgInfo->u4ImgWidth = 1841;
            prDestImgInfo->u4ImgHeight = 323;
            break;
        case 1:
            prDestImgInfo->u4ImgWidth = 473;
            prDestImgInfo->u4ImgHeight = 531;
            break;
        case 2:
            prDestImgInfo->u4ImgWidth = 1109;
            prDestImgInfo->u4ImgHeight = 711;
            break;
        case 3:
            prDestImgInfo->u4ImgWidth = 741;
            prDestImgInfo->u4ImgHeight = 839;
            break;
        case 4:
            prDestImgInfo->u4ImgWidth = 841;
            prDestImgInfo->u4ImgHeight = 119;
            break;
        case 5:
            prDestImgInfo->u4ImgWidth = 745;
            prDestImgInfo->u4ImgHeight = 907;
            break;
        case 6:
            prDestImgInfo->u4ImgWidth = 1117;
            prDestImgInfo->u4ImgHeight = 671;
            break;
        case 7:
            prDestImgInfo->u4ImgWidth = 31;
            prDestImgInfo->u4ImgHeight = 31;
            break;
    }
    u4TestCase /= 8;
    }
    else if(_u4MaxImg8192HVMode == 1)
	{
	    u4Case = u4TestCase % 4; 
        switch(u4Case)
        {
            case 0:
                prDestImgInfo->u4ImgWidth = 8191;
                prDestImgInfo->u4ImgHeight = 199;
                break;
            case 1:
                prDestImgInfo->u4ImgWidth = 409;
                prDestImgInfo->u4ImgHeight = 97;
                break;
            case 2:
                prDestImgInfo->u4ImgWidth = 4001;
                prDestImgInfo->u4ImgHeight = 115;
                break;            
            case 3:
                prDestImgInfo->u4ImgWidth = 743;
                prDestImgInfo->u4ImgHeight = 51;
                break;     
        }
		u4TestCase /= 4;
	}
	else if(_u4MaxImg8192HVMode == 2)
	{
	    u4Case = u4TestCase % 4; 
        switch(u4Case)
        {
            case 0:
                prDestImgInfo->u4ImgWidth = 199;
                prDestImgInfo->u4ImgHeight = 8191;
                break;
            case 1:
                prDestImgInfo->u4ImgWidth = 97;
                prDestImgInfo->u4ImgHeight = 409;
                break;
            case 2:
                prDestImgInfo->u4ImgWidth = 115;
                prDestImgInfo->u4ImgHeight = 4001;
                break;            
            case 3:
                prDestImgInfo->u4ImgWidth = 51;
                prDestImgInfo->u4ImgHeight = 743;
                break;     
        }
		u4TestCase /= 4;
	}

    if(u4TestCase > 0)
        return -1;

    return 0;
}



INT32 i4ImgReszVfyTestScalingRatioOddARGB(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);

#if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
#else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
#endif  
    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not ARGB.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateScalingRatioOddCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Copy source fit buffer to source buffer
            u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
            rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
            VERIFY(rSrcImgInfo.u4BufSA1 != 0);
            vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

            // Destination buffer
            u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
            rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
            VERIFY(rDestImgInfo.u4BufSA1 != 0);

            // Generate destination fit buffer info
            x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
            rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
            rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
            rDestFitImgInfo.u4ImgXOff = 0;
            rDestFitImgInfo.u4ImgYOff = 0;
            u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
            rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
            VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
            x_memset((void *)rDestFitImgInfo.u4BufSA1,0,u4BufSize);
            for(u4HwId=0; u4HwId<=IMG_RESZ_VFY_HW_NUM; u4HwId++)
            {
                if(!_afgImgReszVfyHwEnable[u4HwId])
                    continue;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] dstfit buf addr=%x\n",rDestFitImgInfo.u4BufSA1);
                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);
                i4ImgReszVfyPrintf ("[IMG_RESZ]Resize finish\n ");
                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,FALSE,
                                            FALSE,0,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr1 = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr1 = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr1) != *(UINT8 *)(u4DestGoldAddr1))
                            VERIFY(FALSE);

                        u4DestFitAddr1++;
                        u4DestGoldAddr1++;
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);

    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}

UINT32 _u4SrcImgInfoSA1 = 0;

INT32 i4ImgReszVfyTestAllocSrcImgInfoSA(void)
{    
    _u4SrcImgInfoSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(540*4*600,1);
    VERIFY( _u4SrcImgInfoSA1!= 0);
    i4ImgReszVfyPrintf("[ImgResz][Verify] Please dump file to %x.\n",_u4SrcImgInfoSA1);
    return 0;
}

INT32 i4ImgReszVfyTestScalingRatioOddARGB2(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
 //   INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
/*
#if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
#else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
#endif  
*/
    u4FileListNum = 1;
    ppbFileList[0]="D:\\Projects\\MT8560_vfy\\IMG_RESZ\\105\\ARGB8888\\mn4.bmp";
/*
    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);
*/
    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        //i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);
        rSrcFitImgInfo.u4ImgWidth = 540;
        rSrcFitImgInfo.u4ImgHeight = 600;
        rSrcFitImgInfo.u4BufWidth = 540* 4;
        rSrcFitImgInfo.u4BufHeight = 600;
        rSrcFitImgInfo.u4ImgXOff= 0;
        rSrcFitImgInfo.u4ImgYOff = 0;
        rSrcFitImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
        rSrcFitImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
        
        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not ARGB.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateScalingRatioOddCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = _u4SrcImgInfoSA1;//(UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
/*
#if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_UDVT_USBRW 
                i4ImgReszVfyPrintf("[ImgResz][Verify] Please dump file to %x.\n",rSrcFitImgInfo.u4BufSA1);
                FATS_IF_WaitResponse("Please dump file to DRAM...", 50000);
#else
                //i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u48BufSize);
#endif
*/
            }

            // Copy source fit buffer to source buffer
            u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
            rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
            VERIFY(rSrcImgInfo.u4BufSA1 != 0);
            vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

            // Destination buffer
            u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
            rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
            VERIFY(rDestImgInfo.u4BufSA1 != 0);

            // Generate destination fit buffer info
            x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
            rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
            rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
            rDestFitImgInfo.u4ImgXOff = 0;
            rDestFitImgInfo.u4ImgYOff = 0;
            u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
            rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
            VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
            x_memset((void *)rDestFitImgInfo.u4BufSA1,0,u4BufSize);
            for(u4HwId=0; u4HwId<=IMG_RESZ_VFY_HW_NUM; u4HwId++)
            {
                if(!_afgImgReszVfyHwEnable[u4HwId])
                    continue;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] dstfit buf addr=%x\n",rDestFitImgInfo.u4BufSA1);
                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);
                i4ImgReszVfyPrintf ("[IMG_RESZ]Resize finish\n ");
                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                    i4ImgReszVfyPrintf ("[IMG_RESZ]rDestGoldImgInfo.u4BufSA1 = %x, size=%x\n ", rDestGoldImgInfo.u4BufSA1, u4BufSize);
/*
                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file

                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,FALSE,
                                            FALSE,0,0);
 */                                           
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr1 = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr1 = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr1) != *(UINT8 *)(u4DestGoldAddr1))
                            VERIFY(FALSE);

                        u4DestFitAddr1++;
                        u4DestGoldAddr1++;
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);

    }
/*
    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);
*/
    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}

INT32 i4ImgReszVfyTestScalingRatioOddIndex(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
#if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
#else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
#endif  

    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

       /* if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_INDEX_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Index.\n");
            continue;
        }*/

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
        rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateScalingRatioOddCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Copy source fit buffer to source buffer
            u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
             rSrcImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
             i4ImgReszVfyPrintf("[ImgResz][Verify] SRC buffer size : %d,Src addr :%x.\n",u4BufSize,rSrcImgInfo.u4BufSA1);
#else
            rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
#endif
            VERIFY(rSrcImgInfo.u4BufSA1 != 0);
            vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

            // Destination buffer
            u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
             rDestImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
             i4ImgReszVfyPrintf("[ImgResz][Verify] DST buffer size : %d,DST addr :%x.\n",u4BufSize,rDestImgInfo.u4BufSA1);
#else
            rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
#endif
	     i4ImgReszVfyPrintf("[ImgResz][Verify] source addr %x.\n",rSrcFitImgInfo.u4BufSA1);
            VERIFY(rDestImgInfo.u4BufSA1 != 0);

            // Generate destination fit buffer info
            x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
            rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
            rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
            rDestFitImgInfo.u4ImgXOff = 0;
            rDestFitImgInfo.u4ImgYOff = 0;
            u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
            rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
            VERIFY(rDestFitImgInfo.u4BufSA1 != 0);

            for(u4HwId=0; u4HwId<=IMG_RESZ_VFY_HW_NUM; u4HwId++)
            {
                if(!_afgImgReszVfyHwEnable[u4HwId])
                    continue;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,FALSE,
                                            FALSE,0,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr1 = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr1 = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr1) != *(UINT8 *)(u4DestGoldAddr1))
                            VERIFY(FALSE);

                        u4DestFitAddr1++;
                        u4DestGoldAddr1++;
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }
            }
#if IMGRESZ_IO_MMU_TEST
            x_free_vmem((void *)rSrcImgInfo.u4BufSA1);
            x_free_vmem((void *)rDestImgInfo.u4BufSA1);
#else
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
#endif
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.rBufferFormat.prColorPallet != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.rBufferFormat.prColorPallet);
    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyTestScalingRatioOddJpegToVideo(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
      #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Jpeg.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER;
        rDestImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateScalingRatioOddCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
                rSrcFitImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA3 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Copy source fit buffer to source buffer
            u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
            rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
            VERIFY(rSrcImgInfo.u4BufSA1 != 0);
            rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
            VERIFY(rSrcImgInfo.u4BufSA2 != 0);
            rSrcImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
            VERIFY(rSrcImgInfo.u4BufSA3 != 0);
            vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

            // Destination buffer
            if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            {
                u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                VERIFY(rDestImgInfo.u4BufSA1 != 0);
                rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                VERIFY(rDestImgInfo.u4BufSA2 != 0);
            } else if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER)
            {
                u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                VERIFY(rDestImgInfo.u4BufSA1 != 0);
            }

            // Generate destination fit buffer info
            x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
            rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
            rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
            rDestFitImgInfo.u4ImgXOff = 0;
            rDestFitImgInfo.u4ImgYOff = 0;
            u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
            rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
            VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
            if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            {
                rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rDestFitImgInfo.u4BufSA2 != 0);
            }

            for(u4HwId=0; u4HwId<=IMG_RESZ_VFY_HW_NUM; u4HwId++)
            {
                if(!_afgImgReszVfyHwEnable[u4HwId])
                    continue;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                    if(rDestGoldImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        rDestGoldImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                        VERIFY(rDestGoldImgInfo.u4BufSA2 != 0);
                        x_memcpy((void *)rDestGoldImgInfo.u4BufSA2,(void *)rDestFitImgInfo.u4BufSA2,u4BufSize);
                    }

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            FALSE,0,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            if(rDestImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            if(rDestFitImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            if(rDestGoldImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA3);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
        if(rSrcFitImgInfo.u4BufSA3 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA3);
    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyTestScalingRatioOddJpegToAYUV(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
       #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Jpeg.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
        rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateScalingRatioOddCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
                rSrcFitImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA3 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Copy source fit buffer to source buffer
            u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
            rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
            VERIFY(rSrcImgInfo.u4BufSA1 != 0);
            rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
            VERIFY(rSrcImgInfo.u4BufSA2 != 0);
            rSrcImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
            VERIFY(rSrcImgInfo.u4BufSA3 != 0);
            vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

            // Destination buffer
            if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            {
                u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                VERIFY(rDestImgInfo.u4BufSA1 != 0);
                rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                VERIFY(rDestImgInfo.u4BufSA2 != 0);
            } else if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER)
            {
                u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                u4BufSize = ((u4BufSize + 31) / 32) * 32; // Align to 32 for address swap
                rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,32);
                VERIFY(rDestImgInfo.u4BufSA1 != 0);
            }

            // Generate destination fit buffer info
            x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
            rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
            rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
            rDestFitImgInfo.u4ImgXOff = 0;
            rDestFitImgInfo.u4ImgYOff = 0;
            u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
            u4BufSize = ((u4BufSize + 31) / 32) * 32; // Align to 32 for address swap
            rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,32);
            VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
            if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            {
                rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rDestFitImgInfo.u4BufSA2 != 0);
            }

            for(u4HwId=0; u4HwId<=IMG_RESZ_VFY_HW_NUM; u4HwId++)
            {
                if(!_afgImgReszVfyHwEnable[u4HwId])
                    continue;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                    if(rDestGoldImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        rDestGoldImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                        VERIFY(rDestGoldImgInfo.u4BufSA2 != 0);
                        x_memcpy((void *)rDestGoldImgInfo.u4BufSA2,(void *)rDestFitImgInfo.u4BufSA2,u4BufSize);
                    }

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            FALSE,0,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            if(rDestImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            if(rDestFitImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            if(rDestGoldImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA3);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
        if(rSrcFitImgInfo.u4BufSA3 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA3);
    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}



INT32 i4ImgReszVfyGenerateArbitraryLocationCase(UINT32 u4TestCase,
                                                IMGRESZ_HAL_RESIZE_MODE_T *peResizeMode,
                                                IMGRESZ_HAL_RESAMPLE_METHOD_T *peHResampleMethod,
                                                IMGRESZ_HAL_RESAMPLE_METHOD_T *peVResampleMethod,
                                                IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfo,
                                                IMGRESZ_HAL_IMG_INFO_T *prDestImgInfo)
{
    UINT32 u4Case;
    UINT32 u4SrcBufWidth = 1920, u4SrcBufHeight = 1080;
    UINT32 u4DestBufWidth = 1920, u4DestBufHeight = 1080;

    if((prSrcImgInfo->u4ImgWidth > u4SrcBufWidth) || (prSrcImgInfo->u4ImgHeight > u4SrcBufHeight))
    {
        u4SrcBufWidth = prSrcImgInfo->u4ImgWidth;
        u4SrcBufHeight = prSrcImgInfo->u4ImgHeight;

        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
    }

    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
        u4SrcBufHeight = ((u4SrcBufHeight + 31)/ 32) * 32; // Align to 32
    }

    if(prDestImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4DestBufWidth = ((u4DestBufWidth + 15) / 16) * 16;  // Align to 16
        u4DestBufHeight = ((u4DestBufHeight + 31)/ 32) * 32; // Align to 32
    }

    prSrcImgInfo->u4BufWidth = u4SrcBufWidth * u4ImgReszVfyCalBufFormatBits(&(prSrcImgInfo->rBufferFormat)) / 8;
    prSrcImgInfo->u4BufHeight = u4SrcBufHeight;
    prDestImgInfo->u4BufWidth = u4DestBufWidth * u4ImgReszVfyCalBufFormatBits(&(prDestImgInfo->rBufferFormat)) / 8;
    prDestImgInfo->u4BufHeight = u4DestBufHeight;

    // Resize mode variation and Resize method variation
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= 2;
    } else
    {
        UINT32 u4CaseNum = 6;

        // Y/C buffer has only frame mode, no partial mode.
        if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            u4CaseNum = 4;

        u4Case = u4TestCase % u4CaseNum;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 2:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 3:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 4:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 5:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= u4CaseNum;
    }

    // Progressive frame or interlaced frame
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                break;
            case 1:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                break;
        }
        u4TestCase /= 2;
    }

    // Destination size variation
    u4Case = u4TestCase % 3;
    switch(u4Case)
    {
        case 0:
            prDestImgInfo->u4ImgWidth = 352;
            prDestImgInfo->u4ImgHeight = 240;
            break;
        case 1:
            prDestImgInfo->u4ImgWidth = 960;
            prDestImgInfo->u4ImgHeight = 640;
            break;
        case 2:
            prDestImgInfo->u4ImgWidth = 1600;
            prDestImgInfo->u4ImgHeight = 900;
            break;
    }
    u4TestCase /= 3;

    if(u4TestCase > 0)
        return -1;

    return 0;
}


INT32 i4ImgReszVfyGenerateSubCase(UINT32 u4TestSubCase,UINT32 u4SubCaseType,
                                  UINT32 *pu4HwId,IMGRESZ_HAL_RESIZE_MODE_T eResizeMode,
                                  IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfoNext,
                                  IMGRESZ_HAL_IMG_INFO_T *prDestImgInfoNext)
{
    UINT32 u4Case;
    UINT32 u4HwId;
    UINT32 u4EnalbeHwCnt,u4HwCnt;

    u4EnalbeHwCnt = 0;
    for(u4HwId=0; u4HwId<=IMG_RESZ_VFY_HW_NUM; u4HwId++)
    {
        if(_afgImgReszVfyHwEnable[u4HwId])
            u4EnalbeHwCnt++;
    }

    if(u4EnalbeHwCnt == 0)
        return -1;

    // Hw id variation
    u4Case = u4TestSubCase % u4EnalbeHwCnt;
    u4HwCnt = 0;
    for(u4HwId=0; u4HwId<=IMG_RESZ_VFY_HW_NUM; u4HwId++)
    {
        if(_afgImgReszVfyHwEnable[u4HwId])
        {
            if(u4HwCnt == u4Case)
            {
                *pu4HwId = u4HwId;
                break;
            }
            u4HwCnt++;
        }
    }
    u4TestSubCase /= u4EnalbeHwCnt;

    if(u4SubCaseType == 2)
    {
        // Source location and destination location variation
        if(eResizeMode == IMGRESZ_HAL_RESIZE_MODE_PARTIAL)
        {
            // Jpeg only has destination location variation
            u4Case = u4TestSubCase % 16;
            u4Case += 16;
        } else
        {
            u4Case = u4TestSubCase % 32;
        }
        if(u4Case < 8)
        {
            // Source horizontal location variation
            u4Case %= 8;

            prDestImgInfoNext->u4ImgXOff = 0;
            prDestImgInfoNext->u4ImgYOff = 0;

            prSrcImgInfoNext->u4ImgXOff = (prSrcImgInfoNext->u4BufWidth*8/u4ImgReszVfyCalBufFormatBits(&(prSrcImgInfoNext->rBufferFormat))
                                        - prSrcImgInfoNext->u4ImgWidth);
            prSrcImgInfoNext->u4ImgXOff = prSrcImgInfoNext->u4ImgXOff*u4Case/8;
            prSrcImgInfoNext->u4ImgXOff = ((prSrcImgInfoNext->u4ImgXOff + 15) >> 4) << 4; // Align to 16's
            prSrcImgInfoNext->u4ImgXOff += (7 - u4Case) * 2;

            if(prSrcImgInfoNext->u4ImgXOff >=
               (prSrcImgInfoNext->u4BufWidth*8/u4ImgReszVfyCalBufFormatBits(&(prSrcImgInfoNext->rBufferFormat))
                                        - prSrcImgInfoNext->u4ImgWidth))
                return -1;

            prSrcImgInfoNext->u4ImgYOff = (prSrcImgInfoNext->u4BufHeight - prSrcImgInfoNext->u4ImgHeight)/2;

            if(prSrcImgInfoNext->u4ImgXOff & 1)
                prSrcImgInfoNext->u4ImgXOff--;
            if(prSrcImgInfoNext->u4ImgYOff & 1)
                prSrcImgInfoNext->u4ImgYOff--;

            if((prSrcImgInfoNext->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER) &&
               (!prSrcImgInfoNext->rBufferFormat.fgProgressiveFrame) &&
               (prSrcImgInfoNext->rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420) &&
               ((prSrcImgInfoNext->u4ImgYOff & 3) != 0))
               prSrcImgInfoNext->u4ImgYOff = (prSrcImgInfoNext->u4ImgYOff>>2)<<2;  // Align to 4's
        } else if(u4Case < 16)
        {
            // Source vertical location variation
            u4Case %= 8;

            prDestImgInfoNext->u4ImgXOff = 0;
            prDestImgInfoNext->u4ImgYOff = 0;

            prSrcImgInfoNext->u4ImgXOff = ((prSrcImgInfoNext->u4BufWidth*8/u4ImgReszVfyCalBufFormatBits(&(prSrcImgInfoNext->rBufferFormat)))
                                        - prSrcImgInfoNext->u4ImgWidth)/2;

            prSrcImgInfoNext->u4ImgYOff = (prSrcImgInfoNext->u4BufHeight - prSrcImgInfoNext->u4ImgHeight);
            prSrcImgInfoNext->u4ImgYOff = prSrcImgInfoNext->u4ImgYOff*u4Case/8;
            prSrcImgInfoNext->u4ImgYOff = ((prSrcImgInfoNext->u4ImgYOff + 15) >> 4) << 4; // Align to 16's
            prSrcImgInfoNext->u4ImgYOff += (7 - u4Case) * 2;

            if(prSrcImgInfoNext->u4ImgYOff >= (prSrcImgInfoNext->u4BufHeight - prSrcImgInfoNext->u4ImgHeight))
                return -1;

            if(prSrcImgInfoNext->u4ImgXOff & 1)
                prSrcImgInfoNext->u4ImgXOff--;
            if(prSrcImgInfoNext->u4ImgYOff & 1)
                prSrcImgInfoNext->u4ImgYOff--;

            if((prSrcImgInfoNext->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER) &&
               (!prSrcImgInfoNext->rBufferFormat.fgProgressiveFrame) &&
               (prSrcImgInfoNext->rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420) &&
               ((prSrcImgInfoNext->u4ImgYOff & 3) != 0))
               prSrcImgInfoNext->u4ImgYOff = (prSrcImgInfoNext->u4ImgYOff>>2)<<2;  // Align to 4's
        } else if(u4Case < 24)
        {
            // Destination horizontal location variation
            u4Case %= 8;

            prSrcImgInfoNext->u4ImgXOff = 0;
            prSrcImgInfoNext->u4ImgYOff = 0;

            prDestImgInfoNext->u4ImgXOff = (prDestImgInfoNext->u4BufWidth*8/u4ImgReszVfyCalBufFormatBits(&(prDestImgInfoNext->rBufferFormat))
                                        - prDestImgInfoNext->u4ImgWidth);
            prDestImgInfoNext->u4ImgXOff = prDestImgInfoNext->u4ImgXOff*u4Case/8;
            prDestImgInfoNext->u4ImgXOff = ((prDestImgInfoNext->u4ImgXOff + 15) >> 4) << 4; // Align to 16's
            prDestImgInfoNext->u4ImgXOff += (7 - u4Case) * 2;

            if(prDestImgInfoNext->u4ImgXOff >=
               (prDestImgInfoNext->u4BufWidth*8/u4ImgReszVfyCalBufFormatBits(&(prDestImgInfoNext->rBufferFormat))
                                        - prDestImgInfoNext->u4ImgWidth))
                return -1;

            prDestImgInfoNext->u4ImgYOff = (prDestImgInfoNext->u4BufHeight - prDestImgInfoNext->u4ImgHeight)/2;

            if(prDestImgInfoNext->u4ImgXOff & 1)
                prDestImgInfoNext->u4ImgXOff--;
            if(prDestImgInfoNext->u4ImgYOff & 1)
                prDestImgInfoNext->u4ImgYOff--;

            if((prDestImgInfoNext->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER) &&
               (!prDestImgInfoNext->rBufferFormat.fgProgressiveFrame) &&
               (prDestImgInfoNext->rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420) &&
               ((prDestImgInfoNext->u4ImgYOff & 3) != 0))
               prDestImgInfoNext->u4ImgYOff = (prDestImgInfoNext->u4ImgYOff>>2)<<2;  // Align to 4's
        } else
        {
            // Destination vertical location variation
            u4Case %= 8;

            prSrcImgInfoNext->u4ImgXOff = 0;
            prSrcImgInfoNext->u4ImgYOff = 0;

            prDestImgInfoNext->u4ImgXOff = ((prDestImgInfoNext->u4BufWidth*8/u4ImgReszVfyCalBufFormatBits(&(prDestImgInfoNext->rBufferFormat)))
                                        - prDestImgInfoNext->u4ImgWidth)/2;

            prDestImgInfoNext->u4ImgYOff = (prDestImgInfoNext->u4BufHeight - prDestImgInfoNext->u4ImgHeight);
            prDestImgInfoNext->u4ImgYOff = prDestImgInfoNext->u4ImgYOff*u4Case/8;
            prDestImgInfoNext->u4ImgYOff = ((prDestImgInfoNext->u4ImgYOff + 15) >> 4) << 4; // Align to 16's
            prDestImgInfoNext->u4ImgYOff += (7 - u4Case) * 2;

            if(prDestImgInfoNext->u4ImgYOff >= (prDestImgInfoNext->u4BufHeight - prDestImgInfoNext->u4ImgHeight))
                return -1;

            if(prDestImgInfoNext->u4ImgXOff & 1)
                prDestImgInfoNext->u4ImgXOff--;
            if(prDestImgInfoNext->u4ImgYOff & 1)
                prDestImgInfoNext->u4ImgYOff--;

            if((prDestImgInfoNext->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER) &&
               (!prDestImgInfoNext->rBufferFormat.fgProgressiveFrame) &&
               (prDestImgInfoNext->rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420) &&
               ((prDestImgInfoNext->u4ImgYOff & 3) != 0))
               prDestImgInfoNext->u4ImgYOff = (prDestImgInfoNext->u4ImgYOff>>2)<<2;  // Align to 4's
        }

        if(prSrcImgInfoNext->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
        {
            u4TestSubCase /= 16;
        } else
        {
            u4TestSubCase /= 32;
        }
    }

    if(u4SubCaseType == 3)
    {
        // Block mode and Address swap mode variation
        if(prSrcImgInfoNext->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
        {
            u4Case = u4TestSubCase % 4;
            switch(u4Case)
            {
                case 0:
                    prSrcImgInfoNext->rBufferFormat.fgBlockMode = FALSE;
                    prSrcImgInfoNext->rBufferFormat.fgAddrSwap = FALSE;
                    break;
                case 1:
                    prSrcImgInfoNext->rBufferFormat.fgBlockMode = TRUE;
                    prSrcImgInfoNext->rBufferFormat.fgAddrSwap = FALSE;
                    break;
                case 2:
                    prSrcImgInfoNext->rBufferFormat.fgBlockMode = FALSE;
                    prSrcImgInfoNext->rBufferFormat.fgAddrSwap = TRUE;
                    break;
                case 3:
                    prSrcImgInfoNext->rBufferFormat.fgBlockMode = TRUE;
                    prSrcImgInfoNext->rBufferFormat.fgAddrSwap = TRUE;
                    break;
            }
            u4TestSubCase /= 4;
        } else
        {
            prSrcImgInfoNext->rBufferFormat.fgBlockMode = FALSE;
            prSrcImgInfoNext->rBufferFormat.fgAddrSwap = FALSE;
        }

        // Block mode and Address swap mode variation
        if(prDestImgInfoNext->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
        {
            u4Case = u4TestSubCase % 2;
            switch(u4Case)
            {
                case 0:
                    prDestImgInfoNext->rBufferFormat.fgBlockMode = FALSE;
                    prDestImgInfoNext->rBufferFormat.fgAddrSwap = FALSE;
                    break;
                case 1:
                    prDestImgInfoNext->rBufferFormat.fgBlockMode = TRUE;
                    prDestImgInfoNext->rBufferFormat.fgAddrSwap = FALSE;
                    break;
                case 2:
                    prDestImgInfoNext->rBufferFormat.fgBlockMode = FALSE;
                    prDestImgInfoNext->rBufferFormat.fgAddrSwap = TRUE;
                    break;
                case 3:
                    prDestImgInfoNext->rBufferFormat.fgBlockMode = TRUE;
                    prDestImgInfoNext->rBufferFormat.fgAddrSwap = TRUE;
                    break;
            }
            u4TestSubCase /= 2;
        } else
        {
            prDestImgInfoNext->rBufferFormat.fgBlockMode = FALSE;
            prDestImgInfoNext->rBufferFormat.fgAddrSwap = FALSE;
        }

    }

    if(u4TestSubCase > 0)
        return -1;

    return 0;
}


INT32 i4ImgReszVfyTestArbitraryLocationARGB(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
   #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

      /*  if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not ARGB.\n");
            continue;
        }*/

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateArbitraryLocationCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,2,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                BOOL fgSourceOffsetChange = FALSE;

                if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);
                    x_memset((void *)rSrcImgInfo.u4BufSA1,0,u4BufSize);

                    // Allocate destination buffer
                    u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                    rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rDestImgInfo.u4BufSA1 != 0);
                    x_memset((void *)rDestImgInfo.u4BufSA1,0,u4BufSize);

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
                    rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                    rDestFitImgInfo.u4ImgXOff = 0;
                    rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                // Copy source fit buffer to source buffer
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,FALSE,
                                            FALSE,0,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            if(0)
            {
                imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            }

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyTestArbitraryLocationIndex(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
    #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  

    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

       /* if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_INDEX_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Index.\n");
            continue;
        }*///sun

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
        rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateArbitraryLocationCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,2,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                BOOL fgSourceOffsetChange = FALSE;

                if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
                    rSrcImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
                    i4ImgReszVfyPrintf("[ImgResz][Verify] SRC buffer size : %d,Src addr :%x.\n",u4BufSize,rSrcImgInfo.u4BufSA1);
#else
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
#endif
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);
                     x_memset((void *)rSrcImgInfo.u4BufSA1,0,u4BufSize);

                    // Allocate destination buffer
                    u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
                    rDestImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
                    i4ImgReszVfyPrintf("[ImgResz][Verify] DST buffer size : %d,DST addr :%x.\n",u4BufSize,rDestImgInfo.u4BufSA1);
#else
                    rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
#endif
                    VERIFY(rDestImgInfo.u4BufSA1 != 0);
                    x_memset((void *)rDestImgInfo.u4BufSA1,0,u4BufSize);

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
                    rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                    rDestFitImgInfo.u4ImgXOff = 0;
                    rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
                    x_memset((void *) rDestFitImgInfo.u4BufSA1,0,u4BufSize);

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                // Copy source fit buffer to source buffer
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,FALSE,
                                            FALSE,0,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;
                    UINT32 u4ErrCnt;
		      char bDestName[256];
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");

                    // Compare to golden
                    u4ErrCnt = 0;
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
		      //HalFlushInvalidateDCache();//chunze
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                        {
                           sprintf(bDestName,"%s.y.dst",(BYTE *)ppbFileList[u4CurFileListNum]);
			      i4ImgReszVfySaveDestBuf(bDestName,0,&rDestFitImgInfo);
                            VERIFY(FALSE);
                        }
                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    //if(u4ErrCnt)
                            //i4ImgReszVfyFprintf(i4LogFileHandler, "[ImgResz][Verify] Y Total unmatch count: %d.\n" , u4ErrCnt);
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }
#if IMGRESZ_IO_MMU_TEST
            x_free_vmem((void *)rSrcImgInfo.u4BufSA1);
            x_free_vmem((void *)rDestImgInfo.u4BufSA1);
#else
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
#endif
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            if(0)
            {
                imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            }

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
        if(rSrcFitImgInfo.rBufferFormat.prColorPallet != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.rBufferFormat.prColorPallet);
    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}



INT32 i4ImgReszVfyTestArbitraryLocationJpegToVideo(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
      #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  

    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Jpeg.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER;
        rDestImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateArbitraryLocationCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
                rSrcFitImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA3 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,2,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                BOOL fgSourceOffsetChange = FALSE;

                if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);
                    rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA2 != 0);
                    rSrcImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA3 != 0);

                    // Allocate destination buffer
                    if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                        u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                        rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                        VERIFY(rDestImgInfo.u4BufSA1 != 0);
                        rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                        VERIFY(rDestImgInfo.u4BufSA2 != 0);
                    } else if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER)
                    {
                        u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                        rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                        VERIFY(rDestImgInfo.u4BufSA1 != 0);
                    }

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
                    rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                    rDestFitImgInfo.u4ImgXOff = 0;
                    rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
                    if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                        VERIFY(rDestFitImgInfo.u4BufSA2 != 0);
                    }

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                // Copy source fit buffer to source buffer
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                {
  #if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8560)
                 if((rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[1] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0])
      		      &&(rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[2] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0]))
                     vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,TRUE);
      	         else
	              vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#else
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#endif
                }
                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                    if(rDestGoldImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        rDestGoldImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                        VERIFY(rDestGoldImgInfo.u4BufSA2 != 0);
                        x_memcpy((void *)rDestGoldImgInfo.u4BufSA2,(void *)rDestFitImgInfo.u4BufSA2,u4BufSize);
                    }

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            FALSE,0,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            if(rDestImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            if(rDestFitImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            if(rDestGoldImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA3);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
        if(rSrcFitImgInfo.u4BufSA3 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA3);
    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyTestArbitraryLocationJpegToAYUV(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
       #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Jpeg.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
        rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateArbitraryLocationCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
                rSrcFitImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA3 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,2,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                BOOL fgSourceOffsetChange = FALSE;

                if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);
                    rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA2 != 0);
                    rSrcImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA3 != 0);

                    // Allocate destination buffer
                    if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                        u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                        rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                        VERIFY(rDestImgInfo.u4BufSA1 != 0);
                        rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                        VERIFY(rDestImgInfo.u4BufSA2 != 0);
                    } else if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER)
                    {
                        u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                        rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                        VERIFY(rDestImgInfo.u4BufSA1 != 0);
                    }

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
                    rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                    rDestFitImgInfo.u4ImgXOff = 0;
                    rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
                    if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                        VERIFY(rDestFitImgInfo.u4BufSA2 != 0);
                    }

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                // Copy source fit buffer to source buffer
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                 {
 #if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8560)
                  if((rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[1] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0])
		      &&(rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[2] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0]))
                      vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,TRUE);
	           else
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#else
                   vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#endif
                }

                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                    if(rDestGoldImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        rDestGoldImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                        VERIFY(rDestGoldImgInfo.u4BufSA2 != 0);
                        x_memcpy((void *)rDestGoldImgInfo.u4BufSA2,(void *)rDestFitImgInfo.u4BufSA2,u4BufSize);
                    }

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            FALSE,0,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            if(rDestImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            if(rDestFitImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            if(rDestGoldImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA3);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
        if(rSrcFitImgInfo.u4BufSA3 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA3);
    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyTestArbitraryLocationVideo(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
       #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  

    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Video.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateArbitraryLocationCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,2,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                BOOL fgSourceOffsetChange = FALSE;

                if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
                    u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);
                    rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                    VERIFY(rSrcImgInfo.u4BufSA2 != 0);

                    // Allocate destination buffer
                    u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                    u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                    rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                    VERIFY(rDestImgInfo.u4BufSA1 != 0);
                    rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                    VERIFY(rDestImgInfo.u4BufSA2 != 0);

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth;
                    rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                    rDestFitImgInfo.u4ImgXOff = 0;
                    rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
                    rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA2 != 0);

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                // Copy source fit buffer to source buffer
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                    rDestGoldImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA2 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA2,(void *)rDestFitImgInfo.u4BufSA2,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            FALSE,0,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyGeneratePreloadBufAlphaBlendingCase(UINT32 u4TestCase,
                                                      IMGRESZ_HAL_RESIZE_MODE_T *peResizeMode,
                                                      IMGRESZ_HAL_RESAMPLE_METHOD_T *peHResampleMethod,
                                                      IMGRESZ_HAL_RESAMPLE_METHOD_T *peVResampleMethod,
                                                      IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfo,
                                                      IMGRESZ_HAL_IMG_INFO_T *prDestImgInfo,
                                                      BOOL fgPreloadBuf,UINT32 *pu4Alpha)
{
    UINT32 u4Case;
    UINT32 u4SrcBufWidth = 1920, u4SrcBufHeight = 1080;
    UINT32 u4DestBufWidth = 1920, u4DestBufHeight = 1080;

    if((prSrcImgInfo->u4ImgWidth > u4SrcBufWidth) || (prSrcImgInfo->u4ImgHeight > u4SrcBufHeight))
    {
        u4SrcBufWidth = prSrcImgInfo->u4ImgWidth;
        u4SrcBufHeight = prSrcImgInfo->u4ImgHeight;

        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
    }

    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
        u4SrcBufHeight = ((u4SrcBufHeight + 31)/ 32) * 32; // Align to 32
    }

    if(prDestImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4DestBufWidth = ((u4DestBufWidth + 15) / 16) * 16;  // Align to 16
        u4DestBufHeight = ((u4DestBufHeight + 31)/ 32) * 32; // Align to 32
    }

    prSrcImgInfo->u4BufWidth = u4SrcBufWidth * u4ImgReszVfyCalBufFormatBits(&(prSrcImgInfo->rBufferFormat)) / 8;
    prSrcImgInfo->u4BufHeight = u4SrcBufHeight;
    prDestImgInfo->u4BufWidth = u4DestBufWidth * u4ImgReszVfyCalBufFormatBits(&(prDestImgInfo->rBufferFormat)) / 8;
    prDestImgInfo->u4BufHeight = u4DestBufHeight;
    _fgAlphaB = TRUE;
    // Alfa variation
    if(fgPreloadBuf)
    {
#if defined(IMGRESZ_HAL_MT8550) || defined(IMGRESZ_HAL_MT8530)
        // MT8530 alfa blending range is from 0 ~ 128
        u4Case = u4TestCase % ((8<<0)+1);
        *pu4Alpha = (u4Case<<4);
        u4TestCase /= ((8<<0)+1);
#else
        // MT8530 alfa blending range is from 0 ~ 8
        u4Case = u4TestCase % ((8<<0)+1);
        *pu4Alpha = (u4Case<<0);
        u4TestCase /= ((8<<0)+1);
#endif
    }

    // Resize mode variation and Resize method variation
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= 2;
    } else
    {
        UINT32 u4CaseNum = 6;

        // Y/C buffer has only frame mode, no partial mode.
        if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            u4CaseNum = 4;

        u4Case = u4TestCase % u4CaseNum;
        //if(u4Case == 1)
            //u4Case = 4;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 2:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 3:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 4:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 5:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= u4CaseNum;
    }

    // Progressive frame or interlaced frame
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                break;
            case 1:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                break;
        }
        u4TestCase /= 2;
    }

    // Destination size variation
    u4Case = u4TestCase % 2;
    switch(u4Case)
    {
        case 0:
            prDestImgInfo->u4ImgWidth = 352;
            prDestImgInfo->u4ImgHeight = 240;
            break;
        case 1:
            prDestImgInfo->u4ImgWidth = 1600;
            prDestImgInfo->u4ImgHeight = 900;
            break;
    }
    u4TestCase /= 2;

    if(u4TestCase > 0)
        return -1;

    return 0;
}



INT32 i4ImgReszVfyTestLoadPreloadBuf(BYTE *pbFileName,IMGRESZ_HAL_IMG_INFO_T *prPreloadBufInfo)
{
    INT32 i4Ret;
    char bFileName[256];
    char bLine[256];
    UINT32 u4PreloadBufInfoSa;
    UINT32 u4BufSize;

    i4ImgReszVfyGetPath(bFileName,(char *)pbFileName);
    strcat(bFileName,"preloadbuf.txt");

    // Load preload file info
    u4PreloadBufInfoSa = (UINT32)imgreszvfy_alloc_mem_aligned(256,1);
    i4ImgReszVfyPrintf("[ImgResz][Verify] Load Preload Buffer Info File %s\n",bFileName);
    i4Ret = i4ImgReszVfyReadFile((char *)bFileName,u4PreloadBufInfoSa,256);
    if(i4Ret < 0)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load Preload Buffer Info File fail\n");
        imgreszvfy_free_mem_aligned((void *)u4PreloadBufInfoSa);
        return i4Ret;
    }

    // Load preload file
    i4ImgReszVfyGetLine(u4PreloadBufInfoSa,bLine);
    i4ImgReszVfyGetPath(bFileName,(char *)pbFileName);
    strcat(bFileName,bLine);
    i4ImgReszVfyLoadBufInfo((BYTE *)bFileName,prPreloadBufInfo);

    u4BufSize = prPreloadBufInfo->u4BufWidth*prPreloadBufInfo->u4ImgHeight;
    prPreloadBufInfo->u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
    VERIFY(prPreloadBufInfo->u4BufSA1 != 0);
    if(prPreloadBufInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        prPreloadBufInfo->u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
        VERIFY(prPreloadBufInfo->u4BufSA2 != 0);
    }
    i4ImgReszVfyLoadBuf((BYTE *)bFileName,prPreloadBufInfo,u4BufSize);

    return 0;
}


INT32 i4ImgReszVfyTestPreloadBufAlphaBlendingARGB(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rPreloadBufInfo;
    BOOL fgPreloadBuf = FALSE;
    UINT32 u4Alpha = 0;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
       #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
    {
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);
        x_memset(&rPreloadBufInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        if(i4ImgReszVfyTestLoadPreloadBuf(ppbFileList[0],&rPreloadBufInfo) >= 0)
            fgPreloadBuf = TRUE;
    }

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        x_memset(&rBlBufnfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not ARGB.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        u4TestCase = 0;

        while(i4ImgReszVfyGeneratePreloadBufAlphaBlendingCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo,fgPreloadBuf,&u4Alpha)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,1,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                BOOL fgSourceOffsetChange = FALSE;

                if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);

                    // Allocate destination buffer
                    u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                    rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rDestImgInfo.u4BufSA1 != 0);

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
                    rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                    rDestFitImgInfo.u4ImgXOff = 0;
                    rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                // Copy source fit buffer to source buffer
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Preload buffer
                if(fgPreloadBuf)
                {
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Preload buffer alpha %d.\n",u4Alpha);
                    rBlBufnfo.u1Alpha = u4Alpha;
                    rBlBufnfo.u4BufSA1 = rPreloadBufInfo.u4BufSA1;
                    rBlBufnfo.u4BufSA2 = rPreloadBufInfo.u4BufSA2;
                    i4ImgResz_HAL_Set_Blending_Image_Info(u4HwId, &rBlBufnfo);
                }

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            fgPreloadBuf,u4Alpha,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            if(0)
            {
                imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            }

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
    }

    if(u4FileListNum>0)
    {
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);
        if(rPreloadBufInfo.u4BufSA1 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA1);
        if(rPreloadBufInfo.u4BufSA2 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA2);
    }

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyTestPreloadBufAlphaBlendingIndex(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rPreloadBufInfo;
    BOOL fgPreloadBuf = FALSE;
    UINT32 u4Alpha = 0;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
       #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
    {
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);
        x_memset(&rPreloadBufInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        if(i4ImgReszVfyTestLoadPreloadBuf(ppbFileList[0],&rPreloadBufInfo) >= 0)
            fgPreloadBuf = TRUE;
    }

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        x_memset(&rBlBufnfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        /*if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_INDEX_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Index.\n");
            continue;
        }*/

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
        rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;

        u4TestCase = 0;

        while(i4ImgReszVfyGeneratePreloadBufAlphaBlendingCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo,fgPreloadBuf,&u4Alpha)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,1,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                BOOL fgSourceOffsetChange = FALSE;

                if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
                    rSrcImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
                     i4ImgReszVfyPrintf("[ImgResz][Verify] SRC buffer size : %d,Src addr :%x.\n",u4BufSize,rSrcImgInfo.u4BufSA1);
#else
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
#endif
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);

                    // Allocate destination buffer
                    u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
                    rDestImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
                     i4ImgReszVfyPrintf("[ImgResz][Verify] DST buffer size : %d,DST addr :%x.\n",u4BufSize,rDestImgInfo.u4BufSA1);
#else
                    rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
#endif
                    VERIFY(rDestImgInfo.u4BufSA1 != 0);

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
                    rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                    rDestFitImgInfo.u4ImgXOff = 0;
                    rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                // Copy source fit buffer to source buffer
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Preload buffer
                if(fgPreloadBuf)
                {
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Preload buffer alpha %d.\n",u4Alpha);
                    rBlBufnfo.u1Alpha = u4Alpha;
                    rBlBufnfo.u4BufSA1 = rPreloadBufInfo.u4BufSA1;
                    rBlBufnfo.u4BufSA2 = rPreloadBufInfo.u4BufSA2;
                    i4ImgResz_HAL_Set_Blending_Image_Info(u4HwId, &rBlBufnfo);
                }

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            fgPreloadBuf,u4Alpha,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }
#if IMGRESZ_IO_MMU_TEST
            x_free_vmem((void *)rSrcImgInfo.u4BufSA1);
            x_free_vmem((void *)rDestImgInfo.u4BufSA1);
#else
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
#endif
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            if(0)
            {
                imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            }

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
        if(rSrcFitImgInfo.rBufferFormat.prColorPallet != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.rBufferFormat.prColorPallet);
    }

    if(u4FileListNum>0)
    {
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);
        if(rPreloadBufInfo.u4BufSA1 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA1);
        if(rPreloadBufInfo.u4BufSA2 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA2);
    }

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyTestPreloadBufAlphaBlendingJpegToVideo(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rPreloadBufInfo;
    BOOL fgPreloadBuf = FALSE;
    UINT32 u4Alpha = 0;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);

    if(u4FileListNum>0)
    {
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);
        x_memset(&rPreloadBufInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        if(i4ImgReszVfyTestLoadPreloadBuf(ppbFileList[0],&rPreloadBufInfo) >= 0)
            fgPreloadBuf = TRUE;
    }

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        x_memset(&rBlBufnfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Jpeg.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER;
        rDestImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;

        u4TestCase = 0;

        while(i4ImgReszVfyGeneratePreloadBufAlphaBlendingCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo,fgPreloadBuf,&u4Alpha)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
                rSrcFitImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA3 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,1,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                BOOL fgSourceOffsetChange = FALSE;

                if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);
                    rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA2 != 0);
                    rSrcImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA3 != 0);

                    // Allocate destination buffer
                    if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                        u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                        rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                        VERIFY(rDestImgInfo.u4BufSA1 != 0);
                        rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                        VERIFY(rDestImgInfo.u4BufSA2 != 0);
                    } else if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER)
                    {
                        u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                        rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                        VERIFY(rDestImgInfo.u4BufSA1 != 0);
                    }

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
                    rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                    rDestFitImgInfo.u4ImgXOff = 0;
                    rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
                    if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                        VERIFY(rDestFitImgInfo.u4BufSA2 != 0);
                    }

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                // Copy source fit buffer to source buffer
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                {
#if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8560)
                  if((rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[1] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0])
		      &&(rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[2] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0]))
                      vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,TRUE);
	         else
	               vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#else
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#endif
                }
                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Preload buffer
                if(fgPreloadBuf)
                {
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Preload buffer alpha %d.\n",u4Alpha);
                    rBlBufnfo.u1Alpha = u4Alpha;
                    rBlBufnfo.u4BufSA1 = rPreloadBufInfo.u4BufSA1;
                    rBlBufnfo.u4BufSA2 = rPreloadBufInfo.u4BufSA2;
                    i4ImgResz_HAL_Set_Blending_Image_Info(u4HwId, &rBlBufnfo);
                    //i4HwImgReszSetAlphaBlendingLevel(u4HwId,u4Alpha);
                    //i4HwImgReszSetPreloadBufAddr(u4HwId,rPreloadBufInfo.u4BufSA1,rPreloadBufInfo.u4BufSA2);
                }

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                    if(rDestGoldImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        rDestGoldImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                        VERIFY(rDestGoldImgInfo.u4BufSA2 != 0);
                        x_memcpy((void *)rDestGoldImgInfo.u4BufSA2,(void *)rDestFitImgInfo.u4BufSA2,u4BufSize);
                    }

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            fgPreloadBuf,u4Alpha,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            if(rDestImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            if(rDestFitImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            if(rDestGoldImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA3);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
        if(rSrcFitImgInfo.u4BufSA3 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA3);
    }

    if(u4FileListNum>0)
    {
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);
        if(rPreloadBufInfo.u4BufSA1 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA1);
        if(rPreloadBufInfo.u4BufSA2 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA2);
    }

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyTestPreloadBufAlphaBlendingJpegToAYUV(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rPreloadBufInfo;
    BOOL fgPreloadBuf = FALSE;
    UINT32 u4Alpha = 0;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
   #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
    {
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);
        x_memset(&rPreloadBufInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        if(i4ImgReszVfyTestLoadPreloadBuf(ppbFileList[0],&rPreloadBufInfo) >= 0)
            fgPreloadBuf = TRUE;
    }

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        x_memset(&rBlBufnfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Jpeg.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
        rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;

        u4TestCase = 0;

        while(i4ImgReszVfyGeneratePreloadBufAlphaBlendingCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo,fgPreloadBuf,&u4Alpha)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
                rSrcFitImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA3 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,1,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                BOOL fgSourceOffsetChange = FALSE;

                if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);
                    rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA2 != 0);
                    rSrcImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA3 != 0);

                    // Allocate destination buffer
                    if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                        u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                        rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                        VERIFY(rDestImgInfo.u4BufSA1 != 0);
                        rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                        VERIFY(rDestImgInfo.u4BufSA2 != 0);
                    } else if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER)
                    {
                        u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                        rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                        VERIFY(rDestImgInfo.u4BufSA1 != 0);
                    }

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
                    rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                    rDestFitImgInfo.u4ImgXOff = 0;
                    rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
                    if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                        VERIFY(rDestFitImgInfo.u4BufSA2 != 0);
                    }

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                // Copy source fit buffer to source buffer
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                 {
 #if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8560)
                  if((rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[1] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0])
		      &&(rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[2] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0]))
                      vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,TRUE);
	           else
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#else
                   vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#endif
                 }
                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Preload buffer
                if(fgPreloadBuf)
                {
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Preload buffer alpha %d.\n",u4Alpha);
                    rBlBufnfo.u1Alpha = u4Alpha;
                    rBlBufnfo.u4BufSA1 = rPreloadBufInfo.u4BufSA1;
                    rBlBufnfo.u4BufSA2 = rPreloadBufInfo.u4BufSA2;
                    i4ImgResz_HAL_Set_Blending_Image_Info(u4HwId, &rBlBufnfo);
                }

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                    if(rDestGoldImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        rDestGoldImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                        VERIFY(rDestGoldImgInfo.u4BufSA2 != 0);
                        x_memcpy((void *)rDestGoldImgInfo.u4BufSA2,(void *)rDestFitImgInfo.u4BufSA2,u4BufSize);
                    }

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            fgPreloadBuf,u4Alpha,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            if(rDestImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            if(rDestFitImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            if(rDestGoldImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA3);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
        if(rSrcFitImgInfo.u4BufSA3 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA3);
    }

    if(u4FileListNum>0)
    {
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);
        if(rPreloadBufInfo.u4BufSA1 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA1);
        if(rPreloadBufInfo.u4BufSA2 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA2);
    }

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyTestPreloadBufAlphaBlendingVideo(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rPreloadBufInfo;
    BOOL fgPreloadBuf = FALSE;
    UINT32 u4Alpha = 0;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
   #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
    {
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);
        x_memset(&rPreloadBufInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        if(i4ImgReszVfyTestLoadPreloadBuf(ppbFileList[0],&rPreloadBufInfo) >= 0)
            fgPreloadBuf = TRUE;
    }

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        x_memset(&rBlBufnfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Video.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        u4TestCase = 0;

        while(i4ImgReszVfyGeneratePreloadBufAlphaBlendingCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo,fgPreloadBuf,&u4Alpha)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,1,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                BOOL fgSourceOffsetChange = FALSE;

                if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
                    u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);
                    rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                    VERIFY(rSrcImgInfo.u4BufSA2 != 0);

                    // Allocate destination buffer
                    u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                    u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                    rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                    VERIFY(rDestImgInfo.u4BufSA1 != 0);
                    rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                    VERIFY(rDestImgInfo.u4BufSA2 != 0);

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth;
                    rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                    rDestFitImgInfo.u4ImgXOff = 0;
                    rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
                    rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA2 != 0);

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                // Copy source fit buffer to source buffer
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Preload buffer
                if(fgPreloadBuf)
                {
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Preload buffer alpha %d.\n",u4Alpha);
		     // _rImgReszHalInfo[u4HwId].rBldImgInfo.u1Alpha= u4Alpha;
		    //  _rImgReszHalInfo[u4HwId].rBldImgInfo.u4BufSA1 = rPreloadBufInfo.u4BufSA1;
		    //  _rImgReszHalInfo[u4HwId].rBldImgInfo.u4BufSA2 = rPreloadBufInfo.u4BufSA2;
                    rBlBufnfo.u1Alpha = u4Alpha;
                    rBlBufnfo.u4BufSA1 = rPreloadBufInfo.u4BufSA1;
                    rBlBufnfo.u4BufSA2 = rPreloadBufInfo.u4BufSA2;
                    i4ImgResz_HAL_Set_Blending_Image_Info(u4HwId, &rBlBufnfo);
                }

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                    rDestGoldImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA2 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA2,(void *)rDestFitImgInfo.u4BufSA2,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            fgPreloadBuf,u4Alpha,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
    }

    if(u4FileListNum>0)
    {
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);
        if(rPreloadBufInfo.u4BufSA1 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA1);
        if(rPreloadBufInfo.u4BufSA2 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA2);
    }

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}



INT32 i4ImgReszVfyGenerateBlockModeAndAddressSwapCase(UINT32 u4TestCase,
                                                      IMGRESZ_HAL_RESIZE_MODE_T *peResizeMode,
                                                      IMGRESZ_HAL_RESAMPLE_METHOD_T *peHResampleMethod,
                                                      IMGRESZ_HAL_RESAMPLE_METHOD_T *peVResampleMethod,
                                                      IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfo,
                                                      IMGRESZ_HAL_IMG_INFO_T *prDestImgInfo)
{
    UINT32 u4Case;
    UINT32 u4SrcBufWidth = 1920, u4SrcBufHeight = 1080;
    UINT32 u4DestBufWidth = 1920, u4DestBufHeight = 1080;

    if((prSrcImgInfo->u4ImgWidth > u4SrcBufWidth) || (prSrcImgInfo->u4ImgHeight > u4SrcBufHeight))
    {
        u4SrcBufWidth = prSrcImgInfo->u4ImgWidth;
        u4SrcBufHeight = prSrcImgInfo->u4ImgHeight;

        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
    }

    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
        u4SrcBufHeight = ((u4SrcBufHeight + 31)/ 32) * 32; // Align to 32
    }

    if(prDestImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4DestBufWidth = ((u4DestBufWidth + 15) / 16) * 16;  // Align to 16
        u4DestBufHeight = ((u4DestBufHeight + 31)/ 32) * 32; // Align to 32
    }

    prSrcImgInfo->u4BufWidth = u4SrcBufWidth * u4ImgReszVfyCalBufFormatBits(&(prSrcImgInfo->rBufferFormat)) / 8;
    prSrcImgInfo->u4BufHeight = u4SrcBufHeight;
    prDestImgInfo->u4BufWidth = u4DestBufWidth * u4ImgReszVfyCalBufFormatBits(&(prDestImgInfo->rBufferFormat)) / 8;
    prDestImgInfo->u4BufHeight = u4DestBufHeight;


    if(_fgOpenAddressSwap)
    {
        u4Case = u4TestCase % 8;
        u4SwapMode= u4Case ;
        u4TestCase /= 8;
    }

    // Resize mode variation and Resize method variation
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= 2;
    } else
    {
        UINT32 u4CaseNum = 6;

        // Y/C buffer has only frame mode, no partial mode.
        if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            u4CaseNum = 4;

        u4Case = u4TestCase % u4CaseNum;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 2:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 3:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 4:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 5:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= u4CaseNum;
    }

    // Progressive frame or interlaced frame
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                break;
            case 1:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                break;
        }
        u4TestCase /= 2;
    }

    // Destination size variation
    u4Case = u4TestCase % 1;
    switch(u4Case)
    {
        case 0:
            prDestImgInfo->u4ImgWidth = 720;
            prDestImgInfo->u4ImgHeight = 480;
            break;
    }
    u4TestCase /= 1;

    // For jpeg to video, output YUV420/422 variation
    if((prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER) &&
       (prDestImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER))
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                prDestImgInfo->rBufferFormat.eYUVFormat = IMGRESZ_HAL_IMG_YUV_FORMAT_420;
                break;
            case 1:
                prDestImgInfo->rBufferFormat.eYUVFormat = IMGRESZ_HAL_IMG_YUV_FORMAT_422;
                break;
        }
        u4TestCase /= 2;
    }

    if(u4TestCase > 0)
        return -1;

    return 0;
}


INT32 i4ImgReszVfyTestJpegToVideoBlockModeAndAddressSwap(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;
    UINT32 u4WorkBufSa = 0;

    u4WorkBufSa = (UINT32)imgreszvfy_alloc_mem_aligned(1920*1088,1024);

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
   #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Jpeg.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER;
        rDestImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateBlockModeAndAddressSwapCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
                rSrcFitImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA3 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,3,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                //BOOL fgSourceOffsetChange = FALSE;

                //if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                //   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                //    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);
                    rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA2 != 0);
                    rSrcImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA3 != 0);

                    // Allocate destination buffer
                    if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                        u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                        rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                        VERIFY(rDestImgInfo.u4BufSA1 != 0);
                        rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                        VERIFY(rDestImgInfo.u4BufSA2 != 0);
                    } else if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER)
                    {
                        u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                        rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                        VERIFY(rDestImgInfo.u4BufSA1 != 0);
                    }

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
                    rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                    rDestFitImgInfo.u4ImgXOff = 0;
                    rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
                    if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                        VERIFY(rDestFitImgInfo.u4BufSA2 != 0);
                    }

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                //if((u4TestSubCase == 0) || fgSourceOffsetChange)
                {
                // Copy source fit buffer to source buffer
#if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8560)
                  if((rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[1] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0])
		      &&(rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[2] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0]))
                      vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,TRUE);
	         else
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#else
                   vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#endif

                    if(rSrcImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        // EnBlock
                        if(rSrcImgInfo.rBufferFormat.fgBlockMode)
                        {
                            // Y
                            vImgReszVfyBufEnBlock(rSrcImgInfo.u4BufSA1,u4WorkBufSa,
                                                  rSrcImgInfo.u4BufWidth,rSrcImgInfo.u4BufHeight,16,32);
                            x_memcpy((void *)rSrcImgInfo.u4BufSA1,(void *)u4WorkBufSa,rSrcImgInfo.u4BufWidth*rSrcImgInfo.u4BufHeight);
                            // C
                            vImgReszVfyBufEnBlock(rSrcImgInfo.u4BufSA2,u4WorkBufSa,
                                                  rSrcImgInfo.u4BufWidth,rSrcImgInfo.u4BufHeight,16,16);
                            x_memcpy((void *)rSrcImgInfo.u4BufSA2,(void *)u4WorkBufSa,rSrcImgInfo.u4BufWidth*rSrcImgInfo.u4BufHeight);
                        }

                        // EnAddressSwap
                        if(rSrcImgInfo.rBufferFormat.fgAddrSwap)
                        {
                            // Y
                            vImgReszVfyBufEnAddrSwap(rSrcImgInfo.u4BufSA1,u4WorkBufSa,
                                                     rSrcImgInfo.u4BufWidth*rSrcImgInfo.u4BufHeight);
                            x_memcpy((void *)rSrcImgInfo.u4BufSA1,(void *)u4WorkBufSa,rSrcImgInfo.u4BufWidth*rSrcImgInfo.u4BufHeight);
                            // C
                            vImgReszVfyBufEnAddrSwap(rSrcImgInfo.u4BufSA2,u4WorkBufSa,
                                                     rSrcImgInfo.u4BufWidth*rSrcImgInfo.u4BufHeight);
                            x_memcpy((void *)rSrcImgInfo.u4BufSA2,(void *)u4WorkBufSa,rSrcImgInfo.u4BufWidth*rSrcImgInfo.u4BufHeight);
                        }
                    }
                }

                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                {
                    // DeAddressSwap
                    if(rDestImgInfo.rBufferFormat.fgAddrSwap)
                    {
                        // Y
                        vImgReszVfyBufDeAddrSwap(rDestImgInfo.u4BufSA1,u4WorkBufSa,
                                                 rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                        x_memcpy((void *)rDestImgInfo.u4BufSA1,(void *)u4WorkBufSa,rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                        // C
                        vImgReszVfyBufDeAddrSwap(rDestImgInfo.u4BufSA2,u4WorkBufSa,
                                                 rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                        x_memcpy((void *)rDestImgInfo.u4BufSA2,(void *)u4WorkBufSa,rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                    }

                    // DeBlock
                    if(rDestImgInfo.rBufferFormat.fgBlockMode)
                    {
                        // Y
                        vImgReszVfyBufDeBlock(rDestImgInfo.u4BufSA1,u4WorkBufSa,
                                              rDestImgInfo.u4BufWidth,rDestImgInfo.u4BufHeight,16,32);
                        x_memcpy((void *)rDestImgInfo.u4BufSA1,(void *)u4WorkBufSa,rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                        // C
                        vImgReszVfyBufDeBlock(rDestImgInfo.u4BufSA2,u4WorkBufSa,
                                              rDestImgInfo.u4BufWidth,rDestImgInfo.u4BufHeight,16,16);
                        x_memcpy((void *)rDestImgInfo.u4BufSA2,(void *)u4WorkBufSa,rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                    }
                }

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                    if(rDestGoldImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        rDestGoldImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                        VERIFY(rDestGoldImgInfo.u4BufSA2 != 0);
                        x_memcpy((void *)rDestGoldImgInfo.u4BufSA2,(void *)rDestFitImgInfo.u4BufSA2,u4BufSize);
                    }

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            FALSE,0,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            if(rDestImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            if(rDestFitImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            if(rDestGoldImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA3);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
        if(rSrcFitImgInfo.u4BufSA3 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA3);
    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    imgreszvfy_free_mem_aligned((void *)u4WorkBufSa);

    return 0;
}


INT32 i4ImgReszVfyTestVideoBlockModeAndAddressSwap(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;
    UINT32 u4WorkBufSa = 0;
    u4SwapMode = 0;

    u4WorkBufSa = (UINT32)imgreszvfy_alloc_mem_aligned(1920*1088,1024);

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
       #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Video.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateBlockModeAndAddressSwapCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                                              &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,3,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                //BOOL fgSourceOffsetChange = FALSE;

                //if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                //   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                //    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
                    u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);
                    rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                    VERIFY(rSrcImgInfo.u4BufSA2 != 0);

                    // Allocate destination buffer
                    u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                    u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                    rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                    VERIFY(rDestImgInfo.u4BufSA1 != 0);
                    rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                    VERIFY(rDestImgInfo.u4BufSA2 != 0);

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth;
                    rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                    rDestFitImgInfo.u4ImgXOff = 0;
                    rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
                    rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA2 != 0);

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                //if((u4TestSubCase == 0) || fgSourceOffsetChange)
                {
                    // Copy source fit buffer to source buffer
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

                    if(rSrcImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        // EnBlock
                        if(rSrcImgInfo.rBufferFormat.fgBlockMode)
                        {
                            // Y
                            vImgReszVfyBufEnBlock(rSrcImgInfo.u4BufSA1,u4WorkBufSa,
                                                  rSrcImgInfo.u4BufWidth,rSrcImgInfo.u4BufHeight,16,32);
                            x_memcpy((void *)rSrcImgInfo.u4BufSA1,(void *)u4WorkBufSa,rSrcImgInfo.u4BufWidth*rSrcImgInfo.u4BufHeight);
                            // C
                            vImgReszVfyBufEnBlock(rSrcImgInfo.u4BufSA2,u4WorkBufSa,
                                                  rSrcImgInfo.u4BufWidth,rSrcImgInfo.u4BufHeight,16,16);
                            x_memcpy((void *)rSrcImgInfo.u4BufSA2,(void *)u4WorkBufSa,rSrcImgInfo.u4BufWidth*rSrcImgInfo.u4BufHeight);
                        }

                        // EnAddressSwap
                        if(rSrcImgInfo.rBufferFormat.fgAddrSwap)
                        {
                            // Y
                            vImgReszVfyBufEnAddrSwap(rSrcImgInfo.u4BufSA1,u4WorkBufSa,
                                                     rSrcImgInfo.u4BufWidth*rSrcImgInfo.u4BufHeight);
                            x_memcpy((void *)rSrcImgInfo.u4BufSA1,(void *)u4WorkBufSa,rSrcImgInfo.u4BufWidth*rSrcImgInfo.u4BufHeight);
                            // C
                            vImgReszVfyBufEnAddrSwap(rSrcImgInfo.u4BufSA2,u4WorkBufSa,
                                                     rSrcImgInfo.u4BufWidth*rSrcImgInfo.u4BufHeight);
                            x_memcpy((void *)rSrcImgInfo.u4BufSA2,(void *)u4WorkBufSa,rSrcImgInfo.u4BufWidth*rSrcImgInfo.u4BufHeight);
                        }
                    }
                }

                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                {
                    // DeAddressSwap
                    if(rDestImgInfo.rBufferFormat.fgAddrSwap)
                    {
                        // Y
                        vImgReszVfyBufDeAddrSwap(rDestImgInfo.u4BufSA1,u4WorkBufSa,
                                                 rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                        x_memcpy((void *)rDestImgInfo.u4BufSA1,(void *)u4WorkBufSa,rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                        // C
                        vImgReszVfyBufDeAddrSwap(rDestImgInfo.u4BufSA2,u4WorkBufSa,
                                                 rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                        x_memcpy((void *)rDestImgInfo.u4BufSA2,(void *)u4WorkBufSa,rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                    }

                    // DeBlock
                    if(rDestImgInfo.rBufferFormat.fgBlockMode)
                    {
                        // Y
                        vImgReszVfyBufDeBlock(rDestImgInfo.u4BufSA1,u4WorkBufSa,
                                              rDestImgInfo.u4BufWidth,rDestImgInfo.u4BufHeight,16,32);
                        x_memcpy((void *)rDestImgInfo.u4BufSA1,(void *)u4WorkBufSa,rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                        // C
                        vImgReszVfyBufDeBlock(rDestImgInfo.u4BufSA2,u4WorkBufSa,
                                              rDestImgInfo.u4BufWidth,rDestImgInfo.u4BufHeight,16,16);
                        x_memcpy((void *)rDestImgInfo.u4BufSA2,(void *)u4WorkBufSa,rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                    }
                }

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                    rDestGoldImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA2 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA2,(void *)rDestFitImgInfo.u4BufSA2,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            FALSE,0,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    imgreszvfy_free_mem_aligned((void *)u4WorkBufSa);

    return 0;
}


INT32 i4ImgReszVfyGenerateOutARGBVariationCase(UINT32 u4TestCase,
                                               IMGRESZ_HAL_RESIZE_MODE_T *peResizeMode,
                                               IMGRESZ_HAL_RESAMPLE_METHOD_T *peHResampleMethod,
                                               IMGRESZ_HAL_RESAMPLE_METHOD_T *peVResampleMethod,
                                               IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfo,
                                               IMGRESZ_HAL_IMG_INFO_T *prDestImgInfo,
                                               BOOL fgPreloadBuf,UINT32 *pu4Alpha)
{
    UINT32 u4Case;
    UINT32 u4SrcBufWidth = 1920, u4SrcBufHeight = 1080;
    UINT32 u4DestBufWidth = 1920, u4DestBufHeight = 1080;

    if((prSrcImgInfo->u4ImgWidth > u4SrcBufWidth) || (prSrcImgInfo->u4ImgHeight > u4SrcBufHeight))
    {
        u4SrcBufWidth = prSrcImgInfo->u4ImgWidth;
        u4SrcBufHeight = prSrcImgInfo->u4ImgHeight;

        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
    }

    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
        u4SrcBufHeight = ((u4SrcBufHeight + 31)/ 32) * 32; // Align to 32
    }

    if(prDestImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4DestBufWidth = ((u4DestBufWidth + 15) / 16) * 16;  // Align to 16
        u4DestBufHeight = ((u4DestBufHeight + 31)/ 32) * 32; // Align to 32
    }

    prSrcImgInfo->u4BufWidth = u4SrcBufWidth * u4ImgReszVfyCalBufFormatBits(&(prSrcImgInfo->rBufferFormat)) / 8;
    prSrcImgInfo->u4BufHeight = u4SrcBufHeight;
    prDestImgInfo->u4BufWidth = u4DestBufWidth * u4ImgReszVfyCalBufFormatBits(&(prDestImgInfo->rBufferFormat)) / 8;
    prDestImgInfo->u4BufHeight = u4DestBufHeight;

    // Alfa variation
    if(fgPreloadBuf)
    {
#ifdef IMGRESZ_HAL_MT8530
        // MT8530 alfa blending range is from 0 ~ 128
        u4Case = u4TestCase % ((8<<0)+1);
        *pu4Alpha = (u4Case<<4);
        u4TestCase /= ((8<<0)+1);
#else
        // MT8530 alfa blending range is from 0 ~ 8
        u4Case = u4TestCase % ((8<<0)+1);
        *pu4Alpha = (u4Case<<0);
        u4TestCase /= ((8<<0)+1);
#endif
    }

    // Resize mode variation and Resize method variation
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
    {
        u4Case = u4TestCase % 1;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= 1;
    } else
    {
        UINT32 u4CaseNum = 6;

        // Y/C buffer has only frame mode, no partial mode.
        if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            u4CaseNum = 4;

        u4Case = u4TestCase % u4CaseNum;
        //if(u4Case == 1)
            //u4Case = 4;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 2:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 3:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 4:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 5:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= u4CaseNum;
    }

    // Progressive frame or interlaced frame
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                break;
            case 1:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                break;
        }
        u4TestCase /= 2;
    }

    // Destination size variation
    u4Case = u4TestCase % 2;
    switch(u4Case)
    {
        case 0:
            prDestImgInfo->u4ImgWidth = 352;
            prDestImgInfo->u4ImgHeight = 240;
            break;
        case 1:
            prDestImgInfo->u4ImgWidth = 1600;
            prDestImgInfo->u4ImgHeight = 900;
            break;
    }
    u4TestCase /= 2;

    // Destination ARGB format variation
    if(prDestImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER)
    {
        u4Case = u4TestCase % 4;
        switch(u4Case)
        {
            case 0:
                prDestImgInfo->rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_0565;
                break;
            case 1:
                prDestImgInfo->rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_1555;
                break;
            case 2:
                prDestImgInfo->rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_4444;
                break;
            case 3:
                prDestImgInfo->rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
                break;
        }
        u4TestCase /= 4;
    }

    if(u4TestCase > 0)
        return -1;

    return 0;
}



INT32 i4ImgReszVfyTestARGBOutARGBVariation(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rPreloadBufInfo;
    BOOL fgPreloadBuf = FALSE;
    UINT32 u4Alpha = 0;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
   #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
    {
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);
        x_memset(&rPreloadBufInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        if(i4ImgReszVfyTestLoadPreloadBuf(ppbFileList[0],&rPreloadBufInfo) >= 0)
            fgPreloadBuf = TRUE;
    }

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        /*if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not ARGB.\n");
            continue;
        }*/

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateOutARGBVariationCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo,fgPreloadBuf,&u4Alpha)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,1,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                BOOL fgSourceOffsetChange = FALSE;

                if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
                    rSrcImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
                     i4ImgReszVfyPrintf("[ImgResz][Verify] SRC buffer size : %d,Src addr :%x.\n",u4BufSize,rSrcImgInfo.u4BufSA1);
#else
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
#endif
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);

                    // Allocate destination buffer
                    u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
                    rDestImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
                     i4ImgReszVfyPrintf("[ImgResz][Verify] dest buffer size : %d, dest addr :%x.\n",u4BufSize,rDestImgInfo.u4BufSA1);
#else
                    rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
#endif
                    VERIFY(rDestImgInfo.u4BufSA1 != 0);

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
                    rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                    rDestFitImgInfo.u4ImgXOff = 0;
                    rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                // Copy source fit buffer to source buffer
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Preload buffer
                if(fgPreloadBuf)
                {
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Preload buffer alpha %d.\n",u4Alpha);
                    i4HwImgReszSetAlphaBlendingLevel(u4HwId,u4Alpha);
                    i4HwImgReszSetPreloadBufAddr(u4HwId,rPreloadBufInfo.u4BufSA1,rPreloadBufInfo.u4BufSA2);
                }

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            fgPreloadBuf,u4Alpha,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }
#if IMGRESZ_IO_MMU_TEST
            x_free_vmem((void *)rSrcImgInfo.u4BufSA1);
            x_free_vmem((void *)rDestImgInfo.u4BufSA1);
#else
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
#endif
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            if(0)
            {
                imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            }

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
    }

    if(u4FileListNum>0)
    {
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);
        if(rPreloadBufInfo.u4BufSA1 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA1);
        if(rPreloadBufInfo.u4BufSA2 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA2);
    }

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyTestIndexOutARGBVariation(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rPreloadBufInfo;
    BOOL fgPreloadBuf = FALSE;
    UINT32 u4Alpha = 0;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
    #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  

    if(u4FileListNum>0)
    {
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);
        x_memset(&rPreloadBufInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        if(i4ImgReszVfyTestLoadPreloadBuf(ppbFileList[0],&rPreloadBufInfo) >= 0)
            fgPreloadBuf = TRUE;
    }

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

     /*   if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_INDEX_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Index.\n");
            continue;
        }*/

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
        rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateOutARGBVariationCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo,fgPreloadBuf,&u4Alpha)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,1,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                BOOL fgSourceOffsetChange = FALSE;

                if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
                    rSrcImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
                    //rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                     i4ImgReszVfyPrintf("[ImgResz][Verify] SRC buffer size : %d,Src addr :%x.\n",u4BufSize,rSrcImgInfo.u4BufSA1);
		       vMMUDebug(rSrcImgInfo.u4BufSA1);
#else
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                     i4ImgReszVfyPrintf("[ImgResz][Verify] SRC buffer size : %d,Src addr :%x.\n",u4BufSize,rSrcImgInfo.u4BufSA1);
		       //vMMUDebug(rSrcImgInfo.u4BufSA1);
#endif
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);

                    // Allocate destination buffer
                    u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
                    rDestImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
                    //rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    x_memset((void *)rDestImgInfo.u4BufSA1,0,u4BufSize);
                    i4ImgReszVfyPrintf("[ImgResz][Verify] DST buffer size : %d,DST addr :%x.\n",u4BufSize,rDestImgInfo.u4BufSA1);
		      vMMUDebug(rSrcImgInfo.u4BufSA1);
#else
                    rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    x_memset((void *)rDestImgInfo.u4BufSA1,0,u4BufSize);
                    i4ImgReszVfyPrintf("[ImgResz][Verify] DST buffer size : %d,DST addr :%x.\n",u4BufSize,rDestImgInfo.u4BufSA1);
		      //vMMUDebug(rSrcImgInfo.u4BufSA1);
#endif
                    VERIFY(rDestImgInfo.u4BufSA1 != 0);

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
                    rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                    rDestFitImgInfo.u4ImgXOff = 0;
                    rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                // Copy source fit buffer to source buffer
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Preload buffer
                if(fgPreloadBuf)
                {
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Preload buffer alpha %d.\n",u4Alpha);
                    i4HwImgReszSetAlphaBlendingLevel(u4HwId,u4Alpha);
                    i4HwImgReszSetPreloadBufAddr(u4HwId,rPreloadBufInfo.u4BufSA1,rPreloadBufInfo.u4BufSA2);
                }

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            fgPreloadBuf,u4Alpha,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }
#if IMGRESZ_IO_MMU_TEST
            x_free_vmem((void *)rSrcImgInfo.u4BufSA1);
            x_free_vmem((void *)rDestImgInfo.u4BufSA1);
#else
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
#endif
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            if(0)
            {
                imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            }

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
        if(rSrcFitImgInfo.rBufferFormat.prColorPallet != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.rBufferFormat.prColorPallet);
    }

    if(u4FileListNum>0)
    {
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);
        if(rPreloadBufInfo.u4BufSA1 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA1);
        if(rPreloadBufInfo.u4BufSA2 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA2);
    }

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyGenerateOutAYUVCase(UINT32 u4TestCase,
                                      IMGRESZ_HAL_RESIZE_MODE_T *peResizeMode,
                                      IMGRESZ_HAL_RESAMPLE_METHOD_T *peHResampleMethod,
                                      IMGRESZ_HAL_RESAMPLE_METHOD_T *peVResampleMethod,
                                      IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfo,
                                      IMGRESZ_HAL_IMG_INFO_T *prDestImgInfo,
                                      BOOL fgPreloadBuf,UINT32 *pu4Alpha)
{
    UINT32 u4Case;
    UINT32 u4SrcBufWidth = 1920, u4SrcBufHeight = 1080;
    UINT32 u4DestBufWidth = 1920, u4DestBufHeight = 1080;

    if((prSrcImgInfo->u4ImgWidth > u4SrcBufWidth) || (prSrcImgInfo->u4ImgHeight > u4SrcBufHeight))
    {
        u4SrcBufWidth = prSrcImgInfo->u4ImgWidth;
        u4SrcBufHeight = prSrcImgInfo->u4ImgHeight;

        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
    }

    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
        u4SrcBufHeight = ((u4SrcBufHeight + 31)/ 32) * 32; // Align to 32
    }

    if(prDestImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4DestBufWidth = ((u4DestBufWidth + 15) / 16) * 16;  // Align to 16
        u4DestBufHeight = ((u4DestBufHeight + 31)/ 32) * 32; // Align to 32
    }

    prSrcImgInfo->u4BufWidth = u4SrcBufWidth * u4ImgReszVfyCalBufFormatBits(&(prSrcImgInfo->rBufferFormat)) / 8;
    prSrcImgInfo->u4BufHeight = u4SrcBufHeight;
    prDestImgInfo->u4BufWidth = u4DestBufWidth * u4ImgReszVfyCalBufFormatBits(&(prDestImgInfo->rBufferFormat)) / 8;
    prDestImgInfo->u4BufHeight = u4DestBufHeight;

    // Alfa variation
    if(fgPreloadBuf)
    {
#if defined(IMGRESZ_HAL_MT8530) || defined(IMGRESZ_HAL_MT8550) 
        // MT8530 alfa blending range is from 0 ~ 128
        u4Case = u4TestCase % ((8<<0)+1);
        *pu4Alpha = (u4Case<<4);
        u4TestCase /= ((8<<0)+1);
#else
        // MT8530 alfa blending range is from 0 ~ 8
        u4Case = u4TestCase % ((8<<0)+1);
        *pu4Alpha = (u4Case<<0);
        u4TestCase /= ((8<<0)+1);
#endif
    }

    // Resize mode variation and Resize method variation
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
    {
        u4Case = u4TestCase % 1;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= 1;
    } else
    {
        UINT32 u4CaseNum = 1;

        // Y/C buffer has only frame mode, no partial mode.
        if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            u4CaseNum = 1;

        u4Case = u4TestCase % u4CaseNum;

        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 2:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 3:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 4:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 5:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= u4CaseNum;
    }

    // Progressive frame or interlaced frame
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4Case = u4TestCase % 1;
        switch(u4Case)
        {
            case 0:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                break;
            case 1:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                break;
        }
        u4TestCase /= 1;
    }

    // Destination size variation
    u4Case = u4TestCase % 3;
    switch(u4Case)
    {
        case 0:
            prDestImgInfo->u4ImgWidth = 352;
            prDestImgInfo->u4ImgHeight = 240;
            break;
        case 1:
            prDestImgInfo->u4ImgWidth = 1600;
            prDestImgInfo->u4ImgHeight = 900;
            break;
	case 2:
	     prDestImgInfo->u4ImgWidth = prSrcImgInfo->u4ImgWidth;
            prDestImgInfo->u4ImgHeight= prSrcImgInfo->u4ImgHeight;
	     break;
    }
    u4TestCase /= 3;

    if(u4TestCase > 0)
        return -1;

    return 0;
}


INT32 i4ImgReszVfyTestARGBToAYUV(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rPreloadBufInfo;
    BOOL fgPreloadBuf = FALSE;
    UINT32 u4Alpha = 0;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
       #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
    {
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);
        x_memset(&rPreloadBufInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        if(i4ImgReszVfyTestLoadPreloadBuf(ppbFileList[0],&rPreloadBufInfo) >= 0)
            fgPreloadBuf = TRUE;
    }

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not ARGB.\n");
            continue;
        }

        if(rSrcFitImgInfo.rBufferFormat.eARGBBufferFormat != IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not ARGB8888.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
        rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateOutAYUVCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo,fgPreloadBuf,&u4Alpha)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;
            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,1,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                BOOL fgSourceOffsetChange = FALSE;

                if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
                    rSrcImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
                    i4ImgReszVfyPrintf("[ImgResz][Verify] SRC buffer size : %d,Src addr :%x.\n",u4BufSize,rSrcImgInfo.u4BufSA1);
#else
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
#endif
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);

                    // Allocate destination buffer
                    u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
                    rDestImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
                    i4ImgReszVfyPrintf("[ImgResz][Verify] DST buffer size : %d,DST addr :%x.\n",u4BufSize,rDestImgInfo.u4BufSA1);
#else
                    rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
#endif
                    VERIFY(rDestImgInfo.u4BufSA1 != 0);

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
                    rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                    rDestFitImgInfo.u4ImgXOff = 0;
                    rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                // Copy source fit buffer to source buffer
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Preload buffer
                if(fgPreloadBuf)
                {
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Preload buffer alpha %d.\n",u4Alpha);
                    i4HwImgReszSetAlphaBlendingLevel(u4HwId,u4Alpha);
                    i4HwImgReszSetPreloadBufAddr(u4HwId,rPreloadBufInfo.u4BufSA1,rPreloadBufInfo.u4BufSA2);
                }

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            fgPreloadBuf,u4Alpha,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }
#if IMGRESZ_IO_MMU_TEST
            x_free_vmem((void *)rSrcImgInfo.u4BufSA1);
            x_free_vmem((void *)rDestImgInfo.u4BufSA1);
#else
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
#endif
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            if(0)
            {
                imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            }

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
    }

    if(u4FileListNum>0)
    {
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);
        if(rPreloadBufInfo.u4BufSA1 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA1);
        if(rPreloadBufInfo.u4BufSA2 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA2);
    }

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyTestVideoToAYUV(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rPreloadBufInfo;
    BOOL fgPreloadBuf = FALSE;
    UINT32 u4Alpha = 0;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
       #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
    {
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);
        x_memset(&rPreloadBufInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        if(i4ImgReszVfyTestLoadPreloadBuf(ppbFileList[0],&rPreloadBufInfo) >= 0)
            fgPreloadBuf = TRUE;
    }

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Video.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
        rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateOutAYUVCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo,fgPreloadBuf,&u4Alpha)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,1,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                BOOL fgSourceOffsetChange = FALSE;

                if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
                    u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
 #if IMGRESZ_IO_MMU_TEST
                    rSrcImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Src buffer size : %d,DST addr :%x.\n",u4BufSize,rSrcImgInfo.u4BufSA1);  
#else
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
#endif
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);
                    rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                    VERIFY(rSrcImgInfo.u4BufSA2 != 0);

                    // Allocate destination buffer
                    u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
                    rDestImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
                    i4ImgReszVfyPrintf("[ImgResz][Verify] DST buffer size : %d,DST addr :%x.\n",u4BufSize,rDestImgInfo.u4BufSA1);  
#else
                    rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
#endif
                    VERIFY(rDestImgInfo.u4BufSA1 != 0);

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
                    rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                    rDestFitImgInfo.u4ImgXOff = 0;
                    rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                // Copy source fit buffer to source buffer
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Preload buffer
                if(fgPreloadBuf)
                {
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Preload buffer alpha %d.\n",u4Alpha);
                    i4HwImgReszSetAlphaBlendingLevel(u4HwId,u4Alpha);
                    i4HwImgReszSetPreloadBufAddr(u4HwId,rPreloadBufInfo.u4BufSA1,rPreloadBufInfo.u4BufSA2);
                }

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            fgPreloadBuf,u4Alpha,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }

#if IMGRESZ_IO_MMU_TEST
            x_free_vmem((void *)rSrcImgInfo.u4BufSA1);  
            //imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);       
            x_free_vmem((void *)rDestImgInfo.u4BufSA1);        
#else
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
#endif
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            if(rDestImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            if(rDestFitImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            if(rDestGoldImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
    }

    if(u4FileListNum>0)
    {
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);
        if(rPreloadBufInfo.u4BufSA1 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA1);
        if(rPreloadBufInfo.u4BufSA2 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA2);
    }

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyGenerateBandBuffer(IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfo,
                                     IMGRESZ_HAL_IMG_INFO_T *prSrcBandImgInfo,
                                     UINT32 u4StartBit,UINT32 u4EndBit)
{
    UINT32 u4BufSize;
    UINT32 u4I;
    UINT32 u4SrcAddr,u4SrcBandAddr;
    UINT8 u1BandData;
    UINT8 u1BandMask;
    UINT8 u1PrevEndBitAppend,u1EndBitAppend;

    // Start bit should be larger than or equal to end bit
    if(u4StartBit < u4EndBit)
    {
        UINT32 u4Tmp;

        u4Tmp = u4StartBit;
        u4StartBit = u4EndBit;
        u4EndBit = u4Tmp;
    }

    u1BandMask = 0;
    for(u4I=0; u4I<8; u4I++)
    {
        if((u4I<=u4StartBit) && (u4I>=u4EndBit))
            u1BandMask |= (1<<u4I);
    }

    if(u4EndBit>0)
        u1EndBitAppend = (1<<(u4EndBit-1));
    else
        u1EndBitAppend = 0;

    u1PrevEndBitAppend = (1<<u4StartBit);

    u4BufSize = prSrcImgInfo->u4BufWidth * prSrcImgInfo->u4BufHeight;

    u4SrcAddr = prSrcImgInfo->u4BufSA1;
    u4SrcBandAddr = prSrcBandImgInfo->u4BufSA1;
    for(u4I=0; u4I<u4BufSize; u4I++)
    {
        u1BandData = ((*(UINT8 *)u4SrcAddr) & u1BandMask) | u1EndBitAppend;
        u1BandData += (0x80 - u1PrevEndBitAppend);

        *(UINT8 *)u4SrcBandAddr = u1BandData;

        u4SrcAddr++;
        u4SrcBandAddr++;
    }

    u4SrcAddr = prSrcImgInfo->u4BufSA2;
    u4SrcBandAddr = prSrcBandImgInfo->u4BufSA2;
    for(u4I=0; u4I<u4BufSize; u4I++)
    {
        u1BandData = ((*(UINT8 *)u4SrcAddr) & u1BandMask) | u1EndBitAppend;
        u1BandData += (0x80 - u1PrevEndBitAppend);

        *(UINT8 *)u4SrcBandAddr = u1BandData;

        u4SrcAddr++;
        u4SrcBandAddr++;
    }

    u4SrcAddr = prSrcImgInfo->u4BufSA3;
    u4SrcBandAddr = prSrcBandImgInfo->u4BufSA3;
    for(u4I=0; u4I<u4BufSize; u4I++)
    {
        u1BandData = ((*(UINT8 *)u4SrcAddr) & u1BandMask) | u1EndBitAppend;
        u1BandData += (0x80 - u1PrevEndBitAppend);

        *(UINT8 *)u4SrcBandAddr = u1BandData;

        u4SrcAddr++;
        u4SrcBandAddr++;
    }

    return 0;
}


INT32 i4ImgReszVfyTestJpegToVideoPreload(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rPreloadBufInfo;
    IMGRESZ_HAL_JPEG_INFO_T rJpegInfo;
    BOOL fgPreloadBuf = FALSE;
    UINT32 u4Alpha = 0;
    UINT32 u4BufSize;
    UINT32 u4HwId;
    BOOL fgJpegPreloadTest = TRUE;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
      #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
    {
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);
        x_memset(&rPreloadBufInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        //if(i4ImgReszVfyTestLoadPreloadBuf(ppbFileList[0],&rPreloadBufInfo) >= 0)
        //    fgPreloadBuf = TRUE;
    }

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Jpeg.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER;
        rDestImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;

        u4TestCase = 0;

        while(i4ImgReszVfyGeneratePreloadBufAlphaBlendingCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo,fgPreloadBuf,&u4Alpha)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
                rSrcFitImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA3 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,1,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                BOOL fgSourceOffsetChange = FALSE;

                if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);
                    rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA2 != 0);
                    rSrcImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA3 != 0);

                    // Allocate destination buffer
                    if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                        u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                        rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                        VERIFY(rDestImgInfo.u4BufSA1 != 0);
                        rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                        VERIFY(rDestImgInfo.u4BufSA2 != 0);
                    } else if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER)
                    {
                        u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                        rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                        VERIFY(rDestImgInfo.u4BufSA1 != 0);
                    }

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
                    rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                    rDestFitImgInfo.u4ImgXOff = 0;
                    rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
                    if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                        VERIFY(rDestFitImgInfo.u4BufSA2 != 0);
                    }

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                // Copy source fit buffer to source buffer
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                {
#if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8560)
                  if((rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[1] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0])
		      &&(rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[2] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0]))
                      vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,TRUE);
	          else
	               vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#else
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#endif
                }

                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Preload buffer
                if(fgPreloadBuf)
                {
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Preload buffer alpha %d.\n",u4Alpha);
                    i4HwImgReszSetAlphaBlendingLevel(u4HwId,u4Alpha);
                    i4HwImgReszSetPreloadBufAddr(u4HwId,rPreloadBufInfo.u4BufSA1,rPreloadBufInfo.u4BufSA2);
                }

                if(fgJpegPreloadTest)
                {
                    IMGRESZ_HAL_IMG_INFO_T rSrcBandImgInfo;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg preload test.\n");

                    // Generate source band buffer info
                    x_memcpy(&rSrcBandImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Allocate source band buffer
                    u4BufSize = rSrcBandImgInfo.u4BufWidth * rSrcBandImgInfo.u4BufHeight;
                    rSrcBandImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcBandImgInfo.u4BufSA1 != 0);
                    rSrcBandImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcBandImgInfo.u4BufSA2 != 0);
                    rSrcBandImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcBandImgInfo.u4BufSA3 != 0);

                    // Set destination buffer as 0x80 for initial
                    if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                        u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                    } else if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER)
                    {
                        u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                    }
                    x_memset((void *)rDestImgInfo.u4BufSA1,0x80,u4BufSize);
                    x_memset((void *)rDestImgInfo.u4BufSA2,0x80,u4BufSize);

                    // Generate source band buffer from source buffer
                    // First band
                    i4ImgReszVfyGenerateBandBuffer(&rSrcImgInfo,&rSrcBandImgInfo,7,4);

                    x_memset(&rJpegInfo,0,sizeof(IMGRESZ_HAL_JPEG_INFO_T));
                    rJpegInfo.fgPictureMode = FALSE;
                    rJpegInfo.fgPreloadMode = TRUE;
                    rJpegInfo.fgYExist = TRUE;
                    rJpegInfo.fgCbExist = TRUE;
                    rJpegInfo.fgCrExist = TRUE;

                    // Resize
                    i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                     &rSrcBandImgInfo,&rDestImgInfo,&rJpegInfo);

                    // Generate source band buffer from source buffer
                    // Second band
                    i4ImgReszVfyGenerateBandBuffer(&rSrcImgInfo,&rSrcBandImgInfo,3,0);

                    rJpegInfo.fgYExist = TRUE;
                    rJpegInfo.fgCbExist = FALSE;
                    rJpegInfo.fgCrExist = FALSE;

                    // Resize
                    i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                     &rSrcBandImgInfo,&rDestImgInfo,&rJpegInfo);

                    rJpegInfo.fgYExist = FALSE;
                    rJpegInfo.fgCbExist = TRUE;
                    rJpegInfo.fgCrExist = FALSE;

                    // Resize
                    i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                     &rSrcBandImgInfo,&rDestImgInfo,&rJpegInfo);

                    rJpegInfo.fgYExist = FALSE;
                    rJpegInfo.fgCbExist = FALSE;
                    rJpegInfo.fgCrExist = TRUE;

                    // Resize
                    i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                     &rSrcBandImgInfo,&rDestImgInfo,&rJpegInfo);
                } else
                {
                    // Resize
                    i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                     &rSrcImgInfo,&rDestImgInfo,0);
                }

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                    if(rDestGoldImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        rDestGoldImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                        VERIFY(rDestGoldImgInfo.u4BufSA2 != 0);
                        x_memcpy((void *)rDestGoldImgInfo.u4BufSA2,(void *)rDestFitImgInfo.u4BufSA2,u4BufSize);
                    }

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            fgPreloadBuf,u4Alpha,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            if(rDestImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            if(rDestFitImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            if(rDestGoldImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA3);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
        if(rSrcFitImgInfo.u4BufSA3 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA3);
    }

    if(u4FileListNum>0)
    {
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);
        if(rPreloadBufInfo.u4BufSA1 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA1);
        if(rPreloadBufInfo.u4BufSA2 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA2);
    }

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyTestJpegToAYUVPreload(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rPreloadBufInfo;
    IMGRESZ_HAL_JPEG_INFO_T rJpegInfo;
    BOOL fgPreloadBuf = FALSE;
    UINT32 u4Alpha = 0;
    UINT32 u4BufSize;
    UINT32 u4HwId;
    BOOL fgJpegPreloadTest = TRUE;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
       #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
    {
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);
        x_memset(&rPreloadBufInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        //if(i4ImgReszVfyTestLoadPreloadBuf(ppbFileList[0],&rPreloadBufInfo) >= 0)
        //    fgPreloadBuf = TRUE;
    }

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Jpeg.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
        rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;

        u4TestCase = 0;

        while(i4ImgReszVfyGeneratePreloadBufAlphaBlendingCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo,fgPreloadBuf,&u4Alpha)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
                rSrcFitImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA3 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,1,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                BOOL fgSourceOffsetChange = FALSE;

                if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);
                    rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA2 != 0);
                    rSrcImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA3 != 0);

                    // Allocate destination buffer
                    if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                        u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                        rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                        VERIFY(rDestImgInfo.u4BufSA1 != 0);
                        rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                        VERIFY(rDestImgInfo.u4BufSA2 != 0);
                    } else if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER)
                    {
                        u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                        rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                        VERIFY(rDestImgInfo.u4BufSA1 != 0);
                    }

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
                    rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                    rDestFitImgInfo.u4ImgXOff = 0;
                    rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
                    if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                        VERIFY(rDestFitImgInfo.u4BufSA2 != 0);
                    }

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                // Copy source fit buffer to source buffer
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                {
 #if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8560)
                  if((rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[1] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0])
		      &&(rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[2] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0]))
                      vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,TRUE);
	           else
	               vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#else
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#endif
                }

                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Preload buffer
                if(fgPreloadBuf)
                {
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Preload buffer alpha %d.\n",u4Alpha);
                    i4HwImgReszSetAlphaBlendingLevel(u4HwId,u4Alpha);
                    i4HwImgReszSetPreloadBufAddr(u4HwId,rPreloadBufInfo.u4BufSA1,rPreloadBufInfo.u4BufSA2);
                }

                if(fgJpegPreloadTest)
                {
                    IMGRESZ_HAL_IMG_INFO_T rSrcBandImgInfo;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg preload test.\n");

                    // Generate source band buffer info
                    x_memcpy(&rSrcBandImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Allocate source band buffer
                    u4BufSize = rSrcBandImgInfo.u4BufWidth * rSrcBandImgInfo.u4BufHeight;
                    rSrcBandImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcBandImgInfo.u4BufSA1 != 0);
                    rSrcBandImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcBandImgInfo.u4BufSA2 != 0);
                    rSrcBandImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcBandImgInfo.u4BufSA3 != 0);

                    // Set destination buffer as 0x80 for initial
                    if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                        u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                    } else if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER)
                    {
                        u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                    }
                    x_memset((void *)rDestImgInfo.u4BufSA1,0x80,u4BufSize);
                    x_memset((void *)rDestImgInfo.u4BufSA2,0x80,u4BufSize);

                    // Generate source band buffer from source buffer
                    // First band
                    i4ImgReszVfyGenerateBandBuffer(&rSrcImgInfo,&rSrcBandImgInfo,7,4);

                    x_memset(&rJpegInfo,0,sizeof(IMGRESZ_HAL_JPEG_INFO_T));
                    rJpegInfo.fgPictureMode = FALSE;
                    rJpegInfo.fgPreloadMode = TRUE;
                    rJpegInfo.fgYExist = TRUE;
                    rJpegInfo.fgCbExist = TRUE;
                    rJpegInfo.fgCrExist = TRUE;

                    // Resize
                    i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                     &rSrcBandImgInfo,&rDestImgInfo,&rJpegInfo);

                    // Generate source band buffer from source buffer
                    // Second band
                    i4ImgReszVfyGenerateBandBuffer(&rSrcImgInfo,&rSrcBandImgInfo,3,0);

                    rJpegInfo.fgYExist = TRUE;
                    rJpegInfo.fgCbExist = FALSE;
                    rJpegInfo.fgCrExist = FALSE;

                    // Resize
                    i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                     &rSrcBandImgInfo,&rDestImgInfo,&rJpegInfo);

                    rJpegInfo.fgYExist = FALSE;
                    rJpegInfo.fgCbExist = TRUE;
                    rJpegInfo.fgCrExist = FALSE;

                    // Resize
                    i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                     &rSrcBandImgInfo,&rDestImgInfo,&rJpegInfo);

                    rJpegInfo.fgYExist = FALSE;
                    rJpegInfo.fgCbExist = FALSE;
                    rJpegInfo.fgCrExist = TRUE;

                    // Resize
                    i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                     &rSrcBandImgInfo,&rDestImgInfo,&rJpegInfo);
                } else
                {
                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);
                }

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                    if(rDestGoldImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        rDestGoldImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                        VERIFY(rDestGoldImgInfo.u4BufSA2 != 0);
                        x_memcpy((void *)rDestGoldImgInfo.u4BufSA2,(void *)rDestFitImgInfo.u4BufSA2,u4BufSize);
                    }

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            fgPreloadBuf,u4Alpha,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            if(rDestImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            if(rDestFitImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            if(rDestGoldImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA3);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
        if(rSrcFitImgInfo.u4BufSA3 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA3);
    }

    if(u4FileListNum>0)
    {
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);
        if(rPreloadBufInfo.u4BufSA1 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA1);
        if(rPreloadBufInfo.u4BufSA2 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA2);
    }

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyGenerateAlphaScalingCase(UINT32 u4TestCase,
                                           IMGRESZ_HAL_RESIZE_MODE_T *peResizeMode,
                                           IMGRESZ_HAL_RESAMPLE_METHOD_T *peHResampleMethod,
                                           IMGRESZ_HAL_RESAMPLE_METHOD_T *peVResampleMethod,
                                           IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfo,
                                           IMGRESZ_HAL_IMG_INFO_T *prDestImgInfo,
                                           BOOL fgPreloadBuf,UINT32 *pu4Alpha,
                                           UINT32 *pu4AlphaScalingType,
                                           BOOL *pfgBilinearBoundary,
                                           BOOL *pfgOnlyDistinquishAlpha)
{
    UINT32 u4Case;
    UINT32 u4SrcBufWidth = 1920, u4SrcBufHeight = 1080;
    UINT32 u4DestBufWidth = 1920, u4DestBufHeight = 1080;

    if((prSrcImgInfo->u4ImgWidth > u4SrcBufWidth) || (prSrcImgInfo->u4ImgHeight > u4SrcBufHeight))
    {
        u4SrcBufWidth = prSrcImgInfo->u4ImgWidth;
        u4SrcBufHeight = prSrcImgInfo->u4ImgHeight;

        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
    }

    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
        u4SrcBufHeight = ((u4SrcBufHeight + 31)/ 32) * 32; // Align to 32
    }

    if(prDestImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4DestBufWidth = ((u4DestBufWidth + 15) / 16) * 16;  // Align to 16
        u4DestBufHeight = ((u4DestBufHeight + 31)/ 32) * 32; // Align to 32
    }

    prSrcImgInfo->u4BufWidth = u4SrcBufWidth * u4ImgReszVfyCalBufFormatBits(&(prSrcImgInfo->rBufferFormat)) / 8;
    prSrcImgInfo->u4BufHeight = u4SrcBufHeight;
    prDestImgInfo->u4BufWidth = u4DestBufWidth * u4ImgReszVfyCalBufFormatBits(&(prDestImgInfo->rBufferFormat)) / 8;
    prDestImgInfo->u4BufHeight = u4DestBufHeight;

    // Alpha scaling mode variation
    if((prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER) ||
       (prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER) ||
       (prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_INDEX_BUFFER))
    {
#if defined(IMGRESZ_HAL_MT8530) || defined(IMGRESZ_HAL_MT8550)
        UINT32 u4CaseNum = 6;
#else
        UINT32 u4CaseNum = 3;
#endif

        u4Case = u4TestCase % u4CaseNum;
        switch(u4Case)
        {
            case 0:
                *pu4AlphaScalingType = 0;
                *pfgBilinearBoundary = FALSE;
                *pfgOnlyDistinquishAlpha = FALSE;
                break;
            case 1:
                *pu4AlphaScalingType = 1;
                *pfgBilinearBoundary = FALSE;
                *pfgOnlyDistinquishAlpha = FALSE;
                break;
            case 2:
                *pu4AlphaScalingType = 2;
                *pfgBilinearBoundary = FALSE;
                *pfgOnlyDistinquishAlpha = FALSE;
                break;
            case 3:
                *pu4AlphaScalingType = 2;
                *pfgBilinearBoundary = TRUE;
                *pfgOnlyDistinquishAlpha = FALSE;
                break;
            case 4:
                *pu4AlphaScalingType = 2;
                *pfgBilinearBoundary = FALSE;
                *pfgOnlyDistinquishAlpha = TRUE;
                break;
            case 5:
                *pu4AlphaScalingType = 2;
                *pfgBilinearBoundary = TRUE;
                *pfgOnlyDistinquishAlpha = TRUE;
                break;
        }
        u4TestCase /= u4CaseNum;
    } else
    {
        *pu4AlphaScalingType = 0;
    }

    // Alfa variation
    if(fgPreloadBuf)
    {
#if defined(IMGRESZ_HAL_MT8530) || defined(IMGRESZ_HAL_MT8550)
        // MT8530 alfa blending range is from 0 ~ 128
        u4Case = u4TestCase % ((8<<0)+1);
        *pu4Alpha = (u4Case<<4);
        u4TestCase /= ((8<<0)+1);
#else
        // MT8530 alfa blending range is from 0 ~ 8
        u4Case = u4TestCase % ((8<<0)+1);
        *pu4Alpha = (u4Case<<0);
        u4TestCase /= ((8<<0)+1);
#endif
    }

    // Resize mode variation and Resize method variation
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
    {
        u4Case = u4TestCase % 1;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= 1;
    } else
    {
        UINT32 u4CaseNum = 1;

        // Y/C buffer has only frame mode, no partial mode.
        if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            u4CaseNum = 1;

        u4Case = u4TestCase % u4CaseNum;
        if(u4Case == 0)
            u4Case = 3;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 2:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 3:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 4:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 5:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= u4CaseNum;
    }

    // Progressive frame or interlaced frame
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                break;
            case 1:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                break;
        }
        u4TestCase /= 2;
    }

    // Destination size variation
    u4Case = u4TestCase % 2;
    switch(u4Case)
    {
        case 0:
            prDestImgInfo->u4ImgWidth = 352;
            prDestImgInfo->u4ImgHeight = 240;
            break;
	 case 1:
            prDestImgInfo->u4ImgWidth = 720;
            prDestImgInfo->u4ImgHeight = 480;
            break;
    }
    u4TestCase /= 2;

    if(u4TestCase > 0)
        return -1;

    return 0;
}


INT32 i4ImgReszVfyTestAlphaScalingARGB(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rPreloadBufInfo;
    BOOL fgPreloadBuf = FALSE;
    UINT32 u4Alpha = 0;
    UINT32 u4AlphaScalingType = 0;
    BOOL fgBilinearBoundary = FALSE;
    BOOL fgOnlyDistinquishAlpha = FALSE;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
       #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
    {
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);
        x_memset(&rPreloadBufInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        if(i4ImgReszVfyTestLoadPreloadBuf(ppbFileList[0],&rPreloadBufInfo) >= 0)
            fgPreloadBuf = TRUE;
    }

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not ARGB.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateAlphaScalingCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo,fgPreloadBuf,&u4Alpha,&u4AlphaScalingType,
                                            &fgBilinearBoundary,&fgOnlyDistinquishAlpha)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,1,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                BOOL fgSourceOffsetChange = FALSE;

                if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
                    rSrcImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
                    i4ImgReszVfyPrintf("[ImgResz][Verify] SRC buffer size : %d,Src addr :%x.\n",u4BufSize,rSrcImgInfo.u4BufSA1);
#else
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
#endif
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);

                    // Allocate destination buffer
                    u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
                    rDestImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
                    i4ImgReszVfyPrintf("[ImgResz][Verify] DST buffer size : %d,DST addr :%x.\n",u4BufSize,rDestImgInfo.u4BufSA1);
#else
                    rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
#endif
                    VERIFY(rDestImgInfo.u4BufSA1 != 0);

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
                    rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                    rDestFitImgInfo.u4ImgXOff = 0;
                    rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                // Copy source fit buffer to source buffer
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Preload buffer
                if(fgPreloadBuf)
                {
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Preload buffer alpha %d.\n",u4Alpha);
                    i4HwImgReszSetAlphaBlendingLevel(u4HwId,u4Alpha);
                    i4HwImgReszSetPreloadBufAddr(u4HwId,rPreloadBufInfo.u4BufSA1,rPreloadBufInfo.u4BufSA2);
                }
                _fgScalingchange = TRUE;
                _u4AlphaScalingType = u4AlphaScalingType ;
                _fgBilinearBoundary = fgBilinearBoundary ;
                _fgOnlyDistinquishAlpha = fgOnlyDistinquishAlpha;
                // Alpha scaling type
                i4HwImgReszSetAlphaChangeScalingType(u4HwId,_u4AlphaScalingType);
#if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8530)
                i4HwImgReszSetAlphaChangeBilinearBoundary(u4HwId,_fgBilinearBoundary);
                i4HwImgReszSetOnlyDistinguishAlpha(u4HwId,_fgOnlyDistinquishAlpha);
#endif

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                _fgScalingchange = FALSE;
                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            fgPreloadBuf,u4Alpha,u4AlphaScalingType);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }
#if IMGRESZ_IO_MMU_TEST
            x_free_vmem((void *)rSrcImgInfo.u4BufSA1);
            x_free_vmem((void *)rDestImgInfo.u4BufSA1);
#else
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
#endif
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            if(0)
            {
                imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            }

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
    }

    if(u4FileListNum>0)
    {
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);
        if(rPreloadBufInfo.u4BufSA1 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA1);
        if(rPreloadBufInfo.u4BufSA2 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA2);
    }

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyGenerateSpecialProcessingForLumaKeyCase(UINT32 u4TestCase,
                                                          IMGRESZ_HAL_RESIZE_MODE_T *peResizeMode,
                                                          IMGRESZ_HAL_RESAMPLE_METHOD_T *peHResampleMethod,
                                                          IMGRESZ_HAL_RESAMPLE_METHOD_T *peVResampleMethod,
                                                          IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfo,
                                                          IMGRESZ_HAL_IMG_INFO_T *prDestImgInfo,
                                                          BOOL fgPreloadBuf,UINT32 *pu4Alpha,
                                                          UINT32 *pu4LumaKeyScalingType,
                                                          BOOL *pfgBilinearBoundary,
                                                          BOOL *pfgYUVMode
                                                          )
{
    UINT32 u4Case;
    UINT32 u4SrcBufWidth = 1920, u4SrcBufHeight = 1080;
    UINT32 u4DestBufWidth = 1920, u4DestBufHeight = 1080;

    if((prSrcImgInfo->u4ImgWidth > u4SrcBufWidth) || (prSrcImgInfo->u4ImgHeight > u4SrcBufHeight))
    {
        u4SrcBufWidth = prSrcImgInfo->u4ImgWidth;
        u4SrcBufHeight = prSrcImgInfo->u4ImgHeight;

        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
    }

    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
        u4SrcBufHeight = ((u4SrcBufHeight + 31)/ 32) * 32; // Align to 32
    }

    if(prDestImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4DestBufWidth = ((u4DestBufWidth + 15) / 16) * 16;  // Align to 16
        u4DestBufHeight = ((u4DestBufHeight + 31)/ 32) * 32; // Align to 32
    }

    prSrcImgInfo->u4BufWidth = u4SrcBufWidth * u4ImgReszVfyCalBufFormatBits(&(prSrcImgInfo->rBufferFormat)) / 8;
    prSrcImgInfo->u4BufHeight = u4SrcBufHeight;
    prDestImgInfo->u4BufWidth = u4DestBufWidth * u4ImgReszVfyCalBufFormatBits(&(prDestImgInfo->rBufferFormat)) / 8;
    prDestImgInfo->u4BufHeight = u4DestBufHeight;

    // Luma Key scaling mode variation
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        UINT32 u4CaseNum;
	*pu4LumaKeyScalingType = ((UINT32)rand()) %3;
	 u4CaseNum = ((UINT32)rand()) %4;

        switch(u4CaseNum)
        {
            case 0:
                *pfgYUVMode = TRUE;
                *pfgBilinearBoundary = FALSE;
                break;
            case 1:
                *pfgYUVMode = FALSE;
                *pfgBilinearBoundary = TRUE;
                break;
            case 2:
                *pfgYUVMode = FALSE;
                *pfgBilinearBoundary = FALSE;
                break;
            case 3:
                *pfgYUVMode = TRUE;
                *pfgBilinearBoundary = TRUE;
                break;
        }
    }

    // Alfa variation
    if(fgPreloadBuf)
    {
#ifdef IMGRESZ_HAL_MT8530
        // MT8530 alfa blending range is from 0 ~ 128
        u4Case = u4TestCase % ((8<<0)+1);
        *pu4Alpha = (u4Case<<4);
        u4TestCase /= ((8<<0)+1);
#else
        // MT8530 alfa blending range is from 0 ~ 8
        u4Case = u4TestCase % ((8<<0)+1);
        *pu4Alpha = (u4Case<<0);
        u4TestCase /= ((8<<0)+1);
#endif
    }

    // Resize mode variation and Resize method variation
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
    {
        u4Case = u4TestCase % 1;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= 1;
    } else
    {
        UINT32 u4CaseNum = 1;

        // Y/C buffer has only frame mode, no partial mode.
        if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            u4CaseNum = 4;

        u4Case = u4TestCase % u4CaseNum;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 2:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 3:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 4:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 5:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= u4CaseNum;
    }

    // Progressive frame or interlaced frame
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                break;
            case 1:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                break;
        }
        u4TestCase /= 2;
    }

    // Destination size variation
    u4Case = u4TestCase % 5;
    switch(u4Case)
    {
        case 0:
            prDestImgInfo->u4ImgWidth = 680;
            prDestImgInfo->u4ImgHeight = 480;
            break;
        case 1:
            prDestImgInfo->u4ImgWidth = 352;
            prDestImgInfo->u4ImgHeight = 240;
            break;
        case 2:
            prDestImgInfo->u4ImgWidth = 134;
            prDestImgInfo->u4ImgHeight = 916;
            break;
        case 3:
            prDestImgInfo->u4ImgWidth = 990;
            prDestImgInfo->u4ImgHeight = 120;
            break;
        case 4:
            prDestImgInfo->u4ImgWidth = 1280;
            prDestImgInfo->u4ImgHeight = 1000;
            break;
    }
    u4TestCase /= 5;

    if(u4TestCase > 0)
        return -1;

    return 0;
}


INT32 i4ImgReszVfyTestVideoSpecialProcessingForLumaKey(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rPreloadBufInfo;
    BOOL fgPreloadBuf = FALSE;
    UINT32 u4Alpha = 0;
    UINT32 u4LumaKeyScalingType = 0;
    BOOL fgBilinearBoundary = FALSE;
    BOOL fgYUVMode = FALSE;
    UINT32 u4BufSize;
    UINT32 u4HwId;
    UINT32 u4WorkBufSa = 0;

    u4WorkBufSa = (UINT32)imgreszvfy_alloc_mem_aligned(1920*1088,1024);
    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
       #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  

    if(u4FileListNum>0)
    {
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);
        x_memset(&rPreloadBufInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        if(i4ImgReszVfyTestLoadPreloadBuf(ppbFileList[0],&rPreloadBufInfo) >= 0)
            fgPreloadBuf = TRUE;
    }

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Video.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateSpecialProcessingForLumaKeyCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo,fgPreloadBuf,&u4Alpha,
                                            &u4LumaKeyScalingType,&fgBilinearBoundary,&fgYUVMode)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                i4ImgReszVfyPrintf("[ImgResz][Verify] rSrcFitImgInfo.u4BufWidth %d.\n",rSrcFitImgInfo.u4BufWidth);
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,1,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                BOOL fgSourceOffsetChange = FALSE;

                if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
                    u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);
                    rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                    VERIFY(rSrcImgInfo.u4BufSA2 != 0);

                    // Allocate destination buffer
                    u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                    u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                    rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                    VERIFY(rDestImgInfo.u4BufSA1 != 0);
                    rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                    VERIFY(rDestImgInfo.u4BufSA2 != 0);

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth;
                    rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                    rDestFitImgInfo.u4ImgXOff = 0;
                    rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
                    rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA2 != 0);

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                // Copy source fit buffer to source buffer
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Scaling type is %d.\n",u4LumaKeyScalingType);
                i4ImgReszVfyPrintf("[ImgResz][Verify] YUV,BilinearBoundary (%d,%d).\n",fgYUVMode,fgBilinearBoundary);

                // Preload buffer
                if(fgPreloadBuf)
                {
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Preload buffer alpha %d.\n",u4Alpha);
                    i4HwImgReszSetAlphaBlendingLevel(u4HwId,u4Alpha);
                    i4HwImgReszSetPreloadBufAddr(u4HwId,rPreloadBufInfo.u4BufSA1,rPreloadBufInfo.u4BufSA2);
                }

                // Luma key
                _fgLumakeyTest = TRUE;
                if (((eHResampleMethod == IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR) && (rSrcImgInfo.u4ImgWidth > rDestImgInfo.u4ImgWidth))||
                    ((eVResampleMethod == IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR) && (rSrcImgInfo.u4ImgHeight > rDestImgInfo.u4ImgHeight)))
                 _fgLumakeyTest = FALSE; 

                i4ImgReszVfyPrintf("[ImgResz][Verify] LumaKeyEnable,(%d).\n",_fgLumakeyTest);
                
                i4HwImgReszSetLumaKeyScalingType(u4HwId,u4LumaKeyScalingType);
#if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8530)
                i4HwImgReszSetLumaKeyBilinearBoundary(u4HwId,fgBilinearBoundary);
#endif
#if(CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8560)
                i4HwImgReszSetLumaKeyYUVMode(u4HwId,fgYUVMode);
 #endif
                _u4LumaKeyScalingType = u4LumaKeyScalingType;

                _fgBilinearBoundary = fgBilinearBoundary;

                _fgYUVMode = fgYUVMode;
                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // i4HwImgReszSetLumaKeyEnable(u4HwId,FALSE);
                i4ImgResz_HAL_Set_LumaKey(u4HwId,FALSE,0);
		  _fgLumakeyTest = FALSE;

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                    rDestGoldImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA2 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA2,(void *)rDestFitImgInfo.u4BufSA2,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            fgPreloadBuf,u4Alpha,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
    }

    if(u4FileListNum>0)
    {
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);
        if(rPreloadBufInfo.u4BufSA1 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA1);
        if(rPreloadBufInfo.u4BufSA2 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA2);
    }

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}

INT32 i4ImgReszVfyGenerateSpecialWTCase(UINT32 u4TestCase,
                                        IMGRESZ_HAL_RESIZE_MODE_T *peResizeMode,
                                        IMGRESZ_HAL_RESAMPLE_METHOD_T *peHResampleMethod,
                                        IMGRESZ_HAL_RESAMPLE_METHOD_T *peVResampleMethod,
                                        IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfo,
                                        IMGRESZ_HAL_IMG_INFO_T *prDestImgInfo,
                                        BOOL fgPreloadBuf,UINT32 *pu4Alpha)
{
    UINT32 u4Case;
    UINT32 u4SrcBufWidth = 1920, u4SrcBufHeight = 1080;
    UINT32 u4DestBufWidth = 720, u4DestBufHeight = 720;

    //if((prSrcImgInfo->u4ImgWidth > u4SrcBufWidth) || (prSrcImgInfo->u4ImgHeight > u4SrcBufHeight))
    //{
        u4SrcBufWidth = 736;//prSrcImgInfo->u4ImgWidth;
        u4SrcBufHeight = prSrcImgInfo->u4ImgHeight;

        //u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
   // }

    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
        u4SrcBufHeight = ((u4SrcBufHeight + 31)/ 32) * 32; // Align to 32
    }

    if(prDestImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4DestBufWidth = ((u4DestBufWidth + 15) / 16) * 16;  // Align to 16
        u4DestBufHeight = ((u4DestBufHeight + 31)/ 32) * 32; // Align to 32
    }

    prSrcImgInfo->u4BufWidth = u4SrcBufWidth * u4ImgReszVfyCalBufFormatBits(&(prSrcImgInfo->rBufferFormat)) / 8;
    prSrcImgInfo->u4BufHeight = u4SrcBufHeight;
    prDestImgInfo->u4BufWidth = u4DestBufWidth * u4ImgReszVfyCalBufFormatBits(&(prDestImgInfo->rBufferFormat)) / 8;
    prDestImgInfo->u4BufHeight = u4DestBufHeight;


    //prSrcImgInfo->rBufferFormat.fgWT = FALSE;
    //prDestImgInfo->rBufferFormat.fgWT = TRUE;

    u4Case = u4TestCase % 1;
    switch(u4Case)
    {
        case 2:
            prSrcImgInfo->rBufferFormat.fgWT = FALSE;
            prDestImgInfo->rBufferFormat.fgWT = FALSE;
            break;
        case 3:
            prSrcImgInfo->rBufferFormat.fgWT = FALSE;
            prDestImgInfo->rBufferFormat.fgWT = TRUE;
            break;
        case 0:
            prSrcImgInfo->rBufferFormat.fgWT = TRUE;
            prDestImgInfo->rBufferFormat.fgWT = FALSE;
            break;
        case 1:
            prSrcImgInfo->rBufferFormat.fgWT = TRUE;
            prDestImgInfo->rBufferFormat.fgWT = TRUE;
            break;
    }
    u4TestCase /= 1;

    // Resize mode variation and Resize method variation
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
    {
        u4Case = u4TestCase % 1;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= 1;
    } else
    {
        UINT32 u4CaseNum = 1;

        // Y/C buffer has only frame mode, no partial mode.
        if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            u4CaseNum = 1;

        u4Case = u4TestCase % u4CaseNum;
        //u4Case = 3;
        //if(u4Case == 1)
            //u4Case = 4;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 2:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 3:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 4:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 5:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= u4CaseNum;
    }

    // Progressive frame or interlaced frame
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                break;
            case 1:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                break;
        }
        u4TestCase /= 2;
    }

    // Destination size variation
    u4Case = u4TestCase % 4;
    switch(u4Case)
    {
        case 0:
            prDestImgInfo->u4ImgWidth = 560;
            prDestImgInfo->u4ImgHeight = 320;
            break;
        case 1:
            prDestImgInfo->u4ImgWidth = 320;
            prDestImgInfo->u4ImgHeight = 240;
            break;
        case 2:
            prDestImgInfo->u4ImgWidth = 600;
            prDestImgInfo->u4ImgHeight = 600;
            break;
        case 3:
            prDestImgInfo->u4ImgWidth = 300;
            prDestImgInfo->u4ImgHeight = 600;
            break;
    }
    u4TestCase /= 4;

    u4Case = u4TestCase % 4;
    switch(u4Case)
    {
        case 0:
            prDestImgInfo->u4ImgXOff = 0;
            prDestImgInfo->u4ImgYOff = 0;
            break;
        case 1:
            prDestImgInfo->u4ImgXOff = 1;
            prDestImgInfo->u4ImgYOff = 0;
            break;
        case 2:
            prDestImgInfo->u4ImgXOff = 2;
            prDestImgInfo->u4ImgYOff = 0;
            break;
        case 3:
            prDestImgInfo->u4ImgXOff = 3;
            prDestImgInfo->u4ImgYOff = 0;
            break;
    }
    u4TestCase /= 4;

    // Destination ARGB format variation
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER)
    {
        u4Case = u4TestCase % 1;
        switch(u4Case)
        {
            case 0:
                prDestImgInfo->rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
                break;
            case 1:
                prDestImgInfo->rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
                break;
        }
        u4TestCase /= 1;
    }

    if(u4TestCase > 0)
        return -1;

    return 0;
}

INT32 i4ImgReszVfyGenerateWTCase(UINT32 u4TestCase,
                                 IMGRESZ_HAL_RESIZE_MODE_T *peResizeMode,
                                 IMGRESZ_HAL_RESAMPLE_METHOD_T *peHResampleMethod,
                                 IMGRESZ_HAL_RESAMPLE_METHOD_T *peVResampleMethod,
                                 IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfo,
                                 IMGRESZ_HAL_IMG_INFO_T *prDestImgInfo,
                                 BOOL fgPreloadBuf,UINT32 *pu4Alpha)
{
    UINT32 u4Case;
    UINT32 u4SrcBufWidth = prSrcImgInfo->u4ImgWidth, u4SrcBufHeight = prSrcImgInfo->u4ImgHeight;
    UINT32 u4DestBufWidth = 720, u4DestBufHeight = 480;

    if((prSrcImgInfo->u4ImgWidth > u4SrcBufWidth) || (prSrcImgInfo->u4ImgHeight > u4SrcBufHeight))
    {
        u4SrcBufWidth = prSrcImgInfo->u4ImgWidth;
        u4SrcBufHeight = prSrcImgInfo->u4ImgHeight;

        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
    }

    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
        u4SrcBufHeight = ((u4SrcBufHeight + 31)/ 32) * 32; // Align to 32
    }

    if(prDestImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4DestBufWidth = ((u4DestBufWidth + 15) / 16) * 16;  // Align to 16
        u4DestBufHeight = ((u4DestBufHeight + 31)/ 32) * 32; // Align to 32
    }

    prSrcImgInfo->u4BufWidth = u4SrcBufWidth * u4ImgReszVfyCalBufFormatBits(&(prSrcImgInfo->rBufferFormat)) / 8;
    prSrcImgInfo->u4BufWidth = (prSrcImgInfo->u4BufWidth + 15) / 16 * 16;
    prSrcImgInfo->u4BufHeight = u4SrcBufHeight;
    //prDestImgInfo->u4BufWidth = u4DestBufWidth * u4ImgReszVfyCalBufFormatBits(&(prDestImgInfo->rBufferFormat)) / 8;
    //prDestImgInfo->u4BufHeight = u4DestBufHeight;

    u4Case = u4TestCase % 2;
    switch(u4Case)
    {
        case 0:
            prSrcImgInfo->rBufferFormat.fgWT = TRUE;
            prDestImgInfo->rBufferFormat.fgWT = FALSE;
            break;
        case 1:
            prSrcImgInfo->rBufferFormat.fgWT = TRUE;
            prDestImgInfo->rBufferFormat.fgWT = TRUE;
            break;
        case 2:
            prSrcImgInfo->rBufferFormat.fgWT = TRUE;
            prDestImgInfo->rBufferFormat.fgWT = FALSE;
            break;
        case 3:
            prSrcImgInfo->rBufferFormat.fgWT = TRUE;
            prDestImgInfo->rBufferFormat.fgWT = TRUE;
            break;
    }
    u4TestCase /= 2;


    // Alfa variation
    if(fgPreloadBuf)
    {
#ifdef IMGRESZ_HAL_MT8530
        // MT8530 alfa blending range is from 0 ~ 128
        u4Case = u4TestCase % ((8<<0)+1);
        *pu4Alpha = (u4Case<<4);
        u4TestCase /= ((8<<0)+1);
#else
        // MT8530 alfa blending range is from 0 ~ 8
        u4Case = u4TestCase % ((8<<0)+1);
        *pu4Alpha = (u4Case<<0);
        u4TestCase /= ((8<<0)+1);
#endif
    }

    // Resize mode variation and Resize method variation
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
    {
        u4Case = u4TestCase % 1;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= 1;
    } else
    {
        UINT32 u4CaseNum = 2;

        // Y/C buffer has only frame mode, no partial mode.
        if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            u4CaseNum = 1;

        u4Case = u4TestCase % u4CaseNum;
        //u4Case = 3;
        //if(u4Case == 1)
            //u4Case = 4;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 2:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 3:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 4:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 5:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= u4CaseNum;
    }

    // Progressive frame or interlaced frame
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                break;
            case 1:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                break;
        }
        u4TestCase /= 2;
    }

    // Destination size variation
    /*
    u4Case = u4TestCase % 4;
    switch(u4Case)
    {
        case 0:
            prDestImgInfo->u4ImgWidth = 1280;
            prDestImgInfo->u4ImgHeight = 480;
            break;
        case 1:
            prDestImgInfo->u4ImgWidth = 720;
            prDestImgInfo->u4ImgHeight = 480;
            break;
        case 2:
            prDestImgInfo->u4ImgWidth = 1280;
            prDestImgInfo->u4ImgHeight = 720;
            break;
        case 3:
            prDestImgInfo->u4ImgWidth = 720;
            prDestImgInfo->u4ImgHeight = 720;
            break;
    }
    u4TestCase /= 4;*/

    u4DestBufWidth = prDestImgInfo->u4ImgWidth;
    u4DestBufHeight = prDestImgInfo->u4ImgHeight;
    prDestImgInfo->u4BufWidth = u4DestBufWidth * u4ImgReszVfyCalBufFormatBits(&(prDestImgInfo->rBufferFormat)) / 8;
    prDestImgInfo->u4BufHeight = u4DestBufHeight;
    // Destination ARGB format variation
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER)
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                prDestImgInfo->rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
                break;
            case 1:
                prDestImgInfo->rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
                break;
        }
        u4TestCase /= 2;
    }

    if(u4TestCase > 0)
        return -1;

    return 0;
}
INT32 i4ImgReszVfyGenerateAYUVWTCase(UINT32 u4TestCase,
                                 IMGRESZ_HAL_RESIZE_MODE_T *peResizeMode,
                                 IMGRESZ_HAL_RESAMPLE_METHOD_T *peHResampleMethod,
                                 IMGRESZ_HAL_RESAMPLE_METHOD_T *peVResampleMethod,
                                 IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfo,
                                 IMGRESZ_HAL_IMG_INFO_T *prDestImgInfo,
                                 BOOL fgPreloadBuf,UINT32 *pu4Alpha)
{
    UINT32 u4Case;
    UINT32 u4SrcBufWidth = prSrcImgInfo->u4ImgWidth, u4SrcBufHeight = prSrcImgInfo->u4ImgHeight;
    UINT32 u4DestBufWidth = 800, u4DestBufHeight = 608;

    if((prSrcImgInfo->u4ImgWidth > u4SrcBufWidth) || (prSrcImgInfo->u4ImgHeight > u4SrcBufHeight))
    {
        u4SrcBufWidth = prSrcImgInfo->u4ImgWidth;
        u4SrcBufHeight = prSrcImgInfo->u4ImgHeight;

        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
    }

    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
        u4SrcBufHeight = ((u4SrcBufHeight + 31)/ 32) * 32; // Align to 32
    }

    if(prDestImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4DestBufWidth = ((u4DestBufWidth + 15) / 16) * 16;  // Align to 16
        u4DestBufHeight = ((u4DestBufHeight + 31)/ 32) * 32; // Align to 32
    }

    prSrcImgInfo->u4BufWidth = u4SrcBufWidth * u4ImgReszVfyCalBufFormatBits(&(prSrcImgInfo->rBufferFormat)) / 8;
    prSrcImgInfo->u4BufWidth = (prSrcImgInfo->u4BufWidth + 15) / 16 * 16;
    prSrcImgInfo->u4BufHeight = u4SrcBufHeight;
    prDestImgInfo->u4BufWidth = u4DestBufWidth * u4ImgReszVfyCalBufFormatBits(&(prDestImgInfo->rBufferFormat)) / 8;
    prDestImgInfo->u4BufHeight = u4DestBufHeight;

    u4Case = u4TestCase % 4;
    switch(u4Case)
    {
        case 0:
            prSrcImgInfo->rBufferFormat.fgWT = FALSE;
            prDestImgInfo->rBufferFormat.fgWT = FALSE;
            break;
        case 1:
            prSrcImgInfo->rBufferFormat.fgWT = FALSE;
            prDestImgInfo->rBufferFormat.fgWT = TRUE;
            break;
        case 2:
            prSrcImgInfo->rBufferFormat.fgWT = TRUE;
            prDestImgInfo->rBufferFormat.fgWT = FALSE;
            break;
        case 3:
            prSrcImgInfo->rBufferFormat.fgWT = TRUE;
            prDestImgInfo->rBufferFormat.fgWT = TRUE;
            break;
    }
    u4TestCase /= 4;     


    // Alfa variation
    if(fgPreloadBuf)
    {
#ifdef IMGRESZ_HAL_MT8530
        // MT8530 alfa blending range is from 0 ~ 128
        u4Case = u4TestCase % ((8<<0)+1);
        *pu4Alpha = (u4Case<<4);
        u4TestCase /= ((8<<0)+1);
#else
        // MT8530 alfa blending range is from 0 ~ 8
        u4Case = u4TestCase % ((8<<0)+1);
        *pu4Alpha = (u4Case<<0);
        u4TestCase /= ((8<<0)+1);
#endif
    }

    // Resize mode variation and Resize method variation
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
    {
        u4Case = u4TestCase % 1;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= 1;
    } else
    {
        UINT32 u4CaseNum = 1;

        // Y/C buffer has only frame mode, no partial mode.
        if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            u4CaseNum = 1;

        u4Case = u4TestCase % u4CaseNum;
        //u4Case = 3;
        //if(u4Case == 1)
            //u4Case = 4;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 2:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 3:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 4:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 5:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= u4CaseNum;
    }

    // Progressive frame or interlaced frame
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                break;
            case 1:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                break;
        }
        u4TestCase /= 2;
    }

    // Destination size variation
    u4Case = u4TestCase % 2;
    switch(u4Case)
    {
        case 0:
            prDestImgInfo->u4ImgWidth = 352;
            prDestImgInfo->u4ImgHeight = 240;
            break;
        case 1:
            prDestImgInfo->u4ImgWidth = 800;
            prDestImgInfo->u4ImgHeight = 600;
            break;
        case 2:
            prDestImgInfo->u4ImgWidth = 460;
            prDestImgInfo->u4ImgHeight = 150;
            break;
        case 3:
            prDestImgInfo->u4ImgWidth = 300;
            prDestImgInfo->u4ImgHeight = 300;
            break;
    }
    u4TestCase /= 2;

    //u4DestBufWidth = prDestImgInfo->u4ImgWidth;
   // u4DestBufHeight = prDestImgInfo->u4ImgHeight;
    prDestImgInfo->u4BufWidth = u4DestBufWidth * u4ImgReszVfyCalBufFormatBits(&(prDestImgInfo->rBufferFormat)) / 8;
    prDestImgInfo->u4BufHeight = u4DestBufHeight;
    // Destination ARGB format variation
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER)
    {
        u4Case = u4TestCase % 1;
        switch(u4Case)
        {
            case 0:
                prDestImgInfo->rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
                break;
            case 1:
                prDestImgInfo->rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
                break;
        }
        u4TestCase /= 1;
    }

    if(u4TestCase > 0)
        return -1;

    return 0;
}
INT32 i4ImgReszVfyTestWTAYUV(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rPreloadBufInfo;
    BOOL fgPreloadBuf = FALSE;
    UINT32 u4Alpha = 0;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY((void *)u4FileListSA != NULL);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != NULL);
       #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  

    if(u4FileListNum>0)
    {
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);
        x_memset(&rPreloadBufInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        if(i4ImgReszVfyTestLoadPreloadBuf(ppbFileList[0],&rPreloadBufInfo) >= 0)
            fgPreloadBuf = TRUE;
    }

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not AYUV.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateAYUVWTCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                         &rSrcImgInfo,&rDestImgInfo,fgPreloadBuf,&u4Alpha)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY((void *)rSrcFitImgInfo.u4BufSA1 != NULL);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,1,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                BOOL fgSourceOffsetChange = FALSE;

                if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
                    rSrcImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
                    i4ImgReszVfyPrintf("[ImgResz][Verify] SRC buffer size : %d,Src addr :%x.\n",u4BufSize,rSrcImgInfo.u4BufSA1);
#else
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
#endif
                    VERIFY((void *)rSrcImgInfo.u4BufSA1 != NULL);

                    // Allocate destination buffer
                    u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
                    rDestImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
                    i4ImgReszVfyPrintf("[ImgResz][Verify] SRC buffer size : %d,Src addr :%x.\n",u4BufSize,rDestImgInfo.u4BufSA1);
#else
                    rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
#endif
                    VERIFY((void *)rDestImgInfo.u4BufSA1 != NULL);
                    x_memset((void *)rDestImgInfo.u4BufSA1,0x0,u4BufSize);

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
  //                  rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
  //                  rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
  //                  rDestFitImgInfo.u4ImgXOff = 0;
 //                   rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
		      x_memset((void *)rDestFitImgInfo.u4BufSA1,0x0,u4BufSize);
                    VERIFY((void *)rDestFitImgInfo.u4BufSA1 != NULL);

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                // Copy source fit buffer to source buffer
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Preload buffer
                if(fgPreloadBuf)
                {
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Preload buffer alpha %d.\n",u4Alpha);
                    i4HwImgReszSetAlphaBlendingLevel(u4HwId,u4Alpha);
                    i4HwImgReszSetPreloadBufAddr(u4HwId,rPreloadBufInfo.u4BufSA1,rPreloadBufInfo.u4BufSA2);
                }

                // Turn on WT
                *((volatile UINT32*)(IO_BASE + WT_REG_OFFSET)) = 0xe82a6f11;

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Turn off WT
                *((volatile UINT32*)(IO_BASE + WT_REG_OFFSET)) = 0xc00d6f10;

                // Copy destination buffer to destination fit buffer
               // vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);
                  u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                  x_memcpy((void *)rDestFitImgInfo.u4BufSA1,(void *)rDestImgInfo.u4BufSA1,u4BufSize);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY((void *)rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            fgPreloadBuf,u4Alpha,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }
#if IMGRESZ_IO_MMU_TEST
            x_free_vmem((void *)rSrcImgInfo.u4BufSA1);
            x_free_vmem((void *)rDestImgInfo.u4BufSA1);
#else
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
#endif
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            if(0)
            {
                imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            }

            u4TestCase++;
        }

        if((void *)rSrcFitImgInfo.u4BufSA1 != NULL)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if((void *)rSrcFitImgInfo.u4BufSA2 != NULL)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
    }

    if(u4FileListNum>0)
    {
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);
        if((void *)rPreloadBufInfo.u4BufSA1 != NULL);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA1);
        if((void *)rPreloadBufInfo.u4BufSA2 != NULL);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA2);
    }

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}

INT32 i4ImgReszVfyTestWTARGB(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rPreloadBufInfo;
    BOOL fgPreloadBuf = FALSE;
    UINT32 u4Alpha = 0;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
       #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
    {
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);
        x_memset(&rPreloadBufInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        if(i4ImgReszVfyTestLoadPreloadBuf(ppbFileList[0],&rPreloadBufInfo) >= 0)
            fgPreloadBuf = TRUE;
    }

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER
           && rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not ARGB or AYUV.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateWTCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                         &rSrcImgInfo,&rDestImgInfo,fgPreloadBuf,&u4Alpha)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,1,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                BOOL fgSourceOffsetChange = FALSE;

                if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);

                    // Allocate destination buffer
                    u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                    rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rDestImgInfo.u4BufSA1 != 0);

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
                    rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                    rDestFitImgInfo.u4ImgXOff = 0;
                    rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                // Copy source fit buffer to source buffer
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Preload buffer
                if(fgPreloadBuf)
                {
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Preload buffer alpha %d.\n",u4Alpha);
                    i4HwImgReszSetAlphaBlendingLevel(u4HwId,u4Alpha);
                    i4HwImgReszSetPreloadBufAddr(u4HwId,rPreloadBufInfo.u4BufSA1,rPreloadBufInfo.u4BufSA2);
                }

                // Turn on WT
                *((volatile UINT32*)(0x70040800)) = (*((volatile UINT32*)(0x70040800))) & 0xFFFEFFFF;

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Turn off WT
                *((volatile UINT32*)(0x70040800)) = (*((volatile UINT32*)(0x70040800))) | 0x10000;

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            fgPreloadBuf,u4Alpha,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            if(0)
            {
                imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            }

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
    }

    if(u4FileListNum>0)
    {
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);
        if(rPreloadBufInfo.u4BufSA1 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA1);
        if(rPreloadBufInfo.u4BufSA2 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA2);
    }

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyGenerateWT2Case(UINT32 u4TestCase,
                                 IMGRESZ_HAL_RESIZE_MODE_T *peResizeMode,
                                 IMGRESZ_HAL_RESAMPLE_METHOD_T *peHResampleMethod,
                                 IMGRESZ_HAL_RESAMPLE_METHOD_T *peVResampleMethod,
                                 IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfo,
                                 IMGRESZ_HAL_IMG_INFO_T *prDestImgInfo,
                                 BOOL fgPreloadBuf,UINT32 *pu4Alpha,IMGRESZ_HAL_IMG_INFO_T *prWTImgInfo)
{
    UINT32 u4Case;
    UINT32 u4SrcBufWidth = 1920, u4SrcBufHeight = 1080;
    UINT32 u4DestBufWidth = 800, u4DestBufHeight = 608;

    if((prSrcImgInfo->u4ImgWidth > u4SrcBufWidth) || (prSrcImgInfo->u4ImgHeight > u4SrcBufHeight))
    {
        u4SrcBufWidth = prSrcImgInfo->u4ImgWidth;
        u4SrcBufHeight = prSrcImgInfo->u4ImgHeight;

        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
    }
       prWTImgInfo->u4BufWidth = ((736 + 15) / 16) * 16* u4ImgReszVfyCalBufFormatBits(&(prSrcImgInfo->rBufferFormat)) / 8;  //sun  Align to 16

    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
        u4SrcBufHeight = ((u4SrcBufHeight + 31)/ 32) * 32; // Align to 32
    }

    if(prDestImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4DestBufWidth = ((u4DestBufWidth + 15) / 16) * 16;  // Align to 16
        u4DestBufHeight = ((u4DestBufHeight + 31)/ 32) * 32; // Align to 32
    }

    prSrcImgInfo->u4BufWidth = u4SrcBufWidth * u4ImgReszVfyCalBufFormatBits(&(prSrcImgInfo->rBufferFormat)) / 8;
    prSrcImgInfo->u4BufHeight = u4SrcBufHeight;
    prDestImgInfo->u4BufWidth = u4DestBufWidth * u4ImgReszVfyCalBufFormatBits(&(prDestImgInfo->rBufferFormat)) / 8;
    prDestImgInfo->u4BufHeight = u4DestBufHeight;

    // Alfa variation
    if(fgPreloadBuf)
    {
#ifdef IMGRESZ_HAL_MT8530
        // MT8530 alfa blending range is from 0 ~ 128
        u4Case = u4TestCase % ((8<<0)+1);
        *pu4Alpha = (u4Case<<4);
        u4TestCase /= ((8<<0)+1);
#else
        // MT8530 alfa blending range is from 0 ~ 8
        u4Case = u4TestCase % ((8<<0)+1);
        *pu4Alpha = (u4Case<<0);
        u4TestCase /= ((8<<0)+1);
#endif
    }

    // Resize mode variation and Resize method variation
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= 2;
    } else
    {
        UINT32 u4CaseNum = 1;

        // Y/C buffer has only frame mode, no partial mode.
        if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            u4CaseNum = 4;

        u4Case = u4TestCase % u4CaseNum;
        //if(u4Case == 1)
            //u4Case = 4;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 2:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 3:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 4:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 5:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= u4CaseNum;
    }

    // Progressive frame or interlaced frame
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                break;
            case 1:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                break;
        }
        u4TestCase /= 2;
    }


    u4Case = u4TestCase % 4;
    switch(u4Case)
    {
        case 0:
            prWTImgInfo->u4ImgXOff = 0;
            prWTImgInfo->u4ImgYOff = 0;
            break;
        case 1:
            prWTImgInfo->u4ImgXOff = 1;
            prWTImgInfo->u4ImgYOff = 0;
            break;
        case 2:
            prWTImgInfo->u4ImgXOff = 2;
            prWTImgInfo->u4ImgYOff = 0;
            break;
        case 3:
            prWTImgInfo->u4ImgXOff = 3;
            prWTImgInfo->u4ImgYOff = 0;
            break;
    }
    u4TestCase /= 4;

    // Destination size variation
    u4Case = u4TestCase % 2;
    switch(u4Case)
    {
        case 0:
            prDestImgInfo->u4ImgWidth = 352;
            prDestImgInfo->u4ImgHeight = 240;
            break;
        case 1:
            prDestImgInfo->u4ImgWidth = 800;
            prDestImgInfo->u4ImgHeight = 600;
            break;
    }
    u4TestCase /= 2;

// read or write bypass
    u4Case = u4TestCase % 3;
    switch(u4Case)
    {
        case 0:
            prWTImgInfo->rBufferFormat.fgWT = FALSE;
            prDestImgInfo->rBufferFormat.fgWT= FALSE;
            break;
        case 1:
            prWTImgInfo->rBufferFormat.fgWT = TRUE;
            prDestImgInfo->rBufferFormat.fgWT= FALSE;
            break;
        case 2:
            prWTImgInfo->rBufferFormat.fgWT = TRUE;
            prDestImgInfo->rBufferFormat.fgWT= TRUE;
            break;
    }
    u4TestCase /= 3;

    // Destination ARGB format variation
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER)
    {
        u4Case = u4TestCase % 1;
        switch(u4Case)
        {
            case 0:
                prDestImgInfo->rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
                break;
            case 1:
                prDestImgInfo->rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
                break;
        }
        u4TestCase /= 1;
    }

    if(u4TestCase > 0)
        return -1;

    return 0;
}

INT32 i4ImgReszTestWTWriteOffset(void)
{
    UINT32 *u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rPreloadBufInfo;
    BOOL fgPreloadBuf = FALSE;
    UINT32 u4Alpha = 0;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY((void *)u4FileListSA != NULL);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY((void *)ppbFileList != NULL);
       #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
    {
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);
        x_memset(&rPreloadBufInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        if(i4ImgReszVfyTestLoadPreloadBuf(ppbFileList[0],&rPreloadBufInfo) >= 0)
            fgPreloadBuf = TRUE;
    }

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not ARGB.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateSpecialWTCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                                &rSrcImgInfo,&rDestImgInfo,fgPreloadBuf,&u4Alpha)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY((void *)rSrcFitImgInfo.u4BufSA1 != NULL);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,1,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                BOOL fgSourceOffsetChange = FALSE;

                if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY((void *)rSrcImgInfo.u4BufSA1 != NULL);

                    // Allocate destination buffer
                    u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                    rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY((void *)rDestImgInfo.u4BufSA1 != NULL);
                    memset((void *)rDestImgInfo.u4BufSA1, 0x0, u4BufSize);

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    //rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
                    //rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                    //rDestFitImgInfo.u4ImgXOff = 0;
                    //rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY((void *)rDestFitImgInfo.u4BufSA1 != NULL);

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                // Copy source fit buffer to source buffer
                  u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                    x_memcpy((void *)rSrcImgInfo.u4BufSA1,(void *)rSrcFitImgInfo.u4BufSA1,u4BufSize);


                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Preload buffer
                if(fgPreloadBuf)
                {
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Preload buffer alpha %d.\n",u4Alpha);
                    i4HwImgReszSetAlphaBlendingLevel(u4HwId,u4Alpha);
                    i4HwImgReszSetPreloadBufAddr(u4HwId,rPreloadBufInfo.u4BufSA1,rPreloadBufInfo.u4BufSA2);
                }

                // Turn on WT0xc00c6f10
                *((volatile UINT32*)(IO_BASE + WT_REG_OFFSET)) = (*((volatile UINT32*)(IO_BASE + WT_REG_OFFSET))) & 0xFFFEFFFF;

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,NULL);

                // Turn off WT
                *((volatile UINT32*)(IO_BASE + WT_REG_OFFSET)) = (*((volatile UINT32*)(IO_BASE + WT_REG_OFFSET))) | 0x10000;

                // Copy destination buffer to destination fit buffer
                //vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);
                u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                x_memcpy((void *)rDestFitImgInfo.u4BufSA1,(void *)rDestImgInfo.u4BufSA1,u4BufSize);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY((void *)rDestGoldImgInfo.u4BufSA1 != NULL);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            fgPreloadBuf,u4Alpha,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            if(0)
            {
                imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            }

            u4TestCase++;
        }

        if((void *)rSrcFitImgInfo.u4BufSA1 != NULL)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if((void *)rSrcFitImgInfo.u4BufSA2 != NULL)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
    }

    if(u4FileListNum>0)
    {
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);
        if((void *)rPreloadBufInfo.u4BufSA1 != NULL);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA1);
        if((void *)rPreloadBufInfo.u4BufSA2 != NULL);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA2);
    }

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}
INT32 i4ImgReszVfyTestWTARGB2(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rWTImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rPreloadBufInfo;
    BOOL fgPreloadBuf = FALSE;
    UINT32 u4Alpha = 0;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
       #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  

    if(u4FileListNum>0)
    {
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);
        x_memset(&rPreloadBufInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        if(i4ImgReszVfyTestLoadPreloadBuf(ppbFileList[0],&rPreloadBufInfo) >= 0)
            fgPreloadBuf = TRUE;
    }

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not ARGB.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate WT buffer info
        x_memcpy(&rWTImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
#if defined(IMGRESZ_HAL_MT8530) || defined(IMGRESZ_HAL_MT8550)
        rWTImgInfo.rBufferFormat.fgWT = TRUE;
#endif

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateWT2Case(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                         &rSrcImgInfo,&rDestImgInfo,fgPreloadBuf,&u4Alpha,&rWTImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,1,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                BOOL fgSourceOffsetChange = FALSE;

                if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
                    rSrcImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
#else
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_src_alloc_mem_aligned(u4BufSize,64);
#endif
                    i4ImgReszVfyPrintf("[ImgResz][Verify] SRC buffer size : %d,Src addr :%x.\n",u4BufSize,rSrcImgInfo.u4BufSA1);
		      //vMMUDebug(rSrcImgInfo.u4BufSA1);
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);

                    // Allocate WT buffer
                    u4BufSize = rWTImgInfo.u4BufWidth * rWTImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
                    rWTImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
                    vMMUDebug(rWTImgInfo.u4BufSA1);
#else
                    rWTImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,64);
#endif
                    memset((void *)rWTImgInfo.u4BufSA1, 0x0, u4BufSize);
                     i4ImgReszVfyPrintf("[ImgResz][Verify] WT buffer size : %d,WT addr :%x.\n",u4BufSize,rWTImgInfo.u4BufSA1);
		     // vMMUDebug(rWTImgInfo.u4BufSA1);
                    VERIFY(rWTImgInfo.u4BufSA1 != 0);

                    // Allocate destination buffer
                    u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
                    rDestImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
                    vMMUDebug(rDestImgInfo.u4BufSA1);
#else
                    rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_dst_alloc_mem_aligned(u4BufSize,64);
#endif
		      memset((void *)rDestImgInfo.u4BufSA1, 0x0, u4BufSize);
		     i4ImgReszVfyPrintf("[ImgResz][Verify] DST buffer size : %d,DST addr :%x.\n",u4BufSize,rDestImgInfo.u4BufSA1);
                    //vMMUDebug(rWTImgInfo.u4BufSA1);
		      VERIFY(rDestImgInfo.u4BufSA1 != 0);

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                // Copy source fit buffer to source buffer
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

                   /*Turn on Test agent*/
                #if IMGRESZ_DRAMBUSY_TEST
                           *(volatile UINT32 *)(IO_BASE + 0x007104) = 0x00000000;
                           *(volatile UINT32 *)(IO_BASE + 0x007218) = 0x8e0f110d;
                #endif

                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] wt offset (%d,%d).\n",rWTImgInfo.u4ImgXOff,rWTImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Preload buffer
                if(fgPreloadBuf)
                {
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Preload buffer alpha %d.\n",u4Alpha);
                    i4HwImgReszSetAlphaBlendingLevel(u4HwId,u4Alpha);
                    i4HwImgReszSetPreloadBufAddr(u4HwId,rPreloadBufInfo.u4BufSA1,rPreloadBufInfo.u4BufSA2);
                }

                // Turn on WT
                *((volatile UINT32*)(IO_BASE + WT_REG_OFFSET)) = 0xe82a6f11;

                // Resize source buffer to WT buffer
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rWTImgInfo,0);

		  // save WT buffer
                // i4ImgReszVfySaveWTBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rWTImgInfo);

                // Resize WT buffer to destination buffer
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rWTImgInfo,&rDestImgInfo,0);

                // Turn off WT
                *((volatile UINT32*)(IO_BASE + WT_REG_OFFSET)) = 0xc00d6f10;

	          i4ImgReszVfyPrintf("[ImgResz][Verify] Resizer twice done.\n");
                // Copy destination buffer to destination fit buffer
                //vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);
                u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                x_memcpy((void *)rDestFitImgInfo.u4BufSA1,(void *)rDestImgInfo.u4BufSA1,u4BufSize);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            fgPreloadBuf,u4Alpha,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }
#if 0//IMGRESZ_IO_MMU_TEST
            x_free_vmem((void *)rSrcImgInfo.u4BufSA1);
            x_free_vmem((void *)rWTImgInfo.u4BufSA1);
            x_free_vmem((void *)rDestImgInfo.u4BufSA1);
#else
            imgreszvfy_src_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);        
            imgreszvfy_free_mem_aligned((void *)rWTImgInfo.u4BufSA1);
            imgreszvfy_dst_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);        
#endif
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            if(0)
            {
                imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            }

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
    }

    if(u4FileListNum>0)
    {
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);
        if(rPreloadBufInfo.u4BufSA1 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA1);
        if(rPreloadBufInfo.u4BufSA2 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA2);
    }

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}


INT32 i4ImgReszVfyTestVideoToWTAYUV2(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rWTImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rPreloadBufInfo;
    BOOL fgPreloadBuf = FALSE;
    UINT32 u4Alpha = 0;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
      #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
    {
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);
        x_memset(&rPreloadBufInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        if(i4ImgReszVfyTestLoadPreloadBuf(ppbFileList[0],&rPreloadBufInfo) >= 0)
            fgPreloadBuf = TRUE;
    }

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Video.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
        rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;

        // Generate WT buffer info
        x_memcpy(&rWTImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rWTImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
        rWTImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
        rWTImgInfo.u4ImgWidth = 352;
        rWTImgInfo.u4ImgHeight = 240;
        rWTImgInfo.u4BufWidth =  1920 * 4;
        rWTImgInfo.u4BufHeight = 1080;
#ifdef IMGRESZ_HAL_MT8530
        rWTImgInfo.rBufferFormat.fgWT = TRUE;
#endif

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateWT2Case(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo,fgPreloadBuf,&u4Alpha,&rWTImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;
            IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
            IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Generate next source buffer info
            x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Generate next destination buffer info
            x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            u4TestSubCase = 0;

            while(i4ImgReszVfyGenerateSubCase(u4TestSubCase,1,&u4HwId,eResizeMode,
                                              &rSrcImgInfoNext,&rDestImgInfoNext)>=0)
            {
                BOOL fgSourceOffsetChange = FALSE;

                if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
                   (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                    fgSourceOffsetChange = TRUE;

                // Update source buffer info
                x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update destination buffer info
                x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                if(u4TestSubCase == 0)
                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
                    u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);
                    rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                    VERIFY(rSrcImgInfo.u4BufSA2 != 0);

                    // Allocate destination buffer
                    u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                    rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rDestImgInfo.u4BufSA1 != 0);

                    // Allocate WT buffer
                    u4BufSize = rWTImgInfo.u4BufWidth * rWTImgInfo.u4BufHeight;
                    rWTImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rWTImgInfo.u4BufSA1 != 0);

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
                    rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
                    rDestFitImgInfo.u4ImgXOff = 0;
                    rDestFitImgInfo.u4ImgYOff = 0;
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);

                    // Update next source buffer info
                    x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                    // Update next destination buffer info
                    x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                }

                // Copy source fit buffer to source buffer
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

                // Preload buffer
                if(fgPreloadBuf)
                {
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Preload buffer alpha %d.\n",u4Alpha);
                    i4HwImgReszSetAlphaBlendingLevel(u4HwId,u4Alpha);
                    i4HwImgReszSetPreloadBufAddr(u4HwId,rPreloadBufInfo.u4BufSA1,rPreloadBufInfo.u4BufSA2);
                }

                // Turn on WT
                *((volatile UINT32*)(0x70040800)) = (*((volatile UINT32*)(0x70040800))) & 0xFFFEFFFF;

                // Resize source buffer to WT buffer
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rWTImgInfo,0);

                // Resize WT buffer to destination buffer
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rWTImgInfo,&rDestImgInfo,0);

                // Turn off WT
                *((volatile UINT32*)(0x70040800)) = (*((volatile UINT32*)(0x70040800))) | 0x10000;

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            fgPreloadBuf,u4Alpha,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }

                u4TestSubCase++;
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rWTImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            if(rDestImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            if(rDestFitImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            if(rDestGoldImgInfo.u4BufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
    }

    if(u4FileListNum>0)
    {
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);
        if(rPreloadBufInfo.u4BufSA1 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA1);
        if(rPreloadBufInfo.u4BufSA2 != 0);
            imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA2);
    }

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}
INT32 i4ImgReszVfyTestVideoToVideoSwap2(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSwapImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    u4SwapMode = 0;
    _fgOpenAddressSwap = TRUE;
    // Load file list
    u4FileListSA =(UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY((void *)u4FileListSA != NULL);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY((void *)ppbFileList != NULL);
   #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Video.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));



        u4TestCase = 0;

        while(i4ImgReszVfyGenerateBasicCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY((void *)rSrcFitImgInfo.u4BufSA1 != NULL);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY((void *)rSrcFitImgInfo.u4BufSA2 != NULL);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Copy source fit buffer to source buffer
            u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
            u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
            rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
            VERIFY((void *)rSrcImgInfo.u4BufSA1 != NULL);
            rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
            VERIFY((void *)rSrcImgInfo.u4BufSA2 != NULL);
            vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

            //Copy the Srcimg Info for Swap buffer. for in this item, it is OK!
            x_memcpy(&rSwapImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            //Swap buffer
            u4BufSize = rSwapImgInfo.u4BufWidth * rSwapImgInfo.u4BufHeight;
            u4BufSize = ((u4BufSize + 4095) / 4096) * 4096; // Align to 1024 for address swap
            rSwapImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,2048);
            VERIFY((void *)rSwapImgInfo.u4BufSA1 != NULL);
            rSwapImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,2048);
            VERIFY((void *)rSwapImgInfo.u4BufSA2 != NULL);
            rSwapImgInfo.rBufferFormat.fgBlockMode = TRUE;
            rSwapImgInfo.rBufferFormat.fgAddrSwap = TRUE;

            // Destination buffer
            u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
            u4BufSize = ((u4BufSize + 2047) / 2048) * 2048; // Align to 1024 for address swap

            rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,2048);
            VERIFY((void *)rDestImgInfo.u4BufSA1 != NULL);
            rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,2048);
            VERIFY((void *)rDestImgInfo.u4BufSA2 != NULL);

            // Generate destination fit buffer info
            x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
            rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth;
            rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
            rDestFitImgInfo.u4ImgXOff = 0;
            rDestFitImgInfo.u4ImgYOff = 0;
            u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
            rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
            VERIFY((void *)rDestFitImgInfo.u4BufSA1 != NULL);
            rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
            VERIFY((void *)rDestFitImgInfo.u4BufSA2 != NULL);

            for(u4HwId=0; u4HwId<=IMG_RESZ_VFY_HW_NUM; u4HwId++)
            {
                if(!_afgImgReszVfyHwEnable[u4HwId])
                    continue;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rSwapImgInfo,NULL);
                //Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSwapImgInfo,&rDestImgInfo,NULL);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY((void *)rDestGoldImgInfo.u4BufSA1 != NULL);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                    rDestGoldImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY((void *)rDestGoldImgInfo.u4BufSA2 != NULL);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA2,(void *)rDestFitImgInfo.u4BufSA2,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            FALSE,0,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            if((void *)rSwapImgInfo.u4BufSA1 != NULL)
			    imgreszvfy_free_mem_aligned((void *)rSwapImgInfo.u4BufSA1);
			
			if((void *)rSwapImgInfo.u4BufSA2 != NULL)
			    imgreszvfy_free_mem_aligned((void *)rSwapImgInfo.u4BufSA2);           

            u4TestCase++;
        }

        if((void *)rSrcFitImgInfo.u4BufSA1 != NULL)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if((void *)rSrcFitImgInfo.u4BufSA2 != NULL)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);
     _fgOpenAddressSwap = FALSE;
    return 0;
}
INT32 i4ImgReszVfyTestJpegToVideoSwap2(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSwapImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    u4SwapMode = 0;
    _fgOpenAddressSwap = TRUE;
    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY((void *)u4FileListSA != NULL);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY((void *)ppbFileList != NULL);
   #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",(UINT32)u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif
    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Jpeg.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER;
        rDestImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateBlockModeAndAddressSwapCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY((void *)rSrcFitImgInfo.u4BufSA1 != NULL);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY((void *)rSrcFitImgInfo.u4BufSA2 != NULL);
                rSrcFitImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY((void *)rSrcFitImgInfo.u4BufSA3 != NULL);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Copy source fit buffer to source buffer
            u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
            u4BufSize = ((u4BufSize + 2047) / 2048) * 2048; // Align to 1024 for address swap
            rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,4096);
            VERIFY((void *)rSrcImgInfo.u4BufSA1 != NULL);
            rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,4096);
            VERIFY((void *)rSrcImgInfo.u4BufSA2 != NULL);
            rSrcImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,4096);
            VERIFY((void *)rSrcImgInfo.u4BufSA3 != NULL);
    #if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8560)
           if((rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[1] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0])
	          &&(rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[2] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0]))
                vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,TRUE);
	       else
	            vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
    #else
            vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
    #endif

            //Copy the Desting Info for Swap buffer. for in this item, it is OK!
            x_memcpy(&rSwapImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            //Swap buffer
            u4BufSize = rSwapImgInfo.u4BufWidth * rSwapImgInfo.u4BufHeight;
            u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
            rSwapImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,4096);
            VERIFY((void *)rSwapImgInfo.u4BufSA1 != NULL);
            rSwapImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,4096);
            VERIFY((void *)rSwapImgInfo.u4BufSA2 != NULL);
            rSwapImgInfo.rBufferFormat.fgBlockMode = TRUE;
            rSwapImgInfo.rBufferFormat.fgAddrSwap = TRUE;

            // Destination buffer
            u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
            u4BufSize = ((u4BufSize + 2047) / 2048) * 2048; // Align to 1024 for address swap

            rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,4096);
            VERIFY((void *)rDestImgInfo.u4BufSA1 != NULL);
            rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,4096);
            VERIFY((void *)rDestImgInfo.u4BufSA2 != NULL);

            // Generate destination fit buffer info
            x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
            rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth;
            rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
            rDestFitImgInfo.u4ImgXOff = 0;
            rDestFitImgInfo.u4ImgYOff = 0;
            u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
            rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
            VERIFY((void *)rDestFitImgInfo.u4BufSA1 != NULL);
            rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
            VERIFY((void *)rDestFitImgInfo.u4BufSA2 != NULL);

            for(u4HwId=0; u4HwId<=IMG_RESZ_VFY_HW_NUM; u4HwId++)
            {
                if(!_afgImgReszVfyHwEnable[u4HwId])
                    continue;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rSwapImgInfo,NULL);
                eResizeMode = IMGRESZ_HAL_RESIZE_MODE_FRAME ;
                if (u4TestCase % 4 == 0)
                {
                    eHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                    eVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                }
                else if (u4TestCase % 4 == 1)
                {
                    eHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                    eVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                }
                else if (u4TestCase % 4 == 2)
                {
                    eHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                    eVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                }
                else if (u4TestCase % 4 == 3)
                {
                    eHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                    eVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                }
                //Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSwapImgInfo,&rDestImgInfo,NULL);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY((void *)rDestGoldImgInfo.u4BufSA1 != NULL);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                    rDestGoldImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY((void *)rDestGoldImgInfo.u4BufSA2 != NULL);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA2,(void *)rDestFitImgInfo.u4BufSA2,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            FALSE,0,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                            VERIFY(FALSE);

                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                    }
                    if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                    {
                        u4DestGoldAddr = rDestGoldImgInfo.u4BufSA2;
                        u4DestFitAddr = rDestFitImgInfo.u4BufSA2;

                        u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                        if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                            u4BufSize /= 2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                                VERIFY(FALSE);

                            u4DestFitAddr++;
                            u4DestGoldAddr++;
                        }
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }
            }
            UTIL_Printf("1\n");
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            UTIL_Printf("2\n");
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            UTIL_Printf("3\n");
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            UTIL_Printf("4\n");
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            UTIL_Printf("5\n");
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            UTIL_Printf("6\n");
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            UTIL_Printf("7\n");
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            UTIL_Printf("8\n");
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
            UTIL_Printf("9\n");
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA3);  
            UTIL_Printf("10\n");
            imgreszvfy_free_mem_aligned((void *)rSwapImgInfo.u4BufSA1);
            UTIL_Printf("11\n");
            imgreszvfy_free_mem_aligned((void *)rSwapImgInfo.u4BufSA2);
            UTIL_Printf("12\n");

            u4TestCase++;
        }

        if((void *)rSrcFitImgInfo.u4BufSA1 != NULL)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if((void *)rSrcFitImgInfo.u4BufSA2 != NULL)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
        if((void *)rSrcFitImgInfo.u4BufSA3 != NULL)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA3);
    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}

#if IMGRESZ_VIDEO_MODE_SUPPORT_WEBP

extern void x_thread_delay(UINT32 ui4_delay);
INT32 i4ImgReszVfyTestVideoPartialMode(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    //IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
       #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  

    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not Video.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateBasicCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            //BOOL fgGenGolden = FALSE;
            eVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
            rSrcImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;
            rDestImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;
            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Copy source fit buffer to source buffer
            u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
            u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
            rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
            VERIFY(rSrcImgInfo.u4BufSA1 != 0);
            x_memset((void *)rSrcImgInfo.u4BufSA1,0,u4BufSize);
            rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
            VERIFY(rSrcImgInfo.u4BufSA2 != 0);
            x_memset((void *)rSrcImgInfo.u4BufSA2,0,u4BufSize);

            vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

            // Destination buffer
            u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
            u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
            rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
            VERIFY(rDestImgInfo.u4BufSA1 != 0);
            x_memset((void *)rDestImgInfo.u4BufSA1,0,u4BufSize);
            rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
            VERIFY(rDestImgInfo.u4BufSA2 != 0);
            x_memset((void *)rDestImgInfo.u4BufSA2,0,u4BufSize);
            // Generate destination fit buffer info
            x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
            rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth;
            rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
            rDestFitImgInfo.u4ImgXOff = 0;
            rDestFitImgInfo.u4ImgYOff = 0;
            u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
            rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
            VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
            rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
            VERIFY(rDestFitImgInfo.u4BufSA2 != 0);

            for(u4HwId=0; u4HwId<=IMG_RESZ_VFY_HW_NUM; u4HwId++)
            { 
                UINT32 u4RowBufY;
                UINT32 u4RowBufHeight = 32;
                //UINT32 u4Width = rSrcImgInfo.u4ImgWidth;
                UINT32 u4Height = rSrcImgInfo.u4ImgHeight;
                //UINT32 u4BufferWidth = rSrcImgInfo.u4BufWidth;
                //UINT32 u4BufferHeight = rSrcImgInfo.u4BufHeight;
                //UINT32 u4DestWidth = rDestImgInfo.u4ImgWidth;
                UINT32 u4DestHeight = rDestImgInfo.u4ImgHeight;
                IMGRESZ_HAL_IMG_INFO_T rSrcRowBufImgInfo;
                IMGRESZ_HAL_IMG_INFO_T rPreRowBufImgInfo;
                //IMGRESZ_HAL_IMG_INFO_T rSrcTmpBufImgInfo;
                if(!_afgImgReszVfyHwEnable[u4HwId])
                    continue;                
                // Load source file info
                x_memset(&rSrcRowBufImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                x_memcpy(&rSrcRowBufImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                rSrcRowBufImgInfo.u4ImgYOff = 0;
                rSrcRowBufImgInfo.u4ImgHeight = u4RowBufHeight;  
                rSrcRowBufImgInfo.u4BufHeight = 48;
                u4BufSize = rSrcImgInfo.u4BufWidth * 48;
                
               
                u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                rSrcRowBufImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                VERIFY(rSrcRowBufImgInfo.u4BufSA1 != 0);
                x_memset((void *)rSrcRowBufImgInfo.u4BufSA1,0,u4BufSize);
                rSrcRowBufImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                VERIFY(rSrcRowBufImgInfo.u4BufSA2 != 0);
                x_memset((void *)rSrcRowBufImgInfo.u4BufSA2,0,u4BufSize);
                rSrcRowBufImgInfo.u4ImgRealHeight = rSrcImgInfo.u4ImgHeight;
                rDestImgInfo.u4ImgRealHeight = rDestImgInfo.u4ImgHeight;
                // Load source file info
                x_memset(&rPreRowBufImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                x_memcpy(&rPreRowBufImgInfo,&rSrcRowBufImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                u4BufSize = rSrcImgInfo.u4BufWidth * 48;
                u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                rPreRowBufImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                VERIFY(rPreRowBufImgInfo.u4BufSA1 != 0);
                x_memset((void *)rPreRowBufImgInfo.u4BufSA1,0,u4BufSize);
                rPreRowBufImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
                VERIFY(rPreRowBufImgInfo.u4BufSA2 != 0);
                x_memset((void *)rPreRowBufImgInfo.u4BufSA2,0,u4BufSize);
                
                
                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
#if IMGRESZ_PERFORMANCE_TEST
                x_memset(&_rImgreszStart, 0, sizeof(HAL_TIME_T));
                x_memset(&_rImgreszEnd, 0, sizeof(HAL_TIME_T));
                x_memset(&_rImgreszTime, 0, sizeof(HAL_TIME_T));
                HAL_GetTime(&_rImgreszStart);//pei temp debug!
#endif            
                i4ImgResz_HAL_Init(u4HwId);
                i4ImgResz_HAL_Set_Resize_Mode(u4HwId,eResizeMode);
                i4ImgResz_HAL_Set_Resample_Method(u4HwId,eHResampleMethod,
                                      eVResampleMethod);
                
                i4ImgResz_HAL_Set_PreRow_Image_Info(u4HwId,&rPreRowBufImgInfo,u4RowBufHeight,TRUE);
                i4ImgResz_HAL_Set_Destination_Image_Info(u4HwId,&rDestImgInfo);

                // Progressive resize
                 for(u4RowBufY=0; u4RowBufY<u4Height; u4RowBufY+=u4RowBufHeight)
                 {
                     
                     if((u4RowBufY+u4RowBufHeight)<rSrcRowBufImgInfo.u4ImgRealHeight)
                     {
                         rSrcRowBufImgInfo.u4ImgYOff = 0;
                         rSrcRowBufImgInfo.u4ImgHeight = u4RowBufHeight;  
                         rSrcImgInfo.u4ImgHeight = u4RowBufHeight;           
                         rSrcImgInfo.u4ImgYOff = u4RowBufY;
                     }
                     else
                     {
                         rSrcRowBufImgInfo.u4ImgYOff = 0;
                         rSrcRowBufImgInfo.u4ImgHeight = rSrcRowBufImgInfo.u4ImgRealHeight-u4RowBufY;  
                         rSrcImgInfo.u4ImgHeight = rSrcRowBufImgInfo.u4ImgRealHeight-u4RowBufY;            
                         rSrcImgInfo.u4ImgYOff = u4RowBufY;
                     }
                     vImgReszVfyImageCopy(&rSrcImgInfo,&rSrcRowBufImgInfo,FALSE); 
                     
                     i4ImgResz_HAL_Set_Source_Image_Info(u4HwId,&rSrcRowBufImgInfo);
                     //i4ImgReszVfyPrintf("[ImgResz][Verify] start imgresz.\n");
                     i4ImgResz_HAL_Resize(u4HwId);
                     
                     while(TRUE)
                     {
                          if(i4ImgResz_HAL_Get_Resize_Status(u4HwId)>=0)
                          {
                             break;
                          }
                      }
                      
                      //i4ImgReszVfyPrintf("[ImgResz][Verify] end imgresz.\n");
                     //x_thread_delay(200);
                 }
#if IMGRESZ_PERFORMANCE_TEST

                 HAL_GetTime(&_rImgreszEnd);
                 HAL_GetDeltaTime(&_rImgreszTime, &_rImgreszStart, &_rImgreszEnd);
                 i4ImgReszVfyPrintf  ("[Imgresz][Verify] Imgresz finish time=%d.%06d\n",_rImgreszTime.u4Seconds,_rImgreszTime.u4Micros);
    //i4JdecVfyFprintf(i4FileHandleSavePerformanceTime,"%d.%06d\n",_rJdecTotalTime.u4Seconds,_rJdecTotalTime.u4Micros);
#endif
                 i4ImgReszVfyPrintf("[ImgResz][Verify] imgresz done.\n");
                 i4ImgResz_HAL_Uninit(u4HwId);
                 rSrcImgInfo.u4ImgYOff = 0;
                 rSrcImgInfo.u4ImgHeight = u4Height;
                 rDestImgInfo.u4ImgYOff = 0;
                 rDestImgInfo.u4ImgHeight = u4DestHeight;               
                 // Copy destination buffer to destination fit buffer
                 vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);
                 i4ImgReszVfyPrintf("[ImgResz][Verify] end copy.\n");

                // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestFitImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                      FALSE,0,0);
                i4ImgReszVfyPrintf("[ImgResz][Verify] end save.\n");
              
                imgreszvfy_free_mem_aligned((void *)rSrcRowBufImgInfo.u4BufSA1);
                imgreszvfy_free_mem_aligned((void *)rPreRowBufImgInfo.u4BufSA1);
                imgreszvfy_free_mem_aligned((void *)rSrcRowBufImgInfo.u4BufSA2);
                imgreszvfy_free_mem_aligned((void *)rPreRowBufImgInfo.u4BufSA2); 
                i4ImgReszVfyPrintf("[ImgResz][Verify] end free");
                //VERIFY(FALSE);
            }

            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
            //imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
           // imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);
    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}

#endif

INT32 i4ImgReszVfyGenerateGracefullyRstCase(UINT32 u4TestCase,
                                    IMGRESZ_HAL_RESIZE_MODE_T *peResizeMode,
                                    IMGRESZ_HAL_RESAMPLE_METHOD_T *peHResampleMethod,
                                    IMGRESZ_HAL_RESAMPLE_METHOD_T *peVResampleMethod,
                                    IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfo,
                                    IMGRESZ_HAL_IMG_INFO_T *prDestImgInfo)
{
    UINT32 u4Case;
    UINT32 u4SrcBufWidth = 1920, u4SrcBufHeight = 1080;
    UINT32 u4DestBufWidth = 1920, u4DestBufHeight = 1080;


    if((prSrcImgInfo->u4ImgWidth > u4SrcBufWidth) || (prSrcImgInfo->u4ImgHeight > u4SrcBufHeight))
    {
        return -1;
    }

    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4SrcBufWidth = ((u4SrcBufWidth + 15) / 16) * 16;  // Align to 16
        u4SrcBufHeight = ((u4SrcBufHeight + 31)/ 32) * 32; // Align to 32
    }

    if(prDestImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4DestBufWidth = ((u4DestBufWidth + 15) / 16) * 16;  // Align to 16
        u4DestBufHeight = ((u4DestBufHeight + 31)/ 32) * 32; // Align to 32
    }

    prSrcImgInfo->u4BufWidth = u4SrcBufWidth * u4ImgReszVfyCalBufFormatBits(&(prSrcImgInfo->rBufferFormat)) / 8;
    prSrcImgInfo->u4BufWidth = ((prSrcImgInfo->u4BufWidth + 15) / 16 ) * 16;
    prSrcImgInfo->u4BufHeight = u4SrcBufHeight;
    prDestImgInfo->u4BufWidth = u4DestBufWidth * u4ImgReszVfyCalBufFormatBits(&(prDestImgInfo->rBufferFormat)) / 8;
    prDestImgInfo->u4BufHeight = u4DestBufHeight;

    // Resize mode variation and Resize method variation
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
    {
        u4Case = u4TestCase % 1;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= 1;
    } else
    {
        UINT32 u4CaseNum = 1;

        // Y/C buffer has only frame mode, no partial mode.
        if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            u4CaseNum = 4;

        u4Case = u4TestCase % u4CaseNum;
        switch(u4Case)
        {
            case 0:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 1:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 2:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 3:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
                break;
            case 4:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
            case 5:
                *peResizeMode=IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
                *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
                *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                break;
        }
        u4TestCase /= u4CaseNum;
    }

    // Progressive frame or interlaced frame
    if(prSrcImgInfo->rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
    {
        u4Case = u4TestCase % 2;
        switch(u4Case)
        {
            case 0:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = TRUE;
                break;
            case 1:
                prSrcImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                prDestImgInfo->rBufferFormat.fgProgressiveFrame = FALSE;
                break;
        }
        u4TestCase /= 2;
    }

    // Destination size variation
    u4Case = u4TestCase % 1; //sun temp
    switch(u4Case)
    {
        case 0:
            prDestImgInfo->u4ImgWidth = 1600;
            prDestImgInfo->u4ImgHeight = 900;
            break;
        case 1:
            prDestImgInfo->u4ImgWidth = 720;
            prDestImgInfo->u4ImgHeight = 480;
            break;
    }
    u4TestCase /= 1;

    if(u4TestCase > 0)
        return -1;

    return 0;
}
INT32 i4ImgReszVfyTestGracefullyReset(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    UINT32 u4BufSize;
    UINT32 u4HwId;

    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
       #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  

    if(u4FileListNum>0)
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not ARGB.\n");
            continue;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        u4TestCase = 0;

        while(i4ImgReszVfyGenerateGracefullyRstCase(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                            &rSrcImgInfo,&rDestImgInfo)>=0)
        {
            BOOL fgGenGolden = FALSE;

            // Load source file
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }

            // Copy source fit buffer to source buffer
            u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
            rSrcImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
            i4ImgReszVfyPrintf("[ImgResz][Verify] SRC buffer size : %d,Src addr :%x.\n",u4BufSize,rSrcImgInfo.u4BufSA1);
#else
            rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
#endif
            VERIFY(rSrcImgInfo.u4BufSA1 != 0);
            vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);

            // Destination buffer
            u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
            rDestImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
            i4ImgReszVfyPrintf("[ImgResz][Verify] SRC buffer size : %d,Src addr :%x.\n",u4BufSize,rDestImgInfo.u4BufSA1);
#else
            rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
#endif
            VERIFY(rDestImgInfo.u4BufSA1 != 0);

            // Generate destination fit buffer info
            x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
            rDestFitImgInfo.u4BufWidth = rDestFitImgInfo.u4ImgWidth * u4ImgReszVfyCalBufFormatBits(&(rDestFitImgInfo.rBufferFormat)) / 8;
            rDestFitImgInfo.u4BufHeight = rDestFitImgInfo.u4ImgHeight;
            rDestFitImgInfo.u4ImgXOff = 0;
            rDestFitImgInfo.u4ImgYOff = 0;
            u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
            rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
            VERIFY(rDestFitImgInfo.u4BufSA1 != 0);

#if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8560)
	     //the first pitcture  do gracefully reset
	     if((u4CurFileListNum % 2)== 0)
	     {
	       for(u4HwId=0; u4HwId<=IMG_RESZ_VFY_HW_NUM; u4HwId++)
              {
                if(!_afgImgReszVfyHwEnable[u4HwId])
                    continue;
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
#if 1
	         // Resize
                i4ImgResz_HAL_Init(u4HwId);
	         i4ImgResz_HAL_Set_Resize_Mode(0,eResizeMode);
		  i4ImgResz_HAL_Set_Resample_Method(0,eHResampleMethod, eVResampleMethod);
		  i4ImgResz_HAL_Set_Source_Image_Info(0,&rSrcImgInfo);
                i4ImgResz_HAL_Set_Destination_Image_Info(0,&rDestImgInfo);
		 //gracefully reset
                i4ImgReszVfyPrintf("[ImgResz][Verify] do gracefully reset.\n");
		  i4ImgResz_HAL_Resize(0);
		  i4ImgResz_Gracefully_Reset(0);
#else
               // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);
#endif
		  // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);
                u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;

                 // Save destination file
                 i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestFitImgInfo);

                // Output case info to resize info file
                 i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,FALSE,
                                            FALSE,0,0);
#if IMGRESZ_IO_MMU_TEST
                x_free_vmem((void *)rSrcImgInfo.u4BufSA1);
                x_free_vmem((void *)rDestImgInfo.u4BufSA1);
#else
                imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
#endif
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
	        }
		 break;
	      }
#endif

            for(u4HwId=0; u4HwId<=IMG_RESZ_VFY_HW_NUM; u4HwId++)
            {
                if(!_afgImgReszVfyHwEnable[u4HwId])
                    continue;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);

                // Copy destination buffer to destination fit buffer
                vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

                if(!fgGenGolden)
                {
                    // Copy destination fit buffer to destination golden buffer
                    x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                    x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);

                    // Save destination file
                    i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestGoldImgInfo);

                    // Output case info to resize info file
                    i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,FALSE,
                                            FALSE,0,0);
                    fgGenGolden = TRUE;
                } else
                {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr1 = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr1 = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
                    // Compare to golden
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr1) != *(UINT8 *)(u4DestGoldAddr1))
                            VERIFY(FALSE);

                        u4DestFitAddr1++;
                        u4DestGoldAddr1++;
                    }
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                }
            }
#if IMGRESZ_IO_MMU_TEST
            x_free_vmem((void *)rSrcImgInfo.u4BufSA1);
            x_free_vmem((void *)rDestImgInfo.u4BufSA1);
#else
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);
#endif
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
          if(rDestGoldImgInfo.u4BufSA1)
          	{
             imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
             rDestGoldImgInfo.u4BufSA1 = 0;
		  }

            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);

    }

    if(u4FileListNum>0)
        i4ImgReszVfyFclose(i4ReszInfoFileHandle);

    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);

    return 0;
}
void vImgReszVfyInit(void)
{
    i4ImgResz_HAL_Boot_Init();
    #if(IMG_RESZ_VFY_FILE_IO_TYPE == IMG_RESZ_VFY_FILE_IO_UDVT_USBRW)

      // UDVT_IF_SendResult(UDVT_TEST_PASS);
    #endif
}


void vImgReszVfyUninit(void)
{
    i4ImgResz_HAL_Boot_Uninit();
}

INT32 i4ImgReszVfyTestWTARGBTEST(void)
{
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    BYTE **ppbFileList;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    INT32 i4ReszInfoFileHandle = 0;
    UINT32 u4CurFileListNum;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rWTImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;    
    BOOL fgPreloadBuf = FALSE;
    UINT32 u4Alpha = 0;
    UINT32 u4BufSize;
    UINT32 u4HwId = 0;

	
    // Load file list
    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY(u4FileListSA != 0);
    x_memset((void *)u4FileListSA,0,u4FileListBufSize);   
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != 0);
   #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    if(u4FileListNum>0)
    {
        i4ReszInfoFileHandle = i4ImgReszVfyOpenCaseInfoFile(ppbFileList[0]);
        
    }

    for(u4CurFileListNum=0; u4CurFileListNum<u4FileListNum; u4CurFileListNum++)
    {           
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load File %s\n",ppbFileList[u4CurFileListNum]);

        // Load source file info
        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));            
        i4ImgReszVfyLoadBufInfo(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo);

        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat != IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Format is not ARGB.\n");
            continue;
        }
        rSrcFitImgInfo.u4BufWidth =  rSrcFitImgInfo.u4BufWidth * u4ImgReszVfyCalBufFormatBits(&(rSrcFitImgInfo.rBufferFormat)) / 8;
        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate WT buffer info
        x_memcpy(&rWTImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        rWTImgInfo.u4BufWidth /= 2; 
        rWTImgInfo.u4ImgYOff = 700;
        rWTImgInfo.u4ImgWidth = 640;
        rWTImgInfo.u4ImgHeight = 360;
        rDestImgInfo.u4ImgWidth = 640;
        rDestImgInfo.u4ImgHeight = 360;
        rWTImgInfo.rBufferFormat.fgWT = TRUE;


        u4TestCase = 0;

        //while(i4ImgReszVfyGenerateWT2Case(u4TestCase,&eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                        // &rSrcImgInfo,&rDestImgInfo,fgPreloadBuf,&u4Alpha,&rWTImgInfo)>=0) 
        
        eResizeMode=IMGRESZ_HAL_RESIZE_MODE_FRAME;            
                eHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
                eVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
        {
                  
       
            // Load source file 
            if(u4TestCase == 0)
            {
                u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
                rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
                i4ImgReszVfyLoadBuf(ppbFileList[u4CurFileListNum],&rSrcFitImgInfo,u4BufSize);
            }


            u4TestSubCase = 0;

           {
                BOOL fgSourceOffsetChange = FALSE;

                {
                    // Allocate source buffer
                    u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
                    rSrcImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
#else
                    rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_src_alloc_mem_aligned(u4BufSize,64);
#endif
                    i4ImgReszVfyPrintf("[ImgResz][Verify] SRC buffer size : %d,Src addr :%x.\n",u4BufSize,rSrcImgInfo.u4BufSA1);  
		      //vMMUDebug(rSrcImgInfo.u4BufSA1);
                    VERIFY(rSrcImgInfo.u4BufSA1 != 0);

                    // Allocate WT buffer
                    u4BufSize = rWTImgInfo.u4BufWidth * rWTImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
                    rWTImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
                    vMMUDebug(rWTImgInfo.u4BufSA1);
#else
                    rWTImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,64);
#endif
                    memset((void *)rWTImgInfo.u4BufSA1, 0x0, u4BufSize);
                    i4ImgReszVfyPrintf("[ImgResz][Verify] WT buffer size : %d,WT addr :%x.\n",u4BufSize,rWTImgInfo.u4BufSA1);  
		            // vMMUDebug(rWTImgInfo.u4BufSA1);		
                    VERIFY(rWTImgInfo.u4BufSA1 != 0);					 
					 
                    // Allocate destination buffer
                    u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
#if IMGRESZ_IO_MMU_TEST
                    rDestImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
                    vMMUDebug(rDestImgInfo.u4BufSA1);
#else
                    rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_dst_alloc_mem_aligned(u4BufSize,64);
#endif
		            memset((void *)rDestImgInfo.u4BufSA1, 0x0, u4BufSize);
		            i4ImgReszVfyPrintf("[ImgResz][Verify] DST buffer size : %d,DST addr :%x.\n",u4BufSize,rDestImgInfo.u4BufSA1);  
                    //vMMUDebug(rWTImgInfo.u4BufSA1);
		            VERIFY(rDestImgInfo.u4BufSA1 != 0);			 

                    // Generate destination fit buffer info
                    // Allocate destination fit buffer
                    x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
          
                    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                    rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA1 != 0);    

                }

                // Copy source fit buffer to source buffer
                if((u4TestSubCase == 0) || fgSourceOffsetChange)
                    vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
				
                   /*Turn on Test agent*/
                #if IMGRESZ_DRAMBUSY_TEST	
                           *(volatile UINT32 *)(IO_BASE + 0x007104) = 0x00000000;
                           *(volatile UINT32 *)(IO_BASE + 0x007218) = 0x8e0f110d;
                #endif

                i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);                                
                i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);                                
                //i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);                                
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);            
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);      
                i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);            
                i4ImgReszVfyPrintf("[ImgResz][Verify] wt offset (%d,%d).\n",rWTImgInfo.u4ImgXOff,rWTImgInfo.u4ImgYOff);            
                i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);            
    
           
		   
                // Turn on WT
                *((volatile UINT32*)(IO_BASE + WT_REG_OFFSET)) = 0xe82a6f11; 
    
                // Resize source buffer to WT buffer
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rWTImgInfo,0);

		        // save WT buffer 
                i4ImgReszVfySaveWTBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rWTImgInfo);
				
                // Resize WT buffer to destination buffer
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rWTImgInfo,&rDestImgInfo,0);

                // Turn off WT
                *((volatile UINT32*)(IO_BASE + WT_REG_OFFSET)) = 0xc00d6f10;
                
	            i4ImgReszVfyPrintf("[ImgResz][Verify] Resizer twice done.\n"); 	
                // Copy destination buffer to destination fit buffer            
                //vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);
                u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                x_memcpy((void *)rDestFitImgInfo.u4BufSA1,(void *)rDestImgInfo.u4BufSA1,u4BufSize);


                // Save destination file
                i4ImgReszVfySaveDestBuf(ppbFileList[u4CurFileListNum],u4TestCase,&rDestFitImgInfo);
    
                    // Output case info to resize info file
                i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            fgPreloadBuf,u4Alpha,0);

    
               

                u4TestSubCase++;
            }
#if IMGRESZ_IO_MMU_TEST
            x_free_vmem((void *)rSrcImgInfo.u4BufSA1);        
            x_free_vmem((void *)rWTImgInfo.u4BufSA1);        
            x_free_vmem((void *)rDestImgInfo.u4BufSA1); 
#else
            imgreszvfy_src_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);        
            imgreszvfy_free_mem_aligned((void *)rWTImgInfo.u4BufSA1);        
            imgreszvfy_dst_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);        
#endif
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
           
            if(0)
            {
                imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);        
                imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);        
                imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
            
            }
            
            u4TestCase++;
        }

        if(rSrcFitImgInfo.u4BufSA1 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA1);        
        if(rSrcFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.u4BufSA2);                
    }


    imgreszvfy_free_mem_aligned((void *)u4FileListSA);        
    imgreszvfy_free_mem_aligned((void *)ppbFileList);        

    return 0;
}

void vImgReszVerify(UINT32 u4TestCase)
{
    switch(u4TestCase)
    {
        case 0:
            // Descript test case
            i4ImgReszVfyPrintf("[ImgResz][Verify] Test 1: Mini test ARGB format.\n");
            i4ImgReszVfyPrintf("[ImgResz][Verify] Test 2: Mini test Index format.\n");
            i4ImgReszVfyPrintf("[ImgResz][Verify] Test 3: Mini test Jpeg format.\n");
            i4ImgReszVfyPrintf("[ImgResz][Verify] Test 4: Mini test Video format.\n");
            i4ImgReszVfyPrintf("[ImgResz][Verify] Test 101: ARGB format basic test.\n");
            i4ImgReszVfyPrintf("[ImgResz][Verify] Test 201: Index format basic test.\n");
            i4ImgReszVfyPrintf("[ImgResz][Verify] Test 301: Jpeg format to Video format basic test.\n");
            i4ImgReszVfyPrintf("[ImgResz][Verify] Test 302: Jpeg format to AYUV format basic test.\n");
            i4ImgReszVfyPrintf("[ImgResz][Verify] Test 401: Video format basic test.\n");
            break;
        case 1:
            // ARGB mini test
            {
                INT32 i4Ret;
                UINT32 u4HwId;

                for(u4HwId=0; u4HwId<IMG_RESZ_VFY_HW_NUM; u4HwId++)
                {
                    if(_afgImgReszVfyHwEnable[u4HwId])
                    {
                        i4ImgReszVfyPrintf("[ImgResz][Verify] Mini test ARGB format.\n");
                        i4Ret = i4ImgReszVfyMiniTestARGB(u4HwId);
                        if(i4Ret < 0)
                            i4ImgReszVfyPrintf("[ImgResz][Verify] Mini test ARGB format hw id %d fail.\n",u4HwId);
                    }
                }

                i4ImgReszVfyPrintf("[ImgResz][Verify] Mini test ARGB format complete.\n");
            }
            break;
        case 2:
            // Index mode mini test
            {
                INT32 i4Ret;
                UINT32 u4HwId;

                for(u4HwId=0; u4HwId<IMG_RESZ_VFY_HW_NUM; u4HwId++)
                {
                    if(_afgImgReszVfyHwEnable[u4HwId])
                    {
                        i4ImgReszVfyPrintf("[ImgResz][Verify] Mini test Index format.\n");
                        i4Ret = i4ImgReszVfyMiniTestIndex(u4HwId);
                        if(i4Ret < 0)
                            i4ImgReszVfyPrintf("[ImgResz][Verify] Mini test Index format hw id %d fail.\n",u4HwId);
                    }
                }

                i4ImgReszVfyPrintf("[ImgResz][Verify] Mini test Index format complete.\n");
            }
            break;
        case 3:
            // Jpeg mode mini test
            {
                INT32 i4Ret;
                UINT32 u4HwId;

                for(u4HwId=0; u4HwId<IMG_RESZ_VFY_HW_NUM; u4HwId++)
                {
                    if(_afgImgReszVfyHwEnable[u4HwId])
                    {
                        i4ImgReszVfyPrintf("[ImgResz][Verify] Mini test Jpeg format.\n");
                        i4Ret = i4ImgReszVfyMiniTestJpeg(u4HwId);
                        if(i4Ret < 0)
                            i4ImgReszVfyPrintf("[ImgResz][Verify] Mini test Jpeg format hw id %d fail.\n",u4HwId);
                    }
                }

                i4ImgReszVfyPrintf("[ImgResz][Verify] Mini test Jpeg format complete.\n");
            }
            break;
        case 4:
            // Video mode mini test
            {
                INT32 i4Ret;
                UINT32 u4HwId;

                for(u4HwId=0; u4HwId<IMG_RESZ_VFY_HW_NUM; u4HwId++)
                {
                    if(_afgImgReszVfyHwEnable[u4HwId])
                    {
                        i4ImgReszVfyPrintf("[ImgResz][Verify] Mini test Video format.\n");
                        i4Ret = i4ImgReszVfyMiniTestVideo(u4HwId);
                        if(i4Ret < 0)
                            i4ImgReszVfyPrintf("[ImgResz][Verify] Mini test Video format hw id %d fail.\n",u4HwId);
                    }
                }

                i4ImgReszVfyPrintf("[ImgResz][Verify] Mini test Video format complete.\n");
            }
            break;
        case 5:
#ifdef IMGRESZ_HAL_MT8530
            // ARGB WT mini test
            {
                //INT32 i4Ret;
                UINT32 u4HwId;

                for(u4HwId=0; u4HwId<IMG_RESZ_VFY_HW_NUM; u4HwId++)
                {
                    if(_afgImgReszVfyHwEnable[u4HwId])
                    {
                        i4ImgReszVfyPrintf("[ImgResz][Verify] Mini test ARGB WT format.\n");
                        vImgReszMiniWTTest(u4HwId);
                        //if(i4Ret < 0)
                        //    i4ImgReszVfyPrintf("[ImgResz][Verify] Mini test ARGB WT format hw id %d fail.\n",u4HwId);
                    }
                }

                i4ImgReszVfyPrintf("[ImgResz][Verify] Mini test ARGB WT format complete.\n");
            }
#endif
            break;
        case 101:
            // ARGB test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Basic ARGB test.\n");
                i4Ret = i4ImgReszVfyTestBasicARGB();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB test complete.\n");

            }
            break;
        case 102:
            // ARGB scaling ratio test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB scaling ratio test.\n");
                i4Ret = i4ImgReszVfyTestScalingRatioARGB();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB scaling ratio test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB scaling ratio test complete.\n");

            }
            break;
        case 103:
            // ARGB Arbitrary Location test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB Arbitrary Location test.\n");
                i4Ret = i4ImgReszVfyTestArbitraryLocationARGB();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB Arbitrary Location test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB Arbitrary Location test complete.\n");

            }
            break;
        case 104:
            // ARGB Preload Buffer Alpha Blending test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB Preload Buffer Alpha Blending test.\n");
                i4Ret = i4ImgReszVfyTestPreloadBufAlphaBlendingARGB();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB Preload Buffer Alpha Blending test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB Preload Buffer Alpha Blending test complete.\n");

            }
            break;
        case 105:
            // ARGB scaling ratio odd test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB scaling ratio odd test.\n");
                i4Ret = i4ImgReszVfyTestScalingRatioOddARGB();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB scaling ratio odd test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB scaling ratio test odd complete.\n");

            }
            break;
        case 1051:
            {
                i4ImgReszVfyTestAllocSrcImgInfoSA();
            }
            break;
        case 1052:
            // ARGB scaling ratio odd test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB scaling ratio odd test.\n");
                i4Ret = i4ImgReszVfyTestScalingRatioOddARGB2();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB scaling ratio odd test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB scaling ratio test odd complete.\n");

            }
            break;    
        case 106:
            // ARGB WT test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB WT test.\n");
                i4Ret = i4ImgReszVfyTestWTARGB();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB WT test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB WT test complete.\n");

            }
            break;
        case 107:
            // ARGB WT 2 test.
            {
                INT32 i4Ret;
                BOOL fgTmp;
                i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB WT 2 test.\n");
				//hardware 0 support WT, HW1 don't support wt
                fgTmp = _afgImgReszVfyHwEnable[1];
				_afgImgReszVfyHwEnable[1] = FALSE;
                i4Ret = i4ImgReszVfyTestWTARGB2();
				_afgImgReszVfyHwEnable[1] = fgTmp;
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB WT 2 test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB WT 2 test complete.\n");

            }
            break;
        case 111:
            // ARGB Output ARGB Variation test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB Output ARGB Variation test.\n");
                i4Ret = i4ImgReszVfyTestARGBOutARGBVariation();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB Output ARGB Variation test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB Output ARGB Variation test complete.\n");

            }
            break;
        case 112:
            // ARGB Output AYUV test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB Output AYUV test.\n");
                i4Ret = i4ImgReszVfyTestARGBToAYUV();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB Output AYUV test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB Output AYUV test complete.\n");

            }
            break;
        case 113:
            // ARGB Alpha Scaling Type test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB Alpha Scaling Type test.\n");
                i4Ret = i4ImgReszVfyTestAlphaScalingARGB();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB Alpha Scaling Type test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] ARGB Alpha Scaling Type test complete.\n");

            }
            break;
	  case 114:
	    // ARGB gracefully reset
	    {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Gracefully reset test.\n");
                i4Ret = i4ImgReszVfyTestGracefullyReset();
                if(i4Ret < 0)
                 i4ImgReszVfyPrintf("[ImgResz][Verify] Gracefully reset test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Gracefully reset test complete.\n");
             }
            break;
        case 201:
            // Index test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Basic Index test.\n");
                i4Ret = i4ImgReszVfyTestBasicIndex();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Index test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Index test complete.\n");

            }
            break;
        case 202:
            // Index scaling ratio test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Index scaling ratio test.\n");
                i4Ret = i4ImgReszVfyTestScalingRatioIndex();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Index scaling ratio test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Index scaling ratio test complete.\n");

            }
            break;
        case 203:
            // Index Arbitrary Location test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Index Arbitrary Location test.\n");
                i4Ret = i4ImgReszVfyTestArbitraryLocationIndex();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Index Arbitrary Location test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Index Arbitrary Location test complete.\n");

            }
            break;
        case 204:
            // Index Preload Buffer Alpha Blending test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Index Preload Buffer Alpha Blending test.\n");
                i4Ret = i4ImgReszVfyTestPreloadBufAlphaBlendingIndex();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Index Preload Buffer Alpha Blending test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Index Preload Buffer Alpha Blending test complete.\n");

            }
            break;
        case 205:
            // Index scaling ratio odd test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Index scaling ratio odd test.\n");
                i4Ret = i4ImgReszVfyTestScalingRatioOddIndex();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Index scaling ratio odd test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Index scaling ratio odd test complete.\n");

            }
            break;
        case 211:
            // Index Output ARGB Variation test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Index Output ARGB Variation test.\n");
                i4Ret = i4ImgReszVfyTestIndexOutARGBVariation();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Index Output ARGB Variation test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Index Output ARGB Variation test complete.\n");

            }
            break;
        case 301:
            // Jpeg to Video test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Basic Jpeg to Video test.\n");
                i4Ret = i4ImgReszVfyTestBasicJpegToVideo();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to Video test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to Video test complete.\n");

            }
            break;
        case 302:
            // Jpeg to Video Scaling Ratio test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Basic Jpeg to Video Scaling Ratio test.\n");
                i4Ret = i4ImgReszVfyTestScalingRatioJpegToVideo();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to Video Scaling Ratio test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to Video Scaling Ratio test complete.\n");

            }
            break;
        case 303:
            // Jpeg to Video Arbitrary Location test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Basic Jpeg to Video Arbitrary Location test.\n");
                i4Ret = i4ImgReszVfyTestArbitraryLocationJpegToVideo();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to Video Arbitrary Location test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to Video Arbitrary Location test complete.\n");

            }
            break;
        case 304:
            // Jpeg to Video Preload Buffer Alpha Blending test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Basic Jpeg to Video Preload Buffer Alpha Blending test.\n");
                i4Ret = i4ImgReszVfyTestPreloadBufAlphaBlendingJpegToVideo();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to Video Preload Buffer Alpha Blending test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to Video Preload Buffer Alpha Blending test complete.\n");

            }
            break;
        case 305:
            // Jpeg to Video Scaling Ratio Odd test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Basic Jpeg to Video Scaling Ratio Odd test.\n");
                i4Ret = i4ImgReszVfyTestScalingRatioOddJpegToVideo();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to Video Scaling Ratio Odd test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to Video Scaling Ratio Odd test complete.\n");

            }
            break;
        case 311:
            // Jpeg to Video Block Mode and Address Swap test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Basic Jpeg to Video Block Mode and Address Swap test.\n");
                i4Ret = i4ImgReszVfyTestJpegToVideoSwap2();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to Video Block Mode and Address Swap fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to Video Block Mode and Address Swap test complete.\n");

            }
            break;
        case 312:
            // Jpeg to Video Preload test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Basic Jpeg to Video Preload test.\n");
                i4Ret = i4ImgReszVfyTestJpegToVideoPreload();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to Video Preload fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to Video Preload test complete.\n");

            }
            break;
        case 321:
            // Jpeg to AYUV test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Basic Jpeg to AYUV test.\n");
                i4Ret = i4ImgReszVfyTestBasicJpegToAYUV();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to AYUV test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to AYUV test complete.\n");

            }
            break;
        case 322:
            // Jpeg to AYUV Scaling Ratio test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Basic Jpeg to Scaling Ratio AYUV test.\n");
                i4Ret = i4ImgReszVfyTestScalingRatioJpegToAYUV();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to AYUV Scaling Ratio Atest fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to AYUV Scaling Ratio Atest complete.\n");

            }
            break;
        case 323:
            // Jpeg to AYUV Arbitrary Location test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Basic Jpeg to Arbitrary Location AYUV test.\n");
                i4Ret = i4ImgReszVfyTestArbitraryLocationJpegToAYUV();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to AYUV Arbitrary Location Atest fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to AYUV Arbitrary Location Atest complete.\n");

            }
            break;
        case 324:
            // Jpeg to AYUV Preload Buffer Alpha Blending test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Basic Jpeg to Preload Buffer Alpha Blending AYUV test.\n");
                i4Ret = i4ImgReszVfyTestPreloadBufAlphaBlendingJpegToAYUV();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to AYUV Preload Buffer Alpha Blending Atest fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to AYUV Preload Buffer Alpha Blending Atest complete.\n");

            }
            break;
        case 325:
            // Jpeg to AYUV Scaling Ratio Odd test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Basic Jpeg to Scaling Ratio Odd AYUV test.\n");
                i4Ret = i4ImgReszVfyTestScalingRatioOddJpegToAYUV();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to AYUV Scaling Ratio Odd test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to AYUV Scaling Ratio Odd test complete.\n");

            }
            break;
        case 332:
            // Jpeg to AYUV Preload test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to AYUV Preload test.\n");
                i4Ret = i4ImgReszVfyTestJpegToAYUVPreload();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to AYUV Preload fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg to AYUV Preload test complete.\n");

            }
            break;
        case 401:
            // Video test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Basic Video test.\n");
                i4Ret = i4ImgReszVfyTestBasicVideo();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Video test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Video test complete.\n");

            }
            break;
        case 402:
            // Video scaling ratio test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Video Scaling Ratio test.\n");
                i4Ret = i4ImgReszVfyTestScalingRatioVideo();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Video Scaling Ratio test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Video Scaling Ratio test complete.\n");

            }
            break;
        case 403:
            // Video arbitrary location test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Video Arbitrary Location test.\n");
                i4Ret = i4ImgReszVfyTestArbitraryLocationVideo();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Video Arbitrary Location test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Video Arbitrary Location test complete.\n");

            }
            break;
        case 404:
            // Video Preload Buffer Alpha Blending test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Video Preload Buffer Alpha Blending test.\n");
                i4Ret = i4ImgReszVfyTestPreloadBufAlphaBlendingVideo();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Video Preload Buffer Alpha Blending test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Video Preload Buffer Alpha Blending test complete.\n");

            }
            break;
        case 407:
            // Video to WT AYUV 2 test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Video to WT AYUV 2 test.\n");
                i4Ret = i4ImgReszVfyTestVideoToWTAYUV2();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Video to WT AYUV 2 test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Video to WT AYUV 2 test complete.\n");

            }
            break;
        case 411:
            // Video Block Mode and Address Swap test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Video Block Mode and Address Swap test.\n");
                i4Ret = i4ImgReszVfyTestVideoBlockModeAndAddressSwap();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Video Block Mode and Address Swap test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Video Block Mode and Address Swap test complete.\n");

            }
            break;
        case 412:
            // Video To AYUV test.
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Video To AYUV test.\n");
                i4Ret = i4ImgReszVfyTestVideoToAYUV();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Video To AYUV test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Video To AYUV test complete.\n");

            }
            break;
        case 413:
            // Video Luma Key test.
            {
                INT32 i4Ret;
                BOOL fgTmp;
                i4ImgReszVfyPrintf("[ImgResz][Verify] Video Luma Key test.\n");

                fgTmp = _afgImgReszVfyHwEnable[1];
				_afgImgReszVfyHwEnable[1] = FALSE;
                i4Ret = i4ImgReszVfyTestVideoSpecialProcessingForLumaKey();
			    _afgImgReszVfyHwEnable[1] = fgTmp;

                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Video Luma Key test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Video Luma Key test complete.\n");

            }
            break;
        case 444:
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Video Address Swap test.\n");
                i4Ret = i4ImgReszVfyTestVideoToVideoSwap2();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] Video Address Swap fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] Video Address Swap test complete.\n");
            }
            break;
#if IMGRESZ_VIDEO_MODE_SUPPORT_WEBP
        case 445:
        {
            INT32 i4Ret;

            i4ImgReszVfyPrintf("[ImgResz][Verify] Video Mode Webp Small buffer test.\n");
            i4Ret = i4ImgReszVfyTestVideoPartialMode();
            if(i4Ret < 0)
                i4ImgReszVfyPrintf("[ImgResz][Verify] Video Mode Webp Small buffer test fail.\n");

            i4ImgReszVfyPrintf("[ImgResz][Verify] Video Mode Webp Small buffer test complete.\n");
        }    
        break;  
#endif        
        case 777:
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Video Scale 4to1 Test.\n");
                i4Ret = i4ImgReszVfyTestVideo4to1Scale();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify]  Video Scale 4to1 Test.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify]  Video Scale 4to1 Test complete.\n");
            }
		    break;
        case 888:
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] WT Write Offset test.\n");
                i4Ret = i4ImgReszTestWTWriteOffset();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] WT Write Offset test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] WT Write Offset test complete.\n");
            }
            break;
        case 999:
            {
                INT32 i4Ret;

                i4ImgReszVfyPrintf("[ImgResz][Verify] WT AYUV test.\n");
                i4Ret = i4ImgReszVfyTestWTAYUV();
                if(i4Ret < 0)
                    i4ImgReszVfyPrintf("[ImgResz][Verify] WT AYUV test fail.\n");

                i4ImgReszVfyPrintf("[ImgResz][Verify] WT AYUV test complete.\n");
            }
            break;
	  case 666:
	    {
                INT32 i4Ret;
                UINT32 u4HwId;

                for(u4HwId=0; u4HwId<IMG_RESZ_VFY_HW_NUM; u4HwId++)
                {
                    if(_afgImgReszVfyHwEnable[u4HwId])
                    {
                        i4ImgReszVfyPrintf("[ImgResz][Verify] Mini test RM format.\n");
                        i4Ret = i4ImgReszVfyMiniTestRM(u4HwId);
                        if(i4Ret < 0)
                            i4ImgReszVfyPrintf("[ImgResz][Verify] Mini test RM format hw id %d fail.\n",u4HwId);
                    }
                }

                i4ImgReszVfyPrintf("[ImgResz][Verify] Mini test RM format complete.\n");
             }
            break;
    }

	//vImgreszVfyTestWriteTestDoneSignal();//test done, write done signal, tell PC.
#if(IMG_RESZ_VFY_FILE_IO_TYPE == IMG_RESZ_VFY_FILE_IO_UDVT_USBRW)

       //UDVT_IF_SendResult(UDVT_TEST_PASS);
#endif
}


INT32 i4ImgReszVfyParseCaseInfo(char *pbCaseInfoFile,
                                UINT32 u4CurrCaseInfoSa,UINT32 *pu4NextCaseInfoSa,
                                BOOL fgSkip,
                                IMGRESZ_HAL_RESIZE_MODE_T *peResizeMode,
                                IMGRESZ_HAL_RESAMPLE_METHOD_T *peHResampleMethod,
                                IMGRESZ_HAL_RESAMPLE_METHOD_T *peVResampleMethod,
                                IMGRESZ_HAL_IMG_INFO_T *prSrcImgInfo,
                                IMGRESZ_HAL_IMG_INFO_T *prDestImgInfo,
                                char *pbSrcFileName,char *pbDestFileName,
                                BOOL fgPreloadBuf,UINT32 *pu4Alpha,UINT32 *pu4AlphaScalingType)
{
    char bLine[256];
    BOOL fgInterlaced = FALSE;

    u4CurrCaseInfoSa = u4ImgReszVfyGotoStrEnd(u4CurrCaseInfoSa,"[CASE DESCRIPTION]");
    if(u4CurrCaseInfoSa == 0)
        return -1;

    if(!fgSkip)
    {

        u4CurrCaseInfoSa = u4ImgReszVfyGotoStrEnd(u4CurrCaseInfoSa,"ResizeMode=");
        if(u4CurrCaseInfoSa == 0)
            return -1;

        i4ImgReszVfyGetLine(u4CurrCaseInfoSa,bLine);
        if(strcmp(bLine,"FRAME") == 0)
        {
            *peResizeMode = IMGRESZ_HAL_RESIZE_MODE_FRAME;
        } else if(strcmp(bLine,"PARTIAL") == 0)
        {
            *peResizeMode = IMGRESZ_HAL_RESIZE_MODE_PARTIAL;
        }

        u4CurrCaseInfoSa = u4ImgReszVfyGotoStrEnd(u4CurrCaseInfoSa,"HResampleMethod=");
        if(u4CurrCaseInfoSa == 0)
            return -1;

        i4ImgReszVfyGetLine(u4CurrCaseInfoSa,bLine);
        if(strcmp(bLine,"BILINEAR") == 0)
        {
            *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
        } else if(strcmp(bLine,"4_TAP") == 0)
        {
            *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
        } else if(strcmp(bLine,"8_TAP") == 0)
        {
            *peHResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
        }

        u4CurrCaseInfoSa = u4ImgReszVfyGotoStrEnd(u4CurrCaseInfoSa,"VResampleMethod=");
        if(u4CurrCaseInfoSa == 0)
            return -1;

        i4ImgReszVfyGetLine(u4CurrCaseInfoSa,bLine);
        if(strcmp(bLine,"BILINEAR") == 0)
        {
            *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR;
        } else if(strcmp(bLine,"4_TAP") == 0)
        {
            *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_4_TAP;
        } else if(strcmp(bLine,"8_TAP") == 0)
        {
            *peVResampleMethod = IMGRESZ_HAL_RESAMPLE_METHOD_8_TAP;
        }

        u4CurrCaseInfoSa = u4ImgReszVfyGotoStrEnd(u4CurrCaseInfoSa,"I_P_Mode=");
        if(u4CurrCaseInfoSa == 0)
            return -1;

        i4ImgReszVfyGetLine(u4CurrCaseInfoSa,bLine);
        if(strcmp(bLine,"INTERLACED") == 0)
        {
            fgInterlaced = TRUE;
        } else if(strcmp(bLine,"PROGRESSIVE") == 0)
        {
            fgInterlaced = FALSE;
        }

        if(fgPreloadBuf)
        {
            UINT32 u4AlphMaxCurr;
            UINT32 u4AlphaMax,u4Alpha;

            u4CurrCaseInfoSa = u4ImgReszVfyGotoStrEnd(u4CurrCaseInfoSa,"ALPHA_MAX=");
            if(u4CurrCaseInfoSa == 0)
                return -1;

            i4ImgReszVfyGetLine(u4CurrCaseInfoSa,bLine);
            u4AlphaMax = (UINT32)i4ImgReszStrToInt((UCHAR *)bLine);

            u4CurrCaseInfoSa = u4ImgReszVfyGotoStrEnd(u4CurrCaseInfoSa,"ALPHA_VALUE=");
            if(u4CurrCaseInfoSa == 0)
                return -1;

            i4ImgReszVfyGetLine(u4CurrCaseInfoSa,bLine);
            u4Alpha = (UINT32)i4ImgReszStrToInt((UCHAR *)bLine);

            // Mapping Alpha
#ifdef IMGRESZ_HAL_MT8530
            u4AlphMaxCurr = 128;
#else
            u4AlphMaxCurr = 8;
#endif
            if(u4AlphMaxCurr == u4AlphaMax)
            {
                *pu4Alpha = u4Alpha;
            } else
            {
                *pu4Alpha = u4Alpha * u4AlphMaxCurr / u4AlphaMax;
                if(((*pu4Alpha) * u4AlphaMax) != (u4AlphMaxCurr * u4Alpha))
                    VERIFY(FALSE);
            }
        }

        {
            UINT32 u4AlphaScalingTypeSa,u4NextCaseInfoSa;
            u4AlphaScalingTypeSa = u4ImgReszVfyGotoStrEnd(u4CurrCaseInfoSa,"ALPHA_SCALING_TYPE=");
            u4NextCaseInfoSa = u4ImgReszVfyGotoStrEnd(u4CurrCaseInfoSa,"[CASE DESCRIPTION]");

            if((u4AlphaScalingTypeSa < u4NextCaseInfoSa) ||
               ((u4NextCaseInfoSa == 0) && (u4AlphaScalingTypeSa != 0)))
            {
                i4ImgReszVfyGetLine(u4AlphaScalingTypeSa,bLine);
                if(strcmp(bLine,"GENERAL") == 0)
                {
                    *pu4AlphaScalingType = 0;
                } else if(strcmp(bLine,"REFER_TO_LEFT") == 0)
                {
                    *pu4AlphaScalingType = 1;
                } else if(strcmp(bLine,"REFER_TO_NEAREST") == 0)
                {
                    *pu4AlphaScalingType = 2;
                }
            } else
            {
                *pu4AlphaScalingType = 0;
            }
        }

        u4CurrCaseInfoSa = u4ImgReszVfyGotoStrEnd(u4CurrCaseInfoSa,"CRC=");
        i4ImgReszVfyGetLine(u4CurrCaseInfoSa,bLine);
        u4ImgReszCheckSumGolden = (UINT32)i4ImgReszStrToInt(bLine);
        
        u4CurrCaseInfoSa = u4ImgReszVfyGotoStrEnd(u4CurrCaseInfoSa,"SOURCE_FILE=");
        if(u4CurrCaseInfoSa == 0)
            return -1;

        i4ImgReszVfyGetLine(u4CurrCaseInfoSa,bLine);
        i4ImgReszVfyGetPath(pbSrcFileName,pbCaseInfoFile);
        strcat(pbSrcFileName,bLine);
        i4ImgReszVfyLoadBufInfo((BYTE *)pbSrcFileName,prSrcImgInfo);

        u4CurrCaseInfoSa = u4ImgReszVfyGotoStrEnd(u4CurrCaseInfoSa,"DESTINATION_FILE=");
        if(u4CurrCaseInfoSa == 0)
            return -1;

        i4ImgReszVfyGetLine(u4CurrCaseInfoSa,bLine);
        i4ImgReszVfyGetPath(pbDestFileName,pbCaseInfoFile);
        strcat(pbDestFileName,bLine);
        i4ImgReszVfyLoadBufInfo((BYTE *)pbDestFileName,prDestImgInfo);

        prSrcImgInfo->rBufferFormat.fgProgressiveFrame = !fgInterlaced;
        prDestImgInfo->rBufferFormat.fgProgressiveFrame = !fgInterlaced;
    }

    *pu4NextCaseInfoSa = u4ImgReszVfyGotoStrEnd(u4CurrCaseInfoSa,"[CASE DESCRIPTION]");
    if(*pu4NextCaseInfoSa == 0)
        *pu4NextCaseInfoSa = u4CurrCaseInfoSa;
    else
        *pu4NextCaseInfoSa -= strlen("[CASE DESCRIPTION]");

    return 0;
}


void vImgReszVfyAutoTest(UINT32 u4TestType,UINT32 u4StartCase,char *pbCaseInfoFile)
{
    UINT32 u4CaseInfoSize = 512*1024;
    UINT32 u4CaseInfoSa,u4CurrCaseInfoSa,u4NextCaseInfoSa;
    INT32 i4Ret;
    UINT32 u4TestCase,u4TestSubCase;
    IMGRESZ_HAL_RESIZE_MODE_T eResizeMode;
    IMGRESZ_HAL_RESAMPLE_METHOD_T eHResampleMethod,eVResampleMethod;
    IMGRESZ_HAL_IMG_INFO_T rSrcFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rPreloadBufInfo;
    IMGRESZ_HAL_JPEG_INFO_T rJpegInfo;
    UINT32 u4BufSize;
    UINT32 u4LastBufSA1 = 0,u4LastBufSA2 = 0,u4LastBufSA3 = 0;
    UINT32 u4LastSrcFileNameSa;
    UINT32 u4SrcFileNameSa;
    UINT32 u4DestFileNameSa;
    UINT32 u4HwId = 0;
    UINT32 u4BufSaAlign,u4BufSizeAlign;
    UINT32 u4WorkBufSa = 0;
    BOOL fgPreloadBuf = FALSE;
    UINT32 u4Alpha;
    UINT32 u4AlphaScalingType = 2;
    BOOL fgJpegPreloadTest = FALSE;
#if IMGRESZ_DRAMBUSY_TEST
    UINT32 u4TestAgentSA = 0;
#endif

    //UINT32 i4LogFileHandler;

    //i4LogFileHandler = i4ImgReszVfyFopen("B:\\WorkSpace\\MT8560_vfy\\BDP\\BDP_Generic\\AutoLog.txt","w");

    if(u4TestType == 4)
    {
        u4TestType = 1;
        fgJpegPreloadTest = TRUE;
    }

    if(u4TestType == 3)
        u4WorkBufSa = (UINT32)imgreszvfy_alloc_mem_aligned(1920*1088,1024);

    i4ImgReszVfyPrintf("[ImgResz][Verify] Auto test start\n");

    x_memset(&rPreloadBufInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    if(i4ImgReszVfyTestLoadPreloadBuf((BYTE *)pbCaseInfoFile,&rPreloadBufInfo) >= 0)
    {
        _fgAlphaB = TRUE;
        fgPreloadBuf = TRUE;
    }

    // Load case info file
    i4ImgReszVfyPrintf("[ImgResz][Verify]Case Info File is %s\n" ,  pbCaseInfoFile);
    u4CaseInfoSa = (UINT32)imgreszvfy_alloc_mem_aligned(u4CaseInfoSize,1);
    x_memset((void *)u4CaseInfoSa,0,u4CaseInfoSize);

    i4ImgReszVfyPrintf("[ImgResz][Verify] Load Case Info File %s\n",&pbCaseInfoFile);
    i4Ret = i4ImgReszVfyReadFile(pbCaseInfoFile,u4CaseInfoSa,u4CaseInfoSize);
    if(i4Ret < 0)
    {
        i4ImgReszVfyPrintf("[ImgResz][Verify] Load Case Info File fail\n");
        imgreszvfy_free_mem_aligned((void *)u4CaseInfoSa);
        return;
    }

    u4LastSrcFileNameSa = (UINT32)imgreszvfy_alloc_mem_aligned(256,1);
    *(char *)u4LastSrcFileNameSa = 0;
    u4SrcFileNameSa = (UINT32)imgreszvfy_alloc_mem_aligned(256,1);
    u4DestFileNameSa = (UINT32)imgreszvfy_alloc_mem_aligned(256,1);
    u4CurrCaseInfoSa = u4CaseInfoSa;
    u4TestCase = 0;
    if (fgPreloadBuf == TRUE)
        x_memset(&rBlBufnfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));

   /*Turn on Test agent*/
#if IMGRESZ_DRAMBUSY_TEST
           u4TestAgentSA = (UINT32)imgreszvfy_alloc_mem_aligned(0x1000,16);
           *(volatile UINT32 *)(IO_BASE + 0x007210) = u4TestAgentSA;
	    *(volatile UINT32 *)(IO_BASE + 0x007214) = 0x1000;
           *(volatile UINT32 *)(IO_BASE + 0x007104) = 0x00000000;
           *(volatile UINT32 *)(IO_BASE + 0x007218) = 0x8e0f110d;
#endif

    do
    {
        #ifndef CRC_Compare
        BOOL fgGenGolden = FALSE;
        #endif
        BOOL fgCopySrcFitToSrc = FALSE;
        IMGRESZ_HAL_IMG_INFO_T rSrcImgInfoNext;
        IMGRESZ_HAL_IMG_INFO_T rDestImgInfoNext;

        x_memset(&rSrcFitImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        x_memset(&rDestGoldImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        i4Ret = i4ImgReszVfyParseCaseInfo(pbCaseInfoFile,
                                          u4CurrCaseInfoSa,&u4NextCaseInfoSa,
                                          (u4TestCase < u4StartCase),
                                          &eResizeMode,&eHResampleMethod,&eVResampleMethod,
                                          &rSrcFitImgInfo,&rDestGoldImgInfo,
                                          (char *)u4SrcFileNameSa,(char *)u4DestFileNameSa,
                                          fgPreloadBuf,&u4Alpha,&u4AlphaScalingType);

        if(i4Ret < 0)
            break;

        if(u4TestCase < u4StartCase)
        {
            u4CurrCaseInfoSa = u4NextCaseInfoSa;
            u4TestCase++;
            continue;
        }
/*
#if IMGRESZ_IO_MMU_TEST
       
       if(eResizeMode == IMGRESZ_HAL_RESIZE_MODE_PARTIAL
#if (CONFIG_CHIP_VER_CURR == CONFIG_CHIP_VER_MT8560)       
        &&fgRunBelowSegmentBefore(IC_8560_VER_A) 
#endif
        )
        {
            u4CurrCaseInfoSa = u4NextCaseInfoSa;
            u4TestCase++;
            continue;
        }
#endif
*/
        // Load source file
        if(strcmp((char *)u4LastSrcFileNameSa,(char *)u4SrcFileNameSa) != 0)
        {
            if(u4LastBufSA1 != 0)
                imgreszvfy_free_mem_aligned((void *)u4LastBufSA1);
            if(u4LastBufSA2 != 0)
                imgreszvfy_free_mem_aligned((void *)u4LastBufSA2);
            if(u4LastBufSA3 != 0)
                imgreszvfy_free_mem_aligned((void *)u4LastBufSA3);

            u4BufSize = rSrcFitImgInfo.u4BufWidth*rSrcFitImgInfo.u4ImgHeight;
            rSrcFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
            VERIFY(rSrcFitImgInfo.u4BufSA1 != 0);
	     i4ImgReszVfyPrintf("[ImgResz][Verify] SRC Fit buffer size : %d,Src Fit addr :%x.\n",u4BufSize,rSrcFitImgInfo.u4BufSA1);

            if((rSrcFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER) ||
               (rSrcFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER))
            {
                rSrcFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA2 != 0);
            }
            if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
            {
                rSrcFitImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rSrcFitImgInfo.u4BufSA3 != 0);
            }
            i4ImgReszVfyLoadBuf((BYTE *)u4SrcFileNameSa,&rSrcFitImgInfo,u4BufSize);

            u4LastBufSA1 = rSrcFitImgInfo.u4BufSA1;
            u4LastBufSA2 = rSrcFitImgInfo.u4BufSA2;
            u4LastBufSA3 = rSrcFitImgInfo.u4BufSA3;
        } else
        {
            rSrcFitImgInfo.u4BufSA1 = u4LastBufSA1;
            rSrcFitImgInfo.u4BufSA2 = u4LastBufSA2;
            rSrcFitImgInfo.u4BufSA3 = u4LastBufSA3;
        }

        // Decide source buffer align
        if(rSrcFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
        {
            u4BufSaAlign = 1024;
            u4BufSizeAlign = 1024;
        }
        else
        {
            u4BufSaAlign = 16;
            u4BufSizeAlign = 1;
        }

        // Generate source buffer info
        x_memcpy(&rSrcImgInfo,&rSrcFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    #if 1//IMGRESZ_IO_MMU_TEST
        if(rSrcImgInfo.u4BufWidth < (1920*u4ImgReszVfyCalBufFormatBits(&(rSrcImgInfo.rBufferFormat))/8))
            rSrcImgInfo.u4BufWidth = 1920*u4ImgReszVfyCalBufFormatBits(&(rSrcImgInfo.rBufferFormat))/8;
        if(rSrcImgInfo.u4BufHeight < 1080)
           rSrcImgInfo.u4BufHeight = 1080;
   #endif
        rSrcImgInfo.u4BufWidth = ((rSrcImgInfo.u4BufWidth + 15) / 16) * 16; // Align to 16
        if(rSrcImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            rSrcImgInfo.u4BufHeight = ((rSrcImgInfo.u4BufHeight + 31) / 32) * 32; // Align to 32

        // Generate destination buffer info
        x_memcpy(&rDestImgInfo,&rDestGoldImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    #if 1
        if(rDestImgInfo.u4BufWidth < (1920*u4ImgReszVfyCalBufFormatBits(&(rDestImgInfo.rBufferFormat))/8))
            rDestImgInfo.u4BufWidth = 1920*u4ImgReszVfyCalBufFormatBits(&(rDestImgInfo.rBufferFormat))/8;
        if(rDestImgInfo.u4BufHeight <= 1080)
           rDestImgInfo.u4BufHeight = 1080;
    #endif
        rDestImgInfo.u4BufWidth = ((rDestImgInfo.u4BufWidth + 15) / 16) * 16; // Align to 16
       // rDestImgInfo.u4BufHeight = 1080;
        if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            rDestImgInfo.u4BufHeight = ((rDestImgInfo.u4BufHeight + 31) / 32) * 32; // Align to 32

        // Generate next source buffer info
        x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        // Generate next destination buffer info
        x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

        u4TestSubCase = 0;

        do
        {
            BOOL fgSourceOffsetChange = FALSE;

            i4Ret = i4ImgReszVfyGenerateSubCase(u4TestSubCase,u4TestType,&u4HwId,eResizeMode,
                                                &rSrcImgInfoNext,&rDestImgInfoNext);
            if(i4Ret < 0)
                break;

            if((rSrcImgInfoNext.u4ImgXOff != rSrcImgInfo.u4ImgXOff) ||
               (rSrcImgInfoNext.u4ImgYOff != rSrcImgInfo.u4ImgYOff))
                fgSourceOffsetChange = TRUE;

            // Update source buffer info
            x_memcpy(&rSrcImgInfo,&rSrcImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            // Update destination buffer info
            x_memcpy(&rDestImgInfo,&rDestImgInfoNext,sizeof(IMGRESZ_HAL_IMG_INFO_T));

            if(!fgCopySrcFitToSrc)
            {
                // Allocate source buffer
                u4BufSize = rSrcImgInfo.u4BufWidth * rSrcImgInfo.u4BufHeight;
                u4BufSize = ((u4BufSize + u4BufSizeAlign - 1) / u4BufSizeAlign) * u4BufSizeAlign;
#if IMGRESZ_IO_MMU_TEST
                rSrcImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
#else
                rSrcImgInfo.u4BufSA1 = (UINT32)imgreszvfy_src_alloc_mem_aligned(u4BufSize,u4BufSaAlign);
#endif
                VERIFY(rSrcImgInfo.u4BufSA1 != 0);
		  x_memset((void *)rSrcImgInfo.u4BufSA1,0,u4BufSize);
                if((rSrcImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER) ||
                   (rSrcImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER))
                {
                    rSrcImgInfo.u4BufSA2 = (UINT32)imgreszvfy_src_alloc_mem_aligned(u4BufSize,u4BufSaAlign);
                    VERIFY(rSrcImgInfo.u4BufSA2 != 0);
		      x_memset((void *)rSrcImgInfo.u4BufSA2,0,u4BufSize);
                }
                if(rSrcImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)
                {
                    rSrcImgInfo.u4BufSA3 = (UINT32)imgreszvfy_src_alloc_mem_aligned(u4BufSize,16);
                    VERIFY(rSrcImgInfo.u4BufSA3 != 0);
		      x_memset((void *)rSrcImgInfo.u4BufSA3,0,u4BufSize);
                }
                i4ImgReszVfyPrintf("[ImgResz][Verify] SRC buffer size : %x,Src addr :%x.\n",u4BufSize,rSrcImgInfo.u4BufSA1);

                // Decide destination buffer align
                if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                {
                    u4BufSaAlign = 1024;
                    u4BufSizeAlign = 1024;
                }
                else
                {
                    u4BufSaAlign = 16;
                    u4BufSizeAlign = 1;
                }

                // Allocate destination buffer
                u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                u4BufSize = ((u4BufSize + u4BufSizeAlign - 1) / u4BufSizeAlign) * u4BufSizeAlign;
#if IMGRESZ_IO_MMU_TEST
                rDestImgInfo.u4BufSA1 = (UINT32)GGT_get_vmem(u4BufSize);
#else
                rDestImgInfo.u4BufSA1 = (UINT32)imgreszvfy_dst_alloc_mem_aligned(u4BufSize,u4BufSaAlign);
#endif
                VERIFY(rDestImgInfo.u4BufSA1 != 0);
		  x_memset((void *)rDestImgInfo.u4BufSA1,0,u4BufSize);
                if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                {
                    rDestImgInfo.u4BufSA2 = (UINT32)imgreszvfy_dst_alloc_mem_aligned(u4BufSize,u4BufSaAlign);
                    VERIFY(rDestImgInfo.u4BufSA2 != 0);
		      x_memset((void *)rDestImgInfo.u4BufSA2,0,u4BufSize);
                }
                 i4ImgReszVfyPrintf("[ImgResz][Verify] DST buffer size : %x,DST addr :%x.\n",u4BufSize,rDestImgInfo.u4BufSA1);
                // Generate destination fit buffer info
                // Allocate destination fit buffer
                x_memcpy(&rDestFitImgInfo,&rDestGoldImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
                u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
                rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rDestFitImgInfo.u4BufSA1 != 0);
                x_memset((void *)rDestFitImgInfo.u4BufSA1,0,u4BufSize); 
		  i4ImgReszVfyPrintf("[ImgResz][Verify] DST Fit buffer size : %d,DST Fit addr :%x.\n",u4BufSize,rDestFitImgInfo.u4BufSA1);

                if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                {
                    rDestFitImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestFitImgInfo.u4BufSA2 != 0);
                    x_memset((void *)rDestFitImgInfo.u4BufSA2,0,u4BufSize); 
                }

                // Update next source buffer info
                x_memcpy(&rSrcImgInfoNext,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Update next destination buffer info
                x_memcpy(&rDestImgInfoNext,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
            }

            // Copy source fit buffer to source buffer
            if(!fgCopySrcFitToSrc || fgSourceOffsetChange || (u4TestType == 3))
            {
 #if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8560)
             if((rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[1] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0])
		   &&(rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[2] < rSrcFitImgInfo.rBufferFormat.u4HSampleFactor[0]))
                   vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,TRUE);
	      else
	            vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#else
            vImgReszVfyImageCopy(&rSrcFitImgInfo,&rSrcImgInfo,FALSE);
#endif
	     }
	    // if(u4TestCase == 0)
	   //  i4ImgReszVfySaveWTBuf((BYTE *)u4SrcFileNameSa,u4TestCase,&rSrcImgInfo);

            if(rSrcImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            {
                // EnBlock
                if(rSrcImgInfo.rBufferFormat.fgBlockMode)
                {
                    // Y
                    vImgReszVfyBufEnBlock(rSrcImgInfo.u4BufSA1,u4WorkBufSa,
                                          rSrcImgInfo.u4BufWidth,rSrcImgInfo.u4BufHeight,16,32);
                    x_memcpy((void *)rSrcImgInfo.u4BufSA1,(void *)u4WorkBufSa,rSrcImgInfo.u4BufWidth*rSrcImgInfo.u4BufHeight);
                    // C
                    vImgReszVfyBufEnBlock(rSrcImgInfo.u4BufSA2,u4WorkBufSa,
                                          rSrcImgInfo.u4BufWidth,rSrcImgInfo.u4BufHeight,16,16);
                    x_memcpy((void *)rSrcImgInfo.u4BufSA2,(void *)u4WorkBufSa,rSrcImgInfo.u4BufWidth*rSrcImgInfo.u4BufHeight);
                }

                // EnAddressSwap
                if(rSrcImgInfo.rBufferFormat.fgAddrSwap)
                {
                    // Y
                    vImgReszVfyBufEnAddrSwap(rSrcImgInfo.u4BufSA1,u4WorkBufSa,
                                             rSrcImgInfo.u4BufWidth*rSrcImgInfo.u4BufHeight);
                    x_memcpy((void *)rSrcImgInfo.u4BufSA1,(void *)u4WorkBufSa,rSrcImgInfo.u4BufWidth*rSrcImgInfo.u4BufHeight);
                    // C
                    vImgReszVfyBufEnAddrSwap(rSrcImgInfo.u4BufSA2,u4WorkBufSa,
                                             rSrcImgInfo.u4BufWidth*rSrcImgInfo.u4BufHeight);
                    x_memcpy((void *)rSrcImgInfo.u4BufSA2,(void *)u4WorkBufSa,rSrcImgInfo.u4BufWidth*rSrcImgInfo.u4BufHeight);
                }
            }

            fgCopySrcFitToSrc = TRUE;

            // Load golden file
            #ifndef CRC_Compare
            if(!fgGenGolden)
            {
                u4BufSize = rDestGoldImgInfo.u4BufWidth*rDestGoldImgInfo.u4ImgHeight;
                rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
                if(rDestGoldImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                {
                    rDestGoldImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
                    VERIFY(rDestGoldImgInfo.u4BufSA2 != 0);
                }
                i4ImgReszVfyLoadBuf((BYTE *)u4DestFileNameSa,&rDestGoldImgInfo,u4BufSize);
                //HalFlushInvalidateDCache();	//chunze
                fgGenGolden = TRUE;
            }
            #endif

            i4ImgReszVfyPrintf("[ImgResz][Verify] Test case %d.\n",u4TestCase);
            i4ImgReszVfyPrintf("[ImgResz][Verify] Sub case %d.\n",u4TestSubCase);
            i4ImgReszVfyPrintf("[ImgResz][Verify] Hw id %d.\n",u4HwId);
            i4ImgReszVfyPrintf("[ImgResz][Verify] Resize mode %d.\n",eResizeMode);
            i4ImgReszVfyPrintf("[ImgResz][Verify] Resize method (%d,%d).\n",eHResampleMethod,eVResampleMethod);
            i4ImgReszVfyPrintf("[ImgResz][Verify] Resize to (%d,%d).\n",rDestImgInfo.u4ImgWidth,rDestImgInfo.u4ImgHeight);
            i4ImgReszVfyPrintf("[ImgResz][Verify] Source offset (%d,%d).\n",rSrcImgInfo.u4ImgXOff,rSrcImgInfo.u4ImgYOff);
            i4ImgReszVfyPrintf("[ImgResz][Verify] Destination offset (%d,%d).\n",rDestImgInfo.u4ImgXOff,rDestImgInfo.u4ImgYOff);

            // Preload buffer
            if(fgPreloadBuf)
            {
                i4ImgReszVfyPrintf("[ImgResz][Verify] Preload buffer alpha %d.\n",u4Alpha);
                rBlBufnfo.u1Alpha = u4Alpha;
                rBlBufnfo.u4BufSA1 = rPreloadBufInfo.u4BufSA1;
                rBlBufnfo.u4BufSA2 = rPreloadBufInfo.u4BufSA2;
                i4ImgResz_HAL_Set_Blending_Image_Info(u4HwId, &rBlBufnfo);
                //i4HwImgReszSetAlphaBlendingLevel(u4HwId,u4Alpha);
                //i4HwImgReszSetPreloadBufAddr(u4HwId,rPreloadBufInfo.u4BufSA1,rPreloadBufInfo.u4BufSA2);
            }

            // Alpha scaling type
            u4AlphaScalingType = 2;
            i4HwImgReszSetAlphaChangeScalingType(u4HwId,u4AlphaScalingType);

            if(!fgJpegPreloadTest)
            {
                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcImgInfo,&rDestImgInfo,0);
            } else
            {
                IMGRESZ_HAL_IMG_INFO_T rSrcBandImgInfo;

                i4ImgReszVfyPrintf("[ImgResz][Verify] Jpeg preload test.\n");

                // Generate source band buffer info
                x_memcpy(&rSrcBandImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));

                // Allocate source band buffer
                u4BufSize = rSrcBandImgInfo.u4BufWidth * rSrcBandImgInfo.u4BufHeight;
                rSrcBandImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                VERIFY(rSrcBandImgInfo.u4BufSA1 != 0);
                rSrcBandImgInfo.u4BufSA2 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                VERIFY(rSrcBandImgInfo.u4BufSA2 != 0);
                rSrcBandImgInfo.u4BufSA3 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,16);
                VERIFY(rSrcBandImgInfo.u4BufSA3 != 0);

                // Set destination buffer as 0x80 for initial
                if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                {
                    u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                    u4BufSize = ((u4BufSize + 1023) / 1024) * 1024; // Align to 1024 for address swap
                } else if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER)
                {
                    u4BufSize = rDestImgInfo.u4BufWidth * rDestImgInfo.u4BufHeight;
                }
                x_memset((void *)rDestImgInfo.u4BufSA1,0x80,u4BufSize);
                x_memset((void *)rDestImgInfo.u4BufSA2,0x80,u4BufSize);

                // Generate source band buffer from source buffer
                // First band
                i4ImgReszVfyGenerateBandBuffer(&rSrcImgInfo,&rSrcBandImgInfo,7,4);

                x_memset(&rJpegInfo,0,sizeof(IMGRESZ_HAL_JPEG_INFO_T));
                rJpegInfo.fgPictureMode = FALSE;
                rJpegInfo.fgPreloadMode = TRUE;
                rJpegInfo.fgYExist = TRUE;
                rJpegInfo.fgCbExist = TRUE;
                rJpegInfo.fgCrExist = TRUE;

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcBandImgInfo,&rDestImgInfo,&rJpegInfo);

                // Generate source band buffer from source buffer
                // Second band
                i4ImgReszVfyGenerateBandBuffer(&rSrcImgInfo,&rSrcBandImgInfo,3,0);

                rJpegInfo.fgYExist = TRUE;
                rJpegInfo.fgCbExist = FALSE;
                rJpegInfo.fgCrExist = FALSE;

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcBandImgInfo,&rDestImgInfo,&rJpegInfo);

                rJpegInfo.fgYExist = FALSE;
                rJpegInfo.fgCbExist = TRUE;
                rJpegInfo.fgCrExist = FALSE;

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcBandImgInfo,&rDestImgInfo,&rJpegInfo);

                rJpegInfo.fgYExist = FALSE;
                rJpegInfo.fgCbExist = FALSE;
                rJpegInfo.fgCrExist = TRUE;

                // Resize
                i4ImgReszVfyResz(u4HwId,eResizeMode,eHResampleMethod,eVResampleMethod,
                                 &rSrcBandImgInfo,&rDestImgInfo,&rJpegInfo);
            }
         /*Turn off Test agent*/
       //  *(volatile UINT32 *)(IO_BASE + 0x007218) = 0x060f110d;

            if(rDestImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
            {
                // DeAddressSwap
                if(rDestImgInfo.rBufferFormat.fgAddrSwap)
                {
                    // Y
                    vImgReszVfyBufDeAddrSwap(rDestImgInfo.u4BufSA1,u4WorkBufSa,
                                             rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                    x_memcpy((void *)rDestImgInfo.u4BufSA1,(void *)u4WorkBufSa,rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                    // C
                    vImgReszVfyBufDeAddrSwap(rDestImgInfo.u4BufSA2,u4WorkBufSa,
                                             rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                    x_memcpy((void *)rDestImgInfo.u4BufSA2,(void *)u4WorkBufSa,rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                }

                // DeBlock
                if(rDestImgInfo.rBufferFormat.fgBlockMode)
                {                   // Y
                    vImgReszVfyBufDeBlock(rDestImgInfo.u4BufSA1,u4WorkBufSa,
                                          rDestImgInfo.u4BufWidth,rDestImgInfo.u4BufHeight,16,32);
                    x_memcpy((void *)rDestImgInfo.u4BufSA1,(void *)u4WorkBufSa,rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                    // C
                    vImgReszVfyBufDeBlock(rDestImgInfo.u4BufSA2,u4WorkBufSa,
                                          rDestImgInfo.u4BufWidth,rDestImgInfo.u4BufHeight,16,16);
                    x_memcpy((void *)rDestImgInfo.u4BufSA2,(void *)u4WorkBufSa,rDestImgInfo.u4BufWidth*rDestImgInfo.u4BufHeight);
                }
            }

            // Copy destination buffer to destination fit buffer
            vImgReszVfyImageCopy(&rDestImgInfo,&rDestFitImgInfo,FALSE);

            i4ImgReszVfyPrintf("[ImgResz][Verify] Compare\n");
            // Compare
            {
            #ifdef CRC_Compare
            if(u4ImgReszCheckSumGolden == u4ImgReszCheckSum)
            {
                i4ImgReszVfyPrintf("[ImgResz][Verify] CRC Compare PASS!!!\n");
            }
            else
            {
                i4ImgReszVfyPrintf("[ImgResz][Verify] CRC Compare FAIL!!!\n");
            }
            #else
                INT32 i4Ret;
                char bDestName[256];

                u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
		  //HalFlushInvalidateDCache();//chunze
                i4Ret = x_memcmp((void *)rDestFitImgInfo.u4BufSA1,(void *)rDestGoldImgInfo.u4BufSA1,u4BufSize);

                if(i4Ret != 0)
                {
                    UINT32 u4I;
                    UINT32 u4DestFitBufSa,u4DestGoldBufSa;

                    // Search error
                    u4DestFitBufSa = rDestFitImgInfo.u4BufSA1;
                    u4DestGoldBufSa = rDestGoldImgInfo.u4BufSA1;

                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitBufSa) != *(UINT8 *)(u4DestGoldBufSa))
                         {
                           i4ImgReszVfyPrintf("[ImgResz][Verify]Y compare error. u4DestFitBufSa = %x, u4DestGoldBufSa = %x\n",u4DestFitBufSa,u4DestGoldBufSa);                                
                           
                           sprintf(bDestName,"%s.y.dst",(BYTE *)u4DestFileNameSa);
			      i4ImgReszVfySaveDestBuf(bDestName,0,&rDestFitImgInfo);
                           VERIFY(FALSE);
                           
                          }

                        u4DestFitBufSa++;
                        u4DestGoldBufSa++;
                    }
                }

                if(rDestFitImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER)
                {
                    if(rDestFitImgInfo.rBufferFormat.eYUVFormat == IMGRESZ_HAL_IMG_YUV_FORMAT_420)
                        u4BufSize /= 2;
                    //HalFlushInvalidateDCache();//chunze
                    i4Ret = x_memcmp((void *)rDestFitImgInfo.u4BufSA2,(void *)rDestGoldImgInfo.u4BufSA2,u4BufSize);

                    if(i4Ret != 0)
                    {
                        UINT32 u4I;
                        UINT32 u4DestFitBufSa,u4DestGoldBufSa;

                        // Search error
                        u4DestFitBufSa = rDestFitImgInfo.u4BufSA2;
                        u4DestGoldBufSa = rDestGoldImgInfo.u4BufSA2;

                        for(u4I=0; u4I<u4BufSize; u4I++)
                        {
                            if(*(UINT8 *)(u4DestFitBufSa) != *(UINT8 *)(u4DestGoldBufSa))
                              {
                                i4ImgReszVfyPrintf("[ImgResz][Verify]C compare error. u4DestFitBufSa = %x, u4DestGoldBufSa = %x\n",u4DestFitBufSa,u4DestGoldBufSa);                                
                                
                                sprintf(bDestName,"%s.c.dst",(BYTE *)u4DestFileNameSa);
			           i4ImgReszVfySaveDestBuf(bDestName,u4TestCase,&rDestFitImgInfo);
			                    VERIFY(FALSE);
				    break;
                                
                               }
                            u4DestFitBufSa++;
                            u4DestGoldBufSa++;
                        }
                    }
                }
            #endif
            }
            i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");

            u4TestSubCase++;
        } while (TRUE);

        // Free memory
 #if IMGRESZ_IO_MMU_TEST
        x_free_vmem((void *)rSrcImgInfo.u4BufSA1);
        x_free_vmem((void *)rDestImgInfo.u4BufSA1);
 #else
        imgreszvfy_src_free_mem_aligned((void *)rSrcImgInfo.u4BufSA1);    
        imgreszvfy_dst_free_mem_aligned((void *)rDestImgInfo.u4BufSA1);    
#endif
        imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
        imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
        if(rSrcImgInfo.u4BufSA2 != 0)
        {
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA2);
        }
        if(rDestImgInfo.u4BufSA2 != 0)
        {
            imgreszvfy_free_mem_aligned((void *)rDestImgInfo.u4BufSA2);
         }
        if(rDestFitImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA2);
        if(rDestGoldImgInfo.u4BufSA2 != 0)
            imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA2);
        if(rSrcImgInfo.u4BufSA3 != 0)
        {
            imgreszvfy_free_mem_aligned((void *)rSrcImgInfo.u4BufSA3);
        }
        if(rSrcFitImgInfo.rBufferFormat.prColorPallet != 0)
            imgreszvfy_free_mem_aligned((void *)rSrcFitImgInfo.rBufferFormat.prColorPallet);

        u4CurrCaseInfoSa = u4NextCaseInfoSa;
        strcpy((char *)u4LastSrcFileNameSa,(char *)u4SrcFileNameSa);
        u4TestCase++;
    } while(TRUE);

    _fgAlphaB = FALSE;
    if(u4LastBufSA1 != 0)
        imgreszvfy_free_mem_aligned((void *)u4LastBufSA1);
    if(u4LastBufSA2 != 0)
        imgreszvfy_free_mem_aligned((void *)u4LastBufSA2);
    if(u4LastBufSA3 != 0)
        imgreszvfy_free_mem_aligned((void *)u4LastBufSA3);

    imgreszvfy_free_mem_aligned((void *)u4CaseInfoSa);
    imgreszvfy_free_mem_aligned((void *)u4LastSrcFileNameSa);
    imgreszvfy_free_mem_aligned((void *)u4SrcFileNameSa);
    imgreszvfy_free_mem_aligned((void *)u4DestFileNameSa);

    if(u4TestType == 3)
        imgreszvfy_free_mem_aligned((void *)u4WorkBufSa);

    if(rPreloadBufInfo.u4BufSA1 != 0);
        imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA1);
    if(rPreloadBufInfo.u4BufSA2 != 0);
        imgreszvfy_free_mem_aligned((void *)rPreloadBufInfo.u4BufSA2);
#if IMGRESZ_DRAMBUSY_TEST
        imgreszvfy_free_mem_aligned((void *)u4TestAgentSA);
#endif
    i4ImgReszVfyPrintf("[ImgResz][Verify] Auto test complete.\n");

    //vImgreszVfyTestWriteTestDoneSignal();//test done, write done signal, tell PC.
#if(IMG_RESZ_VFY_FILE_IO_TYPE == IMG_RESZ_VFY_FILE_IO_UDVT_USBRW)

   // UDVT_IF_SendResult(UDVT_TEST_PASS);
#endif	
}

#if 1 //sun for fmc
//////////////////////////////////////////////////////////////////////////////////////
//
//  Interface for Fmc Swap  Mode
//
//////////////////////////////////////////////////////////////////////////////////////
UINT32 _u4FmcVfySwapModeTempLineBuf[2] = { 0 };
void vFmcVfySwapModeModeInit(UINT32 u4FmcSwapmode,
	                                       UINT32 u4HwId,UINT32 u4SrcBufWidth,
                                              UINT32 u4SrcImgWidth,UINT32 u4SrcImgHeight,
                                              UINT32 u4SrcBuf1SA1,UINT32 u4SrcBuf1SA2,
                                              UINT32 u4DestBufWidth,UINT32 u4DestBufHeight,
                                              UINT32 u4DestImgWidth,UINT32 u4DestImgHeight,
                                              UINT32 u4DestBufSA1,UINT32 u4DestBufSA2
)
{
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    u4SwapMode = u4FmcSwapmode;

    i4ImgResz_HAL_Boot_Init();
    i4ImgResz_HAL_Init(u4HwId);
    i4ImgResz_HAL_Set_Resize_Mode(u4HwId,IMGRESZ_HAL_RESIZE_MODE_FRAME);
    i4ImgResz_HAL_Set_Resample_Method(u4HwId,IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR,
                                             IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR);
    memset(&rSrcImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    rSrcImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER;
    rSrcImgInfo.rBufferFormat.eYUVFormat = IMGRESZ_HAL_IMG_YUV_FORMAT_420;
    rSrcImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;
    rSrcImgInfo.rBufferFormat.fgBlockMode = FALSE;
    rSrcImgInfo.rBufferFormat.fgAddrSwap = FALSE;
    rSrcImgInfo.u4BufWidth = u4SrcBufWidth;
    //rSrcImgInfo.u4BufHeight =;
    rSrcImgInfo.u4ImgWidth = u4SrcImgWidth;
    rSrcImgInfo.u4ImgHeight = u4SrcImgHeight;
    rSrcImgInfo.u4ImgXOff = 0;
    rSrcImgInfo.u4ImgYOff = 0;
    rSrcImgInfo.u4BufSA1 = u4SrcBuf1SA1;
    rSrcImgInfo.u4BufSA2 = u4SrcBuf1SA2;

    i4ImgResz_HAL_Set_Source_Image_Info(u4HwId,&rSrcImgInfo);
    memset(&rDestImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));

    rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER;
    rDestImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;
    rDestImgInfo.rBufferFormat.eYUVFormat = IMGRESZ_HAL_IMG_YUV_FORMAT_420;
    rDestImgInfo.rBufferFormat.fgBlockMode = FALSE;
    rDestImgInfo.rBufferFormat.fgAddrSwap = FALSE;
    rDestImgInfo.u4BufWidth = u4DestBufWidth;
    rDestImgInfo.u4BufHeight = u4DestBufHeight;
    rDestImgInfo.u4ImgWidth = u4DestImgWidth;
    rDestImgInfo.u4ImgHeight = u4DestImgHeight;
    rDestImgInfo.u4ImgXOff = 0;
    rDestImgInfo.u4ImgYOff = 0;
    rDestImgInfo.u4BufSA1 = u4DestBufSA1;
    rDestImgInfo.u4BufSA2 = u4DestBufSA2;
    //rDestImgInfo.u4BufSA3 =;
    i4ImgResz_HAL_Set_Destination_Image_Info(u4HwId,&rDestImgInfo);

    {
	 i4ImgResz_HAL_Set_Scale1to1(u4HwId,TRUE);
        _u4FmcVfySwapModeTempLineBuf[u4HwId] = (UINT32)imgreszvfy_alloc_mem_aligned((rDestImgInfo.u4ImgWidth)*3*4,2048);

        i4ImgResz_HAL_Resize(u4HwId);
    }

     while(TRUE)
     {
        if(i4ImgResz_HAL_Get_Resize_Status(u4HwId)>=0)
            break;
     }
     i4ImgResz_HAL_Uninit(u4HwId);
}
#endif
//////////////////////////////////////////////////////////////////////////////////////
//
//  Interface for Jpeg Picture Mode
//
//////////////////////////////////////////////////////////////////////////////////////
UINT32 _u4ImgReszVfyJpegPicModeTempLineBuf[2] = { 0 };
void vImgReszVfyJpegPicModeInit(UINT32 u4HwId,UINT32 u4SrcBufWidth,
                                              UINT32 u4SrcImgWidth,UINT32 u4SrcImgHeight,
                                              UINT32 u4SrcBuf1SA1,UINT32 u4SrcBuf1SA2,UINT32 u4SrcBuf1SA3,
                                              UINT32 u4SrcBuf2SA1,UINT32 u4SrcBuf2SA2,UINT32 u4SrcBuf2SA3,
                                              UINT32 u4DestBufWidth,UINT32 u4DestBufHeight,
                                              UINT32 u4DestImgWidth,UINT32 u4DestImgHeight,
                                              UINT32 u4DestImgXOff,UINT32 u4DestImgYOff,
                                              UINT32 u4DestBufSA1,UINT32 u4DestBufSA2,
                                              UINT32 u4HSampleFactor0,UINT32 u4VSampleFactor0,
                                              UINT32 u4HSampleFactor1,UINT32 u4VSampleFactor1,
                                              UINT32 u4HSampleFactor2,UINT32 u4VSampleFactor2,
                                              BOOL fgAYUVOutput
)
{
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;

    i4ImgResz_HAL_Boot_Init();
    i4ImgResz_HAL_Init(u4HwId);
    i4ImgResz_HAL_Set_Resize_Mode(u4HwId,IMGRESZ_HAL_RESIZE_MODE_PARTIAL);
    i4ImgResz_HAL_Set_Resample_Method(u4HwId,IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR,
                                             IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR);
    memset(&rSrcImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    rSrcImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER;
    rSrcImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;
    rSrcImgInfo.rBufferFormat.fgBlockMode = FALSE;
    rSrcImgInfo.rBufferFormat.fgAddrSwap = FALSE;
    rSrcImgInfo.rBufferFormat.u4HSampleFactor[0] = u4HSampleFactor0;
    rSrcImgInfo.rBufferFormat.u4HSampleFactor[1] = u4HSampleFactor1;
    rSrcImgInfo.rBufferFormat.u4HSampleFactor[2] = u4HSampleFactor2;
    rSrcImgInfo.rBufferFormat.u4VSampleFactor[0] = u4VSampleFactor0;
    rSrcImgInfo.rBufferFormat.u4VSampleFactor[1] = u4VSampleFactor1;
    rSrcImgInfo.rBufferFormat.u4VSampleFactor[2] = u4VSampleFactor2;
    rSrcImgInfo.u4BufWidth = u4SrcBufWidth;
    //rSrcImgInfo.u4BufHeight =;
    rSrcImgInfo.u4ImgWidth = u4SrcImgWidth;
    rSrcImgInfo.u4ImgHeight = u4SrcImgHeight;
    rSrcImgInfo.u4ImgXOff = 0;
    rSrcImgInfo.u4ImgYOff = 0;
    rSrcImgInfo.u4BufSA1 = u4SrcBuf1SA1;
    rSrcImgInfo.u4BufSA2 = u4SrcBuf1SA2;
    rSrcImgInfo.u4BufSA3 = u4SrcBuf1SA3;
    i4ImgResz_HAL_Set_Source_Image_Info(u4HwId,&rSrcImgInfo);
    memset(&rDestImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    if(fgAYUVOutput)
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
    else
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER;
    rDestImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;
    rDestImgInfo.rBufferFormat.eYUVFormat = IMGRESZ_HAL_IMG_YUV_FORMAT_420;
    rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
    rDestImgInfo.rBufferFormat.fgBlockMode = FALSE;
    rDestImgInfo.rBufferFormat.fgAddrSwap = FALSE;
    rDestImgInfo.u4BufWidth = u4DestBufWidth;
    rDestImgInfo.u4BufHeight = u4DestBufHeight;
    rDestImgInfo.u4ImgWidth = u4DestImgWidth;
    rDestImgInfo.u4ImgHeight = u4DestImgHeight;
    rDestImgInfo.u4ImgXOff = u4DestImgXOff;
    rDestImgInfo.u4ImgYOff = u4DestImgYOff;
    rDestImgInfo.u4BufSA1 = u4DestBufSA1;
    rDestImgInfo.u4BufSA2 = u4DestBufSA2;
    //rDestImgInfo.rBufferFormat.fgBlockMode = TRUE;
    //rDestImgInfo.u4BufSA3 =;
    i4ImgResz_HAL_Set_Destination_Image_Info(u4HwId,&rDestImgInfo);

    {
        UINT32 u4RowBufHeight = 0;
        IMGRESZ_HAL_PARTIAL_BUF_INFO_T rSrcRowBufInfo = { 0 };
        IMGRESZ_HAL_JPEG_INFO_T rJpegInfo = { 0 };

       // _u4ImgReszVfyJpegPicModeTempLineBuf[u4HwId] = (UINT32)imgreszvfy_alloc_mem_aligned((rDestImgInfo.u4ImgWidth)*3*4,2048);
        //_u4ImgReszVfyJpegPicModeTempLineBuf[u4HwId] = 0xD0400000;
        rSrcRowBufInfo.u4RowBufHeight = u4RowBufHeight;
        rSrcRowBufInfo.fgFirstRowBuf = TRUE;
        rSrcRowBufInfo.fgLastRowBuf = FALSE;
        rSrcRowBufInfo.u4CurRowBufSA1 = u4SrcBuf1SA1;
        rSrcRowBufInfo.u4CurRowBufSA2 = u4SrcBuf1SA2;
        rSrcRowBufInfo.u4CurRowBufSA3 = u4SrcBuf1SA3;
        rSrcRowBufInfo.u4PrevRowBufSA1 = u4SrcBuf2SA1;
        rSrcRowBufInfo.u4PrevRowBufSA2 = u4SrcBuf2SA2;
        rSrcRowBufInfo.u4PrevRowBufSA3 = u4SrcBuf2SA3;
        //i4ImgReszVfyPrintf("[ImgResz][Verify] _u4ImgReszVfyJpegPicModeTempLineBuf[0]=%x,_u4ImgReszVfyJpegPicModeTempLineBuf[1]=%x\n",_u4ImgReszVfyJpegPicModeTempLineBuf[0],_u4ImgReszVfyJpegPicModeTempLineBuf[1]);
        i4ImgReszVfyPrintf("[ImgResz][Verify]tempbuffer0 sa = %x\n",_u4ImgReszVfyJpegPicModeTempLineBuf[0]);
        i4ImgReszVfyPrintf("[ImgResz][Verify]tempbuffer1 sa = %x\n",_u4ImgReszVfyJpegPicModeTempLineBuf[1]);
        i4ImgResz_HAL_Set_Partial_Mode_Info(u4HwId,&rSrcRowBufInfo,_u4ImgReszVfyJpegPicModeTempLineBuf[u4HwId]);
        rJpegInfo.fgPictureMode = TRUE;
        rJpegInfo.fgPreloadMode = FALSE;
        rJpegInfo.fgYExist = TRUE;
        rJpegInfo.fgCbExist = TRUE;
        rJpegInfo.fgCrExist = TRUE;
        i4ImgResz_HAL_Set_Jpeg_Info(u4HwId,&rJpegInfo);
        i4ImgResz_HAL_Resize(u4HwId);
    }
}

//////////////////////////////////////////////////////////////////////////////////////
//
//  Interface for Jpeg Scan Mode Multi-Collect
//
//////////////////////////////////////////////////////////////////////////////////////
void vImgReszVfyJpegScanModeInit(UINT32 u4HwId,UINT32 u4SrcBufWidth,
                                              UINT32 u4SrcImgWidth,UINT32 u4SrcImgHeight,
                                              UINT32 u4SrcBuf1SA1,UINT32 u4SrcBuf1SA2,UINT32 u4SrcBuf1SA3,
                                              UINT32 u4SrcBuf2SA1,UINT32 u4SrcBuf2SA2,UINT32 u4SrcBuf2SA3,
                                              UINT32 u4DestBufWidth,UINT32 u4DestBufHeight,
                                              UINT32 u4DestImgWidth,UINT32 u4DestImgHeight,
                                              UINT32 u4DestImgXOff,UINT32 u4DestImgYOff,
                                              UINT32 u4DestBufSA1,UINT32 u4DestBufSA2,
                                              UINT32 u4HSampleFactor0,UINT32 u4VSampleFactor0,
                                              UINT32 u4HSampleFactor1,UINT32 u4VSampleFactor1,
                                              UINT32 u4HSampleFactor2,UINT32 u4VSampleFactor2,
                                              BOOL fgAYUVOutput,BOOL fgYExist,
                                              BOOL fgCbExist,BOOL fgCrExist
)
{
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;

    i4ImgResz_HAL_Boot_Init();
    i4ImgResz_HAL_Init(u4HwId);
    i4ImgResz_HAL_Set_Resize_Mode(u4HwId,IMGRESZ_HAL_RESIZE_MODE_PARTIAL);
    i4ImgResz_HAL_Set_Resample_Method(u4HwId,IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR,
                                             IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR);
    memset(&rSrcImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    rSrcImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER;
    rSrcImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;
    rSrcImgInfo.rBufferFormat.fgBlockMode = FALSE;
    rSrcImgInfo.rBufferFormat.fgAddrSwap = FALSE;
    rSrcImgInfo.rBufferFormat.u4HSampleFactor[0] = u4HSampleFactor0;
    rSrcImgInfo.rBufferFormat.u4HSampleFactor[1] = u4HSampleFactor1;
    rSrcImgInfo.rBufferFormat.u4HSampleFactor[2] = u4HSampleFactor2;
    rSrcImgInfo.rBufferFormat.u4VSampleFactor[0] = u4VSampleFactor0;
    rSrcImgInfo.rBufferFormat.u4VSampleFactor[1] = u4VSampleFactor1;
    rSrcImgInfo.rBufferFormat.u4VSampleFactor[2] = u4VSampleFactor2;
    rSrcImgInfo.u4BufWidth = u4SrcBufWidth;
    //rSrcImgInfo.u4BufHeight =;
    rSrcImgInfo.u4ImgWidth = u4SrcImgWidth;
    rSrcImgInfo.u4ImgHeight = u4SrcImgHeight;
    rSrcImgInfo.u4ImgXOff = 0;
    rSrcImgInfo.u4ImgYOff = 0;
    rSrcImgInfo.u4BufSA1 = u4SrcBuf1SA1;
    rSrcImgInfo.u4BufSA2 = u4SrcBuf1SA2;
    rSrcImgInfo.u4BufSA3 = u4SrcBuf1SA3;
    i4ImgResz_HAL_Set_Source_Image_Info(u4HwId,&rSrcImgInfo);
    memset(&rDestImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    if(fgAYUVOutput)
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
    else
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER;
    rDestImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;
    rDestImgInfo.rBufferFormat.eYUVFormat = IMGRESZ_HAL_IMG_YUV_FORMAT_420;
    rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
    rDestImgInfo.rBufferFormat.fgBlockMode = FALSE;
    rDestImgInfo.rBufferFormat.fgAddrSwap = FALSE;
    rDestImgInfo.u4BufWidth = u4DestBufWidth;
    rDestImgInfo.u4BufHeight = u4DestBufHeight;
    rDestImgInfo.u4ImgWidth = u4DestImgWidth;
    rDestImgInfo.u4ImgHeight = u4DestImgHeight;
    rDestImgInfo.u4ImgXOff = u4DestImgXOff;
    rDestImgInfo.u4ImgYOff = u4DestImgYOff;
    rDestImgInfo.u4BufSA1 = u4DestBufSA1;
    rDestImgInfo.u4BufSA2 = u4DestBufSA2;
    //rDestImgInfo.u4BufSA3 =;
    i4ImgResz_HAL_Set_Destination_Image_Info(u4HwId,&rDestImgInfo);

    {
        UINT32 u4RowBufHeight = 0;
        IMGRESZ_HAL_PARTIAL_BUF_INFO_T rSrcRowBufInfo = { 0 };
        IMGRESZ_HAL_JPEG_INFO_T rJpegInfo = { 0 };
        //if(!_u4ImgReszVfyJpegPicModeTempLineBuf[u4HwId])
        //{
        //    _u4ImgReszVfyJpegPicModeTempLineBuf[u4HwId] = (UINT32)imgreszvfy_alloc_mem_aligned((rDestImgInfo.u4ImgWidth)*3*4,2048);
        //}
        //else
        //{
            //imgreszvfy_free_mem_aligned((void *)_u4ImgReszVfyJpegPicModeTempLineBuf[u4HwId]);
            //_u4ImgReszVfyJpegPicModeTempLineBuf[u4HwId] = (UINT32)imgreszvfy_alloc_mem_aligned((rDestImgInfo.u4ImgWidth)*3*4,2048);
        //}
        //_u4ImgReszVfyJpegPicModeTempLineBuf[u4HwId] = 0xD0400000;
        rSrcRowBufInfo.u4RowBufHeight = u4RowBufHeight;
        rSrcRowBufInfo.fgFirstRowBuf = TRUE;
        rSrcRowBufInfo.fgLastRowBuf = FALSE;
        rSrcRowBufInfo.u4CurRowBufSA1 = u4SrcBuf1SA1;
        rSrcRowBufInfo.u4CurRowBufSA2 = u4SrcBuf1SA2;
        rSrcRowBufInfo.u4CurRowBufSA3 = u4SrcBuf1SA3;
        rSrcRowBufInfo.u4PrevRowBufSA1 = u4SrcBuf2SA1;
        rSrcRowBufInfo.u4PrevRowBufSA2 = u4SrcBuf2SA2;
        rSrcRowBufInfo.u4PrevRowBufSA3 = u4SrcBuf2SA3;
        i4ImgResz_HAL_Set_Partial_Mode_Info(u4HwId,&rSrcRowBufInfo,_u4ImgReszVfyJpegPicModeTempLineBuf[u4HwId]);
        rJpegInfo.fgPictureMode = TRUE;
        rJpegInfo.fgPreloadMode = FALSE;
        rJpegInfo.fgYExist = fgYExist;
        rJpegInfo.fgCbExist = fgCbExist;
        rJpegInfo.fgCrExist = fgCrExist;
        i4ImgResz_HAL_Set_Jpeg_Info(u4HwId,&rJpegInfo);
        i4ImgResz_HAL_Resize(u4HwId);
    }
}

//////////////////////////////////////////////////////////////////////////////////////
//
//  Interface for Jpeg Scan Mode Enhance
//
//////////////////////////////////////////////////////////////////////////////////////
void vImgReszVfyJpegScanModePreloadInit(UINT32 u4HwId,UINT32 u4SrcBufWidth,
                                              UINT32 u4SrcImgWidth,UINT32 u4SrcImgHeight,
                                              UINT32 u4SrcBuf1SA1,UINT32 u4SrcBuf1SA2,UINT32 u4SrcBuf1SA3,
                                              UINT32 u4SrcBuf2SA1,UINT32 u4SrcBuf2SA2,UINT32 u4SrcBuf2SA3,
                                              UINT32 u4DestBufWidth,UINT32 u4DestBufHeight,
                                              UINT32 u4DestImgWidth,UINT32 u4DestImgHeight,
                                              UINT32 u4DestImgXOff,UINT32 u4DestImgYOff,
                                              UINT32 u4DestBufSA1,UINT32 u4DestBufSA2,
                                              UINT32 u4HSampleFactor0,UINT32 u4VSampleFactor0,
                                              UINT32 u4HSampleFactor1,UINT32 u4VSampleFactor1,
                                              UINT32 u4HSampleFactor2,UINT32 u4VSampleFactor2,
                                              BOOL fgAYUVOutput,BOOL fgYExist,
                                              BOOL fgCbExist,BOOL fgCrExist,BOOL fgPreload
)
{
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;

    i4ImgResz_HAL_Boot_Init();
    i4ImgResz_HAL_Init(u4HwId);
    i4ImgResz_HAL_Set_Resize_Mode(u4HwId,IMGRESZ_HAL_RESIZE_MODE_PARTIAL);
    i4ImgResz_HAL_Set_Resample_Method(u4HwId,IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR,
                                             IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR);
    memset(&rSrcImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    rSrcImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER;
    rSrcImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;
    rSrcImgInfo.rBufferFormat.fgBlockMode = FALSE;
    rSrcImgInfo.rBufferFormat.fgAddrSwap = FALSE;
    rSrcImgInfo.rBufferFormat.u4HSampleFactor[0] = u4HSampleFactor0;
    rSrcImgInfo.rBufferFormat.u4HSampleFactor[1] = u4HSampleFactor1;
    rSrcImgInfo.rBufferFormat.u4HSampleFactor[2] = u4HSampleFactor2;
    rSrcImgInfo.rBufferFormat.u4VSampleFactor[0] = u4VSampleFactor0;
    rSrcImgInfo.rBufferFormat.u4VSampleFactor[1] = u4VSampleFactor1;
    rSrcImgInfo.rBufferFormat.u4VSampleFactor[2] = u4VSampleFactor2;
    rSrcImgInfo.u4BufWidth = u4SrcBufWidth;
    //rSrcImgInfo.u4BufHeight =;
    rSrcImgInfo.u4ImgWidth = u4SrcImgWidth;
    rSrcImgInfo.u4ImgHeight = u4SrcImgHeight;
    rSrcImgInfo.u4ImgXOff = 0;
    rSrcImgInfo.u4ImgYOff = 0;
    rSrcImgInfo.u4BufSA1 = u4SrcBuf1SA1;
    rSrcImgInfo.u4BufSA2 = u4SrcBuf1SA2;
    rSrcImgInfo.u4BufSA3 = u4SrcBuf1SA3;
    i4ImgResz_HAL_Set_Source_Image_Info(u4HwId,&rSrcImgInfo);
    memset(&rDestImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    if(fgAYUVOutput)
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
    else
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER;
    rDestImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;
    rDestImgInfo.rBufferFormat.eYUVFormat = IMGRESZ_HAL_IMG_YUV_FORMAT_420;
    rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
    rDestImgInfo.rBufferFormat.fgBlockMode = FALSE;
    rDestImgInfo.rBufferFormat.fgAddrSwap = FALSE;
    rDestImgInfo.u4BufWidth = u4DestBufWidth;
    rDestImgInfo.u4BufHeight = u4DestBufHeight;
    rDestImgInfo.u4ImgWidth = u4DestImgWidth;
    rDestImgInfo.u4ImgHeight = u4DestImgHeight;
    rDestImgInfo.u4ImgXOff = u4DestImgXOff;
    rDestImgInfo.u4ImgYOff = u4DestImgYOff;
    rDestImgInfo.u4BufSA1 = u4DestBufSA1;
    rDestImgInfo.u4BufSA2 = u4DestBufSA2;
    //rDestImgInfo.u4BufSA3 =;
    i4ImgResz_HAL_Set_Destination_Image_Info(u4HwId,&rDestImgInfo);

    {
        UINT32 u4RowBufHeight = 0;
        IMGRESZ_HAL_PARTIAL_BUF_INFO_T rSrcRowBufInfo = { 0 };
        IMGRESZ_HAL_JPEG_INFO_T rJpegInfo = { 0 };

        //_u4ImgReszVfyJpegPicModeTempLineBuf[u4HwId] = (UINT32)imgreszvfy_alloc_mem_aligned((rDestImgInfo.u4ImgWidth)*3*4,2048);
        //_u4ImgReszVfyJpegPicModeTempLineBuf[u4HwId] = 0xD0400000;
        rSrcRowBufInfo.u4RowBufHeight = u4RowBufHeight;
        rSrcRowBufInfo.fgFirstRowBuf = TRUE;
        rSrcRowBufInfo.fgLastRowBuf = FALSE;
        rSrcRowBufInfo.u4CurRowBufSA1 = u4SrcBuf1SA1;
        rSrcRowBufInfo.u4CurRowBufSA2 = u4SrcBuf1SA2;
        rSrcRowBufInfo.u4CurRowBufSA3 = u4SrcBuf1SA3;
        rSrcRowBufInfo.u4PrevRowBufSA1 = u4SrcBuf2SA1;
        rSrcRowBufInfo.u4PrevRowBufSA2 = u4SrcBuf2SA2;
        rSrcRowBufInfo.u4PrevRowBufSA3 = u4SrcBuf2SA3;
        i4ImgResz_HAL_Set_Partial_Mode_Info(u4HwId,&rSrcRowBufInfo,_u4ImgReszVfyJpegPicModeTempLineBuf[u4HwId]);
        rJpegInfo.fgPictureMode = TRUE;
	 if(fgPreload)
        rJpegInfo.fgPreloadMode = TRUE;
	 else
	    rJpegInfo.fgPreloadMode = FALSE;
        rJpegInfo.fgYExist = fgYExist;
        rJpegInfo.fgCbExist = fgCbExist;
        rJpegInfo.fgCrExist = fgCrExist;
        i4ImgResz_HAL_Set_Jpeg_Info(u4HwId,&rJpegInfo);
        i4ImgResz_HAL_Resize(u4HwId);
    }
}

INT32 i4ImgReszVfyJpegPicModeGetResizeStatus(UINT32 u4HwId)
{
    return i4ImgResz_HAL_Get_Resize_Status(u4HwId);
}


void vImgReszVfyJpegPicModeUninit(UINT32 u4HwId)
{
    //imgreszvfy_free_mem_aligned(_u4ImgReszVfyJpegPicModeTempLineBuf[u4HwId]);

    i4ImgResz_HAL_Uninit(u4HwId);
    i4ImgResz_HAL_Boot_Uninit();
}


void vImgReszVfyJpegPicModeWorkaroundYC2AYUV(UINT32 u4HwId,UINT32 u4SrcBufWidth,
                                                           UINT32 u4SrcImgWidth,UINT32 u4SrcImgHeight,
                                                           UINT32 u4SrcBufSA1,UINT32 u4SrcBufSA2,
                                                           UINT32 u4DestBufWidth,UINT32 u4DestBufHeight,
                                                           UINT32 u4DestImgWidth,UINT32 u4DestImgHeight,
                                                           UINT32 u4DestImgXOff,UINT32 u4DestImgYOff,
                                                           UINT32 u4DestBufSA1)
{
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;

    i4ImgResz_HAL_Boot_Init();
    i4ImgResz_HAL_Init(u4HwId);
    i4ImgResz_HAL_Set_Resize_Mode(u4HwId,IMGRESZ_HAL_RESIZE_MODE_FRAME);
    i4ImgResz_HAL_Set_Resample_Method(u4HwId,IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR,
                                             IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR);
    memset(&rSrcImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    rSrcImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER;
    rSrcImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;
    rSrcImgInfo.rBufferFormat.eYUVFormat = IMGRESZ_HAL_IMG_YUV_FORMAT_420;
    rSrcImgInfo.rBufferFormat.fgBlockMode = FALSE;
    rSrcImgInfo.rBufferFormat.fgAddrSwap = FALSE;
    //rSrcImgInfo.rBufferFormat.eARGBBufferFormat = _eSrcARGBFormat;
    //rSrcImgInfo.rBufferFormat.eIndexBufferFormat = _eSrcIndexFormat;
    //rSrcImgInfo.rBufferFormat.prColorPallet = (IMGRESZ_HAL_ARGB_COLOR_T *)_pucImgReszSrcIndexTable;
    //rSrcImgInfo.rBufferFormat.u4HSampleFactor[0] = _u4ImgReszVfyHSampleFactor[0];
    //rSrcImgInfo.rBufferFormat.u4HSampleFactor[1] = _u4ImgReszVfyHSampleFactor[1];
    //rSrcImgInfo.rBufferFormat.u4HSampleFactor[2] = _u4ImgReszVfyHSampleFactor[2];
    //rSrcImgInfo.rBufferFormat.u4VSampleFactor[0] = _u4ImgReszVfyVSampleFactor[0];
    //rSrcImgInfo.rBufferFormat.u4VSampleFactor[1] = _u4ImgReszVfyVSampleFactor[1];
    //rSrcImgInfo.rBufferFormat.u4VSampleFactor[2] = _u4ImgReszVfyVSampleFactor[2];
    rSrcImgInfo.u4BufWidth = u4SrcBufWidth;
    //rSrcImgInfo.u4BufHeight = ;
    rSrcImgInfo.u4ImgWidth = u4SrcImgWidth;
    rSrcImgInfo.u4ImgHeight = u4SrcImgHeight;
    rSrcImgInfo.u4ImgXOff = 0;
    rSrcImgInfo.u4ImgYOff = 0;
    rSrcImgInfo.u4BufSA1 = u4SrcBufSA1;
    rSrcImgInfo.u4BufSA2 = u4SrcBufSA2;
    //rSrcImgInfo.u4BufSA3 = u4SrcBufSA3;
    i4ImgResz_HAL_Set_Source_Image_Info(u4HwId,&rSrcImgInfo);
    memset(&rDestImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
    rDestImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;
    //rDestImgInfo.rBufferFormat.eYUVFormat = eDestYUVFormat;
    rDestImgInfo.rBufferFormat.fgBlockMode = FALSE;
    rDestImgInfo.rBufferFormat.fgAddrSwap = FALSE;
    rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
    rDestImgInfo.u4BufWidth = u4DestBufWidth;
    rDestImgInfo.u4BufHeight = u4DestBufHeight;
    rDestImgInfo.u4ImgWidth = u4DestImgWidth;
    rDestImgInfo.u4ImgHeight = u4DestImgHeight;
    rDestImgInfo.u4ImgXOff = u4DestImgXOff;
    rDestImgInfo.u4ImgYOff = u4DestImgYOff;
    rDestImgInfo.u4BufSA1 = u4DestBufSA1;
    //rDestImgInfo.u4BufSA2 = _u4DestBufSA2;
    //rDestImgInfo.u4BufSA3 = _u4DestBufSA3;
    i4ImgResz_HAL_Set_Destination_Image_Info(u4HwId,&rDestImgInfo);

    i4ImgResz_HAL_Resize(u4HwId);
    while(TRUE)
    {
        if(i4ImgResz_HAL_Get_Resize_Status(u4HwId)>=0)
            break;
    }

    i4ImgResz_HAL_Uninit(u4HwId);
    i4ImgResz_HAL_Boot_Uninit();
}


//////////////////////////////////////////////////////////////////////////////////////
//
//  Interface for Jpeg Progressive Preload
//
//////////////////////////////////////////////////////////////////////////////////////
void vImgReszVfyJpegPreloadInit(UINT32 u4HwId,UINT32 u4SrcBufWidth,
                                              UINT32 u4SrcImgWidth,UINT32 u4SrcImgHeight,
                                              UINT32 u4SrcBufSA1,UINT32 u4SrcBufSA2,UINT32 u4SrcBufSA3,
                                              UINT32 u4DestBufWidth,UINT32 u4DestBufHeight,
                                              UINT32 u4DestImgWidth,UINT32 u4DestImgHeight,
                                              UINT32 u4DestImgXOff,UINT32 u4DestImgYOff,
                                              UINT32 u4DestBufSA1,UINT32 u4DestBufSA2,
                                              UINT32 u4HSampleFactor0,UINT32 u4VSampleFactor0,
                                              UINT32 u4HSampleFactor1,UINT32 u4VSampleFactor1,
                                              UINT32 u4HSampleFactor2,UINT32 u4VSampleFactor2,
                                              BOOL fgYExist,BOOL fgCbExist, BOOL fgCrExist
)
{
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_JPEG_INFO_T rJpegInfo;

    i4ImgResz_HAL_Boot_Init();
    i4ImgResz_HAL_Init(u4HwId);
    i4ImgResz_HAL_Set_Resize_Mode(u4HwId,IMGRESZ_HAL_RESIZE_MODE_FRAME);
    i4ImgResz_HAL_Set_Resample_Method(u4HwId,IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR,
                                             IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR);
    memset(&rSrcImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    rSrcImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER;
    rSrcImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;
    rSrcImgInfo.rBufferFormat.fgBlockMode = FALSE;
    rSrcImgInfo.rBufferFormat.fgAddrSwap = FALSE;
    rSrcImgInfo.rBufferFormat.u4HSampleFactor[0] = u4HSampleFactor0;
    rSrcImgInfo.rBufferFormat.u4HSampleFactor[1] = u4HSampleFactor1;
    rSrcImgInfo.rBufferFormat.u4HSampleFactor[2] = u4HSampleFactor2;
    rSrcImgInfo.rBufferFormat.u4VSampleFactor[0] = u4VSampleFactor0;
    rSrcImgInfo.rBufferFormat.u4VSampleFactor[1] = u4VSampleFactor1;
    rSrcImgInfo.rBufferFormat.u4VSampleFactor[2] = u4VSampleFactor2;
    rSrcImgInfo.u4BufWidth = u4SrcBufWidth;
    rSrcImgInfo.u4BufHeight = u4SrcImgHeight;
    rSrcImgInfo.u4ImgWidth = u4SrcImgWidth;
    rSrcImgInfo.u4ImgHeight = u4SrcImgHeight;
    rSrcImgInfo.u4ImgXOff = 0;
    rSrcImgInfo.u4ImgYOff = 0;
    rSrcImgInfo.u4BufSA1 = u4SrcBufSA1;
    rSrcImgInfo.u4BufSA2 = u4SrcBufSA2;
    rSrcImgInfo.u4BufSA3 = u4SrcBufSA3;
    i4ImgResz_HAL_Set_Source_Image_Info(u4HwId,&rSrcImgInfo);
    memset(&rDestImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER;
    rDestImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;
    rDestImgInfo.rBufferFormat.eYUVFormat = IMGRESZ_HAL_IMG_YUV_FORMAT_420;
    rDestImgInfo.rBufferFormat.fgBlockMode = FALSE;
    rDestImgInfo.rBufferFormat.fgAddrSwap = FALSE;
    rDestImgInfo.u4BufWidth = u4DestBufWidth;
    rDestImgInfo.u4BufHeight = u4DestBufHeight;
    rDestImgInfo.u4ImgWidth = u4DestImgWidth;
    rDestImgInfo.u4ImgHeight = u4DestImgHeight;
    rDestImgInfo.u4ImgXOff = u4DestImgXOff;
    rDestImgInfo.u4ImgYOff = u4DestImgYOff;
    rDestImgInfo.u4BufSA1 = u4DestBufSA1;
    rDestImgInfo.u4BufSA2 = u4DestBufSA2;
    //rDestImgInfo.u4BufSA3 =;

    i4ImgResz_HAL_Set_Destination_Image_Info(u4HwId,&rDestImgInfo);

    memset(&rJpegInfo,0,sizeof(IMGRESZ_HAL_JPEG_INFO_T));
    rJpegInfo.fgPictureMode = FALSE;
    rJpegInfo.fgPreloadMode = TRUE;
    rJpegInfo.fgYExist = fgYExist;
    rJpegInfo.fgCbExist = fgCbExist;
    rJpegInfo.fgCrExist = fgCrExist;
    i4ImgResz_HAL_Set_Jpeg_Info(u4HwId,&rJpegInfo);
    i4ImgResz_HAL_Resize(u4HwId);
}

//////////////////////////////////////////////////////////////////////////////////////
//
//  Interface for Jpeg Progressive Preload, Change by chunze
//
//////////////////////////////////////////////////////////////////////////////////////
void vImgReszVfyJpegPreloadInitEnhanceMCUROW(UINT32 u4HwId,UINT32 u4SrcBufWidth,
                                              UINT32 u4SrcImgWidth,UINT32 u4SrcImgHeight,
                                              UINT32 u4SrcBufSA1,UINT32 u4SrcBufSA2,UINT32 u4SrcBufSA3,
                                              UINT32 u4DestBufWidth,UINT32 u4DestBufHeight,
                                              UINT32 u4DestImgWidth,UINT32 u4DestImgHeight,
                                              UINT32 u4DestImgXOff,UINT32 u4DestImgYOff,
                                              UINT32 u4DestBufSA1,UINT32 u4DestBufSA2,
                                              UINT32 u4HSampleFactor0,UINT32 u4VSampleFactor0,
                                              UINT32 u4HSampleFactor1,UINT32 u4VSampleFactor1,
                                              UINT32 u4HSampleFactor2,UINT32 u4VSampleFactor2,
                                              BOOL fgYExist,BOOL fgCbExist, BOOL fgCrExist,
                                              BOOL fgAYUVOutput,BOOL fgFirstScan
)
{
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_JPEG_INFO_T rJpegInfo;

    UINT32 u4RowBufHeight = 16;
    UINT32 u4RowBufY;
    IMGRESZ_HAL_PARTIAL_BUF_INFO_T rSrcRowBufInfo;
    UINT32 u4TempLineBuf;

    //UINT32 u4TempCbBuf, u4TempCrBuf;
    
   // if(fgFirstRow)
    {
    
    i4ImgResz_HAL_Boot_Init();
    i4ImgResz_HAL_Init(u4HwId);
    //i4ImgResz_HAL_Set_Resize_Mode(u4HwId,IMGRESZ_HAL_RESIZE_MODE_FRAME);
    i4ImgResz_HAL_Set_Resize_Mode(u4HwId,IMGRESZ_HAL_RESIZE_MODE_PARTIAL);
    i4ImgResz_HAL_Set_Resample_Method(u4HwId,IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR,
                                             IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR);
    memset(&rSrcImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    
    rSrcImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER;
    rSrcImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;
    rSrcImgInfo.rBufferFormat.fgBlockMode = FALSE;
    rSrcImgInfo.rBufferFormat.fgAddrSwap = FALSE;
    rSrcImgInfo.rBufferFormat.u4HSampleFactor[0] = u4HSampleFactor0;
    rSrcImgInfo.rBufferFormat.u4HSampleFactor[1] = u4HSampleFactor1;
    rSrcImgInfo.rBufferFormat.u4HSampleFactor[2] = u4HSampleFactor2;
    rSrcImgInfo.rBufferFormat.u4VSampleFactor[0] = u4VSampleFactor0;
    rSrcImgInfo.rBufferFormat.u4VSampleFactor[1] = u4VSampleFactor1;
    rSrcImgInfo.rBufferFormat.u4VSampleFactor[2] = u4VSampleFactor2;
    rSrcImgInfo.u4BufWidth = u4SrcBufWidth;
    rSrcImgInfo.u4BufHeight = u4SrcImgHeight;
    rSrcImgInfo.u4ImgWidth = u4SrcImgWidth;
    rSrcImgInfo.u4ImgHeight = u4SrcImgHeight;
    rSrcImgInfo.u4ImgXOff = 0;
    rSrcImgInfo.u4ImgYOff = 0;
    rSrcImgInfo.u4BufSA1 = u4SrcBufSA1;
    rSrcImgInfo.u4BufSA2 = u4SrcBufSA2;
    rSrcImgInfo.u4BufSA3 = u4SrcBufSA3;
    i4ImgResz_HAL_Set_Source_Image_Info(u4HwId,&rSrcImgInfo);
    memset(&rDestImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
    if(fgAYUVOutput)
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
    else
    rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_C_BUFFER;
    rDestImgInfo.rBufferFormat.fgProgressiveFrame = TRUE;
    rDestImgInfo.rBufferFormat.eYUVFormat = IMGRESZ_HAL_IMG_YUV_FORMAT_420;
    rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
    rDestImgInfo.rBufferFormat.fgBlockMode = FALSE;
    rDestImgInfo.rBufferFormat.fgAddrSwap = FALSE;
    rDestImgInfo.u4BufWidth = u4DestBufWidth;
    rDestImgInfo.u4BufHeight = u4DestBufHeight;
    rDestImgInfo.u4ImgWidth = u4DestImgWidth;
    rDestImgInfo.u4ImgHeight = u4DestImgHeight;
    rDestImgInfo.u4ImgXOff = u4DestImgXOff;
    rDestImgInfo.u4ImgYOff = u4DestImgYOff;
    rDestImgInfo.u4BufSA1 = u4DestBufSA1;
    rDestImgInfo.u4BufSA2 = u4DestBufSA2;
    //rDestImgInfo.u4BufSA3 =;
    
    i4ImgResz_HAL_Set_Destination_Image_Info(u4HwId,&rDestImgInfo);

    memset(&rJpegInfo,0,sizeof(IMGRESZ_HAL_JPEG_INFO_T));
    rJpegInfo.fgPictureMode = FALSE;
    if(fgFirstScan)
        rJpegInfo.fgPreloadMode = FALSE;
    else
    rJpegInfo.fgPreloadMode = TRUE;
    rJpegInfo.fgYExist = fgYExist;
    rJpegInfo.fgCbExist = fgCbExist;
    rJpegInfo.fgCrExist = fgCrExist;
    i4ImgResz_HAL_Set_Jpeg_Info(u4HwId,&rJpegInfo);
    }
    u4TempLineBuf = (UINT32)imgreszvfy_alloc_mem_aligned(rDestImgInfo.u4BufWidth*3,16);
    x_memset(&rSrcRowBufInfo,0,sizeof(IMGRESZ_HAL_PARTIAL_BUF_INFO_T));
        rSrcRowBufInfo.u4RowBufHeight = u4RowBufHeight;

    for(u4RowBufY=0; u4RowBufY<rSrcImgInfo.u4ImgHeight; u4RowBufY+=u4RowBufHeight)  
    { 
         if(u4RowBufY == 0)
         {    
             rSrcRowBufInfo.fgFirstRowBuf = TRUE;
         }
         else
             rSrcRowBufInfo.fgFirstRowBuf = FALSE;

         if((u4RowBufY + u4RowBufHeight) < rSrcImgInfo.u4ImgHeight)
             rSrcRowBufInfo.fgLastRowBuf = FALSE;
         else
             rSrcRowBufInfo.fgLastRowBuf = TRUE;

         rSrcRowBufInfo.u4PrevRowBufSA1 = rSrcRowBufInfo.u4CurRowBufSA1;
         rSrcRowBufInfo.u4PrevRowBufSA2 = rSrcRowBufInfo.u4CurRowBufSA2;
         rSrcRowBufInfo.u4PrevRowBufSA3 = rSrcRowBufInfo.u4CurRowBufSA3;

         rSrcRowBufInfo.u4CurRowBufSA1 = rSrcImgInfo.u4BufSA1 + u4RowBufY * rSrcImgInfo.u4BufWidth;
         if(rSrcImgInfo.rBufferFormat.eBufferMainFormat == IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_Y_CB_CR_BUFFER)            
         {                
              UINT32 u4BufWidthC;
   #if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8560)                   	        
              if((rSrcImgInfo.rBufferFormat.u4HSampleFactor[1] <rSrcImgInfo.rBufferFormat.u4HSampleFactor[0])                 
                 && (rSrcImgInfo.rBufferFormat.u4HSampleFactor[2] < rSrcImgInfo.rBufferFormat.u4HSampleFactor[0]))
              {                 
                  // u4BufWidthC =((rSrcImgInfo.u4BufWidth/2 + 15) /16) * 16;
                   u4BufWidthC = rSrcImgInfo.u4BufWidth;
              }
              else    	       
              {    	          
                   u4BufWidthC = rSrcImgInfo.u4BufWidth;    	       
              }
   #else                
              u4BufWidthC = rSrcImgInfo.u4BufWidth;
   #endif                
              u4BufWidthC = rSrcImgInfo.u4BufWidth;
              rSrcRowBufInfo.u4CurRowBufSA2 = rSrcImgInfo.u4BufSA2 + (u4RowBufY
                                              * rSrcImgInfo.rBufferFormat.u4VSampleFactor[1]
                                              / rSrcImgInfo.rBufferFormat.u4VSampleFactor[0])
                                               * u4BufWidthC;
              rSrcRowBufInfo.u4CurRowBufSA3 = rSrcImgInfo.u4BufSA3 + (u4RowBufY
                                               * rSrcImgInfo.rBufferFormat.u4VSampleFactor[2] 
                                               / rSrcImgInfo.rBufferFormat.u4VSampleFactor[0]) 
                                               * u4BufWidthC;  
              //rSrcRowBufInfo.u4CurRowBufSA2 = rSrcImgInfo.u4BufSA2 + (u4RowBufY)* u4BufWidthC;
              //rSrcRowBufInfo.u4CurRowBufSA3 = rSrcImgInfo.u4BufSA3 + (u4RowBufY) * u4BufWidthC; 
        }

        i4ImgResz_HAL_Set_Partial_Mode_Info(u4HwId,&rSrcRowBufInfo,u4TempLineBuf);
    
    i4ImgResz_HAL_Resize(u4HwId);
        while(TRUE)            
        {                
            if(i4ImgResz_HAL_Get_Resize_Status(u4HwId)>=0)                    
                break;            
        }
    
    }
    imgreszvfy_free_mem_aligned((void *)u4TempLineBuf);
    i4ImgResz_HAL_Uninit(u4HwId);
}


INT32 i4ImgReszVfyJpegPreloadGetResizeStatus(UINT32 u4HwId)
{
    return i4ImgResz_HAL_Get_Resize_Status(u4HwId);
}


void vImgReszVfyJpegPreloadUninit(UINT32 u4HwId)
{
    i4ImgResz_HAL_Uninit(u4HwId);
    i4ImgResz_HAL_Boot_Uninit();
}

void vImgReszSpecialCaseForWT(void *argv)
{
#if 1
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rWTImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    char bFileName[256];

    UINT32 u4SrcARGB = 1;
    UINT32 u4DstARGB = 1;
    UINT32 fgSrcBypass = 1;
    UINT32 u4SrcBufferAddr;
    UINT32 u4DstBufferAddr;
    UINT32 u4WTBufferAddr;

    UINT32 u4HwId;
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    UINT32 u4BufSize;
    BYTE **ppbFileList;
    UINT32 u4TestCount = 1;
    BOOL   fgGenGolden = TRUE;

    char bSouceName[256];
    UINT32 u4Temp;
    UINT32 u4Temp1;
   
#if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8560)
    u4HwId = 0;
#else
    u4HwId = 1;
#endif

#if IMGRESZ_IO_MMU_TEST
    u4BufSize = 448 * 640 * 4;
    u4SrcBufferAddr = (UINT32)x_mem_alloc(u4BufSize); 
    u4WTBufferAddr = (UINT32)GGT_get_vmem(u4BufSize); 
    u4DstBufferAddr = (UINT32)GGT_get_vmem(u4BufSize/4);
    vMMUDebug(u4SrcBufferAddr);
    vMMUDebug(u4WTBufferAddr);	 
    vMMUDebug(u4DstBufferAddr);
    
#else	 
    u4SrcBufferAddr = (UINT32)imgreszvfy_alloc_mem_aligned(448 * 640 * 4, 1024);
    u4WTBufferAddr = (UINT32)imgreszvfy_alloc_mem_aligned(448 * 640 * 4, 1024);
    u4DstBufferAddr = (UINT32)imgreszvfy_alloc_mem_aligned(224 * 320 * 4, 1024);
#endif
    u4BufSize = 448 * 640 * 4;
    i4ImgReszVfyPrintf("[ImgResz][Verify] SRC buffer size : %d,Src addr :%x.\n",u4BufSize,u4SrcBufferAddr);    
    i4ImgReszVfyPrintf("[ImgResz][Verify] WT buffer size : %d,WT addr :%x.\n",u4BufSize,u4WTBufferAddr); 
    i4ImgReszVfyPrintf("[ImgResz][Verify] DST buffer size : %d,DST addr :%x.\n",(u4BufSize/4),u4DstBufferAddr);

    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY((void *)u4FileListSA != NULL);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != NULL);
   #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  

    x_thread_delay(200);
    i4ImgReszVfyPrintf("[ImgResz][Verify] Load Buffer File %s\n",bFileName);
	    // Turn on WT
   // *((volatile UINT32*)(IO_BASE + WT_REG_OFFSET)) = 0xe82a6f11;  
 while(1)  
 {
     u4Temp =  ((UINT32)rand()) %11;
     i4ImgReszVfyPrintf("[ImgResz][Verify] Src X offset is : %d.\n",u4Temp);
     u4Temp1 =  ((UINT32)rand()) %10;
     //i4ImgReszVfyPrintf("[ImgResz][Verify] Src Y offset is : %d.\n",u4Temp1);	 
     fgGenGolden = TRUE; 
     u4TestCount = 1;
     while(u4TestCount < 12)
     {
	    BOOL fgCompareError = FALSE;

	    //generate src info
        // x_thread_delay(500);
        memset(&rSrcImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        if(u4SrcARGB)
        {
            rSrcImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
            rSrcImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
        }
        else
        {
            rSrcImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
        }
        if(fgSrcBypass)
        {
            rSrcImgInfo.rBufferFormat.fgWT = FALSE;
        }
        else
        {
            rSrcImgInfo.rBufferFormat.fgWT = TRUE;
        }	 
        rSrcImgInfo.rBufferFormat.fgAddrSwap = FALSE;
        rSrcImgInfo.u4BufWidth = 448 * 4;
        rSrcImgInfo.u4BufHeight = 640;
        rSrcImgInfo.u4ImgWidth = 438;
        rSrcImgInfo.u4ImgHeight = 640;
        rSrcImgInfo.u4ImgXOff = u4Temp;
        rSrcImgInfo.u4ImgYOff = 0;//u4Temp1;
        rSrcImgInfo.u4BufSA1 = u4SrcBufferAddr;

	    //generate wt info
	    memset(&rWTImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
	    x_memcpy(&rWTImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rWTImgInfo.rBufferFormat.fgWT = FALSE;
	    rWTImgInfo.u4BufSA1 = u4WTBufferAddr;
	 
	    //generate dest info
        memset(&rDestImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        if(u4DstARGB)
        {
            rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
            rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
        }
        else
        {
            rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
        }
        rDestImgInfo.rBufferFormat.fgWT = FALSE;
        rDestImgInfo.rBufferFormat.fgAddrSwap = FALSE;
        rDestImgInfo.u4BufWidth = 224 * 4;
        rDestImgInfo.u4BufHeight = 320;
        rDestImgInfo.u4ImgWidth = 224;
        rDestImgInfo.u4ImgHeight = 320;
        rDestImgInfo.u4ImgXOff = 0;
        rDestImgInfo.u4ImgYOff = 0;
        rDestImgInfo.u4BufSA1 = u4DstBufferAddr;

        x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
	    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
        rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);	   
        VERIFY(rDestFitImgInfo.u4BufSA1 != 0);  

		
        // Resize source buffer to WT buffer
        i4ImgReszVfyResz(u4HwId,IMGRESZ_HAL_RESIZE_MODE_FRAME,
                                       IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR,IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR,
                                       &rSrcImgInfo,&rWTImgInfo,0);
				
        // Resize WT buffer to destination buffer
        i4ImgReszVfyResz(u4HwId,IMGRESZ_HAL_RESIZE_MODE_FRAME,
                                         IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR,IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR,
                                         &rWTImgInfo,&rDestImgInfo,0);

	    u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
        x_memcpy((void *)rDestFitImgInfo.u4BufSA1,(void *)rDestImgInfo.u4BufSA1,u4BufSize);

	    sprintf(bSouceName,"%s.source",(char *)ppbFileList[0]);
	
	    if( fgGenGolden)
        {
             // Copy destination fit buffer to destination golden buffer
              x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));            
              u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
              rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
              VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);                
              x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);
                        
              // Save destination file
              i4ImgReszVfySaveDestBuf(bSouceName,0,&rSrcImgInfo);
              i4ImgReszVfySaveDestBuf(ppbFileList[0],0,&rDestGoldImgInfo);
              fgGenGolden = FALSE;
        } 
	    else
        {
              UINT32 u4I;
              UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
              UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

              i4ImgReszVfyPrintf("[ImgResz][Verify] 2Compare.\n");                
              // Compare to golden
              u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
              for(u4I=0; u4I<u4BufSize; u4I++)
              {
                   if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                   {
                       i4ImgReszVfyPrintf("[ImgResz][Verify] 2Compare error\n");
			           fgCompareError = TRUE;
			           break;
                   }			   
                   u4DestFitAddr++;
                   u4DestGoldAddr++;
               }
               if(fgCompareError)
		       {
		           i4ImgReszVfySaveDestBuf(bSouceName,u4TestCount,&rSrcImgInfo);
		           i4ImgReszVfySaveDestBuf(ppbFileList[0],u4TestCount,&rDestImgInfo);
			       ASSERT(0);
               }
			   else
               {
                   i4ImgReszVfyPrintf("[ImgResz][Verify] 2Compare complete.\n");
               }
                   
         }  
	     u4TestCount++;
	     imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
         i4ImgReszVfyPrintf("[ImgResz][Verify] 2Reszr Done One Time\n"); 
         //  x_cli_parser("cd ..");
	     //x_cli_parser("drv.os.spa");
       }

	   imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);

    }
 
#if IMGRESZ_IO_MMU_TEST
    x_mem_free((void *)u4SrcBufferAddr);
    x_mem_free((void *)u4WTBufferAddr);
    x_free_vmem((void *)u4DstBufferAddr);
#else
    imgreszvfy_free_mem_aligned((void *)u4DstBufferAddr);
    imgreszvfy_free_mem_aligned((void *)u4SrcBufferAddr);
    imgreszvfy_free_mem_aligned((void *)u4WTBufferAddr);
#endif
    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);
    imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
#else
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;

    UINT32 u4SrcBufferAddr;
    UINT32 u4DstBufferAddr;

    UINT32 u4LoopCnt = 0;

    u4SrcBufferAddr = (UINT32)imgreszvfy_alloc_mem_aligned(440 * 640 * 4, 1024);
    u4DstBufferAddr = (UINT32)imgreszvfy_alloc_mem_aligned(220 * 320 * 4, 1024);

    *((volatile UINT32*)(0x70040800)) = (*((volatile UINT32*)(0x70040800))) & 0xFFFEFFFF;

    x_thread_delay(200);


    while(1)
    {
        i4ImgResz_HAL_Boot_Init();
        i4ImgResz_HAL_Init(1);
        i4ImgResz_HAL_Set_Resize_Mode(1,IMGRESZ_HAL_RESIZE_MODE_FRAME);
        i4ImgResz_HAL_Set_Resample_Method(1,IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR,
                                             IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR);
        memset(&rSrcImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rSrcImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
        rSrcImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
        rSrcImgInfo.rBufferFormat.fgWT = FALSE;
        rSrcImgInfo.rBufferFormat.fgAddrSwap = FALSE;
        rSrcImgInfo.u4BufWidth = 320 * 4;
        rSrcImgInfo.u4BufHeight = 240;
        rSrcImgInfo.u4ImgWidth = 320;
        rSrcImgInfo.u4ImgHeight = 240;
        rSrcImgInfo.u4ImgXOff = 0;
        rSrcImgInfo.u4ImgYOff = 0;
        rSrcImgInfo.u4BufSA1 = u4SrcBufferAddr;
        i4ImgResz_HAL_Set_Source_Image_Info(1,&rSrcImgInfo);
        memset(&rDestImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
        rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
        rDestImgInfo.rBufferFormat.fgWT = TRUE;
        rDestImgInfo.rBufferFormat.fgAddrSwap = FALSE;
        rDestImgInfo.u4BufWidth = 160 * 4;
        rDestImgInfo.u4BufHeight = 120;
        rDestImgInfo.u4ImgWidth = 160;
        rDestImgInfo.u4ImgHeight = 120;
        rDestImgInfo.u4ImgXOff = 0;
        rDestImgInfo.u4ImgYOff = 0;
        rDestImgInfo.u4BufSA1 = u4DstBufferAddr;
        i4ImgResz_HAL_Set_Destination_Image_Info(1,&rDestImgInfo);

        i4ImgResz_HAL_Resize(1);

        while(TRUE)
        {
            if(i4ImgResz_HAL_Get_Resize_Status(1)>=0)
                break;
        }
        u4LoopCnt++;
        if((u4LoopCnt % 100)== 0)
        {
            i4ImgReszVfyPrintf("[ImgResz][Verify] Reszr Done 100 or 0 Times\n");
        }
        i4ImgResz_HAL_Uninit(1);
        i4ImgResz_HAL_Boot_Uninit();
    }
#endif
}

void vImgreszForWT(void)
{
  HANDLE_T hThread1;

  if (x_thread_create(&hThread1, "IMGRESZ", 1024, 160,
        vImgReszSpecialCaseForWT, 0, NULL) != OSR_OK)
  {

    ASSERT(0);
  }
  x_thread_delay(200);
}

UINT32 g_u4ImgreszLoadFileFinished = FALSE;

void vImgReszSpecialCaseForWT1(void *argv)
{
    IMGRESZ_HAL_IMG_INFO_T rSrcImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestFitImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rWTImgInfo;
    IMGRESZ_HAL_IMG_INFO_T rDestGoldImgInfo;
    char bFileName[256];
    //BOOL fgLoadDst = FALSE;

    UINT32 u4SrcARGB = 1;
    UINT32 u4DstARGB = 1;
    UINT32 fgSrcBypass = 1;
    UINT32 u4SrcBufferAddr;
    UINT32 u4DstBufferAddr;
    UINT32 u4WTBufferAddr;

    UINT32 u4HwId;
    UINT32 u4FileListSA;
    UINT32 u4FileListBufSize = _u4ImgReszFileListMax*256;
    UINT32 u4FileListNum = 0;
    UINT32 u4BufSize;
    BYTE **ppbFileList;
    UINT32 u4TestCount = 0;
    BOOL   fgGenGolden = TRUE;

   char bSouceName[256];

#if (CONFIG_CHIP_VER_CURR >= CONFIG_CHIP_VER_MT8560)
    u4HwId = 0;
#else
    u4HwId = 1;
#endif

#if IMGRESZ_IO_MMU_TEST
     u4BufSize = 448 * 640 * 4;
    u4SrcBufferAddr = (UINT32)GGT_get_vmem(u4BufSize);
    u4WTBufferAddr = (UINT32)GGT_get_vmem(u4BufSize);
    u4DstBufferAddr = (UINT32)GGT_get_vmem(u4BufSize/4);
     vMMUDebug(u4SrcBufferAddr);
     vMMUDebug(u4WTBufferAddr);
     vMMUDebug(u4DstBufferAddr);
#else
    u4SrcBufferAddr = (UINT32)imgreszvfy_alloc_mem_aligned(448 * 640 * 4, 1024);
    u4WTBufferAddr = (UINT32)imgreszvfy_alloc_mem_aligned(448 * 640 * 4, 1024);
    u4DstBufferAddr = (UINT32)imgreszvfy_alloc_mem_aligned(224 * 320 * 4, 1024);
#endif
    u4BufSize = 448 * 640 * 4;
    i4ImgReszVfyPrintf("[ImgResz][Verify] SRC buffer size : %d,Src addr :%x.\n",u4BufSize,u4SrcBufferAddr);
    i4ImgReszVfyPrintf("[ImgResz][Verify] WT buffer size : %d,WT addr :%x.\n",u4BufSize,u4WTBufferAddr);
    i4ImgReszVfyPrintf("[ImgResz][Verify] DST buffer size : %d,DST addr :%x.\n",(u4BufSize/4),u4DstBufferAddr);

    u4FileListSA = (UINT32)imgreszvfy_alloc_mem_aligned(u4FileListBufSize,1);
    VERIFY((void *)u4FileListSA != NULL);
    ppbFileList = (BYTE **)imgreszvfy_alloc_mem_aligned(_u4ImgReszFileListMax*sizeof(BYTE *),sizeof(BYTE *));
    VERIFY(ppbFileList != NULL);
   #if IMG_RESZ_VFY_FILE_IO_TYPE==IMG_RESZ_VFY_FILE_IO_HDD_USBRW
    i4ImgReszVfyLoadFileList("/mnt/usb/imgresz_vfy/imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #else  
    i4ImgReszVfyLoadFileList("D:\\Projects\\MT8560_vfy\\IMG_RESZ\\imgreszlist.txt",u4FileListSA,u4FileListBufSize,
                             ppbFileList,&u4FileListNum);
   #endif  
    x_thread_delay(200);
    i4ImgReszVfyPrintf("[ImgResz][Verify] Load Buffer File %s\n",bFileName);
    // Turn on WT
    //*((volatile UINT32*)(IO_BASE + WT_REG_OFFSET)) = 0xe82a6f11; 
    while(1)
    {
	 BOOL fgCompareError = FALSE;

	//generate src info
       // x_thread_delay(500);
        memset(&rSrcImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        if(u4SrcARGB)
        {
            rSrcImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
            rSrcImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
        }
        else
        {
            rSrcImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
        }
        if(fgSrcBypass)
        {
            rSrcImgInfo.rBufferFormat.fgWT = FALSE;
        }
        else
        {
            rSrcImgInfo.rBufferFormat.fgWT = TRUE;
        }
        rSrcImgInfo.rBufferFormat.fgAddrSwap = FALSE;
        rSrcImgInfo.u4BufWidth = 448 * 4;
        rSrcImgInfo.u4BufHeight = 640;
        rSrcImgInfo.u4ImgWidth = 448;//438
        rSrcImgInfo.u4ImgHeight = 640;
        rSrcImgInfo.u4ImgXOff = 0;
        rSrcImgInfo.u4ImgYOff = 0;//0
        rSrcImgInfo.u4BufSA1 = u4SrcBufferAddr;

	 //generate wt info
	 memset(&rWTImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
	 x_memcpy(&rWTImgInfo,&rSrcImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        rWTImgInfo.rBufferFormat.fgWT = FALSE;
	 rWTImgInfo.u4BufSA1 = u4WTBufferAddr;

	    //memset(&rWTImgInfo.u4BufSA1,0,448 * 640 * 4);
	 //generate dest info
        memset(&rDestImgInfo,0,sizeof(IMGRESZ_HAL_IMG_INFO_T));
        if(u4DstARGB)
        {
            rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_ARGB_BUFFER;
            rDestImgInfo.rBufferFormat.eARGBBufferFormat = IMGRESZ_HAL_ARGB_BUFFER_FORMAT_8888;
        }
        else
        {
            rDestImgInfo.rBufferFormat.eBufferMainFormat = IMGRESZ_HAL_IMG_BUF_MAIN_FORMAT_AYUV_BUFFER;
        }
        rDestImgInfo.rBufferFormat.fgWT = FALSE;
        rDestImgInfo.rBufferFormat.fgAddrSwap = FALSE;
        rDestImgInfo.u4BufWidth = 224 * 4;
        rDestImgInfo.u4BufHeight = 320;
        rDestImgInfo.u4ImgWidth = 224;
        rDestImgInfo.u4ImgHeight = 320;
        rDestImgInfo.u4ImgXOff = 0;
        rDestImgInfo.u4ImgYOff = 0;
        rDestImgInfo.u4BufSA1 = u4DstBufferAddr;

       x_memcpy(&rDestFitImgInfo,&rDestImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
	u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
       rDestFitImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1);
       VERIFY(rDestFitImgInfo.u4BufSA1 != 0);


        // Resize source buffer to WT buffer
        i4ImgReszVfyResz(u4HwId,IMGRESZ_HAL_RESIZE_MODE_FRAME,
                                       IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR,IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR,
                                       &rSrcImgInfo,&rWTImgInfo,0);

        // Resize WT buffer to destination buffer
        i4ImgReszVfyResz(u4HwId,IMGRESZ_HAL_RESIZE_MODE_FRAME,
                                         IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR,IMGRESZ_HAL_RESAMPLE_METHOD_BILINEAR,
                                         &rWTImgInfo,&rDestImgInfo,0);

	 u4BufSize = rDestFitImgInfo.u4BufWidth * rDestFitImgInfo.u4BufHeight;
        x_memcpy((void *)rDestFitImgInfo.u4BufSA1,(void *)rDestImgInfo.u4BufSA1,u4BufSize);

	#if 1
	sprintf(bSouceName,"%s.source",(char *)ppbFileList[0]);
	if( fgGenGolden)
         {
             // Copy destination fit buffer to destination golden buffer
              x_memcpy(&rDestGoldImgInfo,&rDestFitImgInfo,sizeof(IMGRESZ_HAL_IMG_INFO_T));
              u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
              rDestGoldImgInfo.u4BufSA1 = (UINT32)imgreszvfy_alloc_mem_aligned(u4BufSize,1024);
              VERIFY(rDestGoldImgInfo.u4BufSA1 != 0);
              x_memcpy((void *)rDestGoldImgInfo.u4BufSA1,(void *)rDestFitImgInfo.u4BufSA1,u4BufSize);

              // Save destination file
              i4ImgReszVfySaveDestBuf(bSouceName,0,&rSrcImgInfo);
              i4ImgReszVfySaveDestBuf(ppbFileList[0],0,&rDestGoldImgInfo);

             // Output case info to resize info file
            /* i4ImgReszOutputCaseInfo(i4ReszInfoFileHandle,ppbFileList[u4CurFileListNum],u4TestCase,
                                            eResizeMode,eHResampleMethod,eVResampleMethod,
                                            !rDestFitImgInfo.rBufferFormat.fgProgressiveFrame,
                                            fgPreloadBuf,u4Alpha,0);*/
                    fgGenGolden = FALSE;
                 g_u4ImgreszLoadFileFinished = TRUE;
	    }
	    else
              {
                    UINT32 u4I;
                    UINT32 u4DestGoldAddr = rDestGoldImgInfo.u4BufSA1;
                    UINT32 u4DestFitAddr = rDestFitImgInfo.u4BufSA1;

                    i4ImgReszVfyPrintf("[ImgResz][Verify] Compare.\n");
          i4ImgReszVfyPrintf("[ImgResz][Verify] u4DestGoldAddr=%x, u4DestFitAddr=%x.\n",u4DestGoldAddr,u4DestFitAddr); 
                    // Compare to golden
          //HalFlushInvalidateDCache();	//chunze
                    u4BufSize = rDestGoldImgInfo.u4BufWidth * rDestGoldImgInfo.u4BufHeight;
                    for(u4I=0; u4I<u4BufSize; u4I++)
                    {
                        if(*(UINT8 *)(u4DestFitAddr) != *(UINT8 *)(u4DestGoldAddr))
                         {
                           i4ImgReszVfyPrintf("[ImgResz][Verify] Compare error\n");
			      fgCompareError = TRUE;
			      break;
                          }
                        u4DestFitAddr++;
                        u4DestGoldAddr++;
                     }
                    if(fgCompareError)
		       {
		         i4ImgReszVfySaveDestBuf(bSouceName,u4TestCount,&rSrcImgInfo);
		         i4ImgReszVfySaveDestBuf(ppbFileList[0],u4TestCount,&rDestImgInfo);
			  ASSERT(0);
                    	}else
                    	{
                    	  i4ImgReszVfyPrintf("[ImgResz][Verify] Compare complete.\n");
                    	}

                	}
	  #else
        if(fgLoadDst)
        {
            fgLoadDst = FALSE;
            strcpy(bFileName,(char *)ppbFileList[fgSrcBypass]);
            if(u4DstARGB)
            {
                strcat(bFileName,".0000.argb.bin");
            }
            else
            {
                strcat(bFileName,".0000.ayuv.bin");
            }
            i4ImgReszVfyPrintf("[ImgResz][Verify] Load Dest File %s\n",bFileName);
            i4ImgReszVfyWriteFile(bFileName,u4DstBufferAddr,220 * 320 * 4);
        }
	#endif

        	
	    imgreszvfy_free_mem_aligned((void *)rDestFitImgInfo.u4BufSA1);
        i4ImgReszVfyPrintf("[ImgResz][Verify] Reszr Done %d Time\n",u4TestCount); 
	u4TestCount++;
}
	
#if IMGRESZ_IO_MMU_TEST
    x_free_vmem((void *)u4SrcBufferAddr);
    x_free_vmem((void *)u4WTBufferAddr);
    x_free_vmem((void *)u4DstBufferAddr);
#else
    imgreszvfy_free_mem_aligned((void *)u4SrcBufferAddr);
    imgreszvfy_free_mem_aligned((void *)u4WTBufferAddr);
    imgreszvfy_free_mem_aligned((void *)u4DstBufferAddr);
#endif
    imgreszvfy_free_mem_aligned((void *)u4FileListSA);
    imgreszvfy_free_mem_aligned((void *)ppbFileList);
    imgreszvfy_free_mem_aligned((void *)rDestGoldImgInfo.u4BufSA1);
}

void vImgreszForWT1(void)
{
  HANDLE_T hThread1;

  if (x_thread_create(&hThread1, "IMGRESZ", 1024, 160,
        vImgReszSpecialCaseForWT1, 0, NULL) != OSR_OK)
  {

    ASSERT(0);
  }

  while (!g_u4ImgreszLoadFileFinished)
  {
  x_thread_delay(200);
}
}

