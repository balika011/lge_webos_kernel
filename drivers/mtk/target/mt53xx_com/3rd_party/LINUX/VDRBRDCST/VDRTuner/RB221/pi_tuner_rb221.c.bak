/*
  NOTE: This is glue layer code of RB221 driver but not perfect
  because Sony do not have much information about MTK software.
  Please modify it to fit MTK's system.
*/

#include "sonyrf_ascot2e_rb221.h"
#include "sonyrf_i2c_MTK.h"

#ifndef SONYRF_DUMMY_DEBUG // Only for dummy environment debug by Sony. Ignore it.
#include "tuner_interface_if.h"
#include "fe_tuner_common_if.h"
#include "i2c_api.h"
#include "x_typedef.h"
#include "tunerDebug.h"
#include "x_os.h"
#include "eq_script_rb221.h"
#endif // SONYRF_DUMMY_DEBUG

//-----------------------------------------------------------------------------
// Constant definitions
//-----------------------------------------------------------------------------
//Frequency boundary .Get from tuner spec
#define C_RB221_LO_ADDRESS           0xC0 // In 8bit form

#define C_RB221_FREQ_DBOUND_UPPER      1002*1000*1000
#define C_RB221_FREQ_DBOUND_LOWER        42*1000*1000
#define C_RB221_FREQ_DBOUND_UPPER_Ana  1002*1000*1000
#define C_RB221_FREQ_DBOUND_LOWER_Ana    42*1000*1000

#define C_RB221_IF_FREQUENCY        ((UINT16)  3550)  /* kHz */
#define C_RB221_IF_FREQUENCY_ANA      ((UINT16)  5750)  /* kHz */
//#define RB221_ANA_LO_STEP             ((UINT16) 100)  /* 10Hz */
#define C_SONY_RB221_STR				"SONY_RB221 ES2 2010-01-01\n 2012-08-02\n v1.0\n"
/* Tuner control data type. */
typedef struct sonyrf_tuner_ctx
{
    sonyrf_ascot2e_t tuner;
    sonyrf_i2c_t     i2c;
    BOOL fgCable;    /* Analog signal input, 0:Air input, 1:Cable input */
} sonyrf_tuner_ctx;

/* Tuner control data instance. */
static sonyrf_tuner_ctx g_sonyrf_tuner_ctx;

#ifndef SONYRF_DUMMY_DEBUG
static UINT8* pRB221EqNormal[MOD_ANA_TYPE_END - MOD_ANA_TYPE_BEGIN] = {NULL};
static UINT8* pRB221EqWeak[MOD_ANA_TYPE_END - MOD_ANA_TYPE_BEGIN] = {NULL};

//Tuner releated ATD register
static ATD_TUNER_REL_REG_T arrAtdRelReg[]={
#if (defined CC_MT5396) || (defined CC_MT5368) || (defined CC_MT5389)|| (defined CC_MT5398)|| (defined CC_MT5880)
    {0x7D4,0x04},//PRA RF BIAS
    {0x7D5,0x00},//PRA IF BIAS 1
    {0x7D6,0x00},//PRA IF BIAS 2
    {0x7D7,0xEC},//PRA RF SCLOPE
    {0x7D8,0xF1},//PRA IF SLOPE 1
    {0x7D9,0xF1},//PRA IF SLOPE 2
    {0x7DA,0x7F},//PRA RF AGC MAXIMUM
    {0x7DB,0x7F},//PRA IF AGC MINIMUM
    {0x7DC,0x80},//PAR RF AGC MINIMUM
    {0x7DD,0x80},//PRA IF AGC MINIMUM 1
    {0x7DE,0x80},//PRA IF AGC MINIMUM 2
    {0x7DF,0x51},  //IFAGC PORIRITY
    {0x790,0x08},//DAGC DC REMOVER CONFIGURATION
    {0x794,0x30}, //DAGC Target H
    {0x7a4,0x30}, //DAGC Target L
    {0x7B7,0x10},//PRA STATIC TARGET LEVEL HIGH(MSB),degrade target level for lowif tuner(legacy)
    {0x7B9,0x10},//PRA STATIC TARGET LEVEL LOW(MSB)
    {0x00,0x00}//end flag
#else
    {0x2D4,0x04},//PRA RF BIAS
    {0x2D5,0x04},//PRA IF BIAS 1
    {0x2D6,0x04},//PRA IF BIAS 2
    {0x2D7,0xEC},//PRA RF SCLOPE
    {0x2D8,0xF4},//PRA IF SLOPE 1
    {0x2D9,0xF4},//PRA IF SLOPE 2
    {0x2DA,0x7F},//PRA RF AGC MAXIMUM
    {0x2DB,0x7F},//PRA IF AGC MINIMUM
    {0x2DC,0x80},//PAR RF AGC MINIMUM
    {0x2DD,0x80},//PRA IF AGC MINIMUM 1
    {0x2DE,0x80},//PRA IF AGC MINIMUM 2
    {0x290,0x08},//DAGC DC REMOVER CONFIGURATION
    {0x294,0x38}, //DAGC Target H
    {0x2a4,0x28}, //DAGC Target L
    {0x2B7,0x10},//PRA STATIC TARGET LEVEL HIGH(MSB),degrade target level for lowif tuner(legacy)
    {0x2B9,0x10},//PRA STATIC TARGET LEVEL LOW(MSB)
    {0x00,0x00}//end flag
#endif
};

#endif // SONYRF_DUMMY_DEBUG

//-----------------------------------------------------------------------------
/** RB221_TunerInit
 *  Tuner initialzation for RB221.
 *  @param  pTCtx       Pointer of pi tuner driver context.
 *  @retval void
 */
//-----------------------------------------------------------------------------
VOID RB221_TunerInit(
    ITUNER_CTX_T *pTCtx
    )
{	ITUNER_CTX_T *psTunerCtx = pTCtx;

    sonyrf_result_t sonyrf_result = SONYRF_RESULT_OK;
    sonyrf_ascot2e_t *pTuner = &g_sonyrf_tuner_ctx.tuner;
    sonyrf_i2c_t *pI2c = &g_sonyrf_tuner_ctx.i2c;
	
	psTunerCtx->I2cAddress = C_RB221_LO_ADDRESS;
    psTunerCtx->u2IF_Freq = C_RB221_IF_FREQUENCY;
    psTunerCtx->u2IF_Freq_A = C_RB221_IF_FREQUENCY_ANA;//analog if frequency for ATD
#ifndef SONYRF_DUMMY_DEBUG
    //ATD patch selection
    psTunerCtx->u1AtdPatchSwitch =0x09;
    
    psTunerCtx->fgRFAGC = FALSE;//indicate if tuner need extern RF_AGC
    psTunerCtx->fgRFTuner =FALSE;//not sawless tuner,it include BPF internal

	// AGC para
     psTunerCtx->sAtdAgcPara.AgcRfBias = 0x2F;     //CJ 091021//0x19;
     psTunerCtx->sAtdAgcPara.AgcRfMin  = 0x80;
     psTunerCtx->sAtdAgcPara.AgcIfMin  = 0xD5;      //CJ 091021//0xE8;//Yueqin's test result 090925 0xEF;According to YueQin's advice 090921
     psTunerCtx->sAtdAgcPara.AgcDrSel  = 0x0B;
	// init EQ script
	pRB221EqNormal[MOD_NTSC_M - MOD_ANA_TYPE_BEGIN]  = EQRB221MN;
	pRB221EqWeak[MOD_NTSC_M - MOD_ANA_TYPE_BEGIN]  = EQRB221Weak;
    // ...
#endif // SONYRF_DUMMY_DEBUG

    // RB221 driver initialization
    g_sonyrf_tuner_ctx.fgCable = 0;
	mcDBG_MSG_L2((" %s \n", __FUNCTION__));

    // I2C struct initialization
    // NOTE: Please change following line depend on RF tuner I2C.
    //sonyrf_i2c_MTK_CreateI2c(pI2c); // Normal (via I2C repeater)
    sonyrf_i2c_MTK_CreateI2cGw(pI2c, 0xD8, 0x09); // I2C gateway

    // Tuner struct initialization
    sonyrf_ascot2e_rb221_Create(pTuner, pI2c);

    sonyrf_result = sonyrf_ascot2e_rb221_Initialize(pTuner);
    if(sonyrf_result != SONYRF_RESULT_OK){
        mcDBG_MSG_L1(("RB221Tuner: sonyrf_ascot2e_rb221_Initialize is failed. (%d)\n", sonyrf_result));
    }
	
}

//----------------------------------------------------------------------------- 
/**  RB221_TunerGetStatus
 *  Set Tuner PLL staus for RB221
 *  @param  pTCtx       Pointer of pi tuner driver context.
 *  @retval TRUE        PLL lock
 *  @retval FALSE       PLL unlock
 */
//-----------------------------------------------------------------------------
static BOOL RB221_TunerGetStatus(ITUNER_CTX_T *pTCtx)
{
    sonyrf_result_t sonyrf_result = SONYRF_RESULT_OK;
    sonyrf_ascot2e_t *pTuner = &g_sonyrf_tuner_ctx.tuner;

    UINT8 data = 0;
    mcDBG_MSG_L2((" %s \n",__FUNCTION__));

    /* Get DLD */
    sonyrf_result = pTuner->pI2c->ReadRegister(pTuner->pI2c, pTuner->i2cAddress, 0x1D, &data, 1);
    if(sonyrf_result != SONYRF_RESULT_OK){
        return FALSE;
    }

    if(data & 0x02){
        return TRUE;
    }else{
        return FALSE;
    }
}

//----------------------------------------------------------------------------- 
/** RB221_TunerSetFreq
 *  Set Tuner PLL for RB221 to tune RF frequency.
 *  @param  pTCtx       Pointer of pi tuner driver context.
 *  @param 	param    Pointer of structure of parameters
 *  @retval  0 success
                    1  fail   out of range 
                   -1  fail  I2C error 
 */
//-----------------------------------------------------------------------------
INT16 RB221_TunerSetFreq(
    ITUNER_CTX_T *pTCtx,
    PARAM_SETFREQ_T* param
    )
{
    sonyrf_result_t sonyrf_result = SONYRF_RESULT_OK;
    sonyrf_ascot2e_t *pTuner = &g_sonyrf_tuner_ctx.tuner;

    UINT32 Freq = param->Freq; // transfer to video freq(KHz)
    UINT8 Mode = param->Modulation;

    mcDBG_MSG_L2((" %s \n", __FUNCTION__));
    pTCtx->u4RF_Freq = Freq; // Update current frequency to context

    mcDBG_MSG_L2(("RB221Tuner: Set Freq %d KHz\n",Freq));
    if (Freq < (C_RB221_FREQ_DBOUND_LOWER/1000) || 
        Freq > (C_RB221_FREQ_DBOUND_UPPER/1000))
    {
        mcDBG_MSG_ERR(("RB221Tuner: Out of range for LO!\n"));
        return 1;
    }

    if(Mode == MOD_ISDBT){
        mcDBG_MSG_L2(("RB221Tuner: ISDB-T SetFreq (%d kHz)\n", Freq));
        sonyrf_result = sonyrf_ascot2e_rb221_AntSw(pTuner, 1); /* Set terrestrial input */
        if(sonyrf_result != SONYRF_RESULT_OK){
            return -1;
        }

        sonyrf_result = sonyrf_ascot2e_rb221_Tune(pTuner, Freq, SONYRF_ASCOT2E_DTV_ISDBT_6);
        if(sonyrf_result != SONYRF_RESULT_OK){
            return -1;
        }
    }else{
        mcDBG_MSG_L2(("RB221Tuner: Analog SetFreq (%d kHz, fgCable = %d)\n", Freq, g_sonyrf_tuner_ctx.fgCable));
        // Analog mode
        // Assume System-M

        // Switch input by g_sonyrf_tuner_ctx.fgCable flag
        sonyrf_result = sonyrf_ascot2e_rb221_AntSw(pTuner, g_sonyrf_tuner_ctx.fgCable ? 0 : 1);
        if(sonyrf_result != SONYRF_RESULT_OK){
            return -1;
        }

        sonyrf_result = sonyrf_ascot2e_rb221_Tune(pTuner, Freq, SONYRF_ASCOT2E_ATV_MN_SAP);
        if(sonyrf_result != SONYRF_RESULT_OK){
            return -1;
        }
    }
	x_thread_delay(50);

    return 0;
}

//----------------------------------------------------------------------------- 
/** RB221_TunerGetVer
 *  Get Tuner type version
 *  @param  pTCtx       Pointer of pi tuner driver context.
 *  @retval tuner model name
 */
//-----------------------------------------------------------------------------
static CHAR *RB221_TunerGetVer(VOID)
{
    return (C_SONY_RB221_STR);
}

//----------------------------------------------------------------------------- 
/** RB221_SetInMode
 *  Set Tuner for Cable or Air input mode
 *  @param  pTunerCtx       Pointer of pi tuner driver context.
 *  @param  bMode           Mode (0: Air, 1: Cable)
 *  @retval void
 */
//-----------------------------------------------------------------------------
static void RB221_SetInMode(ITUNER_CTX_T * pTunerCtx, BOOL bMode)
{
    g_sonyrf_tuner_ctx.fgCable = bMode;
    mcDBG_MSG_L2(("RB221Tuner: In Mode = %d (0: Air, 1:Cable)\n", g_sonyrf_tuner_ctx.fgCable));  
}


//----------------------------------------------------------------------------- 
/** RB221_TunerOP
 * Set/Get function
 *  @param  pTCtx       Pointer of pi tuner driver context.
 *  @param  eOperation       To Get/Set operation id
 *  @retval  ITUNER_OK    Operation Success
 *  @retval  ITUNER_NOT_OK    Operation fail
 *  @retval  ITUNER_NOT_SUPPORTED Operation not supported in  driver
 */
//-----------------------------------------------------------------------------
INT16 RB221_TunerOP(ITUNER_CTX_T * pTCtx, ITUNEROP_T eOperation, UINT8 SetVal,  VOID * pInOutVal)
{
    switch(eOperation){
    case itGetStatus:
        {
            BOOL * Retval=(BOOL *)pInOutVal;
            *Retval = RB221_TunerGetStatus(pTCtx);
        }
        break;
    case itGetVer:
        {
            CHAR ** RetStr=(CHAR **)pInOutVal;
            *RetStr = RB221_TunerGetVer();
        }
        break;
    case itSetInCableMode: 
        RB221_SetInMode(pTCtx,SetVal);
        break; 
#ifndef SONYRF_DUMMY_DEBUG
    case itGetEqScriptNormal: 
    *(UINT8**)pInOutVal = pRB221EqNormal[SetVal];
    break;
        
    case itGetEqScriptWeak: 
        *(UINT8**)pInOutVal = pRB221EqWeak[SetVal];
        break;
    case itGetTunerRelReg:
    {
    *(ATD_TUNER_REL_REG_T **)pInOutVal=arrAtdRelReg;
    }
    break;
#endif // SONYRF_DUMMY_DEBUG
    default:
        return ITUNER_NOT_SUPPORTED;
    }

    return ITUNER_OK;
}

/* For driver debug trace --------------------------------------------------- */
#ifdef SONYRF_TRACE_ENABLE
void sonyrf_trace_log_enter(const char* funcname, const char* filename, unsigned int linenum)
{
    mcDBG_MSG_L4(("RB221_ENTER : %s (%d)\n", funcname, linenum));
}
void sonyrf_trace_log_return(sonyrf_result_t result, const char* filename, unsigned int linenum)
{
    if(result != SONYRF_RESULT_OK){
        mcDBG_MSG_L4(("RB221_ERROR_RETURN(%d) : (line %d)\n", result, linenum));
    }else{
        mcDBG_MSG_L4(("RB221_RETURN : (line %d))\n", linenum));
    }
}

void sonyrf_trace_i2c_log_enter(const char* funcname, const char* filename, unsigned int linenum)
{
    sonyrf_trace_log_enter(funcname, filename, linenum);
}
void sonyrf_trace_i2c_log_return(sonyrf_result_t result, const char* filename, unsigned int linenum)
{
    sonyrf_trace_log_return(result, filename, linenum);
}
#endif /* SONYRF_TRACE_ENABLE */
