

#include "stdlib.h"
#include "string.h"
#include "tzst.h"
#include "dmx_drm_drvif.h"
#include <tomcrypt.h>
#include "crypto_types.h"
#include "bignum/bigdefs.h"
#include "bignum/bignum.h"
#include "bignum/field.h"
#include "bignum/fieldpriv.h"
#include "bignum/ecurve.h"
#include "bignum/mprand.h"
#include "drmeccp160.h"
#include "drmeccp256.h"
#include "crypto_results.h"



//#include "drmsha256.h"

static DRMBIGNUM_CONTEXT_STRUCT bigCtx;

/*
** Defines
*/
#define P256_KEY_GEN_TRIES ( 1000 )

/*
** Extern Defines
*/

extern const field_arithmetic_t prime_arithmetic;

/*
** Globals
*/

#if CRYPTO_PRECOMPUTE_GTABLE

#define ECC_P256_TABLE_SPACING 5
#define ECC_P256_TABLE_LAST 256


/*
 * Statically generated table using ecaffine_table_construction and table spacing of 5 and table length of 256
 */

static const digit_t TABLE[ ( ECC_P256_TABLE_LAST + 1 ) * ECC_P256_POINT_SIZE_IN_ECAFFINES ] = {

                0x18a9143c, 0x79e730d4, 0x5fedb601, 0x75ba95fc, 0x77622510, 0x79fb732b, 0xa53755c6, 0x18905f76, 0xce95560a, 0xddf25357, 0xba19e45c, 0x8b4ab8e4, 0xdd21f325, 0xd2e88688, 0x25885d85, 0x8571ff18, 0xc5e3a3d8, 0xd8c5fccf, 0x4079dfbf, 0xbefd904c, 0xfead0197, 0xbc6d6a58, 0x695532a4, 0x39227077, 0xdbef42f5, 
                0x09e23e6d, 0x480a9908, 0x7e449b64, 0xad9a2e40, 0x7b969c1a, 0x9591c2a4, 0x6231d792, 0x44cc3add, 0x4f7081e1, 0x87be82cf, 0xd5ffa1d6, 0x0edd6472, 0x89890b6c, 0x3ed17863, 0xada26e1a, 0x63483caa, 0x276f2715, 0x2f6077fd, 0xe6924cd9, 0x0a466e3c, 0x05a7fe98, 0xb1902d1f, 0xf1c794b0, 0x3b36f9fd, 
                0x79b0fe62, 0xfde19fc0, 0x26543b23, 0x958482ef, 0x136e64a0, 0x9b095825, 0x23f63771, 0xb6a1142e, 0x14cfd596, 0x335aac0b, 0x5ea6aac6, 0xf3081dd5, 0x86a0e8bd, 0x003dc12a, 0x5fb89d79, 0x584c5e20, 0xa7a8746a, 0xb9dc7035, 0x267e4ea1, 0xb9548c9b, 0x593a15cf, 0x4bd012f3, 0x5e6e2135, 0x8c8f936e, 
                0xdf31cc6a, 0xb5c241dc, 0x8af84d04, 0x345efb86, 0x63990a6f, 0xb9b962cb, 0x6fef4e61, 0x2c11bb37, 0x540234b2, 0xed4c74a3, 0x2d0366dd, 0xeec5f25d, 0xf9a968da, 0x67b63142, 0x36601068, 0x68d7b6d4, 0x07cd6d2c, 0x0c842942, 0xa8f74f09, 0x7768b1ee, 0xe2751404, 0xfe62aee4, 0x4b5f7e89, 0xa61a76fa, 
                0x55d5c68d, 0xca1554dc, 0x598b441d, 0x773b279c, 0xd39923b9, 0x36bf9efc, 0x33331d3c, 0x298de399, 0x2d4c848e, 0xa1a27f56, 0xcfdb8e77, 0x57b8ab70, 0x94c855ea, 0x6f7879ba, 0xdcdb9dae, 0x22248acc, 0xb2083a12, 0x3264e366, 0x1f6ec0ef, 0x5afdee28, 0x5659b704, 0xe6430bb5, 0x7a823a40, 0xe1900a79, 
                0x24592a04, 0xc9ee6576, 0xcde09d4a, 0x4b5ea54a, 0x52b6463f, 0xd3ca65a7, 0x1efe9ed3, 0x533ef217, 0x889f6d65, 0xc3ca2e87, 0x7158c7e4, 0xdc2b4167, 0xfb670dfb, 0x844c257f, 0x75910a01, 0xcf88577d, 0xf336bf07, 0xe45e2ace, 0x22245250, 0x7ca23d85, 0x2ed92e8d, 0x2b812f58, 0x29f8be4c, 0xea6c3997, 
                0x5ace5035, 0xc2610bef, 0x54259aaa, 0x3c80dd39, 0xef18bb3f, 0x5fc3fa39, 0x6910b95b, 0x43e09aee, 0xfce2f510, 0xa7675665, 0xced56c9f, 0xd872db61, 0x10e265ac, 0xae9fce69, 0x6982812e, 0xa90567e6, 0x97b14f7e, 0xb6ae5cb7, 0x513257b7, 0x9f10903d, 0x85454a3c, 0x69bc3724, 0xd8d2c9ad, 0x6b29cb44, 
                0x38da9324, 0x77c8cbac, 0xb540a21d, 0x01918e42, 0x9bbfe435, 0x56c3614e, 0xfffa707a, 0xc094dbb5, 0x6233ea68, 0xd968d410, 0xb77d062e, 0x58b3002d, 0x3e719bbc, 0x3dc49d58, 0x68e7dd3d, 0x013a5e58, 0x8d825740, 0x3c9e3c1b, 0x21311747, 0x7c99b6ab, 0x0cb0a2a7, 0xc2f888f2, 0x5c48a3b3, 0x6424c49b, 
                0x646f9679, 0x67c241c9, 0xf888dfe8, 0x24f68b49, 0xe12d4b93, 0xa571df20, 0x9a6b62d8, 0x179483cb, 0x81b4b26d, 0x9511fae2, 0x666f9632, 0xd53aa51f, 0xd281b3e4, 0x7f3dbd16, 0x7f96a765, 0xfac61d9a, 0x027cc8b8, 0xe3c6fe8a, 0x7d25e062, 0xe5bff503, 0xe08805bf, 0x6ff632f7, 0x13271e6c, 0x232f76a5, 
                0x55dca6c0, 0x701ef426, 0x8957c32d, 0xa10a5178, 0xee728bcb, 0xb62c5173, 0x5ea60411, 0xa3e6fced, 0x0d53f5c7, 0xf45fbdeb, 0xe8cbbdd5, 0x13339a70, 0xf85c01df, 0x142ceb81, 0x0ff71880, 0xbd70437a, 0x4c4e8774, 0xba0bda6a, 0x5fb32891, 0xf18bd26e, 0x1cdbebd2, 0x03a9d522, 0x2f9526f1, 0x65c7322d, 
                0x439530b6, 0xb3c1b3fb, 0xcf12cc01, 0x0172f685, 0xc70b0186, 0x1b58391d, 0xb915ee22, 0xa317db24, 0x9afdf03b, 0x17b8ffc4, 0x87dec659, 0xe4d3d050, 0x7f46597b, 0x006500e7, 0x80a1c1ed, 0xf1c367ca, 0xe4050f1c, 0xc90fbc7d, 0x9bc85a9b, 0xe1a11032, 0xa373c4a2, 0xad0393a9, 0xb64232b7, 0x167dad29, 
                0xf5577eb0, 0x94b78ab2, 0x1604f301, 0xe829348b, 0x0baa94af, 0x41654342, 0x77fbd8dd, 0x5ca7d866, 0xab58b910, 0x3adb3b34, 0x582967e2, 0xcceac0bc, 0x89ae4447, 0x7bf56af5, 0x919c667c, 0x60f5dcd7, 0x9aec17b1, 0xddcaadbc, 0xec697b9f, 0x463467f5, 0x0b98f341, 0xa967132f, 0xb187f1f7, 0x3a29467a, 
                0x9894344f, 0xc51eba6d, 0xde81e949, 0xa5e5c2f2, 0xdaea066b, 0x08c8c7b3, 0x3fc8a614, 0x06d0de9f, 0x7adff88f, 0x3b75ce0a, 0xbbc11cf5, 0xfbbc87d5, 0x9fbb7acc, 0x7badfde2, 0xa1458e26, 0xc5f95cd8, 0xb06b1244, 0xf4ab95f4, 0xda8c8af0, 0xb9e5836d, 0x1bae59c2, 0x3acffffc, 0x07d51e7e, 0xc2ccbcda, 
                0x01e15e6a, 0x8528c3e0, 0x3bc1923f, 0xa49fead4, 0x43324577, 0x2aa7a711, 0x61a1b884, 0xc8de610b, 0x0f893a5d, 0x67e223ce, 0xe8c515fb, 0x4ead6dc5, 0x7774bfa6, 0x925c728f, 0x89d20f95, 0x098583ce, 0x7a1e0966, 0x93f2a7d7, 0xa2eedb94, 0x4c304d4a, 0x1b282097, 0xc077282d, 0x0842e3da, 0x36f09ab0, 
                0xefb2149e, 0x4a10bb5b, 0x03f163ca, 0x06e20998, 0xd0297045, 0x1b5a3bab, 0x56f0af00, 0x70880e0d, 0x7af4cfec, 0xbe3d913f, 0x7332a66f, 0x7eceb4bd, 0x32e6c84a, 0x9c228f55, 0xedc4a79a, 0x1bf4581c, 0x98857ceb, 0xaca7b166, 0xe635e186, 0x659722ac, 0x278ddd22, 0x1db68007, 0xa0903c4c, 0x48f21402, 
                0x366e4589, 0xb96abda2, 0x31b49c14, 0xe0403190, 0x329c4b09, 0xd29f43fe, 0x97197ca3, 0x80eb24a9, 0x60e28570, 0x488e0cfd, 0x7bedfb4d, 0xc259cdb8, 0x721ebbd7, 0xbc6390a9, 0x0b0da855, 0xde314c70, 0x2b4d04db, 0x6c32e846, 0xcdbf1fbc, 0xb162fc9e, 0x33833eab, 0xb0dd3ab7, 0x9939b48b, 0xd111f8ec, 
                0x3e0e5c9d, 0xb7c4e760, 0xbcc33f8d, 0xbd392a51, 0x702f9a91, 0xc132e92d, 0x7da4a795, 0x0bb1151b, 0x1a0b0ae3, 0x02e32251, 0x54febac8, 0x694e9e78, 0xea3a5082, 0xe4fe40b8, 0xe58ffec1, 0xb733aa5f, 0x3c2f0ba9, 0xf05af235, 0xdece47cb, 0xa2ac82a5, 0xf8e3f715, 0x2203f18a, 0xc97ba641, 0x09c11060, 
                0xc3af5504, 0x46af512d, 0x56ea2c05, 0xf3f28146, 0xfac28daf, 0x959ef494, 0x87fab43a, 0x41c23fa3, 0xb4480f04, 0xc1989a2e, 0xb4712eb0, 0x93a29ca7, 0x3ccbba0f, 0xd619428c, 0x6e205c14, 0xb3641686, 0x90db7957, 0x45ac8b4e, 0x0432691d, 0xf64e0350, 0x07a759ac, 0x9c972517, 0x0514d89c, 0xe2c2bf15, 
                0xfeb09740, 0xa9e99704, 0x627a2205, 0xc2fbc565, 0xec8d73d0, 0xc20c8de8, 0x223eed8f, 0xa8363b49, 0x1ee32583, 0xc9c2b0a6, 0x1a0b6cb9, 0x90dbc85c, 0x49f7c3d2, 0x1ef4c1ac, 0xa8dfbb97, 0xfa181e69, 0xef0a3fec, 0x30d69a98, 0x9ea02f81, 0x66eab95d, 0xb2e9cf8e, 0x24720021, 0x520f2beb, 0x1df84361, 
                0x621c540a, 0x71fa6d5d, 0x12037721, 0x0ff5f6ff, 0x6e3c7b51, 0xabb2bef3, 0x817a069b, 0x700a1acd, 0xb5560fb6, 0xfd999681, 0xe823fd73, 0x6cb4e1ba, 0xda915d1f, 0x6ebe00a3, 0x0d030118, 0x89fca8cd, 0x744fb0c9, 0xf9da0e0b, 0x970d01db, 0x7931d76f, 0x0ad8c564, 0xf659b96a, 0xb15737bf, 0x626332d5, 
                0x994f523a, 0x5561bb44, 0x7bc38833, 0x3d845ea2, 0x005ed4b0, 0xc2a1f08a, 0xd39d3ee1, 0xe7676b0d, 0x6561fdd3, 0xfb706017, 0x620e35ff, 0xf264f9a8, 0x36ce424f, 0xda2681f7, 0xc4c3419f, 0x7cb1282c, 0xb828dd1a, 0xbe46973a, 0xa08d7626, 0xe708d6b2, 0x6baf8d40, 0x4daeb3f3, 0x72571fa1, 0xf22dfd98, 
                0x85b1732f, 0x0087108d, 0x87ab01a7, 0x5988207a, 0xaaaafea8, 0x69f00755, 0xccc832f8, 0x6d3549cf, 0xd433e50f, 0xfacd665e, 0x6f33696f, 0xce11fcb4, 0x695bfdac, 0xaf7c9860, 0x810ee252, 0x7159bb2c, 0x65450fe1, 0x758b357b, 0xf7dfbebe, 0xd69fea72, 0x2b057e74, 0x92731745, 0xd485717a, 0x46ac49d2, 
                0xa6b5c9d6, 0x83137aa9, 0x42c77c0b, 0x68225a38, 0x24d000fc, 0x2fe1e907, 0x0f63cfc8, 0xc6441f95, 0x22d1b01b, 0xec8e448f, 0x7d38f719, 0x787fb1ba, 0x9b33fa5f, 0x190158df, 0x94dcfda1, 0xc4e83d33, 0x43ed81b5, 0x5efd488b, 0xd9f35879, 0x9deb4d0f, 0x164a620f, 0xac6a7394, 0xc6927bdb, 0x9f9e0f03, 
                0x45c28df7, 0xfcd7e1a9, 0x2868661e, 0xffa348f1, 0x7cf4e8d0, 0x398538e0, 0x6bd4c284, 0x52666a58, 0xb0d1ed84, 0xe6a9c3c2, 0x4bcb6e00, 0x26906408, 0x3c57411c, 0x13556400, 0xcfc20755, 0x5294dba3, 0xa08b1c50, 0x8b7dd31e, 0xa30ba286, 0x991eca74, 0xd70ba90e, 0xe762c2b9, 0x094e142c, 0xe1337c26, 
                0x949c9976, 0xd73d68e5, 0x6faadebd, 0xf1b768d9, 0x9e158614, 0x9cc4f069, 0x22dfa557, 0xbe93c6d6, 0xccd6da17, 0xa504f5b9, 0x24866c61, 0x8d694da1, 0x2121353c, 0x0140b8c6, 0x1c6ca580, 0xb0166f7a, 0xae8317f4, 0xceec74e6, 0xfbd3e3f7, 0xe0874bfd, 0xfdb516ac, 0xc681f3a3, 0x3d846019, 0x7c1620b0, 
                0x0b12ee5c, 0x2b63c501, 0xba68b4dd, 0x6668c51e, 0xac03cd32, 0x4e0bcb5b, 0x2a6279f7, 0xc2c6ff70, 0x8735728d, 0xc5dc2235, 0x79d6122f, 0x19e277f9, 0x23f5d003, 0xdded8cc7, 0x7ee84e25, 0x63cd880a, 0x91a8afb0, 0x3574af60, 0x3f3ea7c6, 0x02de7f42, 0x0cfcdc84, 0xb31aa152, 0x62d0792f, 0x4cd8f64c, 
                0xc492ec64, 0x279d7b51, 0x58a2d790, 0x1fc75256, 0x0ced1fc5, 0x8f433017, 0x3e658aed, 0x05da59eb, 0x0b61942e, 0x0ddc3722, 0xba3d60a3, 0x742e7f87, 0x7c311cd1, 0xf6b01b6e, 0x6473ffee, 0x81fdad90, 0x25914f78, 0x0d2cf6ab, 0xcf638f56, 0xcc054de5, 0xb90bc03f, 0x18b06350, 0x932811a7, 0x9bbd11ff, 
                0x2f00b330, 0xb4044974, 0x76108a6f, 0xa851d266, 0x801bb9e0, 0xbf8990c1, 0x0dd099be, 0xcb198ac7, 0x1c894849, 0x0f264665, 0xa884a93d, 0x9b200678, 0x2da964ef, 0x009834e6, 0x3c351b87, 0xe2c4b44b, 0xafb2ef9f, 0x3326790c, 0x580f6c47, 0x0b02264a, 0xb8480521, 0x42a194e2, 0x8ba6f9e2, 0x9d8e68fd, 
                0xe5f649be, 0x1b044320, 0xdb0f0533, 0xe0c33398, 0xf6fde9b3, 0x66c8cfae, 0x92f4209b, 0x1a739d4b, 0xe9d1afcc, 0xa28ab8de, 0x09aea75f, 0xeac6f1d0, 0x14375fb5, 0x708f7aa5, 0x6420b560, 0xe0f222c2, 0x5043dea7, 0x72e65142, 0x309d42ac, 0x9216cd30, 0x94fe9ddd, 0x0f87feec, 0xd6539c7d, 0x432ac7d7, 
                0x03c5a57c, 0x327fda10, 0x72692cf0, 0x280698de, 0xec28c85f, 0x7ec283b1, 0x2331fb46, 0xc42bd6d2, 0xdb567d6a, 0xbb1f96ae, 0x6df86468, 0x4843b28e, 0x0efe5b1a, 0x6379b240, 0x961bbb05, 0x70a6a26b, 0xb6caf5f0, 0x328e6e39, 0x70686c0d, 0x895fc8d3, 0x80da06cf, 0xb363fdc9, 0x804d8810, 0x292a9287, 
                0xa004dcb3, 0x77b092c7, 0xddc15cf6, 0x806c0605, 0x083a8464, 0x3db997b0, 0x4a68df70, 0x05bf7dd0, 0x9c134e45, 0x8ccf7f8c, 0xa4e63d39, 0x41b5f8af, 0xa6e6517f, 0xad7bc1cc, 0xaa8b9342, 0xf23206d5, 0x2bf5db47, 0x1d260152, 0x2f6d3420, 0x3f8ff89a, 0x17b87653, 0x378fa458, 0x5157c30c, 0x2d4fb936, 
                0x7517c5c5, 0xe6518cdc, 0xef22f7ac, 0xbf847a64, 0xdeb483e6, 0x92e0fa89, 0xf5084558, 0xef7d9289, 0x549db2b5, 0x197f015a, 0x2480d4a8, 0xc40493b6, 0x61d5590b, 0x6f780331, 0x3a55b52e, 0x309eadb0, 0x40eb8115, 0x92e5c625, 0xdea7de5a, 0xcc6a3d5a, 0x64d631f0, 0x93e8dd61, 0x9d5e9d7c, 0x1f095615, 
                0x1083e2ea, 0x14e68c33, 0x0a28ad77, 0x3d8818be, 0x6bfc0252, 0xf35850cd, 0xb585113a, 0x30df8aa1, 0x7d935f0b, 0x4ab7e3ac, 0xaddda07c, 0x552f00cb, 0x92c34299, 0x2909df6c, 0xc33ed1de, 0x566c5c43, 0x6e85cb51, 0x3597f046, 0xcff9c919, 0x4994d94a, 0x9354e90c, 0x2147927d, 0xe0a39332, 0x0dc1eb2b, 
                0x8427fac1, 0x2ff319fa, 0x88cfd8c2, 0x01965274, 0xe2d4e684, 0x67aaa746, 0xfa2e067d, 0x23a5d896, 0x9910ba6b, 0x7fe4364e, 0x1fe19e35, 0x9a33c677, 0x6e1da8c3, 0x29fd9fd0, 0x15b4488b, 0x1a1f22bf, 0x1f439254, 0xab8163e8, 0x920a8a70, 0x07e5658e, 0x3fd1b249, 0xb6ec839b, 0xf2c4f79c, 0x95a7b1a2, 
                0x197dd46d, 0x3c6341fb, 0x9c4e7ad6, 0x484c2ece, 0x426eca29, 0xde7f4f8a, 0x9211e489, 0xc78ef1f4, 0x14997f6e, 0x06574586, 0x2b2c0910, 0x1c3eede8, 0x17286a6e, 0x0f60e018, 0x25f92e47, 0x6d55d6a4, 0xc52d8d8b, 0xbe58e8f9, 0xc4130fb3, 0xe1275627, 0x5f55c345, 0x117042d3, 0xb881a03c, 0x3238d301, 
                0x00a970a5, 0x12a2c4f1, 0x40d7cf24, 0xd770ea74, 0xace4a2f5, 0xe96940b2, 0x36a2e587, 0x1ab98df0, 0xee8b49b0, 0xf59a9427, 0xecbdeab5, 0x548c6a63, 0xbb05effa, 0xdb9344ef, 0x7efc4617, 0x357e0678, 0x4f4444f2, 0x72103a20, 0xd4b9f5f7, 0xb9777db0, 0x4f0d7397, 0x8288f5df, 0x7ff6e1d2, 0x5a463486, 
                0x97575f51, 0x306eaa96, 0x3cf990bc, 0xfe851fe2, 0xbbfd37ee, 0x0347d5d8, 0x98075a38, 0x087def74, 0xd799f5a9, 0x1ba1609c, 0x07365f7a, 0x76a88396, 0xe6a39ca6, 0x39fb04ca, 0xab11ed8d, 0x2d6d2261, 0x30dbdb03, 0x0a712d66, 0x9c2cc5ea, 0x91be6c9b, 0x04096f3c, 0x0aab7e15, 0x0410f050, 0xf6831d44, 
                0x6acd71db, 0x732f1b08, 0x6e118cec, 0xa4e928f8, 0x942ef8cc, 0x42577ccb, 0xb9395357, 0x241507a2, 0x6243e9b8, 0x2b237781, 0x68ab873f, 0x5526adf7, 0x0e53b515, 0xdf40fa2e, 0xac542701, 0x686808e7, 0x9ee929c6, 0x176c5288, 0x44977caa, 0x867c9c46, 0x1375fd2b, 0xcdb2e6d2, 0xb1395e94, 0xe323fe2a, 
                0x88dbf571, 0x89081b0f, 0x1fce5d43, 0x6d053b84, 0xf94cf853, 0x00233caf, 0x95c5550d, 0xd39a394f, 0x0afb5c85, 0x465031a5, 0x4badb9fd, 0x974faba7, 0x1ae7afae, 0x53cc5c75, 0xb5281147, 0xd4f4e970, 0x8306ad4b, 0x05a8c25b, 0x3118e937, 0xbdc8c9e3, 0x9cdded3c, 0x7c1a5725, 0x2e1c3a6b, 0x73acf0a1, 
                0x4cd326b4, 0xf21a3175, 0xa6bfda97, 0x1e00da12, 0x4f64bca2, 0xbbd27529, 0x17b50465, 0x08e7d678, 0xac362409, 0x6d29ce9a, 0x98308f24, 0xe5b43e8d, 0x6b6ad08e, 0x07bf8762, 0xf1e60a0f, 0xc6fcb2cf, 0x14a074d1, 0x6fd43c2f, 0x349f7d2f, 0x94ea4778, 0x8e7ac5d7, 0xcb80f618, 0xec106a62, 0xc02afe47, 
                0x2eef718c, 0x3e360468, 0xff8c9db3, 0x50d841a0, 0x446f73e8, 0xc188b6cd, 0x670ef28c, 0x65819f96, 0x205f7808, 0xfc2a6491, 0x130f6317, 0xb288ca97, 0x7c93567b, 0xea4d03bc, 0xf4733fbd, 0x0878dd00, 0x58840ac5, 0x9491e292, 0xcbb2e188, 0x840cbe7b, 0x40b17a07, 0x7255b284, 0x7e90ce7c, 0x5fe2938f, 
                0x28c3a65b, 0x79fe6187, 0x1e85c4ee, 0x1f641ca0, 0x1f85724e, 0x582584c1, 0x261a3c5e, 0xf4798f9f, 0x516b1c42, 0x52ca7b06, 0x2329f7fd, 0x42e70261, 0xda781d5d, 0xd8e5cfb7, 0x34677c35, 0x87a7d45b, 0x7e3828f7, 0x6120dcfd, 0x7f0b1b62, 0x5120867d, 0x099b5f4c, 0xc4b3d7c8, 0x31f1fcc6, 0x39a3132a, 
                0x01e68417, 0x93c06a60, 0xf0c11a60, 0x84651665, 0x1172be49, 0xf54a2da6, 0xd5f63e50, 0xf97d61d2, 0xdbf53fe5, 0x929ffd1a, 0xa91a964b, 0xc504e62d, 0xe0ace6b2, 0x1eb04527, 0x302bd557, 0x8cfc4a6a, 0x0b1c611b, 0x0b0274e0, 0x6c28c8d1, 0x1ee813f5, 0x75fa46e8, 0x41c07cb4, 0x6526fdc0, 0x887d2b2f, 
                0xd7b48235, 0xf3871545, 0x92c684e3, 0xe78e9b70, 0xb5f5f2e3, 0x9b211ade, 0xf90e43ac, 0xb96850ad, 0x2badfe7e, 0x53d0063a, 0x149ee17c, 0xd36592cf, 0xad4c5b0c, 0x602f3797, 0xfbce9ecf, 0x0ed1f3cb, 0x01f796be, 0x9a47299d, 0xaf694d61, 0x6dc824f6, 0x881cda7d, 0xb572af5b, 0xdcfdbe1a, 0x6694a2a8, 
                0x9303b61d, 0xe599688f, 0xe21e7555, 0x35e2a19d, 0x1ab483d8, 0x61e48a0c, 0x8a912bad, 0x6b8b4b42, 0x7f0e193f, 0x1c3966dc, 0xc4f2d16f, 0x1218f4b8, 0x4b915343, 0x5795259a, 0x81858c60, 0xcf62e6d1, 0x1e07f57b, 0x39af1c3e, 0xce99c2df, 0x8e946432, 0x73d9df11, 0xda3ac6af, 0x60f19331, 0x1d8bbe4f, 
                0xbfcdddfa, 0x14477713, 0x5add9d2f, 0xfaefffce, 0xab51c819, 0x53e3958b, 0xbc458fdf, 0xbeb5f5fe, 0xd9fecd9d, 0xcc90a0a8, 0x6e251161, 0x9325239a, 0xbb73932b, 0x1ff66e45, 0x6442dd12, 0xa206c95f, 0x5e1365e2, 0xf1cd1105, 0x6e4bbea6, 0x0599b828, 0x68d8cabe, 0xba4c2251, 0x68fe1cd9, 0xc1320557, 
                0x6792173a, 0x8df69e39, 0xcf96f290, 0x45ec9115, 0x6e14b7fd, 0x437e74b3, 0x34fa98f0, 0x5ff194af, 0x52979f37, 0x7fc1a505, 0xfbfb2ed2, 0xed49d9d7, 0x3c98090d, 0x92c3d76f, 0xbf600559, 0x809ea598, 0xbd0fd85b, 0x24e95867, 0xe48e1df2, 0x6fd29f61, 0x9e205fb7, 0x2c7aa375, 0x7f27e98f, 0x8d3ee115, 
                0xd3959a69, 0x122f6cf8, 0x51e15ad6, 0x43beae52, 0x36f29974, 0xcf43f2b0, 0xf2035e2d, 0x9fb905a1, 0x38f7e3e6, 0x3f07e6cf, 0xef2990d4, 0xe737e343, 0xafed8661, 0xbed161fa, 0xa53b9a9d, 0x8571acdd, 0x556c1ef7, 0x32ec01a6, 0x5e82254b, 0x30d5ab3c, 0x12eb099c, 0x65cf24c4, 0xefbb038a, 0x548f5729, 
                0x545aa7e0, 0xdb8b4e88, 0x0278140f, 0xd250c4ba, 0xdc352716, 0x3276b856, 0x71cf044f, 0xba73e7a0, 0xd423f233, 0xc91bb1b3, 0x95f07b69, 0xf4c5bb24, 0xa831588a, 0x3efd91bb, 0xeb1d4917, 0x475e6388, 0x6b456c97, 0x2688182d, 0x5e67a4e8, 0x0a5867da, 0xdd98b3df, 0x42a48cee, 0x04a876b1, 0x925d6c52, 
                0x166e1c17, 0x4f9f2c89, 0x439774f9, 0x98767e4f, 0x31530a7e, 0x998e5f2b, 0xa6026123, 0xc405e032, 0x8b77bf91, 0xa9dca02d, 0x8f7aa529, 0x4e55c7a4, 0x60232f35, 0x11b8502f, 0xbaed3a9a, 0x0f39645d, 0xdfe8b6b0, 0x11b2d295, 0xcc2c9f8b, 0x7527dda7, 0x4c8d6c07, 0x6c7f757b, 0x0d9a9e01, 0xc70f1134, 
                0x00ed73ff, 0x769d06e7, 0xdf892b4e, 0xb91cd0c3, 0x56a39047, 0xee8241bc, 0x8a17acce, 0x2ad384fe, 0x633adda9, 0xb580a51d, 0x7115cf0b, 0xcacfa799, 0x37732209, 0x4c0e4df9, 0xc2730cf2, 0xe177864f, 0xa37ddf85, 0xae27a244, 0x57a4e0a7, 0xb5a8948d, 0x0dec95fc, 0x0ca6116c, 0xf00d7c64, 0xde338ebc, 
                0xa95ea503, 0x3b30f5ea, 0xc6561a09, 0x98927ae2, 0xa5d936f4, 0xd0fd8e00, 0x76369b1d, 0x0131f641, 0x670e26b5, 0x16120de5, 0x36137c2f, 0x6a4f7877, 0x1ecdcf54, 0xb149f6ca, 0x2e3b382e, 0xa1a4a9bd, 0x1d639b19, 0x6d66fa5d, 0x806d38a4, 0xe7bf9a3d, 0x39c66da5, 0x03865476, 0xf82870f8, 0x861e3fa2, 
                0x0c5a0f20, 0xc12ff342, 0x495a0aec, 0x206840e0, 0x14a885d3, 0x1242f32a, 0xc134ef26, 0x22c372f4, 0x0c6022af, 0x7cf7dcd4, 0x9c6f1d8b, 0x8c0f1f4d, 0x4e5cfd78, 0x93ea817a, 0x50c65ac6, 0x824e3c8b, 0xe65b20bf, 0xa7354090, 0x46f2bc84, 0x6bb68f5c, 0xe4a63f5a, 0x1b8c1a8d, 0x80424b38, 0x9532f44a, 
                0xc899dccf, 0x8d261d93, 0xc017acf8, 0x3d681143, 0x3c156ba7, 0xe0f46929, 0xd5cc52c9, 0xe576b18b, 0xc21aeb08, 0xf746139b, 0x9f31eb94, 0x4794f4d5, 0x997f128b, 0x7846149b, 0x65dbe966, 0x30daccd9, 0xce6a526a, 0x07cbb45d, 0xa64c6572, 0xc0e06263, 0x4262cb4c, 0x27c08f45, 0xb9f01d5a, 0xe9f50c0d, 
                0xd49d62f0, 0x5da9dc83, 0xc8066a1e, 0x73107703, 0xacc8a408, 0x2df1801c, 0x1277ffa1, 0x282d4b83, 0x8779c438, 0xef0828a6, 0x43a5b177, 0xe8baa9b0, 0xb34893ad, 0x49f35f50, 0xcd8a7523, 0x08733e26, 0xa42c6f46, 0x38f0b396, 0x236a5d8f, 0xf6e14d45, 0x846e3a06, 0x6784852e, 0x2d8dc98b, 0x26a9e620, 
                0x14fce5f8, 0x3a0c74b1, 0x6e41a645, 0xc14ddce8, 0x35a7c405, 0xd0700ce3, 0xea8f9915, 0xb0cedc91, 0x74f1a1be, 0xe686f0c5, 0x103c8c05, 0xe3e6e1b1, 0x95f18e15, 0xd239a907, 0x5cb5d4a1, 0xa7854e41, 0xc0e6b131, 0xe78b238e, 0x210232ec, 0xe79ebbb6, 0xd3bef13e, 0xb06e3cdd, 0x06110ff2, 0x5d346e44, 
                0x3a7c897b, 0x9948c2a9, 0x4101dc61, 0x83bc93a7, 0x03c81c58, 0x249e5712, 0x898e5b18, 0x81ad2eba, 0x68465c41, 0x4dc749b5, 0xc9c56c25, 0x733480f9, 0x5898b7e3, 0x9744de1e, 0x5039406a, 0xfe16b2aa, 0x25f8209c, 0x73eb293d, 0xb93d6789, 0x82d26c5e, 0xea9b8c89, 0x2118886b, 0x9c63db50, 0x3b82d2e5, 
                0x3a7c63b0, 0xfdf217e8, 0xb28f738f, 0x66aa63c9, 0x3ec686e0, 0xd271e1e4, 0x41e0f6a3, 0x00e0f2b7, 0x8ecfdf69, 0xf30e53e1, 0xdecdbeb6, 0x59180d5d, 0xc5f1d5e3, 0xe53ed44a, 0x5cb489e4, 0x873da1fc, 0xd8f7ef4e, 0xd45f81c0, 0x208b2335, 0x8ec2802e, 0x036fd4af, 0x8d21241c, 0x50abd05d, 0xa6b84e15, 
                0x69f51d77, 0x2cb21881, 0x5722bd2f, 0xf20c486f, 0x06e28519, 0x752e123b, 0xe439dbc7, 0x8098be00, 0x74d6201a, 0x951b0872, 0xcc72e5a6, 0xf21b6fbb, 0x01f64521, 0xbdd9db86, 0xea2d215f, 0x30168579, 0x990c865b, 0x49c6604d, 0x1bc779bb, 0x8b2c4f1e, 0xba0ed23c, 0x3ef864d6, 0x8647366a, 0x2d9017da, 
                0x63634d25, 0x3ccf877b, 0x9f8983b6, 0x2f020c28, 0xa1df9e84, 0x09d1ce85, 0x278e2874, 0x2d81b8f1, 0x5f397964, 0x1f4374d4, 0x4b220a8f, 0x10b6f2b6, 0x036e5dd9, 0x95080533, 0xadd76c36, 0xcaed6cca, 0x3aa73d11, 0xe00c4d6e, 0x5ebc9b60, 0x77d7d420, 0xe3b5aba0, 0x89d9ee0e, 0x0aaa05f4, 0x3f2258a9, 
                0xac1cd922, 0xbe6753c1, 0x12c22095, 0x456e683a, 0xe5ff32df, 0x47190ca2, 0xc16ca713, 0xd5941915, 0x265078b6, 0x5e0d8f7d, 0x5ff6da74, 0xf4ecf027, 0x993f605e, 0x44470571, 0xdb656d5b, 0x8eba05ae, 0x25e93457, 0xa6121b18, 0x16054e7b, 0x73c7f885, 0x714d715e, 0x5116adc3, 0x9b374968, 0x9d234b75, 
                0x77b91d2e, 0xe7ec4573, 0xd911ac4d, 0x30c67f3a, 0x009cbf61, 0x8bc4b3aa, 0x3628d070, 0xf772f116, 0x0d98f483, 0xec8c33a3, 0x6dbccb8b, 0x9296a7e5, 0x9fb1a435, 0x4817ff3c, 0x6960595b, 0x814a3d8f, 0x989d7ad0, 0xcdb698b8, 0xa05f28d2, 0x717fc758, 0x5699810f, 0x49328b2d, 0xabd71424, 0x392cc048, 
                0xe142ab66, 0x6868d481, 0x2684a6e3, 0x5c822b1d, 0x2794ef9e, 0x4a3e90e4, 0x1548ba86, 0xf1f6df1e, 0x6cceddb6, 0xff3fab70, 0xfa35cccf, 0xfbbb889c, 0xa911fd20, 0x697dc2b7, 0xf355c5e3, 0x84c6ef5c, 0x2ea194c3, 0xf6f121aa, 0xf2bb613a, 0x917e22d2, 0xb1f9376a, 0xf807ca16, 0x8c61a1d2, 0xa1c2fe01, 
                0x1e453cd5, 0xa7c662f2, 0x4a234649, 0x8e624262, 0xf8949993, 0xbc14dbf5, 0x1c6b0da9, 0x441acb44, 0x6b087f17, 0xc8c137ee, 0x8ef3a084, 0x053ee779, 0xf248a32c, 0x3362d801, 0x705dca7b, 0xa51c8e9a, 0xec40b399, 0x4533cc5d, 0x023acea0, 0xeb3935b2, 0xacd85bcf, 0xf0e15002, 0x51f886dc, 0x270ffbba, 
                0x43878fa2, 0x36de06a4, 0xfe593ec2, 0xbc075242, 0x756cd38c, 0xba849f97, 0x6abcb20a, 0x7927b445, 0xce91c966, 0xcac01bce, 0xf0d040dc, 0xa616f1b7, 0x614e39d8, 0x58f35e1c, 0x8ff16ab8, 0x243d9357, 0x8f6a1ff8, 0x477cd153, 0xa0614df6, 0x27c6404c, 0x0a8e99fe, 0xafcc3af5, 0x9136e6e6, 0x2f213a45, 
                0xffbf2dfe, 0x86289bd1, 0x45a9d8f7, 0xf9f7936d, 0xaa45ed94, 0xf9ce5efd, 0xc2d73062, 0x82312eac, 0x6c33f50c, 0x818520a0, 0x860cc642, 0x74d20b05, 0x7057e04f, 0x788158a1, 0xbe1f9e9a, 0x7a594160, 0x1fb347ac, 0x721a5be9, 0x1dd6459f, 0x904a1022, 0x54934a15, 0x427b6d2c, 0xdbc5c3cd, 0x33277945, 
                0xc41f40db, 0x2cb0dc07, 0xfbc8b014, 0x750dc202, 0xc4fbaf79, 0xc48bf3ec, 0x7754582b, 0xade91632, 0x9e138595, 0x37bb180b, 0x9c3f5e48, 0x6f3f03fa, 0x9ea528ec, 0x3c38e838, 0x6ccbd78c, 0x90b5720d, 0xdacff4a6, 0x77e808e3, 0x14f6e4c5, 0xf3cb42f1, 0x3787df0b, 0x846551e2, 0x665603a4, 0x5292ab5e, 
                0xf9bdfcd1, 0x3ca1c920, 0xaae1459c, 0x31430b72, 0x319a6aea, 0x89b5dcb7, 0x504537fe, 0x77fef4ec, 0x9a028dd0, 0x658d180e, 0x7c9c49c7, 0xfaa225aa, 0x7c578fe5, 0xc8ff5c4d, 0x1667da4f, 0xe7c0aa48, 0x3f04e0e6, 0xb256641e, 0x0065e9f9, 0x809e6c02, 0x2e65b917, 0x7a61b8ca, 0xd7353172, 0xb74cc230, 
                0x22034a2a, 0x91f8c490, 0xa87aca64, 0x0118e2fc, 0xd0289c89, 0xa9feaafd, 0x076132ff, 0x75316c5d, 0xd3e2d775, 0x925b3065, 0xbbd987d0, 0xbda36c22, 0x1a2ade14, 0x37f750b8, 0x4d1c58f0, 0xd80a3ddf, 0x9e981d55, 0x2579bfc1, 0x90dfbe17, 0x26664123, 0x2b3690b2, 0xcc6ba057, 0x326f19c3, 0x6b21b959, 
                0x8a32e7cf, 0x757c5397, 0xcec596a2, 0x7cd657d9, 0x1a321482, 0x4d42a5b9, 0x4c37a940, 0xa12fed61, 0x90133797, 0xdb47a485, 0x1c88ff5e, 0x9dbeb2f7, 0x51d68bbd, 0x08bac776, 0x8aa3443b, 0xafb22550, 0x468f779a, 0xbc526acc, 0x4945a9f1, 0x6cdb5073, 0x8d5131a6, 0xf84a4a2f, 0x82373818, 0x74838afd, 
                0x41ab436e, 0xf19e030c, 0xec0d696f, 0x7d31e315, 0xd168e51a, 0x6342eab2, 0xb38d6af3, 0x22ccd3db, 0xa63cffee, 0xdf0e2cca, 0x3ea485e8, 0x969b8543, 0x8045f2f8, 0xe3b444a3, 0xe8483be4, 0x89493942, 0x971c29a6, 0x5c1eecab, 0xed73e23b, 0x5f1dd5c3, 0xf69bad8b, 0x1a52ea60, 0x81215d06, 0x1faf7ea3, 
                0xf187f1aa, 0x5ae54ee4, 0xecdb7ba0, 0xf9662824, 0xe32b466c, 0x607e6ed6, 0xefd58014, 0xcbc68ef8, 0xd281551a, 0xd0ebac90, 0x095500e7, 0x51568112, 0x30cbcbe9, 0x3cc38eae, 0xc339e056, 0xe3c2f676, 0xe35a9b64, 0x9b0d1e76, 0xe65339a6, 0xa105be92, 0xbc203461, 0xaa308d81, 0xe9f73f31, 0x675a3d2e, 
                0x344cabc0, 0xdd80048b, 0xed4a158c, 0xa06b2812, 0xeb10fb59, 0x68582575, 0x51a46dbd, 0x82a6c74a, 0x6276575c, 0x9e33e5f7, 0xace88484, 0xf6b2b6b8, 0x6de2e783, 0x75b119da, 0xc1ea05f7, 0xca95a7b7, 0x830692ad, 0x492a52aa, 0x5c0b0e5d, 0xa0c7cb76, 0xb8a7b9bd, 0xd76b9d50, 0xdb732f00, 0xb72d8c7a, 
                0xfd0eee19, 0x594f2761, 0x2f753b06, 0x02b3b39e, 0x74b112f8, 0x03835b01, 0x51759bf3, 0xfa9694dd, 0xd022a95d, 0xae7b2fd8, 0xdb6dc66a, 0xa36940d9, 0x7f9eed14, 0x7b85c89c, 0x416fc067, 0xaa61f8d0, 0xe96bd046, 0x42c96a5f, 0x1792a8a9, 0x9f43dfc5, 0x1837637f, 0xcfaef982, 0xd7fc826a, 0x278518cd, 
                0x2f9148f9, 0x64b22bb7, 0x97c5ea91, 0x8c7e4b2a, 0x4a341b6b, 0x67f5dafd, 0xfd8d6e17, 0xa61083f9, 0xde66462d, 0x8baff658, 0x1291df73, 0xd349a347, 0x4aefdfdb, 0xb224a31a, 0xb6ee8436, 0xa8e42f66, 0x211b7d7e, 0xd9d021bc, 0xe441a627, 0xb5a23d59, 0x06a47dd4, 0xd1c514c4, 0x87b22893, 0x626a95dd, 
                0x5164bd62, 0x09c7e7d5, 0x0a974211, 0x5992764a, 0xa91316f9, 0xd6c6d2f0, 0x3c5a381c, 0xb33df14e, 0x53808999, 0x60620e08, 0x13a4a8c5, 0xf66118de, 0x4ce48425, 0x1e7f3cd1, 0x59f6391d, 0x62da1827, 0xfeac0a63, 0x7ff90695, 0xadfeb3d3, 0xba63cf4a, 0xfa334854, 0xc9548f68, 0xdd433044, 0xb618f68e, 
                0xec6b0d7c, 0x284fbc7a, 0xb865f25f, 0x3111ee31, 0x682f7952, 0x901755bb, 0x3ad94a77, 0xbf19b917, 0x9192bc84, 0x4346521f, 0xcb41b31f, 0xbb38d6ad, 0xd2cec305, 0xce118cc7, 0xc75fc2a0, 0x521292dc, 0xc96accb5, 0x6bf8e078, 0x6628f004, 0x78a84e63, 0xbbbaf816, 0xba76fe0a, 0x57439e1f, 0xe54a5ac4, 
                0xaac5a06b, 0xbdc57f46, 0x81933085, 0xd0a29d4c, 0x72542397, 0x01fb6ac5, 0x4ebb2292, 0x7be3c194, 0xa4ab2393, 0xf5550da0, 0x50bc234c, 0x3bca7b46, 0x250dd20a, 0xf8b60908, 0x3001722a, 0xf590cdcc, 0xfb2e6342, 0xb07cbb4e, 0x836a852e, 0x1d442b86, 0xcf5339a7, 0xca4ba329, 0x7af2a91a, 0x5a18591d, 
                0x2a67aaeb, 0x2c36acfc, 0x88786292, 0x75970b7c, 0x5cf5a6e2, 0xbdc09eff, 0x0fc24cca, 0x9d1a5b83, 0xa83323a4, 0x323257fe, 0xf1ebcb2d, 0xcb077399, 0xd1af2024, 0xf8defde1, 0xad868941, 0x15fa7495, 0x274209df, 0xbf5a59d0, 0x4b49d61f, 0xd56f6dad, 0xaf1cd526, 0x777a4e2e, 0x116b99f7, 0x12d8bfa5, 
                0xde7f38f3, 0x0d89beab, 0xbbfbf6e0, 0x0cea9506, 0xb6e4db9c, 0x47f28127, 0xaa242939, 0xcd889293, 0x646ec2f7, 0x0cbddae0, 0xa0987ef7, 0x06bf24ac, 0xc7633a51, 0x492c6944, 0xa906829e, 0x50e20207, 0x1f3c95a9, 0x0aa06091, 0xadc32d4a, 0x174794c0, 0xc22ef80b, 0x081d2391, 0x1a647603, 0x3615380a, 
                0x046c9096, 0xf7e1790b, 0x391cef9d, 0xdbe268e2, 0x700b6f4c, 0x580d8683, 0xebb56b58, 0xbb9940f2, 0x6f464009, 0x7c8446c0, 0x8af6e9ff, 0x030acd8f, 0xa4b35bc5, 0x398ed314, 0x9102fdce, 0xdcf5ef6a, 0xd78ee60c, 0xac3e365c, 0x19c36802, 0x7f4d841b, 0x47fad56b, 0x8f0f75c3, 0x6928e447, 0x932bc68e, 
                0xc1f5a0f3, 0x508191f9, 0x63ef5e86, 0x0e255c30, 0x63b54b5c, 0x45c12bdb, 0x0d7fb5ce, 0x177bca63, 0xe3eeb8a4, 0x78f63910, 0x13df0554, 0x06aebbf1, 0xba7072c0, 0x7542e1d9, 0x9b050a93, 0x6af48744, 0x45db6fdb, 0x61175d5f, 0xfa3a48c7, 0x2e6dd1aa, 0xc2c4b2f2, 0xd35b8e0c, 0x16a7cd3e, 0xd28ea294, 
                0x41f97875, 0x34553e22, 0x84a8d982, 0xe04148da, 0x166c771f, 0xb00c305d, 0x581d3e1c, 0xbd5447a9, 0xa1f2fdac, 0x1b96ab66, 0x826f75be, 0x9610485b, 0xc0856564, 0xd5e70914, 0xce66e1c9, 0xcd638c84, 0x1984e7c5, 0x45f6f089, 0xdc025757, 0x5db4006b, 0x81181ca3, 0x50c547e1, 0x013b7e6a, 0x735e48d5, 
                0x5eb66031, 0xa2b9df0f, 0x085db5fc, 0x9f91b7c9, 0x1758d648, 0xb930f619, 0x1d80328a, 0x507c4de0, 0x230c2828, 0x30866e20, 0xa44f4fe7, 0x801c919f, 0x9bd2e279, 0x51a04050, 0x7e13932d, 0xbadb05a6, 0x03981e92, 0x3767ba02, 0x01e8fee2, 0xcbfbe2b7, 0x272d9986, 0xb207adf5, 0x3beed25f, 0x580f58bb, 
                0x33fe8033, 0x6e7918d5, 0x399a7d73, 0xc1be322f, 0x32fb4701, 0xc2f1e540, 0xbe521b70, 0x4c87a16a, 0x37d91ce0, 0x426ac16e, 0x5215bc46, 0x49c8983e, 0x6918e130, 0xe9830dae, 0xa58484e8, 0xab66ef78, 0x5e14fe3f, 0x881a6f64, 0x58e954d4, 0x5f50ad85, 0x542d0801, 0x447dde9f, 0x5474eb0e, 0x682446a7, 
                0xd55167fc, 0xf007ab99, 0x2f5a4730, 0x83544efd, 0x69e688e7, 0x991f764e, 0x67808de0, 0x72575466, 0xaf921f9b, 0x104c469a, 0x9f172263, 0xdeb6966a, 0xe929a886, 0xbd05d75e, 0xde7872fb, 0x4ee51963, 0x3a1b8c9b, 0x5de5b967, 0xdc4e6ff6, 0xfb729a05, 0xc0c7e831, 0xf2cc556f, 0x860b505c, 0xa58554c0, 
                0x66567147, 0xe905aa99, 0x6e2b382f, 0x3711d930, 0x41ba24f9, 0xddf687d9, 0x4e2ccc39, 0xec7eedfe, 0xaa9da44a, 0x9bfe7ddc, 0xef428ae1, 0x08a9d63f, 0xaf042050, 0x27b50e9b, 0x2854f43f, 0x1a1b86b5, 0xd7a49d7a, 0x336a7ef7, 0x02c4f41c, 0xc71d4c9c, 0x02c8446c, 0x39056950, 0x0186aa45, 0x1aa66a6e, 
                0x3e2ad255, 0x6a79c75b, 0x4f163af4, 0xc4f4aef8, 0xe5145dd9, 0x77d5a744, 0x9ae95e09, 0xd4ddeac5, 0xd1643494, 0xe66d93e0, 0x3e1304e7, 0xe77273c6, 0x6058a50a, 0x7d2325df, 0x802683b7, 0xf7c76684, 0x374a1199, 0xe47cbac1, 0x5bd5a30b, 0xf911fb74, 0xe33c152e, 0xfd8c9b95, 0x28400c8a, 0x02c8ecc6, 
                0x01d43404, 0xbaccec12, 0xcc4cc25b, 0x3179120c, 0x8fe9754c, 0x347a48ec, 0x1b55c1f3, 0xbe44af2a, 0xcffbaf03, 0x34ec9888, 0x9d1b95fd, 0x7c34d847, 0x1ebce8c8, 0xf1c4113a, 0x519cbc2d, 0x65850da8, 0xaaff0bc0, 0x800860f3, 0x73701efa, 0x01af3371, 0xa9758873, 0xa3753191, 0x4743be4e, 0x0948a424, 
                0x28a04907, 0x48d2ad3c, 0x0e3f84db, 0x35cf49d2, 0x65d72dd6, 0xae04b103, 0x6437f502, 0xb7cf0d86, 0x4c9315d0, 0x30400dc4, 0x04fe2163, 0xd510b0aa, 0x2ef7d2bb, 0x120f2cfe, 0x716218ee, 0x413e3b93, 0xa88f03b0, 0xd13b7c2d, 0x1aa20e34, 0x5a826883, 0x03c05e72, 0x3e70d6a3, 0x20b9b7e2, 0xa1d141f5, 
                0x57ac4d86, 0xe0384acf, 0x4ef851a1, 0x7d1ff78a, 0x5e1dcb65, 0x98c08ed0, 0x44b0b947, 0xbc51f3c5, 0x82fc1164, 0x2ae5c651, 0x868e7a42, 0x5153a816, 0x4258a9bc, 0x4dd53d7f, 0xd313c753, 0xcdfbfb6a, 0xd03ae7ec, 0x646d9b06, 0xdcab4ceb, 0x900e83c6, 0x6255440a, 0x089247ba, 0xf10e84fb, 0xc885eb6d, 
                0xba9ba0d9, 0xfe802ed5, 0x9ba24966, 0x9f9f0002, 0xe82d36ce, 0xd73e03d1, 0x107f2fca, 0xae6aadef, 0xc26c8c80, 0x920f6579, 0x83d7784f, 0x6b708967, 0xeac6c30e, 0x1a6c515f, 0xfd259493, 0xd5175429, 0x8a29479f, 0xb63223be, 0x5ecf0cf0, 0xc2fffc05, 0x11f539a7, 0x83026174, 0xf5eab3f2, 0x51a9a8bb, 
                0xe7b4d5bb, 0x4fa9f8a5, 0x04cf2743, 0xda9da599, 0x2bc6095a, 0x0d9123f0, 0x2987652b, 0xf78cdada, 0x1e2d50a2, 0x90d8e559, 0xf37f5aff, 0xe719a93a, 0xb8648fc4, 0xecbc27b7, 0xd369927a, 0x8c463c8a, 0xef36a7b3, 0xb67cdaae, 0x639f0672, 0xc60fd5b7, 0xc0a1c0f9, 0x1b55e7dd, 0x3c47a6f3, 0xf262bf48, 
                0x8ece9978, 0x6a142606, 0xa5f26a79, 0xef55dfd0, 0x5084ca00, 0xf573b934, 0x7b1aa6c3, 0x8cb84088, 0xb13f33ee, 0x94669de2, 0xda04e42d, 0x0f4e7810, 0xf06f2f16, 0x3abaaa6d, 0xa9f38353, 0x987cd5b9, 0x89b2b132, 0xb3c45398, 0x31df8785, 0x97b11158, 0x718a1565, 0x3e298674, 0xe85f5f6f, 0x5aa92026, 
                0xb1709b0f, 0xa0ba9f6e, 0x0e52a62b, 0x43bc9634, 0xb4ddeaef, 0x7efbb6ce, 0x3c94defb, 0xc8b71905, 0xbe84a8e0, 0x0afcfe76, 0xb39a7f48, 0x27cb7deb, 0x02cd401c, 0x22abf2c8, 0x815d7557, 0x92226b3f, 0x4abd0378, 0x320e9c2a, 0x0e1373a0, 0xe4b39f48, 0x2a84461b, 0xbdfef3b2, 0xb129b386, 0xa28c0c19, 
                0x78d12db1, 0xbd042f21, 0xd5a43a92, 0x9f865427, 0x492b5684, 0x1d87ab21, 0x72696fd6, 0x31b11a7d, 0x7c9cfd91, 0xd4f32d44, 0x831ab3c2, 0x39cfbf77, 0x31b6c6b9, 0x6b11f091, 0x7027cc25, 0x3a8eb38e, 0x9ffd355a, 0xe7382433, 0x97fdf58c, 0x3bf092f5, 0x87ea79b4, 0x6a65a865, 0x00f9c35e, 0x5926b92c, 
                0x97f76e8d, 0xbac181f9, 0x3251c6ed, 0x5473f742, 0x8cfc2334, 0x13f081f8, 0x0965f5f1, 0x4aba6105, 0x932c8cbc, 0xa90a2b6a, 0x1fc1dcb7, 0x766c8827, 0x86a78a79, 0xfe3272a9, 0x3265b411, 0xc02eee79, 0x0a707976, 0xa0409b4b, 0xba6cced7, 0x3e0e115a, 0x8dac420f, 0x7da9e9ef, 0x8e39d75c, 0xb3772b8f, 
                0x028aa587, 0x7dcbfc06, 0x8e6d4ca0, 0x5471ed74, 0xfb4efa63, 0x3cf54fb2, 0xaae67206, 0x257420c6, 0xbe855acc, 0xba1e5abf, 0x63651c86, 0x73ab4918, 0xef35f249, 0x4e5fa0c9, 0x613a23f0, 0x53dd810a, 0x6b15330c, 0x80c10bd9, 0x13c4b030, 0xb3d20149, 0xfee4087a, 0x14cc0041, 0x716d8792, 0x1d763357, 
                0x49cc8686, 0xa55f45c1, 0xcafd8dac, 0x29d0d808, 0x82accda8, 0x3a8a3936, 0xc6e3ce96, 0xf9035f5f, 0x423d9a27, 0xe1175d58, 0x4615c158, 0x98ab126a, 0x2b004452, 0x13f2f6a9, 0x0b797335, 0x15fc116b, 0xd5c7923b, 0xa81ab2d2, 0x46526e89, 0x30eccd2d, 0x93796b44, 0x7cbce8c1, 0xa653fd75, 0xd72a8efd, 
                0x4640611b, 0x79e536bd, 0x02bffba3, 0x769965ad, 0x3eff7563, 0x03f73af2, 0xbd804cd7, 0x9b3dec93, 0x1e4e0f53, 0x3eaea57b, 0xa1e2ff9f, 0x1dcbb5fa, 0xf62a1a93, 0xf5f73cf8, 0xc0cd7da3, 0x501aa8f4, 0xf101be19, 0x00c2f119, 0xff5e6d86, 0x289ecd5f, 0x9d52daf9, 0x5375ca11, 0x5ab03c37, 0x8e17b35c, 
                0xa05e2d50, 0xe922e17d, 0x65a48d9b, 0x1d79af49, 0x57756064, 0xff491849, 0xe18e4e9f, 0xaec6114f, 0xf9b18566, 0x2453d491, 0x881fdc8e, 0xb3c2b6c8, 0x9d51312a, 0xf4b88adc, 0x3853205a, 0xf10704d1, 0x7747ae2f, 0x26aa1c1e, 0x968a13fa, 0x61842ed6, 0x46123d26, 0x44da9539, 0xb0e9b183, 0xa6a3efca, 
                0xb94482ae, 0x3ead5652, 0xb2a14d1d, 0xffdd6c06, 0x267454f4, 0xe5ae479b, 0xc6a83fa7, 0x8a6bafe5, 0xad956684, 0x11765bb5, 0x8d23bb70, 0x7b3b061d, 0x00aae32d, 0xdcf55e1e, 0xed175b90, 0x02c93d26, 0xb6735ec9, 0x6defaaa3, 0xf70ae493, 0xbfbe8e94, 0xea6d930c, 0x3dd332ca, 0xf57e71f7, 0x5a8ee015, 
                0xa0a71db1, 0xec1a21b9, 0x07b899eb, 0x18db44b3, 0x7cf23c90, 0xc3be3c53, 0xe0695efa, 0xe7851d08, 0x8e749638, 0xdff8d555, 0xfc9f1532, 0x0a3b6fcb, 0x8d3ba8ef, 0x263e65db, 0x29af4753, 0x3021a729, 0x5665c989, 0xf89b937b, 0x2ed4c2b6, 0x80cb4afb, 0xb37b8cc9, 0xbebbdce5, 0x242cd888, 0xcc6ba03e, 
                0x6bce8a24, 0x350a2856, 0xc294fc54, 0xee79e074, 0xe1cf38f2, 0x40ea94f4, 0xa4d459d4, 0x37b6cd8e, 0xd778034e, 0xba08e5c3, 0x7546aceb, 0x9de119fa, 0xb2a4eeaa, 0x324b9f8d, 0x304fc008, 0x5dc5d0e4, 0x51ad7612, 0xb2863663, 0xf011e5da, 0x5cc818c6, 0x7f6472be, 0x2f528299, 0xa8ba46de, 0x1fa0c709, 
                0x48a029e0, 0x231d479e, 0x90e61d27, 0xc6243a79, 0x59f73a7a, 0xcbe7d14a, 0x0ed9fc8b, 0x651ce8a0, 0x677c9879, 0x660bda8b, 0xe571ce10, 0xa41c6d1a, 0x43cfe642, 0x6cea9afb, 0x556c4b45, 0xd6cbc996, 0x77f10da1, 0xb6dbe4cb, 0x41a2c913, 0x5a9e07eb, 0xddda6793, 0x627aacc9, 0x1f2cbc43, 0x2352db58, 
                0x1bcc9aa6, 0xcc88cdac, 0x2770253d, 0x73f24d71, 0x90ae9dea, 0xa6c2526a, 0x38809ae5, 0x2426f37a, 0xb41f63a3, 0xb699efa8, 0x0469d01f, 0x35859f6e, 0x2486ea48, 0xcce50a88, 0x1d6b4209, 0x31ac2573, 0x7070fb26, 0x04d5af4a, 0xd6aca7b0, 0xc767c199, 0xa4b29478, 0x376ca232, 0xbbc59073, 0x0a809757, 
                0xfd50af73, 0x950b8f67, 0x32e8da91, 0x6de52866, 0xb8d6d092, 0x0e1f1fce, 0xa50363bf, 0x6492f6e8, 0x90dc0934, 0x1a5549b0, 0xc4d317ef, 0x1b374700, 0xe112cd9b, 0x490619eb, 0x3de8e77f, 0xffdb7e0d, 0x72278fe1, 0xd09c09c3, 0x1c878fa6, 0x92c88f81, 0xfe0b8ab6, 0xbf7293ec, 0xf960b1cc, 0xc1870bfc, 
                0x0671bc45, 0x0c2596c9, 0x49d2dc4a, 0x8ae395da, 0x74de2a9f, 0x51aa051f, 0xb33efcad, 0xeabbf59b, 0x60663177, 0x4b6a8f2a, 0x6b093d54, 0x44598287, 0x4d6381d8, 0x46a3f99d, 0x311d73c1, 0xf29812d2, 0x39af5e34, 0x781bc26e, 0x50fb4bc4, 0x68d00869, 0x4e52e09d, 0x8247e427, 0x4d59739e, 0x050ac8c4, 
                0x70730ec8, 0x15a809dd, 0xdcc83e54, 0x27d510a1, 0x8a1306e5, 0x4c8f6709, 0x8db7707c, 0xa31f6ac5, 0xf98a4a4f, 0x954334b0, 0x99b08668, 0xa242f3b7, 0xaa20c6d6, 0xcf89255f, 0xade9093e, 0x455390b4, 0x259ca04a, 0x1fd6d93d, 0x4d95aa3a, 0x268d2339, 0x9203c3e1, 0xfa268578, 0x57ccc3ea, 0xa2ca90f2, 
                0xa20f2bab, 0xb3d00473, 0x004fb4aa, 0xf318d885, 0x0a67abfa, 0x800953c1, 0x9ff7a81c, 0xba8d6568, 0x637fba7a, 0x78dc1d60, 0x7a5771dc, 0x8771a757, 0x5eb7bde4, 0x80f98ea3, 0xf2cf0f7c, 0x87d85e7b, 0x13ea707c, 0xfe6a86b3, 0xfa18e699, 0xfc82bc14, 0xa72df4ba, 0x65fe3ce1, 0x25c3c0f1, 0xcbadd018, 
                0x89d2d40c, 0x656a4a57, 0xc7238acd, 0xe24e9a22, 0x9d677ace, 0x32e06681, 0x20c8d504, 0x5ff48206, 0x0834ae15, 0xf1f52712, 0x47c9053e, 0x79addda2, 0x123480d2, 0x945aa54b, 0x14cb391d, 0xbdd88d97, 0x40c9afe6, 0x47a4fd5e, 0x5b386351, 0x3037986d, 0x8f5d7d82, 0x428e93c2, 0x2131ba39, 0x2c822417, 
                0xf6ffde6a, 0xea40d041, 0xa09fc652, 0xc1a43480, 0x4520b792, 0x07178630, 0x798472be, 0xee062342, 0x33fbe09d, 0x4139d014, 0x2bd9d479, 0xac10e741, 0x1112f754, 0xab9b3824, 0x0d3b94f6, 0x059fa8f8, 0x04f71716, 0x62836d6b, 0xb530534a, 0x4d8dcc8a, 0x8d196dab, 0xc95c640b, 0x89c03f98, 0xe306cfe8, 
                0x5c9a8217, 0x8256e00c, 0x674e2f7a, 0xbac51e42, 0xa888c98f, 0x2a0c570e, 0x3c5c1ba6, 0x552c5f69, 0xbd574821, 0x64e34bf2, 0x5cb5d076, 0x32fe2e04, 0x31717151, 0x54272f05, 0xcc63d567, 0xa17b994b, 0xeb1e983f, 0x5519b609, 0xe5d0229a, 0x72c34cac, 0x8d3ec51e, 0xb97931d3, 0xa1603fee, 0x34da80b5, 
                0xce9146a7, 0x77cd8a9b, 0x6f8278b1, 0x14f98490, 0x21bfbeff, 0x1a080d4c, 0x8e1369d2, 0x5d992429, 0x138f6c92, 0x8cfd36c2, 0x461c86da, 0xf8d77d0a, 0xe0b772db, 0xeec2d9a5, 0xeaefde45, 0x0d002c76, 0x3b44538d, 0xb3c0133f, 0xedb0f04b, 0xc17c0b13, 0x48b9464e, 0x01c5dc8d, 0x22171b69, 0x979656a8, 
                0x73ad86ef, 0x200d99f4, 0x4047c80f, 0x0e3ab577, 0xd18ec9b9, 0xc7e8f64e, 0xb702b484, 0x80535b9b, 0x568570fd, 0x4f88474c, 0xcf75ee83, 0xb6c81704, 0xb0dfa758, 0x47f68432, 0xbe524d63, 0x2cdaf625, 0x0ef3ac9d, 0x552592d3, 0xd9f4276e, 0x79965b6d, 0x67f76455, 0xbf791f84, 0xdab2e48b, 0x5e6face2, 
                0x9931dcc7, 0x609c1982, 0x84e83184, 0x49a94139, 0x315ed00e, 0x34c5740f, 0xe7a45340, 0x784f372c, 0x414a9b8e, 0xe77a7ac0, 0x5db4d1b3, 0xaaf83aa1, 0xb8d883f3, 0x787c68d8, 0x1142bfca, 0x299798a2, 0x755d2aa8, 0x924908a7, 0xc1485cbb, 0x660df332, 0x9a4d6b17, 0xd30c2ff5, 0x1d8afc85, 0x0a924ed8, 
                0xeb924315, 0x26eb7497, 0xf10d5df9, 0xd9d7ec53, 0xeab031ce, 0x20716640, 0x149a733d, 0x9074282e, 0x935dc9e9, 0xc683ceb3, 0x3ea36799, 0x73468dbc, 0x415010fe, 0xd63e8b8d, 0xf46658bf, 0xa021aa1a, 0x86aa398b, 0x6106c96c, 0x0b1adb5d, 0x2e41edc4, 0x0616ef47, 0x35f25867, 0x07ecda68, 0x7f9cf849, 
                0x3f55dd43, 0xf452aa7f, 0x505a7a57, 0xf4642853, 0x0ae7ef88, 0xcf7848bb, 0xe504fb90, 0x1292a017, 0xf86e5009, 0x1db7f1b6, 0x7bd07267, 0xa0192204, 0xab126981, 0xb8a66c9c, 0x38b0bc19, 0xd5fc4364, 0xa1c83651, 0xe5669dd8, 0xefa7042c, 0xf9c917d0, 0xa6c941b9, 0x3bee68eb, 0xfa68e052, 0x3f3e3b18, 
                0x8a851c13, 0x731404a6, 0x1f36110f, 0x64e6af8a, 0xb5bd2ff1, 0x3df2eb9c, 0x1f14b86f, 0x5c0b7cbb, 0x6f7c64ca, 0xbc831255, 0xadaddfdd, 0x8525a868, 0x3a816540, 0xed588188, 0xb4cda638, 0xeafbf335, 0x1b5f57b0, 0x32c11276, 0xb9f39c35, 0x22fd2356, 0x016e5d3d, 0x1994d8dd, 0x2a684cae, 0xdad6d5e9, 
                0x2e68799e, 0xa8149228, 0x4788dbad, 0x04000644, 0x87d76c45, 0xbcdbab5a, 0xffadd041, 0xad97b1aa, 0x1d113d1b, 0xca59dbf8, 0xefb70cac, 0x074b989e, 0x29a5d826, 0xf4a45666, 0xfaa779b2, 0xda1f954b, 0xaa57c266, 0xe5f01a1a, 0x0ad9cd92, 0x260edd42, 0x1f7fa336, 0xde261b5b, 0x7aa01378, 0xdce2c3df, 
                0xe9d34ecb, 0x9915c14d, 0x60b0f61e, 0x29b18806, 0x70d73ad5, 0x7868f268, 0x75f17cbf, 0x4cf45826, 0x886ef17a, 0x60ec9774, 0xe4083290, 0xd3025c0b, 0x11e6db22, 0x770ddafe, 0xb9e24e73, 0x49c65718, 0x11f191e7, 0x1beb5e19, 0xd5e1599a, 0x811a564b, 0xbf1ef507, 0xf5172c90, 0x17073f4a, 0xe38f01d4, 
                0x7c2f33c4, 0x4deceed8, 0x046a8ccd, 0x01240286, 0xf7f52fd8, 0xe29f52e0, 0xcc28d185, 0xe15f0cd1, 0xcb9969c1, 0x267e5dca, 0x9cc8c9b3, 0xc420ac5f, 0x78751eb2, 0xba9d4c47, 0x00a5276b, 0x5309aff0, 0x8a6293c0, 0x480d7850, 0x51a1f3ef, 0xcb931bcd, 0xaf0dabde, 0x750fd2e5, 0xb4d78e45, 0xdbf3ca43, 
                0xa1711913, 0x0e66b485, 0x9d7b07a2, 0xccf35e3d, 0x8fcb5da5, 0xe7177856, 0xccfba684, 0x05790723, 0xe9c68173, 0x92c5f001, 0x64dba8cb, 0xca7400c2, 0x17337781, 0x189fd693, 0x532946cb, 0x044138d7, 0x0f25b168, 0x0ea4d611, 0xff4a7508, 0x6988403b, 0xd01a927d, 0x985aedf2, 0xb1c737ac, 0x2e6bd7bd, 
                0x48327287, 0x70bb6360, 0x7b988d1d, 0xbda0f17c, 0x6da4e938, 0x2aaa0619, 0x8feb4a3c, 0x07712eee, 0x7d817ef4, 0x54c1ffd2, 0x8aebb7e1, 0x5986cafa, 0xc93f7f5b, 0x4cd46218, 0xbde8af8e, 0x64e6a77b, 0x2453b918, 0x61715072, 0x21be3afc, 0x1de0163a, 0x3cc2cab0, 0xdd000f07, 0xb5a97001, 0xcbedda04, 
                0x179e5696, 0xafe9b1f2, 0x1ada65ac, 0x7bc9975c, 0x13e2693e, 0x37791fca, 0xff1713fa, 0xa1b3fac1, 0xc338f2bb, 0xdee5b849, 0x8f4a4353, 0x404a273d, 0x5268e384, 0xd83ecf1d, 0x9b458613, 0x0be8542d, 0xfef9ab2d, 0xd4b4e8e2, 0xe5dbacdf, 0xa3898f8d, 0xedae78ab, 0x365fe65e, 0xc582e7bf, 0x92f20282, 
                0xf8de5700, 0x1d9a69cb, 0x26be783b, 0xcba3b133, 0x5d2bc847, 0xaf2f4033, 0x9e0fd306, 0x128840d0, 0xb80c8b2e, 0x80c38d97, 0x534f8949, 0x0cb2977b, 0x68612e53, 0xcaca9c69, 0xef229c64, 0x3adfa56d, 0x1a81520f, 0x954a0904, 0xe2921a25, 0xf02763f9, 0xcb8cfaf5, 0x6d4bfa3e, 0xffeff0f7, 0x544d1ec4, 
                0x9a6a8fd6, 0xf9571444, 0x8d66b617, 0x8700aee0, 0x7b29ea30, 0xb40be434, 0xcfa30c7c, 0xa7ce4395, 0x39d83271, 0xfbdb4905, 0x60e48c41, 0x9d04ac9f, 0xe161acde, 0x4366ce64, 0x10671c0c, 0x2168ae6f, 0x74ab018b, 0x860036ec, 0x54bffd1a, 0x2ba38cb4, 0x8ef7e747, 0x07fa7e15, 0x9ee45657, 0x2e730825, 
                0xcb8a02ca, 0x09c6d3b6, 0x7718dae0, 0x0cfb9de9, 0xd0e2e509, 0xe70eda33, 0x4111461b, 0x409a6f00, 0x274e36dd, 0x30386ce2, 0x5be07c03, 0x548233af, 0x0aa0916c, 0x092b6005, 0xf000ded0, 0x218ac0f7, 0xd11d8184, 0xaa71963d, 0x5aaa7306, 0x1bb1b968, 0xaa4c5e6e, 0x73927f3a, 0x943cae8e, 0xc8f6c853, 
                0x6a54fa6f, 0x6eafcd65, 0x9aa1b972, 0x106d80b4, 0x252106ce, 0x88e93385, 0xc5fc2a20, 0x68577fec, 0x30729cc8, 0x25ba6f3f, 0x12b7e979, 0xcf87c0dd, 0xd13ad6b1, 0x4ed00379, 0x446768b8, 0x8beb4840, 0x5b50a252, 0xc87b1e05, 0xc37de630, 0xe94e635d, 0x1a576a26, 0xae2597ed, 0xcb51b184, 0x23c41af4, 
                0x7f66a345, 0x009d9dcc, 0x7c9085a7, 0xf19b3000, 0x4f16b87a, 0x8acd09ea, 0x36797cf1, 0x64c468b9, 0x94422fc5, 0x534c1f40, 0xc0e448f4, 0x87bb8784, 0x766976e1, 0x411fc196, 0x7dbf19bd, 0xcfb639cb, 0x337c50ae, 0xaafb9ffa, 0x18a1bcae, 0x0ce5a895, 0x1316f546, 0x91d0db72, 0x331b0d66, 0x12bf832b, 
                0xb75579ab, 0x8881a857, 0x2f8c3250, 0xf06fadbb, 0x93867630, 0x5aec4abf, 0x70a2f515, 0xfa0929e8, 0xadd7d8a6, 0xf4f2182d, 0xefdf4cd3, 0x16bd9f58, 0xd7f21be0, 0xea92acbe, 0x82fcbf0f, 0xcfb8a7b0, 0x71890358, 0xd2c4fed5, 0x7bf213d5, 0x075e323f, 0x2906aff7, 0xf3bcc7fa, 0x8b9cc5b6, 0x23742631, 
                0xa250aec9, 0xabb2f43e, 0xc5f24b5c, 0x54182642, 0x68096678, 0xddbeef50, 0x36338a3e, 0x1b72bb30, 0x07d7a168, 0xbdaa03d8, 0xa3b19bfc, 0xc1a27528, 0x3d24304b, 0x18b91c03, 0x2fc70b36, 0x3e183de3, 0x142d429c, 0x9e41f6c6, 0x6b0d8b9d, 0xdff1cd35, 0x14e254d1, 0x0a9cf0b6, 0xdd4690b7, 0xecbea28f, 
                0x9321de7a, 0xc6e737e4, 0x2eeaa9b9, 0x90a834aa, 0x57ef5483, 0xc692d238, 0x4356c755, 0x382719c7, 0x8dabe3bc, 0xfaaa3730, 0x1d30aeb9, 0x31d0402b, 0xdc64bb6f, 0x49a04384, 0xb72ed51e, 0x4489dd5c, 0xccfc4f94, 0x7b40908b, 0xe12a7cd3, 0x29d91536, 0x9f92f5be, 0x859cccd9, 0x6615c4e8, 0xafc0e4db, 
                0x060b07bc, 0xc1a32280, 0xe405c4b1, 0x5f4a05f1, 0xd393e489, 0x3d2b65a9, 0x57d637f6, 0x5b5d450f, 0xb33679fd, 0x32d6c0cc, 0xe51b3d94, 0x656b2a4c, 0xc782108e, 0x54750490, 0x4a13a048, 0x6db1f5af, 0x4f43913b, 0xe1066f75, 0x8e271506, 0x98fcd460, 0xafaeeaf1, 0xd0a1bedf, 0x7070f2e1, 0x669d0487, 
                0x89584f02, 0x035c004b, 0x02c1ecc5, 0x593933d6, 0xa416bdfc, 0xd42c688e, 0x57cf532a, 0xfc73551e, 0xe937c902, 0xdbb86547, 0x61b2f74e, 0xec1f3360, 0x735c393b, 0x217d032b, 0x828fbfe8, 0xf9588ad4, 0x990716dc, 0xac76c0a5, 0x8f92d44b, 0xfa0f3890, 0x609460e1, 0x5d1d9606, 0xa274b117, 0x5d8420cf, 
                0x0e741b50, 0x0330329d, 0xc5eafec2, 0x67b80c35, 0xffc2cac5, 0x61ed2094, 0x6536bbee, 0xfc9edfde, 0xa31a5321, 0x2175daa7, 0xcb3ca0e0, 0x37525576, 0xa454d468, 0xb9a7ab78, 0x65df0d5c, 0x9d875bb5, 0x99af57b6, 0x500e97ea, 0xe81f08d4, 0x69fd47e9, 0xe05487a9, 0x8a97aee1, 0xd70e1395, 0xb64e48b5, 
                0x7d5fa274, 0xc5a483d3, 0xf220a7b2, 0xb6ed8743, 0x23e1f41b, 0xf7b80d78, 0xd9ee3379, 0xb4417691, 0xa5e83143, 0xc02346b5, 0xac252896, 0x8f6f069e, 0x8155f991, 0x1302b8b1, 0xa854964f, 0x55141c38, 0x5fdf4d3d, 0x6b1e2e8f, 0x6de6bbcf, 0x16ae9d3b, 0xbe45bbef, 0x060e948a, 0xaee84b1e, 0x131ccc04, 
                0x505c3551, 0x283bd681, 0xe06a24a3, 0x2a2434f0, 0xe966fa43, 0x5164544f, 0xb2ef9dee, 0xf836253c, 0x215154e8, 0xf4560f9b, 0xcc0644c1, 0x6c6540db, 0x100c7234, 0x5fd9e709, 0xf96b04e8, 0xa6a8dfe4, 0xa2b29f97, 0x3543d667, 0xef6e432e, 0x30f50083, 0x83e5b188, 0xd13d0dd9, 0x0a147c71, 0x607c28da, 
                0x74934706, 0xe0331fb4, 0x5b2d97c3, 0xc2c8b21d, 0x66bac8f8, 0x23f774ff, 0x825d21eb, 0x908c070f, 0xbbb9a412, 0xb1ee301d, 0x168eb863, 0x68da2f5f, 0x36718445, 0x0ef50679, 0x70980f17, 0xd996c16e, 0x142ecbce, 0x57d921b0, 0x47261757, 0x0f4be4e0, 0xc36d9fd9, 0x25e0af2f, 0x7cdb045d, 0x7b9d59b0, 
                0xa2ba8958, 0x7ac38818, 0x70e21303, 0xedde2a96, 0x1565dd4e, 0xb3b21af5, 0x6594ab31, 0x0917f23c, 0x4d97076b, 0xc1d486dd, 0xf89bddf1, 0xa6cae209, 0x1f3098e9, 0x16930e3d, 0xfb83f04d, 0xa21263a5, 0xb2a59138, 0xad91848f, 0x1b7f05b9, 0xe24faa79, 0xd6beb774, 0xade580c2, 0x27c82d61, 0xf619631f, 
                0x35c65ed7, 0x6613e25e, 0x62018f93, 0xf4b3e6d7, 0x92d19c01, 0xb5641c5f, 0xa7657522, 0xe041cabe, 0x98d71d8a, 0x9e0e1152, 0x57426349, 0xef05c7f0, 0x88f5d912, 0x30e0725f, 0x2cea53c3, 0x9b3d5322, 0x6e23c77c, 0x7b018169, 0x43314c3c, 0xedb09236, 0x19ba4022, 0x880a6ceb, 0x793ffe39, 0xa79f3219, 
                0xbd1661a3, 0x2ec22636, 0x5d99fa01, 0xfb1b166b, 0xdac74336, 0x5f6be2cb, 0x6abdcf65, 0x47ca798c, 0xa3214b69, 0xdd46c997, 0xe40d20aa, 0x3501dfa2, 0xd786a225, 0x13bccf28, 0xe5b90086, 0x2ba88ee3, 0x120e7847, 0x963cf0e3, 0x176d8883, 0xe5bc49d8, 0x927bdf83, 0x64b97718, 0xab110bb7, 0xda780824, 
                0xec82f579, 0x9bcd8cbd, 0x663dee46, 0x4ee92aa3, 0x3ec3119d, 0x589d0980, 0xbddd76c0, 0x20a04275, 0xb3f17f22, 0xc899b04b, 0x550ba21f, 0x2c4e6c7f, 0xc1c9d1b1, 0xef859333, 0xf4b17f74, 0x26f2db0e, 0x05b0f453, 0x630804e3, 0x950aeac6, 0x36f62c2f, 0xda3df44e, 0x4821fa65, 0x1d094cb3, 0xf07c571b, 
                0xdd12d8b5, 0xade08619, 0x89763bb3, 0xfede8795, 0x7d703fa8, 0x61db0075, 0x7667e67d, 0xb34e4df5, 0xf9e00f35, 0xceaa324a, 0x899a69a1, 0x681d23f6, 0x814004de, 0xd89741b3, 0x86c8361f, 0xb558735f, 0xf9c62a7a, 0xc0476525, 0xfbcdf278, 0x1d2fd6e5, 0x2db8134f, 0x31dc4d38, 0xb254b992, 0x45cacd0f, 
                0xc7194b38, 0x5fe34073, 0x4fd9795b, 0xaa35086a, 0xc611109e, 0xbcad7e28, 0xdacf271a, 0x8c17e6ed, 0x1143198b, 0x06c85e48, 0xe598bcef, 0xff9821af, 0x8ebe92f4, 0x21537abb, 0xb5706e90, 0x1bc589ea, 0x9600905a, 0xf760a646, 0xafa58470, 0xe6e3d7cf, 0x6abbca88, 0xfee6a45e, 0x4d503b7f, 0x88b229e1, 
                0xd12d6913, 0x84c6708e, 0x1b0d1960, 0x674892a5, 0x282687fc, 0xcccc55fd, 0x9166a9ac, 0x20b3d3e0, 0x7311cb2e, 0xb5da6e7c, 0xa733ab6d, 0xdc4addd9, 0xd6e41695, 0xcc8f6751, 0x78613c7e, 0xd8beebb9, 0x507d4541, 0x173e7000, 0x5508b35a, 0xc5a6bdd6, 0xf73a8e37, 0x33eb1586, 0xacf8d9b4, 0xf9fc2644, 
                0x4a725c2d, 0x37acb7d0, 0xd9ed33a3, 0x8d7f5b71, 0x8d80eca2, 0x44a9173a, 0x6f8a536c, 0xab4320ad, 0x8f6fb20a, 0x424a9476, 0xd9d4162c, 0xc1f61cf2, 0xd5efa74d, 0x01f49071, 0xdf189d10, 0x57a732e9, 0x1973091b, 0x123207f4, 0x5373de64, 0x460aeaa9, 0x7d5456cb, 0xacc56d59, 0xbb8f04eb, 0x031e9e68, 
                0xe9e787cb, 0x123543f8, 0x02c0b72c, 0x63cfaa16, 0x67145d8e, 0x19050068, 0x696d288e, 0x810eed5d, 0x0071e42b, 0x50381d21, 0x37d4a77e, 0xc9aba2df, 0xf9b30055, 0x80a4326b, 0xc813d0f5, 0xad3be34a, 0x4a3d70ff, 0x4169d6ee, 0xab773add, 0x727df822, 0xb8ad8d65, 0xf676f0e7, 0x4b3a886e, 0x8b2ea2bf, 
                0x14ab68f6, 0xff88469b, 0x42aa79fc, 0x33c3b903, 0x122f6a28, 0x2624cc44, 0xcd2d1d53, 0xa5d977f7, 0x4e4ffe41, 0x4b0a2fcc, 0x06c5cbcc, 0x07370fea, 0x82682cd5, 0xfefa3498, 0x5157d86e, 0x7dd006ba, 0x6cfe78b4, 0x764eba3c, 0x3f1d3294, 0x4fda225e, 0x36d02ab8, 0x081051c7, 0x3bf0519c, 0x2ea97d9e, 
                0x74437c56, 0x652c2351, 0x73a34d60, 0x59fe7635, 0x0c74e2b6, 0xa8ff342d, 0x0ccf6e04, 0xe3905c7d, 0x890c7da6, 0xb79e2d08, 0xcc182f35, 0xba6d52b0, 0xfaead005, 0x830025cb, 0x13012e1e, 0xfef153e4, 0xa9926336, 0x1bb65fbf, 0x3632a0fc, 0xf4e279a2, 0xfcefe2ec, 0x3e4e01b8, 0x28139cc0, 0xfe529652, 
                0x7e46e9dd, 0x020c52e4, 0x1e71e382, 0x7c3191e5, 0x3af07aa6, 0x493a208d, 0x4688c5de, 0x72b68a07, 0xcdb3f392, 0xbf41c35b, 0x16e4477d, 0xc64622c6, 0x5ef42bf8, 0x7ea9b48b, 0x36aa1b13, 0xf580f67b, 0xe9720890, 0x524cbc15, 0xbc8a8e73, 0xe74c5a52, 0xf3a2f30d, 0xe1020b7b, 0xb65adbe5, 0x1b83c2fe, 
                0x63bce6de, 0x8ff34a50, 0xbb1b65f1, 0xd711e845, 0x2dc7612e, 0x3fd9173a, 0x1dd6248e, 0x8324753e, 0x5ba44d67, 0x2f517095, 0x697741a3, 0x91074b42, 0x9a886e29, 0x9f0fb50a, 0x89137935, 0x2731d323, 0x65445a55, 0x4f4d2e7c, 0x28eef06d, 0xd27a6a7d, 0xa37d2e41, 0x0f7ae846, 0xf48283ff, 0x3e49aac0, 
                0x7d7a6884, 0xfe714c33, 0x4356d7e0, 0x69053af2, 0x472c8450, 0x0ac90dbf, 0x5d19d718, 0xbd8690d7, 0x718bc7e3, 0xa771666b, 0x7c259fa4, 0x6f020899, 0x16620a41, 0x07516e40, 0xc98d10fa, 0x0ae944f0, 0xc6d86451, 0x88162d37, 0x56b81f92, 0xf482b62d, 0x8d7f00e6, 0x0f8807b2, 0xa41a08c3, 0xe4678a25, 
                0xe8516974, 0xa9e03bf2, 0x99167051, 0x3d0a7d3d, 0xdecb6bd8, 0x3a224abb, 0x3649dbd4, 0x313927a6, 0x297ae216, 0x6abb07f2, 0x78249715, 0x2790c23e, 0x249d5914, 0xfa71f334, 0x4fe26c11, 0x2623156a, 0x017a0efd, 0x5e72f432, 0x281257a4, 0x70206036, 0x7ff4336b, 0xcf674ef7, 0xa01903c6, 0x65adcb80, 
                0xbdc7ac02, 0xf9da5885, 0xa6197e28, 0xfba9bc68, 0x5ad48044, 0xaf9574c3, 0x31e6953c, 0xe00191e8, 0x7f65e287, 0xe447567b, 0x51b7bb1b, 0x7b03ed61, 0x272d00ab, 0xf0901168, 0x08a1e2af, 0xc17890e9, 0xc2bd080f, 0xbb060e53, 0x436d2257, 0x71c67c93, 0x408165e1, 0xf1dd2220, 0x82dfa881, 0x547cfee9, 
                0x0e528bd7, 0xbbf3d980, 0xc6642518, 0x2faebe46, 0x5c4d1c1e, 0x9f6f0207, 0x7aabe213, 0x73d98667, 0xa90aed2d, 0xa81fd7df, 0xb5626621, 0x3245f214, 0x841bf509, 0x87c53018, 0x42fdaad2, 0x779ed41b, 0x8b03695c, 0xefcdf1a3, 0x3a3d9eda, 0xd990a917, 0xda3d7ef0, 0x9da2bd8f, 0x07529df0, 0x34f77bf7, 
                0xaf9e01df, 0x9a0c7311, 0xfd8ac698, 0xfa8b0b6c, 0x1aa52526, 0x0f4738ed, 0x0be708bc, 0x7671057e, 0x7a2e689b, 0x6da9d34a, 0x01dbcf9c, 0x83ee4f95, 0xaed69e3d, 0x064155b7, 0xc72be713, 0x180c3b4b, 0xf1c75ba4, 0x78112b4f, 0x26c714ed, 0xcba4ebac, 0x05321ee9, 0x4aee141b, 0x55d6972e, 0x5ec3d068, 
                0xbf7a7f57, 0xb81247e5, 0x09c669a6, 0x9df2e40c, 0xed7cff58, 0xc7fcbce0, 0x726a0a1c, 0xddeac73e, 0x8e655959, 0x1f25a55b, 0x97eccefe, 0x072d7246, 0x45d7a1a7, 0x9937fccb, 0x3ecdeb26, 0x3c24b861, 0x16966467, 0xb820a31e, 0x9513fbc6, 0x02201f41, 0xbfd27dfe, 0x108442ee, 0xc60d43b5, 0xcfc99d16, 
                0xe4243964, 0xa055b421, 0x78374730, 0xcaf8702f, 0x417c89db, 0xc8daedc2, 0xb5302cc4, 0x2e3eb63a, 0x600a51f3, 0xb72cce52, 0xcf609e75, 0x52cbb937, 0xb61ba2b4, 0x6552fc7b, 0x85afc8ab, 0x2f8c0e98, 0xf130f34f, 0xff1ce55c, 0x2f1c1436, 0xbc456efa, 0xfff8c5c5, 0x075e625e, 0x92a69b20, 0x729f4976, 
                0x3269b307, 0x1f996a57, 0x11e950c8, 0xcd620889, 0x0b7da84c, 0x3d28b817, 0x68531e2c, 0x565f9f69, 0x69d242e1, 0xcdec8d11, 0x79fe6c2e, 0x63a47a45, 0x6063ab15, 0x4c42f0a5, 0xff3dfd3b, 0x0e4be547, 0xa6616596, 0xac812a58, 0x4506bb89, 0x00116d6f, 0x553e9d3b, 0x08055503, 0xda3cc8fa, 0xfdc11a9d, 
                0x99306f22, 0x3da4c1b3, 0x871a845d, 0xe0901a2d, 0xbfc335dc, 0x141c73b9, 0x6894c770, 0x6eb66789, 0x2246ded6, 0xd3c2013e, 0x7cb77a53, 0x5bd08b97, 0xefce5ced, 0xbc1fbd6e, 0x1d7d3ba0, 0x4fde2013, 0xc9bb48b9, 0xade1c31d, 0x1165348d, 0xca948058, 0x8e9107ce, 0xd7aa1417, 0x6dae00b8, 0xbc6658be, 
                0x6f7d77c8, 0xccd20921, 0x971eb9a6, 0x4fe3ad9c, 0xba8e3508, 0x9307dff5, 0xfd0de746, 0xbfde7405, 0x4325acdd, 0xc034124c, 0xe2888bd3, 0xddc7244a, 0x935bef34, 0x99ec4074, 0x7ea26d6e, 0xfe2f90d1, 0x57769127, 0xa619b50e, 0x552ac9ed, 0xd727e06e, 0x2d00a573, 0xf72c8343, 0x43ec3e60, 0xe8533f84, 
                0xf6b3fc01, 0xc3d5a7ff, 0xced6124e, 0x99930d79, 0xc05cfe85, 0xeda677fb, 0x223fa1f3, 0x70116a2f, 0x31431609, 0x107885bb, 0x13780de4, 0x467e3e13, 0xd28dbb32, 0x83e57eb1, 0x6580c66d, 0x79b3e8d9, 0x5dfcfc1c, 0x0b7d1f15, 0x9f182177, 0x85eaeb92, 0x28b8a00a, 0x611c85d0, 0xa8f00d11, 0xbcad606b, 
                0x9869713b, 0xbb4333ec, 0x2a808cc4, 0x7a9d90e2, 0x4b535fc0, 0x4057b6b4, 0xe1f6fc6d, 0x60a8834b, 0xe26150af, 0x3dbcb49d, 0x2fcfc152, 0x5fbb07f8, 0x128a21b2, 0xf0acbcb7, 0x66160ab4, 0xa762a00a, 0xfa668d65, 0xd20a6bc7, 0x4af648a0, 0x17e2493b, 0xc75c5769, 0xad3fb33e, 0x14e4b152, 0xfb710a3c, 
                0xea70697c, 0xd2c5ca37, 0x295e0040, 0xe0307da6, 0x63f26d95, 0x206c40ae, 0xe28e2dab, 0x645579d3, 0x71c30f8a, 0x86f6ac97, 0x08f3fe95, 0x9edaf43f, 0x6cdc9331, 0xcb3b9e88, 0xbebaaacb, 0xbb832327, 0x22cecd5a, 0x2cc4f928, 0x09400d38, 0x1f85e984, 0xa6f3dd00, 0x61ac06ad, 0x2fc59847, 0x63f0208b, 
                0xaebfd0eb, 0xff122ce7, 0x54acf0b1, 0x1ab6ac9c, 0xf5985a38, 0xe27f98a0, 0x3b786202, 0x7fd164a0, 0x259e281a, 0x62ab01bb, 0xa052c273, 0xc5308721, 0xbc5964ea, 0x72bfe62e, 0xa643d1cc, 0xb8918c86, 0xd60a2614, 0x21a49f71, 0xfe1212c4, 0x08bbcc65, 0xd7e91af4, 0x5a3de012, 0x229965bd, 0x320e1251, 
                0x9feb0c1e, 0xc1ecae2d, 0xa608f24a, 0xfe4c768c, 0x6b89f1c5, 0x01b05fda, 0x2bc052bb, 0x0d69668d, 0x76ad4808, 0xa8294e60, 0x30449e36, 0x96c95f1e, 0xdf572841, 0xacbaefc8, 0xec7b8aab, 0x8addbd8c, 0xecc39754, 0x15409175, 0xc31330a1, 0x2f809993, 0xb58cf542, 0x0872dc9b, 0x602cae07, 0xf4715642, 
                0x326dd202, 0x732c385b, 0xc2664d7c, 0xc8af6a0b, 0xbb881ccd, 0x1e925342, 0x45916a11, 0x8a64a77f, 0xd99c90b8, 0x20bfffa4, 0x61cf9c0c, 0x8ffd02fe, 0x092cef65, 0x71647f8d, 0xac5074fc, 0x11742be8, 0x6b88661f, 0x09288a6f, 0x4d4dacfd, 0x796317e6, 0xe923905e, 0xe2573a12, 0x1731891c, 0xe0538bbf, 
                0x785075ac, 0x5006812c, 0x6d6cbbd4, 0x557a08f6, 0x873787e7, 0x3b15985b, 0xef572cfd, 0x4028fa47, 0xc12fb273, 0xb6e8fea6, 0x78f9f762, 0x8a95d33c, 0x0b9d007a, 0x723ccad5, 0xc120d010, 0xd29e62fa, 0x76c3ded3, 0x0e489048, 0x46e1e2dd, 0x5771ec46, 0xda4df2fe, 0xf948c211, 0x6b61a774, 0xafe3edb9, 
                0x32eea8fe, 0x42311054, 0xc3704aaa, 0xc954a41a, 0x5281ea70, 0x8fe6d5e2, 0xbac2c0d5, 0x2cba28fa, 0x16a05b58, 0x08d4fc0f, 0x9f9af098, 0x8605e029, 0x18801f58, 0xb10c4a48, 0x6272cb14, 0x5540f336, 0x4e8f8406, 0x18050a83, 0xbb79eb05, 0xd8d65309, 0x7ba4f188, 0x1bd4aebb, 0xaf982ac5, 0x152c0690, 
                0xa6d3c52c, 0xb7c30dc7, 0x34027788, 0x8b6327c3, 0x8b9816df, 0x3b018f73, 0x6b3bb4a4, 0xceb55d06, 0x8ff0e565, 0xaff91eca, 0xfa182a92, 0xc0a18487, 0x7e16e96e, 0x2a806368, 0xf9559a99, 0x85069bc7, 0xb68bc6c7, 0x4e9a3117, 0xc9a49e64, 0x53ccf2b1, 0x28ab9bfe, 0x20494701, 0x1353ff50, 0x7e016ca8, 
                0x2e00c131, 0x01cecd91, 0xb41cf59a, 0x07853c38, 0x1abe6d34, 0xf521303e, 0xacc95056
}; //TABLE
 
#endif /* CRYPTO_PRECOMPUTE_GTABLE */


#if ( RADIX_BITS == 32 )

static const int g_rgdOrder_P256[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] =
{
    0xfc632551, 0xf3b9cac2, 0xa7179e84, 0xbce6faad,
    0xffffffff, 0xffffffff, 0x00000000, 0xffffffff
};

static const digit_t g_rgdA_P256[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] =
{
    0xfffffffc, 0xffffffff, 0xffffffff, 0x00000003,
    0x00000000, 0x00000000, 0x00000004, 0xfffffffc
};

static const digit_t g_rgdB_P256[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] =
{
    0x29c4bddf, 0xd89cdf62, 0x78843090, 0xacf005cd,
    0xf7212ed6, 0xe5a220ab, 0x04874834, 0xdc30061d
};

static const digit_t g_rgecG_P256[ ECC_P256_POINT_SIZE_IN_ECAFFINES ] =
{
    0x18a9143c, 0x79e730d4, 0x5fedb601, 0x75ba95fc,
    0x77622510, 0x79fb732b, 0xa53755c6, 0x18905f76,
    0xce95560a, 0xddf25357, 0xba19e45c, 0x8b4ab8e4, 
    0xdd21f325, 0xd2e88688, 0x25885d85, 0x8571ff18
};

static const digit_t g_rgdConstModulus_P256[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] =
{
    0xffffffff, 0xffffffff, 0xffffffff, 0x00000000,
    0x00000000, 0x00000000, 0x00000001, 0xffffffff
};

static const digit_t g_rgdConstA_P256[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] =
{
    0xfffffffc, 0xffffffff, 0xffffffff, 0x00000003,
    0x00000000, 0x00000000, 0x00000004, 0xfffffffc
};

static const digit_t g_rgdConstB_P256[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] =
{
    0x29c4bddf, 0xd89cdf62, 0x78843090, 0xacf005cd,
    0xf7212ed6, 0xe5a220ab, 0x04874834, 0xdc30061d
};

static const digit_t g_rgecConstG_P256[ ECC_P256_POINT_SIZE_IN_ECAFFINES ] =
{
    0x18a9143c, 0x79e730d4, 0x5fedb601, 0x75ba95fc,
    0x77622510, 0x79fb732b, 0xa53755c6, 0x18905f76,
    0xce95560a, 0xddf25357, 0xba19e45c, 0x8b4ab8e4, 
    0xdd21f325, 0xd2e88688, 0x25885d85, 0x8571ff18
};

static const digit_t g_rgdMulFirst[ ECC_P256_POINT_SIZE_IN_ECAFFINES ] =
{
    0xffffffff, 0xffffffff, 0x00000001, 0x00000001,
    0xffffffff, 0xfffffffe, 0x00000001, 0xfffffffe
};

static const digit_t g_rgdMulScnd[ ECC_P256_LNGRED2 ] =
{
    0xffffffff, 0xffffffff, 0xffffffff, 0xfffffffe
};

static const digit_t g_rgdOne[ ECC_P256_POINT_SIZE_IN_ECAFFINES ] =
{
    0x00000001, 0x00000000, 0x00000000, 0xffffffff, 
    0xffffffff, 0xffffffff, 0xfffffffe, 0x00000000
};


static const digit_t m_rgdInverseAdjustment[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] = 
{
    0x00000000, 0x00000003, 0xfffffffe, 0x00000001, 
    0x00000002, 0xfffffffd, 0x00000003, 0xfffffffe
};

#else /* #if ( RADIX_BITS == 32 ) */

#error -- "digit_t is defined as an unsupported size"

#endif /* #if ( RADIX_BITS != 32 ) */ 




/*
** A warning is thrown by the following globals that states
** we should not be using a non-obfuscated global constant function pointer. 
** This should be ok on the porting kit, however this code must not go on the PC
** The reason why it exists on the PK is that these globals must be consts b/c
** certain compilers do not support global non-constant data ( and hence we can't
** obfuscate the pointers ).
*/
#if defined( _PREFAST_ )
#pragma warning( disable : 22112 )
#endif

/*
** Pre-inititalized read only curve context for the P256 crypto
*/
static const mp_modulus_t g_Modulus =
{
    ECC_P256_INTEGER_SIZE_IN_DIGITS,        /* length  */
    ECC_P256_LNGRED2,                       /* lngred2 */
    ECC_P256_INTEGER_SIZE_IN_DIGITS * 2,    /* modmul_algorithm_temps */
    ( CRYPTO_INT )( RADIX_BITS * ECC_P256_INTEGER_SIZE_IN_DIGITS ), /* scaling_power2;  */
    FROM_RIGHT,                             /* reddir */
    { 0 },                                  /* left_reciprocal_1 */
    0xffffffff,                             /* right_reciprocal_1 */
    ( digit_t* )g_rgdConstModulus_P256,     /* modulus */
    ( digit_t* )g_rgdMulFirst,              /* multiplier_first */
    ( digit_t* )g_rgdMulScnd,               /* multiplier_second */    
    ( digit_t* )g_rgdOne,                   /* one */     

#if ECC_P256_INTEGER_SIZE_IN_DIGITS == LNGQ_MODULO_8    
    modmul_from_right_default_modulo8,      /* modmul_algorithm for case with one ECC_P256_INTEGER as 8 digits*/
#else 
    modmul_from_right_default,              /* modmul_algorithm */
#endif 
};


static const field_desc_t g_Fdesc =
{
    ECC_P256_INTEGER_SIZE_IN_DIGITS, /* elng */
    1,                               /* degree */
    11 * ECC_P256_INTEGER_SIZE_IN_DIGITS + 6,   /* ndigtemps_arith */
    ECC_P256_INTEGER_SIZE_IN_DIGITS * 2,        /* ndigtemps_mul */
    10 * ECC_P256_INTEGER_SIZE_IN_DIGITS + 6,   /* ndigtemps_invert1 */
    FIELD_Q_MP,             /* ftype */    
    FALSE,                  /* free_modulus */
    ( digit_t* )g_rgdOne,   /* one */
    NULL,                   /* deallocate */
    &prime_arithmetic,       /* arithmetic */
    NULL,                   /* base_field */
    NULL,                   /* minimal_polynomial */
    &g_Modulus,              /* modulo */
    ( digit_t* )m_rgdInverseAdjustment, /* inverse_adjustment */
    0,                      /* T */
    0,                      /* lng_mulshifts */
    NULL,                   /* mulshifts */
    0,                      /* nonzero_trace_power */
    NULL,                   /* leading_inverse */
    NULL,                   /* freduc */
    0,                      /* unused_bits_top */
    RADIXM1,                /* mask_used_bits */
    
};


extern const ecurve_t g_Ecurve = 
{
     &g_Fdesc,                          /* field desc */
    ( digit_t* )g_rgdConstA_P256,       /* A */
    ( digit_t* )g_rgdConstB_P256,       /* B */
    ( digit_t* )g_rgecConstG_P256,      /* G */
    ( digit_t* )g_rgdOrder_P256,        /* order */
      NULL,                   /* Deallocs, should be NULL */
      NULL,                   /* fexpon */
      FALSE,                  /* Free field, should be false - nothing to free */
      FALSE,                  /* is b == zero, obviously this is false */
      ECC_P256_NDIGTEMPS,     /* ndigtemps */
      0,                      /* lnggorder */
    { 0 }                     /* G reciprocal */
};


/*
** Local Function defs
*/

CRYPTO_RESULT Convert_P256_BigEndianBytesToModular(
				const CRYPTO_BYTE    f_rgbInBytes[], 
				const ecurve_t   *f_pEcurve,    
				digit_t  f_rgecModular[],
				struct bigctx_t *f_pBigCtx );

CRYPTO_RESULT Convert_P256_ModularIntToBigEndianBytesModOrder(
				const  digit_t    f_rgecInModularInt[],
				const  ecurve_t  *f_pEcurve,
				CRYPTO_BYTE   f_rgbOutBytes[] );

CRYPTO_RESULT  Convert_P256_PlaintextToPoint( 
				const  UINT8  *f_pPlaintext, 
				const  ecurve_t        *f_pEcurve,
				digit_t          f_rgdSuppliedTemps[],
				digit_t          f_rgptOutPoint[],
				struct bigctx_t        *f_pBigCtx );

CRYPTO_RESULT Convert_P256_PointToBigEndianBytes(
				const  digit_t    f_rgptInPoint[],
				const  ecurve_t  *f_pEcurve,
				CRYPTO_BYTE   f_rgbOutBytes[] );

/*
** Function Implementations
*/


/*************************************************************************************************
**
** Function: Convert_BigEndianBytesToDigits
**
** Description: Convert a DRM_BYTE array to a digit_t array. Input should have big-endian form.
**
** Args:
**    [f_rgbInBytes]:   The bytes to convert
**    [f_rgdOutDigits]: The output converted digits
**    [f_cBits]:        Number of bits to convert
**
** Returns: CRYPTO_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes: 
**
*************************************************************************************************/
CRYPTO_RESULT Convert_BigEndianBytesToDigits(
        const unsigned char  f_rgbInBytes[],
        unsigned long        f_rgdOutDigits[],
        const unsigned long  f_cBits )
{
    /*
    ** Decls and inits
    */
    CRYPTO_DWORD   cDigitLen = BITS_TO_DIGITS( f_cBits );
    CRYPTO_DWORD   iByte     = 0;
    CRYPTO_DWORD   iDig      = 0;
    CRYPTO_DWORD   cByteLen  = __CB_DECL( ( f_cBits + 7 ) / 8 );
    CRYPTO_RESULT  dr        = CRYPTO_SUCCESS;

    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_rgbInBytes );
    ChkArg( NULL != f_rgdOutDigits );
    ChkArg( 0    != f_cBits );
    
    memset( f_rgdOutDigits, 0, cDigitLen * sizeof( digit_t ) );

    /*
    ** Loop through and set each digit, byte by byte
    */
    for ( iDig = 0; iDig < cDigitLen; ++iDig ) 
    {
        /*
        ** Figure out how many bytes to process for this digit ( it should be
        ** the min between the number of bytes in the digit and number of bytes 
        ** left unprocessed in the byte array )
        */
        CRYPTO_DWORD cbBytesRemaining = cByteLen - RADIX_BYTES * iDig;
        CRYPTO_DWORD cbBytesToProcess = MIN( cbBytesRemaining, RADIX_BYTES );             

        /*
        ** Assign the bytes into the current digit
        */
        for ( iByte = 0; iByte < cbBytesToProcess; ++iByte ) 
        {
            f_rgdOutDigits[ iDig ] ^=    ( digit_t )GET_BYTE( f_rgbInBytes, cbBytesRemaining - 1 - iByte )
                                      << ( 8 * iByte );
        } /* end for iByte */
    } /* end for iDig */

    /*
    ** Pad the end digit in the array if the bytes don't fit perfectly
    ** into the digits. This padding should be all 0x00s
    */
    f_rgdOutDigits[ cDigitLen - 1 ] &= RADIXM1 >> ( RADIX_BITS * cDigitLen - f_cBits );

ErrorExit:


    return dr;
} /* end Convert_BigEndianBytesToDigits */

/*************************************************************************************************
**
** Function: Convert_DigitsToBigEndianBytes
**
** Description: Convert digit_t array to bytes. Put most significant byte first.
**
** Args:
**    [f_rgdInDigits]: The input digits to be converted
**    [f_rgbOutBytes]: The output converted bytes
**    [f_cBits]:       Number of bits to convert
**
** Returns: CRYPTO_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
CRYPTO_RESULT Convert_DigitsToBigEndianBytes(
            const digit_t   f_rgdInDigits[],
            CRYPTO_BYTE  f_rgbOutBytes[],
            const CRYPTO_DWORD f_cBits )
{
    /*
    ** Decls and inits
    */
    CRYPTO_DWORD   cDigitLen = BITS_TO_DIGITS( f_cBits );
    CRYPTO_DWORD   iByte     = 0;
    CRYPTO_DWORD   iDig      = 0;
    CRYPTO_DWORD   cByteLen  = __CB_DECL( ( f_cBits + 7 ) / 8 );
    CRYPTO_RESULT  dr        = CRYPTO_SUCCESS;



    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_rgdInDigits );
    ChkArg( NULL != f_rgbOutBytes );
    ChkArg( 0    != f_cBits );

    /*
    ** Pull the bytes out of the digit array an stick them in their correct posn
    */
    for ( iDig = 0; iDig != cDigitLen; ++iDig ) 
    {
        digit_t   dValue = f_rgdInDigits[ iDig ];
        CRYPTO_DWORD cbBytesRemaining = cByteLen - RADIX_BYTES * iDig;
        CRYPTO_DWORD cbBytesToProcess = MIN( cbBytesRemaining, RADIX_BYTES );

        for ( iByte = 0; iByte != cbBytesToProcess; ++iByte ) 
        {
            PUT_BYTE( f_rgbOutBytes,cbBytesRemaining - 1 - iByte, ( CRYPTO_BYTE )( dValue & 0xff ) );
            dValue >>= 8;
        } /* end for iByte */
    } /* end for iDig */

ErrorExit:
    


    return dr;
} /* end digits_to_endian_bytes */

/*************************************************************************************************
**
** Function: Convert_P256_BigEndianBytesToDigits
**
** Description: 
**
** Args:
**    [f_rgbInBytes]:   The input bytes to be converted
**    [f_rgdOutDigits]: The output converted digits
**
** Returns: CRYPTO_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
CRYPTO_RESULT Convert_P256_BigEndianBytesToDigits(
                const CRYPTO_BYTE f_rgbInBytes[], 
                digit_t  f_rgdOutDigits[] )
{
    /*
    ** decls
    */
    CRYPTO_RESULT dr = CRYPTO_SUCCESS;



    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_rgdOutDigits );
    ChkArg( NULL != f_rgbInBytes );

    /*
    ** Now do the conversion
    */
    if ( CRYPTO_FAILED( Convert_BigEndianBytesToDigits( f_rgbInBytes, 
                                                     f_rgdOutDigits, 
                                                     ECC_P256_INTEGER_SIZE_IN_BITS ) ) )
    {
        ChkDR( CRYPTO_E_P256_CONVERSION_FAILURE );
    } /* end if */
    
ErrorExit:
    


    return dr;
} /* end Convert_P256_BigEndianBytesToDigits */


/*************************************************************************************************
**
** Function: Convert_P256_BigEndianBytesToDigitsModOrder
**
** Description: 
**
** Args:
**    [f_rgbBytes]:  The input bytes to be converted
**    [f_pEcurve ]:  EC that we are working on
**    [f_rgdDigits]: The output converted digits mod order 
**
** Returns: CRYPTO_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
CRYPTO_RESULT Convert_P256_BigEndianBytesToDigitsModOrder(
            const CRYPTO_BYTE  f_rgbBytes[],
            const ecurve_t *f_pEcurve,
            digit_t   f_rgdDigits[] )
{
    /*
    ** decls
    */
    CRYPTO_RESULT dr = CRYPTO_SUCCESS;
    digit_t    rgdTemp[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] = { 0 };



    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_rgbBytes );
    ChkArg( NULL != f_pEcurve );
    ChkArg( NULL != f_rgdDigits );    

    /*
    ** Now do the conversion
    */
    if ( CRYPTO_FAILED( Convert_BigEndianBytesToDigits( f_rgbBytes, 
                                                     rgdTemp, 
                                                     ECC_P256_INTEGER_SIZE_IN_BITS ) ) )
    {
        ChkDR( CRYPTO_E_P256_CONVERSION_FAILURE );
    } /* end if */

    /*
    ** Now do the modding
    */ 
    ChkBOOL( divide( rgdTemp,
                     ECC_P256_INTEGER_SIZE_IN_DIGITS,
                     f_pEcurve->gorder, 
                     ECC_P256_INTEGER_SIZE_IN_DIGITS,
                     NULL, 
                     NULL, 
                     f_rgdDigits ),
             CRYPTO_E_P256_CONVERSION_FAILURE );
ErrorExit:
    


    return dr;
} /* end Convert_P256_BigEndianBytesToDigitsModOrder */

/*************************************************************************************************
**
** Function: Convert_P256_BigEndianBytesToModular
**
** Description: Converts big endian bytes into modular formatted 
**
** Args:
**    [f_rgbInBytes]:  The bytes to be converted into modular digits ( ecaffines )
**    [f_pEcurve ]:    EC that we are working on
**    [f_rgecModular]: The converted modular format integer output
**    [f_pBigCtx]:     Bignum context pointer
**
** Returns: CRYPTO_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
CRYPTO_RESULT Convert_P256_BigEndianBytesToModular(
            const  CRYPTO_BYTE   f_rgbInBytes[], 
            const  ecurve_t  *f_pEcurve,    
            digit_t    f_rgecModular[],
            struct bigctx_t  *f_pBigCtx )
{
    /*
    ** decls
    */
    CRYPTO_RESULT dr = CRYPTO_SUCCESS;
    digit_t    rgdTemp[ ECC_P256_POINT_SIZE_IN_DIGITS / 2 ] = { 0 };



    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_rgbInBytes );
    ChkArg( NULL != f_pEcurve );
    ChkArg( NULL != f_rgecModular );
    ChkArg( NULL != f_pBigCtx );
    ChkArg( NULL != f_pEcurve->fdesc );
    ChkArg( NULL != f_pEcurve->fdesc->modulo );
    ChkArg( ECC_P256_INTEGER_SIZE_IN_DIGITS == f_pEcurve->fdesc->modulo->length );

    /*
    ** First convert to digits
    */
    ChkDR( Convert_P256_BigEndianBytesToDigits( f_rgbInBytes, rgdTemp ) );

    /*
    ** Now Convert to modular format
    */
    ChkBOOL( to_modular( rgdTemp, 
                         ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                         f_rgecModular,
                         f_pEcurve->fdesc->modulo,
                         f_pBigCtx ),
             CRYPTO_E_P256_CONVERSION_FAILURE );

ErrorExit:
    


    return dr;
} /* end Convert_P256_BigEndianBytesToModular */ 

/*************************************************************************************************
**
** Function: Convert_P256_BigEndianBytesToPoint
**
** Description: Converts big endian bytes into a modular EC point ( ecaffines )
**
** Args:
**    [f_rgbInBytes]:   The input bytes to be converted
**    [f_pEcurve ]:     EC that we are working on
**    [f_rgptOutPoint]: The output converted data in modular point format
**    [f_pBigCtx]:      Bignum context pointer
**
** Returns: CRYPTO_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
CRYPTO_RESULT Convert_P256_BigEndianBytesToPoint(
            const  CRYPTO_BYTE      f_rgbInBytes[], 
            const  ecurve_t         *f_pEcurve,    
            digit_t                 f_rgptOutPoint[],
            struct bigctx_t         *f_pBigCtx )
{
    /*
    ** decls
    */
    CRYPTO_RESULT dr = CRYPTO_SUCCESS;
    digit_t    rgdTemp[ ECC_P256_POINT_SIZE_IN_DIGITS / 2 ] = { 0 };



    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_rgbInBytes );
    ChkArg( NULL != f_pEcurve );
    ChkArg( NULL != f_rgptOutPoint );
    ChkArg( NULL != f_pBigCtx );
	ChkArg( NULL != f_pEcurve->fdesc );
	ChkArg( NULL != f_pEcurve->fdesc->modulo );
	ChkArg( ECC_P256_INTEGER_SIZE_IN_DIGITS == f_pEcurve->fdesc->modulo->length );

    /*
    ** Convert the bytes into digits and then into modular (point ) format for the x coord
    */
    ChkDR( Convert_P256_BigEndianBytesToDigits( f_rgbInBytes, rgdTemp ) );
    ChkBOOL( to_modular( rgdTemp,
                         ECC_P256_POINT_SIZE_IN_ECAFFINES / 2,
                         f_rgptOutPoint,
                         f_pEcurve->fdesc->modulo,
                         f_pBigCtx ),
             CRYPTO_E_P256_CONVERSION_FAILURE );

    /*
    ** Convert the bytes into digits and then into modular (point ) format for the y coord
    */
    ChkDR( Convert_P256_BigEndianBytesToDigits( &f_rgbInBytes[ ECC_P256_POINT_SIZE_IN_BYTES / 2 ],
                                                 rgdTemp ) );
    ChkBOOL( to_modular( rgdTemp,
                         ECC_P256_POINT_SIZE_IN_ECAFFINES / 2,
                        &f_rgptOutPoint[ ECC_P256_POINT_SIZE_IN_ECAFFINES / 2 ],
                         f_pEcurve->fdesc->modulo,
                         f_pBigCtx ),
             CRYPTO_E_P256_CONVERSION_FAILURE );
    
ErrorExit:
    


    return dr;
} /* end Convert_P256_BigEndianBytesToPoint */

/*************************************************************************************************
**
** Function: Convert_P256_DigitsToBigEndianBytes
**
** Description: Convert EC integer in digits format into big endian bytes format
**
** Args:
**    [f_rgdInDigits]: The digits to convert into bytes
**    [f_rgbOutBytes]: The converted bytes output buffer
**
** Returns: CRYPTO_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
CRYPTO_RESULT Convert_P256_DigitsToBigEndianBytes(
            const digit_t   f_rgdInDigits[], 
            CRYPTO_BYTE     f_rgbOutBytes[] )
{
    /*
    ** decls
    */
    CRYPTO_RESULT dr = CRYPTO_SUCCESS;



    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_rgdInDigits );
    ChkArg( NULL != f_rgbOutBytes );

    /*
    ** Convert the digits to bytes
    */
    if( CRYPTO_FAILED( Convert_DigitsToBigEndianBytes( f_rgdInDigits, 
                                                    f_rgbOutBytes,
                                                    ECC_P256_INTEGER_SIZE_IN_BITS ) ) )
    {
        ChkDR( CRYPTO_E_P256_CONVERSION_FAILURE );
    } /* end if */
    
ErrorExit:
    


    return dr;
} /* end Convert_P256_DigitsToBigEndianBytes */

/*************************************************************************************************
**
** Function: Convert_P256_ModularIntToBigEndianBytesModOrder
**
** Description: Converts modular format EC integer into big endian bytes mod curve's order 
**
** Args:
**    [f_rgecInModularInt]: The modular format integer to be converted into big endian bytes % o
**    [f_pEcurve ]:         EC that we are working on
**    [f_rgbOutBytes]:      The output buffer containing bytes in big endian format ( mod order )
**
** Returns: CRYPTO_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
CRYPTO_RESULT Convert_P256_ModularIntToBigEndianBytesModOrder(
            const  digit_t      f_rgecInModularInt[],
            const  ecurve_t     *f_pEcurve,
            CRYPTO_BYTE         f_rgbOutBytes[] )
{
    /*
    ** decls
    */
    CRYPTO_RESULT dr = CRYPTO_SUCCESS;
    digit_t    rgdModNum[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] = { 0 };    


    
    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_rgecInModularInt );
    ChkArg( NULL != f_pEcurve );
    ChkArg( NULL != f_rgbOutBytes );    

    /*
    ** Convert first from modular to digits ( and do the modding )
    */
    ChkDR( Convert_P256_ModularIntToDigitsModOrder( f_rgecInModularInt,
                                                    f_pEcurve,
                                                    rgdModNum ) );

    /*
    ** Now convert now from digits to bytes
    */
    ChkDR( Convert_P256_DigitsToBigEndianBytes( rgdModNum, f_rgbOutBytes ) );
    
ErrorExit:
    


    return dr;
}/* end Convert_P256_ModularIntToBigEndianBytesModOrder */

/*************************************************************************************************
**
** Function: Convert_P256_ModularIntToDigitsModOrder
**
** Description: Converts a modular format EC integer into digits mod the curve's order
**
** Args:
**    [f_rgecInModularInt]: The modular format integer to be converted into big endian bytes % o
**    [f_pEcurve ]:         EC that we are working on
**    [f_rgbOutDigits]:     The output buffer containing digits formatted data ( mod order )
**
** Returns: CRYPTO_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
CRYPTO_RESULT  Convert_P256_ModularIntToDigitsModOrder(
            const  digit_t      f_rgecInModularInt[],
            const  ecurve_t     *f_pEcurve,
            digit_t             f_rgbOutDigits[] )
{
    /*
    ** decls
    */
    CRYPTO_RESULT dr = CRYPTO_SUCCESS;
    digit_t    rgdTemp[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] = { 0 };

  

    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_rgecInModularInt );
    ChkArg( NULL != f_pEcurve );
    ChkArg( NULL != f_rgbOutDigits );    
	ChkArg( NULL != f_pEcurve->fdesc );
	ChkArg( NULL != f_pEcurve->fdesc->modulo );
	ChkArg( ECC_P256_INTEGER_SIZE_IN_DIGITS == f_pEcurve->fdesc->modulo->length );

    /*
    ** Convert first from modular to digits
    */
    ChkBOOL( from_modular( f_rgecInModularInt,
                           rgdTemp,
                           f_pEcurve->fdesc->modulo ),
             CRYPTO_E_P256_CONVERSION_FAILURE );

    /*
    ** We now take the digits and mod by the order
    */
    ChkBOOL( divide( rgdTemp,
                     ECC_P256_INTEGER_SIZE_IN_DIGITS,
                     f_pEcurve->gorder,
                     ECC_P256_INTEGER_SIZE_IN_DIGITS,
                     NULL,
                     NULL,
                     f_rgbOutDigits ),
             CRYPTO_E_P256_CONVERSION_FAILURE );
       
ErrorExit:
    


    return dr;
} /* end Convert_P256_ModularIntToDigitsModOrder */

/************************************************************************************************
**
** Function:  CRYPTO_ECC_MapX2PointP256
**
** Synopsis:  Given X coordinate of a point tries to calculate Y coordinate. Such that the 
**            resulting point is on the P256 curve. Fails if it is not possible. 
**
** Arguments:  
**    [f_pX]:               X Coordinate
**    [f_pY]:               Output Y Coordinate
**    [f_rgdSuppliedTemps]: Optional temps Array for math functions
**    [f_pBigCtx]:          Bignum context pointer
**
** Returns: CRYPTO_RESULT indicating success or the corresponding error code, 
**          DRM_E_P256_PLAINTEXT_MAPPING_FAILURE is returned if mapping was not possible.
**          f_pY is filled in case of success. 
**
** Notes:   
**
*************************************************************************************************/
CRYPTO_RESULT CRYPTO_ECC_MapX2PointP256(
            digit_t          *f_pX,
            digit_t          *f_pY,
            digit_t           f_rgdSuppliedTemps[],
            struct bigctx_t         *f_pBigCtx)
{
    CRYPTO_RESULT dr = CRYPTO_SUCCESS; 
    CRYPTO_BOOL   fSquare = FALSE;
    digit_t    rgdYSqrd[ ECC_P256_INTEGER_SIZE_IN_DIGITS * 2 ] = { 0 }; /* big enough for x^3 + ax + b */

  

    /*
    ** Compute the right-hand size of the EC function in two steps:
    ** rgdYSqrd = x^2 + a
    ** rgdYSqrd = x^3 + ax + b
    **
    ** FYI: EC function is defined as y^2 = x^3 + ax + b
    */
    ChkBOOL( Kmuladd( f_pX, 
                      f_pX,
                      g_Ecurve.a,
                      rgdYSqrd,
                      g_Ecurve.fdesc,
                      f_rgdSuppliedTemps,
                      f_pBigCtx ),
             CRYPTO_E_P256_PKCRYPTO_FAILURE );

    ChkBOOL( Kmuladd( f_pX,
                      rgdYSqrd,
                      g_Ecurve.b,
                      rgdYSqrd,
                      g_Ecurve.fdesc,
                      f_rgdSuppliedTemps,
                      f_pBigCtx ),
             CRYPTO_E_P256_PKCRYPTO_FAILURE );

    /*
    ** Calculate the square root of our x^3 + ax + b, this solves for y,
    ** b/c the equation is: y^2 = x^3 + ax + b, if this function succeeds in
    ** producing a root then we have successfully mapped the array to a point!
    */
    ChkBOOL( Kprime_sqrter( rgdYSqrd, 
                            f_pY,
                            1, 
                            g_Ecurve.fdesc,
                           &fSquare,
                            f_pBigCtx ), CRYPTO_E_P256_PKCRYPTO_FAILURE); 

    /*
    ** if we could not square root the value, then return the mapping error
    */
    ChkBOOL( fSquare, CRYPTO_E_P256_PLAINTEXT_MAPPING_FAILURE ); /* Is x^3 + ax + b  a square? */
     
ErrorExit:



    return dr; 
}

/************************************************************************************************
**
** Function:  Convert_P256_PlaintextToPoint
**
** Synopsis:  Maps a plaintext array into an EC point, this can fail if the plaintext
**            is not a valid x coord on the EC curve. Conversion expands the data by 100%
**
** Arguments:  
**    [f_pPlaintext]:       Input Plaintext data array to be converted into a point
**    [f_pEcurve ]:         EC that we are working on 
**    [f_rgdSuppliedTemps]: Optional temps array that the math functions can use.
**    [f_rgptOutPoint]:     Output plaintext in modular point format ( ecaffines )
**    [f_pBigCtx]:          Bignum context pointer
**
** Returns: CRYPTO_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:   This function is very similar to HMAC calculation function. 
**
*************************************************************************************************/
CRYPTO_RESULT Convert_P256_PlaintextToPoint( 
            const  UINT8  *f_pPlaintext, 
            const  ecurve_t        *f_pEcurve,
            digit_t                 f_rgdSuppliedTemps[],
            digit_t                 f_rgptOutPoint[],
            struct bigctx_t        *f_pBigCtx )
{
    /*
    ** Decls
    */
    CRYPTO_RESULT dr      = CRYPTO_SUCCESS;


    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_pPlaintext );
    ChkArg( NULL != f_pEcurve );
    ChkArg( NULL != f_rgptOutPoint );
    ChkArg( NULL != f_pBigCtx );


    /*
    ** Convert to the array to modular format
    */
    ChkDR( Convert_P256_BigEndianBytesToModular( f_pPlaintext,
                                                 f_pEcurve,
                                                 f_rgptOutPoint,
                                                 f_pBigCtx ) );
    
    ChkDR( CRYPTO_ECC_MapX2PointP256( f_rgptOutPoint, 
                                  &f_rgptOutPoint[ ECC_P256_POINT_SIZE_IN_ECAFFINES / 2 ] ,
                                   f_rgdSuppliedTemps,
                                   f_pBigCtx ) ); 
                 
ErrorExit:
    


    return dr;
} /* end Convert_P256_PlaintextToPoint */

/*************************************************************************************************
**
** Function: Convert_P256_PointToBigEndianBytes
**
** Description: Converts a modular EC point into big endian bytes format
**
** Args:
**    [f_rgptPoint]:  EC point to convert
**    [f_pEcurve ]:   EC that we are working on
**    [f_pPlaintext]: Convert plaintext output
**
** Returns: CRYPTO_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
inline CRYPTO_RESULT Convert_P256_PointToBigEndianBytes(
            const  digit_t          f_rgptInPoint[],
            const  ecurve_t         *f_pEcurve,
            CRYPTO_BYTE             f_rgbOutBytes[] )
{
    /*
    ** Decls
    */
    CRYPTO_RESULT dr = CRYPTO_SUCCESS;
    digit_t    rgdTemp[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] = { 0 };


    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_rgptInPoint );
    ChkArg( NULL != f_pEcurve );
    ChkArg( NULL != f_rgbOutBytes );
	ChkArg( NULL != f_pEcurve->fdesc );
	ChkArg( NULL != f_pEcurve->fdesc->modulo );
	ChkArg( ECC_P256_INTEGER_SIZE_IN_DIGITS == f_pEcurve->fdesc->modulo->length );

    /*
    ** Convert the x-coord out of modular format ( into digits ) then into bytes
    */
    ChkBOOL( from_modular( f_rgptInPoint,
                           rgdTemp,
                           f_pEcurve->fdesc->modulo ),
             CRYPTO_E_P256_CONVERSION_FAILURE );
    ChkDR( Convert_P256_DigitsToBigEndianBytes( rgdTemp, f_rgbOutBytes ) );

    /*
    ** Convert the y-coord out of modular format ( into digits ) then into bytes
    */
    ChkBOOL( from_modular( f_rgptInPoint + ECC_P256_POINT_SIZE_IN_ECAFFINES / 2,
                           rgdTemp,
                           f_pEcurve->fdesc->modulo ),
             CRYPTO_E_P256_CONVERSION_FAILURE );
    ChkDR( Convert_P256_DigitsToBigEndianBytes( rgdTemp, 
                                               &f_rgbOutBytes[ ECC_P256_POINT_SIZE_IN_BYTES / 2 ] ) );

ErrorExit:
    


    return dr;
} /* end Convert_P256_PointToBigEndianBytes */


/*************************************************************************************************
**
** Function: Convert_P256_PointToPlaintext
**
** Description: Converts points into plaintext, assuming a lossless integer-to-point formula 
**              see CRYPTO_ECC_Encrpyt_P256 for details
**
** Arguements:
**    [f_rgptPoint]:  EC point to convert
**    [f_pEcurve ]:   EC that we are working on
**    [f_pPlaintext]: Convert plaintext output
**
** Returns: CRYPTO_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
CRYPTO_RESULT Convert_P256_PointToPlaintext(
            const digit_t           f_rgptPoint[],
            const ecurve_t          *f_pEcurve,
            UINT8          *f_pPlaintext )
{
    /*
    ** Decls
    */
    CRYPTO_RESULT dr = CRYPTO_SUCCESS;
    digit_t    rgdTemp[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] = { 0 };


    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_pPlaintext );
    ChkArg( NULL != f_rgptPoint );
    ChkArg( NULL != f_pEcurve );
    ChkArg( NULL != f_pEcurve->fdesc );
    ChkArg( FIELD_Q_MP == f_pEcurve->fdesc->ftype );
    ChkArg( NULL != f_pEcurve->fdesc->modulo );
    ChkArg( ECC_P256_INTEGER_SIZE_IN_DIGITS == f_pEcurve->fdesc->modulo->length );

    /*
    ** Convert the x coord of the point from modular format to digits
    */
    ChkBOOL( from_modular( f_rgptPoint,
                                         rgdTemp,
                                         f_pEcurve->fdesc->modulo ),
                                         CRYPTO_E_P256_CONVERSION_FAILURE );

    /*
    ** Now convert the digits into the DRM_BYTE array output
    */
    ChkDR( Convert_P256_DigitsToBigEndianBytes( rgdTemp, f_pPlaintext ) );
    
ErrorExit:
    


    return dr;
} /* end Convert_P256_PointToPlaintext */
#if 0
/*************************************************************************************************
**
** Function:    CRYPTO_AES_GenerateHMacKey
**
** Description: This function assumes that PLAINTEXT_P256 stucture can contain 2 128bit AES keys.
**              It will, given a PLAINTEXT_P256 struct with the 2nd key set, generate the 1st key
**              in the struct (used for XMR HMACing ) such that will have a 100% chance of being
**              Mapped to an EC point without losing any information. (See CRYPTO_ECC_Encrypt_P256 
**              function header for more details ).
**
** Arguements:
**    [f_pKeys]   : A struct containing the ALREADY SET 2nd key (content key ) for XMR lics.
**    [f_pBigCtx] : Pointer to DRMBIGNUM_CONTEXT_STRUCT for temporary memory allocations.
**
** Returns: CRYPTO_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes: This function uses the P256 bit curve. 
**        ( !!!) There is a very small chance that this function may fail to find a HMAC key
**        that, coupled with the content key will map to an EC Point. While the probability 
**        is very low (way less then .01%) the caller should check if the CRYPTO_RESULT returned
**        is DRM_E_P256_HMAC_KEYGEN_FAILURE. In which case calling the function another time will
**        probably solve the issue.
**
*************************************************************************************************/
CRYPTO_RESULT CRYPTO_ECC_GenerateHMACKey_P256(
            PLAINTEXT_P256  *f_pKeys, 
            struct bigctx_t *f_pBigCtx )
{
    /*
    ** Decls
    */
    CRYPTO_RESULT dr       = CRYPTO_SUCCESS;
    CRYPTO_DWORD  i        = 0;
    digit_t    rgdRandNum[ ECC_P256_POINT_SIZE_IN_DIGITS ] = { 0 };


    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_pKeys );
    ChkArg( NULL != f_pBigCtx );
     
    /*
    ** Init big num context
    */
    ChkDR( CRYPTO_ECC_PKInit( f_pBigCtx, NULL ) );
    
    /*
    ** Zero the HMAC key that was given
    */
    memset( f_pKeys, 0, ECC_P256_INTEGER_SIZE_IN_BYTES / 2 );

    /*
    ** Convert the first key to digits
    */
    Convert_P256_BigEndianBytesToDigits( f_pKeys->m_rgbPlaintext, 
                                         rgdRandNum );

    /*
    ** Now do a loop where I attempt to generate an AES key such that the two
    ** keys will successfully map into an EC point
    */
    for ( i = 0; i < P256_KEY_GEN_TRIES; ++i )
    {
        /*
        ** Generate the digits
        */
        ChkBOOL( random_mod_nonzero( g_Ecurve.gorder + ECC_P256_INTEGER_SIZE_IN_DIGITS / 2,  
                                     rgdRandNum + ECC_P256_INTEGER_SIZE_IN_DIGITS / 2, 
                                     ECC_P256_INTEGER_SIZE_IN_DIGITS / 2, 
                                     f_pBigCtx ),
                 CRYPTO_E_P256_PKCRYPTO_FAILURE );


        /*
        ** Check if it there is a solution to the EC equation for this x value,
        ** if there is then we have generated a good key.
        */
        dr = CRYPTO_ECC_CanMapToPoint_P256( rgdRandNum, f_pBigCtx );

        if (CRYPTO_SUCCESS == dr )
        {
            /*
            ** SUCCESS: Now lets covert the digits to bytes
            */
            ChkDR( Convert_P256_DigitsToBigEndianBytes( rgdRandNum, f_pKeys->m_rgbPlaintext ) );           
            break;
        } /* end if */
        else if ( CRYPTO_S_FALSE == dr )
        {
            /*
            ** The number we produced does not have a solution to the EC equation, try again.
            */
            continue;
        } /* end else if */
        else
        {
            /*
            ** Some error occured in the Mapping test function, bail out of this function.
            */
            ChkDR( dr );
        }
    } /* end for */

    /*
    ** Check we ran out of generation tries, if so then return a corresponding error.
    */
    if ( i >= P256_KEY_GEN_TRIES )
    {
        ChkDR( CRYPTO_E_P256_HMAC_KEYGEN_FAILURE );
    } /* end if */
ErrorExit:
    


    return dr;
} 
#endif


/************************************************************************************************
**
** Function:  CRYPTO_ECC_CanMapToPoint_P256
**
** Synopsis:  This function test to see if a number can be mapped into an EC point, to do this
**            the function checks if the number has a solution to the equation y^2 = x^3 + ax + b,
**            where the passed in number is the 'x' value
**
** Arguments:  
**    [f_rgdNumber]: Number to test if it can map to an EC point
**    [f_pBigCtx]  : Pointer to DRMBIGNUM_CONTEXT_STRUCT for temporary memory allocations.
**
** Returns: CRYPTO_SUCCESS if the number can be mapped, CRYPTO_S_FALSE if it can not, and returns
**          an error code if there has an error while executing the function
**
** Notes: 
**
*************************************************************************************************/
CRYPTO_RESULT CRYPTO_ECC_CanMapToPoint_P256(
            const  digit_t   f_rgdNumber[], 
            struct bigctx_t *f_pBigCtx )
{
    /*
    ** Decls
    */
    CRYPTO_RESULT dr      = CRYPTO_SUCCESS;
    digit_t rgptTemp[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]    = { 0 };
    digit_t rgdSuppliedTemps[ ECC_P256_INTEGERADD_TEMPS ]   = { 0 };


    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_rgdNumber );
    ChkArg( NULL != f_pBigCtx );
    ChkArg( NULL != g_Ecurve.fdesc->modulo );
    ChkArg( ECC_P256_INTEGER_SIZE_IN_DIGITS == g_Ecurve.fdesc->modulo->length );


    /*
    ** Convert to the array to modular format
    */
    ChkBOOL( to_modular( f_rgdNumber,
                         ECC_P256_INTEGER_SIZE_IN_DIGITS,
                         rgptTemp,
                         g_Ecurve.fdesc->modulo,
                         NULL ),
                         CRYPTO_E_P256_CONVERSION_FAILURE );

    dr = CRYPTO_ECC_MapX2PointP256(
                                                        rgptTemp,
                                                        &rgptTemp[ ECC_P256_POINT_SIZE_IN_ECAFFINES / 2 ] ,
                                                        rgdSuppliedTemps, 
                                                        f_pBigCtx ); 
    
    if ( CRYPTO_E_P256_PLAINTEXT_MAPPING_FAILURE == dr )
    {
        dr = CRYPTO_S_FALSE; 
    }

ErrorExit:
    


    return dr;
} /* end CRYPTO_ECC_CanMapToPoint_P256 */

/************************************************************************************************
**
** Function: CRYPTO_ECC_Decrypt_P256
**
** Synopsis: Performs EC El-Gamal P256 decryption on a buffer. The equation is:
**           P = C2 - k*C1, where ( C1, C2 ) is the ciphertext, P is the plaintext 
**           and k is the private key.
**
** Arguments:  
**    [f_pprivkey] -- Private key to decrypt with
**    [f_pCiphertext]    -- Encrypted bytes that are to be decrypted
**    [f_pPlaintext]   -- Clear text result
**    [f_pBigCtx]  -- Pointer to DRMBIGNUM_CONTEXT_STRUCT for temporary memory allocations.
**
** Returns: CRYPTO_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully. 
**
** Notes: It is put in the [f_pPlaintext]. This function uses
**        the private key, be sure to protect/obfuscate/encrypt this function if the private key
**        is an asset. Also refer to the CRYPTO_ECC_Decrypt_P256 function comments for more details
**        about the exact protocol for encyption and plaintext convesion.
**
*************************************************************************************************/
CRYPTO_RESULT CRYPTO_ECC_Decrypt_P256(
            const  UINT8    *f_pPrivkey,
            const  UINT8    *f_pCiphertext,
            UINT8              *f_pPlaintext) 
{
    /*
    ** decls
    */
    CRYPTO_RESULT dr = CRYPTO_SUCCESS;
    digit_t    rgdTemps[ ECC_P256_DECRYPT_TEMPS ]             = { 0 };
    digit_t    rgdPrivkey[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]  = { 0 };
    digit_t rgptC1[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]     = { 0 };
    digit_t rgptC2[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]     = { 0 };
    digit_t rgptResult[ ECC_P256_POINT_SIZE_IN_ECAFFINES ] = { 0 };
    CIPHERTEXT_P256_2POINTS *pCtPoints = ( CIPHERTEXT_P256_2POINTS* )f_pCiphertext;


    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_pPrivkey );
    ChkArg( NULL != f_pCiphertext );
    ChkArg( NULL != f_pPlaintext );

    CRYPTO_ECC_PKInit( &bigCtx, NULL );
    
    /*
    ** Convert priv key from big endian bytes to digits
    */
    ChkDR( Convert_P256_BigEndianBytesToDigits( f_pPrivkey, rgdPrivkey ) );

    /*
    ** Convert the ciphertext byte stream to two modular format points
    */
    ChkDR( Convert_P256_BigEndianBytesToPoint( pCtPoints->m_rgbC1,
                                              &g_Ecurve,
                                               rgptC1,
                                               (struct bigctx_t *)&bigCtx ) );
    ChkDR( Convert_P256_BigEndianBytesToPoint( pCtPoints->m_rgbC2,
                                              &g_Ecurve,
                                               rgptC2,
                                               (struct bigctx_t *)&bigCtx ) );

    /*
    ** Calc: result := k*C1, where k is the private key
    */
    ChkBOOL( ecaffine_exponentiation( rgptC1,
								rgdPrivkey,
								ECC_P256_INTEGER_SIZE_IN_DIGITS,
								rgptResult,
								&g_Ecurve,
								(struct bigctx_t *)&bigCtx ),
								CRYPTO_E_PKCRYPTO_FAILURE );

    /*
    ** Calc: plaintext point == result := C2 - k*C1, where k*C1
    ** was calculated in the previous step
    */
    ChkBOOL( ecaffine_addition( rgptC2,
							rgptResult,
							rgptResult,
							ECC_POINT_SUBTRACTION,
							&g_Ecurve,
							rgdTemps,
							(struct bigctx_t *)&bigCtx ),
							CRYPTO_E_PKCRYPTO_FAILURE );

    /*
    ** Do some magic and convert the plaintext point ( 512 bit ) back to a plaintext
    ** big endian byte array ( 256 bit ) ( !!11!?11! )
    */
    ChkDR( Convert_P256_PointToPlaintext( rgptResult,
                                        &g_Ecurve,
                                         f_pPlaintext ) );

ErrorExit:
    memset( rgdPrivkey, 0, ECC_P256_INTEGER_SIZE_IN_DIGITS  * sizeof( digit_t ) );
    memset( rgptResult, 0, ECC_P256_POINT_SIZE_IN_ECAFFINES * sizeof( digit_t ) );

    return dr;
}/* end CRYPTO_ECC_Decrypt_P256 */

#if 0
/************************************************************************************************
**
** Function:  CRYPTO_ECC_Encrypt_P256
**
** Synopsis:  Encrpyts a block of plaintext, given a public key. The algorithm is EC El-Gamal:
**            C1 = r*G, C2 = P + r*K, where ( C1, C2 ) is the ciphertext, r is a runtime generated
**            random integer (256 bit) K is the public key, G is the generator or basepoint for 
**            the elliptic curve and P is the plaintext.
**
** Arguments:  
**    [f_pPubkey]:     Public key used to encrypt the plaintext
**    [f_pPlaintext]:  Plaintext data to be encrypted. Not all plaintext can map to Ciphertext!
**    [f_pCiphertext]: Ciphertext result, this will be output if function succeeds
**    [f_pBigCtx]:     Pointer to DRMBIGNUM_CONTEXT_STRUCT for temporary memory allocations.
**
** Returns: CRYPTO_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:  Data is not encrpyted in place.  It is put in the f_pCiphertext. Not all plaintext
**         maps to ciphertext. There are two methods in which to deal with this:
**         1) Shorten the plaintext buffer such that the left over space can be arbirarily changed.
**            At decryption time we will not be able to retrieve those spare bytes.
**         2) Choose the ciphertext such that we know that it will be able to map to ciphertext.
**            In this way we can use all 32 bytes in the plaintext buffer, but if someone does not
**            choose a good plaintext then there is a chance that encryption will fail!
**         This function implements the 2nd of the two options, so your plaintext must be good!
**
*************************************************************************************************/
CRYPTO_RESULT CRYPTO_ECC_Encrypt_P256( 
            const   PUBKEY_P256      *f_pPubkey,
            const   PLAINTEXT_P256   *f_pPlaintext,
            CIPHERTEXT_P256  *f_pCiphertext,
            struct  bigctx_t         *f_pBigCtx )
{
    /*
    ** decls
    */
    CRYPTO_RESULT dr = CRYPTO_SUCCESS;
    digit_t    rgdTemps[ ECC_P256_ENCRYPT_TEMPS ]                = { 0 };
    digit_t    rgptPubkey[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]    = { 0 };
    digit_t    rgptC1[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]        = { 0 };
    digit_t    rgptC2[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]        = { 0 };
    digit_t    rgptPlaintext[ ECC_P256_POINT_SIZE_IN_ECAFFINES ] = { 0 };
    digit_t    rgdR[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]           = { 0 };
    CIPHERTEXT_P256_2POINTS *pCtPoints = ( CIPHERTEXT_P256_2POINTS* )f_pCiphertext;


    /*
    ** Arg Checks ( we allow f_rgdSuppliedTemps to be NULL )
    */
    ChkArg( NULL != f_pPubkey );
    ChkArg( NULL != f_pPlaintext );
    ChkArg( NULL != f_pCiphertext );
    ChkArg( NULL != f_pBigCtx );
    
    /*
    ** Ensure that BigNum context is initialized
    */
    CRYPTO_ECC_PKInit( f_pBigCtx, NULL );
     
    /*
    ** Convert the public key and generator point ( aka base point ) into point format
    */
    ChkDR( Convert_P256_BigEndianBytesToPoint( f_pPubkey->m_rgbPubkey, 
                                              &g_Ecurve, 
                                               rgptPubkey, 
                                               f_pBigCtx ) );


    /*
    ** Verify the (now converted) point is a valid curve point
    */
    ChkBOOL( ecaffine_on_curve( rgptPubkey, 
                               &g_Ecurve, 
                                NULL, 
                                rgdTemps, 
                                f_pBigCtx ),
             CRYPTO_E_PKCRYPTO_FAILURE );

    /*
    ** Now map the plaintext byte array to a plaintext point
    */
    ChkDR( Convert_P256_PlaintextToPoint( f_pPlaintext, 
                                        &g_Ecurve,
                                         rgdTemps, 
                                         rgptPlaintext,
                                         f_pBigCtx ) );

    /*
    ** Generate our random integer for encryption, r ( it must be smaller than our curve's order )
    */
    ChkBOOL( random_mod_nonzero( g_Ecurve.gorder, 
                                 rgdR, 
                                 ECC_P256_INTEGER_SIZE_IN_DIGITS,
                                 f_pBigCtx ),
             CRYPTO_E_PKCRYPTO_FAILURE );

    /*
    ** Calculate C1 = rG
    */
#if CRYPTO_PRECOMPUTE_GTABLE

    ChkBOOL( ecaffine_exponentiation_tabular( TABLE, 
                                              ECC_P256_TABLE_SPACING, 
                                              ECC_P256_TABLE_LAST, 
                                              rgdR, 
                                              ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                                              rgptC1,
                                             &g_Ecurve,
                                              f_pBigCtx ),
             CRYPTO_E_PKCRYPTO_FAILURE );
#else
    ChkBOOL( ecaffine_exponentiation( g_Ecurve.generator,
                                      rgdR,
                                      ECC_P256_INTEGER_SIZE_IN_DIGITS,
                                      rgptC1,
                                     &g_Ecurve,
                                      f_pBigCtx ),
             CRYPTO_E_PKCRYPTO_FAILURE );
#endif
    /*
    ** Calculate C2 = P + rK where P is the plaintext point and K is the pub key point
    */
    ChkBOOL( ecaffine_exponentiation( rgptPubkey,
                                      rgdR,
                                      ECC_P256_INTEGER_SIZE_IN_DIGITS,
                                      rgptC2,
                                     &g_Ecurve,
                                      f_pBigCtx ),
             CRYPTO_E_PKCRYPTO_FAILURE );

    ChkBOOL( ecaffine_addition( rgptPlaintext, 
                                rgptC2,
                                rgptC2,
                                ECC_POINT_ADDITION,
                               &g_Ecurve,
                                rgdTemps,
                                f_pBigCtx ),
             CRYPTO_E_PKCRYPTO_FAILURE );

     /*
     ** We now have our two ciphertext points, now convert them to one big
     ** ciphertext byte array ( in big endian bytes format )
     */
    ChkDR( Convert_P256_PointToBigEndianBytes( rgptC1,
                                              &g_Ecurve,
                                               pCtPoints->m_rgbC1 ) );
    ChkDR( Convert_P256_PointToBigEndianBytes( rgptC2,
                                              &g_Ecurve,
                                               pCtPoints->m_rgbC2 ) );

ErrorExit:
    OEM_SECURE_ZERO_MEMORY( rgptPlaintext, ECC_P256_POINT_SIZE_IN_ECAFFINES * sizeof( digit_t ) );
    OEM_SECURE_ZERO_MEMORY( rgdR, ECC_P256_INTEGER_SIZE_IN_DIGITS * sizeof( digit_t ) ) ;

    
    return dr;
} /* end CRYPTO_ECC_Encrypt_P256 */ 
#endif

/************************************************************************************************
**
** Function:  CRYPTO_ECC_GenKeyPair_P256
**
** Synopsis:  Generates a public-private key pair for the P256 FIPS Elliptic Curve
**
** Arguments:  
**    [f_pPubKey]:  A pointer to the structure that will be populated with the new public key
**    [f_pPrivKey]: A pointer to the structure that will be populated with the new public key
**    [f_pBigCtx]:  Pointer to DRMBIGNUM_CONTEXT_STRUCT for temporary memory allocations.
**
** Returns: CRYPTO_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes: Generates a private key, this function should be protected the key is deemed as an asset
**
*************************************************************************************************/
CRYPTO_RESULT CRYPTO_ECC_GenKeyPair_P256( 
                UINT8         *f_pPubKey,
                UINT8         *f_pPrivKey)
{
    /*
    ** decls
    */
    CRYPTO_RESULT dr = CRYPTO_SUCCESS;
    digit_t    rgdPriv[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]    = { 0 };
    digit_t    rgdSuppliedTemps[ ECC_P256_GENKEYPAIR_TEMPS ] = { 0 };
    digit_t    rgptPub[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]   = { 0 };


    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_pPrivKey );
    ChkArg( NULL != f_pPubKey );

    CRYPTO_ECC_PKInit( (struct bigctx_t *)&bigCtx , NULL );
    
    /*
    ** Create the private key such that it is any random number < curve order
    */
    ChkBOOL( random_mod_nonzero( g_Ecurve.gorder, 
                                 rgdPriv, 
                                 ECC_P256_INTEGER_SIZE_IN_DIGITS),
             CRYPTO_E_P256_PKCRYPTO_FAILURE );

    /*
    ** Compute the Public key ( privKey * G )
    */
    ChkBOOL( ecaffine_exponentiation( g_Ecurve.generator,
                                      rgdPriv, 
                                      ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                                      rgptPub, 
                                     &g_Ecurve, 
                                      NULL ),
             CRYPTO_E_P256_PKCRYPTO_FAILURE );

    /*
    ** Just to be safe lets make sure the pubkey is on the curve
    */
    ChkBOOL( ecaffine_on_curve( rgptPub, 
							&g_Ecurve,
							NULL, 
							rgdSuppliedTemps,
							NULL ),
							CRYPTO_E_P256_PKCRYPTO_FAILURE );

    /*
    ** Now Convert the priv and pub keys into big-endian DRM-BYTES
    */
    ChkDR( Convert_P256_DigitsToBigEndianBytes( rgdPriv, f_pPrivKey ) );
    ChkDR( Convert_P256_PointToBigEndianBytes( rgptPub,
                                              &g_Ecurve,
                                               f_pPubKey ) );   
ErrorExit: 
   


    return dr;
} /* end CRYPTO_ECC_GenKeyPair_P256 */


/************************************************************************************************
**
** Function:  CRYPTO_ECC_GenKeyPairRestrictedPriv_P256
**
** Synopsis:  Generates a public-private key pair for the P256 FIPS Elliptic Curve
**
** Arguments:  
**    [f_pPubKey]:  A pointer to the structure that will be populated with the new public key
**    [f_pPrivKey]: A pointer to the structure that will be populated with the new public key
**    [f_pBigCtx]:  Pointer to DRMBIGNUM_CONTEXT_STRUCT for temporary memory allocations.
**
** Returns: CRYPTO_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes: Generates a private key, this function should be protected the key is deemed as an asset
**
*************************************************************************************************/
CRYPTO_RESULT CRYPTO_ECC_GenKeyPairRestrictedPriv_P256( 
              UINT8  *f_pPubKey,
              UINT8  *f_pPrivKey)
{
    /*
    ** decls
    */
    CRYPTO_RESULT dr         = CRYPTO_SUCCESS;
    CRYPTO_DWORD  dwNumTries = 0;
    UINT32    rgdPriv[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]    = { 0 };
    UINT32    rgdSuppliedTemps[ ECC_P256_GENKEYPAIR_TEMPS ] = { 0 };
    UINT32    rgptPub[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]   = { 0 };
    
    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_pPrivKey );
    ChkArg( NULL != f_pPubKey );

    CRYPTO_ECC_PKInit( (struct bigctx_t *)&bigCtx , NULL );
    /*
    ** Create the private key such that it is any random number < curve order
    */
    do
    {
        /* 
        ** Make sure we have not tried too many times (prevent infinite loop)
        */
        if ( P256_KEY_GEN_TRIES < dwNumTries )
        {
            ChkDR( CRYPTO_E_P256_PLAINTEXT_MAPPING_FAILURE );
        } /* end if */

        /*
        ** Generate random key, test to see if it is a valid key
        */
        ChkBOOL( random_mod_nonzero( g_Ecurve.gorder, 
                                     rgdPriv, 
                                     ECC_P256_INTEGER_SIZE_IN_DIGITS),
                 CRYPTO_E_P256_PKCRYPTO_FAILURE );

        ChkDR( CRYPTO_ECC_CanMapToPoint_P256(rgdPriv, (struct bigctx_t *)&bigCtx) );

        ++dwNumTries;
    } /* end do/while */
    while  ( CRYPTO_SUCCESS != dr );
        
    /*
    ** Compute the Public key ( privKey * G )
    */
    ChkBOOL( ecaffine_exponentiation( g_Ecurve.generator,
                                      rgdPriv, 
                                      ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                                      rgptPub, 
                                     &g_Ecurve, 
                                      (struct bigctx_t *)&bigCtx ),
             CRYPTO_E_P256_PKCRYPTO_FAILURE );

    /*
    ** Just to be safe lets make sure the pubkey is on the curve
    */
    ChkBOOL( ecaffine_on_curve( rgptPub, 
                               &g_Ecurve,
                                NULL, 
                                rgdSuppliedTemps,
                                (struct bigctx_t *)&bigCtx ),
             CRYPTO_E_P256_PKCRYPTO_FAILURE );

    /*
    ** Now Convert the priv and pub keys into big-endian DRM-BYTES
    */
    ChkDR( Convert_P256_DigitsToBigEndianBytes( rgdPriv, f_pPrivKey ) );
    ChkDR( Convert_P256_PointToBigEndianBytes( rgptPub,
                                              &g_Ecurve,
                                               f_pPubKey ) );   
ErrorExit: 
   

    
    return dr;
} /* end CRYPTO_ECC_GenKeyPairEncryptablePriv_P256 */


/*************************************************************************************************
**
**  Function: CRYPTO_ECDSA_Sign_P256
**
**  Synopsis: Creates an ECDSA P256 signature for a message, given a private keys
**
**  Algorithm: x = message, P = public key, G = generator pt,
**             ( s, t ) = signature, q = field order and the ECDSA modulus
**             w = inverse( t ) MOD q
**             i = w * SHA256( x ) MOD q
**             j = w * s MOD q
**             ( u, v ) = iG + jP
**             Verify( x, ( s, t ) ) := u MOQ q == s
**
**  Arguments:
**   IN   [f_rgbMessage ]:   Message to check signature
**   IN   [f_cbMessageLen]: Message length in bytes
**   IN   [f_pPrivkey]:      Pointer to ECC Priv Key struct containing the privkey
**   OUT  [f_pSignature ]:   Pointer to the signature for the message 
**        [f_pBigCtx] :   Pointer to DRMBIGNUM_CONTEXT_STRUCT for temporary memory allocations.
**
**  Notes: This function deals with the private key thus it must be protected/obfuscated/encrypted
**
*************************************************************************************************/
CRYPTO_RESULT CRYPTO_ECDSA_Sign_P256(
            const  UINT8                     f_rgbMessage[],
            const  CRYPTO_DWORD      f_cbMessageLen,
            const  UINT8         		 *f_pPrivkey,
            UINT8                              *f_pSignature)
{    
    /*
    ** Decls
    */
    UINT8 Message_Digest[SHA256_DIGEST_SIZE_IN_BYTES];    
    CRYPTO_RESULT  dr            = CRYPTO_SUCCESS;
    CRYPTO_DWORD   dwNumTry      = 0;
    CRYPTO_DWORD   cdGCDLen      = 0;
    digit_t     rgptRandPoint[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]              = { 0 };
    digit_t     rgdRandNum[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]               = { 0 };
    digit_t     rgdRandNumInverse[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]        = { 0 };
    digit_t     rgdSigElement[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]            = { 0 };
    digit_t     rgdIntermediateVal1[ 2 * ECC_P256_INTEGER_SIZE_IN_DIGITS ]  = { 0 };
    digit_t     rgdIntermediateVal2[ 2 * ECC_P256_INTEGER_SIZE_IN_DIGITS ]  = { 0 }; 
    digit_t     rgdIntermediateVal3[ 2 * ECC_P256_INTEGER_SIZE_IN_DIGITS ]  = { 0 };
    digit_t     rgdMessageHash[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]           = { 0 };
    digit_t     rgdSuppliedTemps[ ECC_P256_SIGN_TEMPS ]                     = { 0 };


    /*
    ** Arg Checks
    */  
    ChkArg( NULL !=  f_rgbMessage );
    ChkArg( NULL !=  f_pPrivkey );
    ChkArg( 0    !=  f_cbMessageLen );
    ChkArg( NULL !=  f_pSignature );

    /*
    ** Re-Init big num context if it was not inialized or erased.
    */ 
    CRYPTO_ECC_PKInit( &bigCtx, NULL );

#if 1
    /*
    ** Hash the message
    */
    {
        SHA256_CONTEXT_T rCtx;
        SHA256_Reset(&rCtx);
        SHA256_Input(&rCtx, f_rgbMessage, f_cbMessageLen);
        SHA256_Result(&rCtx, Message_Digest);

        /*
        ** Convert the data into digits MOD order
        */
        ChkDR( Convert_P256_BigEndianBytesToDigitsModOrder( Message_Digest, 
                                                           &g_Ecurve,
                                                            rgdMessageHash ) );            
    }
#else
    /*
    ** Hash the message
    */
    {
        CRYPTO_SHA256_Digest  shaDigest;
        CRYPTO_SHA256_Context shaData;  
    
        ChkDR( CRYPTO_SHA256_Init( &shaData ) );
        ChkDR( CRYPTO_SHA256_Update( &shaData,
                                   f_rgbMessage, 
                                   f_cbMessageLen ) );
        ChkDR( CRYPTO_SHA256_Finalize( &shaData, &shaDigest ) );

        /*
        ** Convert the data into digits MOD order
        */
        ChkDR( Convert_P256_BigEndianBytesToDigitsModOrder( shaDigest.m_rgbDigest, 
                                                           &g_Ecurve,
                                                            rgdMessageHash ) );
    } /* end Hashing block */
#endif

    /* 
    ** Attempt the rest of the algorithm, if something is wrong, like we hit the pt at infinity, 
    ** if something goes wrong try again, until it succeeds or our loop ctr expires 
    */ 
    for( dwNumTry = 0; dwNumTry < 1000; ++dwNumTry ) 
    {
        /*
        ** Generate r, the random number
        */
        ChkBOOL( random_mod_nonzero( g_Ecurve.gorder, 
                                     rgdRandNum, 
                                     ECC_P256_INTEGER_SIZE_IN_DIGITS),
                 CRYPTO_E_P256_ECDSA_SIGNING_ERROR );

        /*  
        ** Calculate r*G, where G is the generator point 
        */  
#if CRYPTO_PRECOMPUTE_GTABLE


        ChkBOOL( ecaffine_exponentiation_tabular( TABLE, 
                                                  ECC_P256_TABLE_SPACING, 
                                                  ECC_P256_TABLE_LAST, 
                                                  rgdRandNum, 
                                                  ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                                                  rgptRandPoint,
                                                 &g_Ecurve,
                                                  (struct bigctx_t *)&bigCtx ),
                 CRYPTO_E_P256_ECDSA_SIGNING_ERROR );
#else
        ChkBOOL( ecaffine_exponentiation( g_Ecurve.generator, 
                                          rgdRandNum, 
                                          ECC_P256_INTEGER_SIZE_IN_DIGITS,   
                                          rgptRandPoint,      
                                         &g_Ecurve,          
                                          (struct bigctx_t *)&bigCtx ),
                 CRYPTO_E_P256_ECDSA_SIGNING_ERROR );
#endif

        /*
        ** where r*G = (u, v) grab u, then calculate s = u MOD q  
        */ 
        ChkDR( Convert_P256_ModularIntToDigitsModOrder( rgptRandPoint,
                                                       &g_Ecurve,
                                                        rgdSigElement ) );

        /*
        ** Chk to make sure that our signature element is not zero, if it is try again!
        ** If != 0, top the first part of the sig. out to the output buffer in big endian bytes
        */
        if ( significant_digit_count( rgdSigElement,  ECC_P256_INTEGER_SIZE_IN_DIGITS ) == 0 )
        {
            continue;
        } /* end if */
        ChkDR( Convert_P256_DigitsToBigEndianBytes( rgdSigElement, f_pSignature ) );

        /*
        ** Calculate inverse( r )   
        */   
        ChkBOOL( mp_gcdex( rgdRandNum,  
                           ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                           g_Ecurve.gorder,                
                           ECC_P256_INTEGER_SIZE_IN_DIGITS,  
                           rgdRandNumInverse,   
                           NULL, 
                           rgdIntermediateVal1, 
                           NULL,
                          &cdGCDLen, 
                           rgdSuppliedTemps, 
                           (struct bigctx_t *)&bigCtx ),
                 CRYPTO_E_P256_ECDSA_SIGNING_ERROR );  

        /*  
        ** Make sure that the rand num and the modulus are relative primes, (GDC must == 1 too!) 
        ** if not then there can be no inverse, try the whole process again!
        */
        if (   1 != cdGCDLen 
            || 1 != rgdIntermediateVal1[ 0 ] )
        {
            continue;
        } /* end if */

        /*
        ** Convert the priv key into digit format
        */
        ChkDR( Convert_P256_BigEndianBytesToDigits( f_pPrivkey, rgdRandNum ) );

        /*  
        ** Calculate k*s and zero the priv key afterwards regardless of success or failure
        ** Note: I am reusing the randnum buffer b/c it does not need to be use anymore
        */  
        ChkBOOL( multiply( rgdSigElement,
                           ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                           rgdRandNum,   
                           ECC_P256_INTEGER_SIZE_IN_DIGITS,  
                           rgdIntermediateVal1 ),
                 CRYPTO_E_P256_ECDSA_SIGNING_ERROR );

        /*
        ** Need to zero out ASAP b/c this is a weakpoint of the algorimth 
        */
        memset( rgdRandNum, 0, sizeof( digit_t ) * ECC_P256_INTEGER_SIZE_IN_DIGITS ); 
        
        /*
        ** calc: k*s mod q, 
        */
        ChkBOOL( divide( rgdIntermediateVal1, 
                          2 * ECC_P256_INTEGER_SIZE_IN_DIGITS,   
                          g_Ecurve.gorder, 
                          ECC_P256_INTEGER_SIZE_IN_DIGITS,   
                          NULL,
                          NULL, 
                          rgdIntermediateVal2 ),
                 CRYPTO_E_P256_ECDSA_SIGNING_ERROR );

        /*   
        ** Calculate x + (k*s MOD q), where x is the message hash
        */ 
        ChkBOOL( add_diff( rgdIntermediateVal2,  
                           2 * ECC_P256_INTEGER_SIZE_IN_DIGITS,    
                           rgdMessageHash,
                           ECC_P256_INTEGER_SIZE_IN_DIGITS,    
                           rgdIntermediateVal3,
                           NULL ),
                 CRYPTO_E_P256_ECDSA_SIGNING_ERROR );  

        /*
        ** Calculate x + (k*s MOD q) MOD q
        ** Note I am reusing the randNum buffer b/c it is not used for either the priv key,
        ** or the random number anymore.
        */
        ChkBOOL( divide( rgdIntermediateVal3, 
                         2 * ECC_P256_INTEGER_SIZE_IN_DIGITS,   
                         g_Ecurve.gorder, 
                         ECC_P256_INTEGER_SIZE_IN_DIGITS,   
                         NULL,
                         NULL, 
                         rgdRandNum ),
                 CRYPTO_E_P256_ECDSA_SIGNING_ERROR );

        /* 
        ** Calculate (x + (k*s MOD q) MOD q)/r mod q 
        ** Note: Need to zero out the out param before hand just in case all bits don't
        ** get written over
        */ 
        memset( rgdIntermediateVal1, 0, sizeof( digit_t ) * 2 * ECC_P256_INTEGER_SIZE_IN_DIGITS );     
        ChkBOOL( multiply( rgdRandNumInverse, 
                           ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                           rgdRandNum,     
                           ECC_P256_INTEGER_SIZE_IN_DIGITS,       
                           rgdIntermediateVal1 ),
                CRYPTO_E_P256_ECDSA_SIGNING_ERROR );
        ChkBOOL( divide( rgdIntermediateVal1, 
                         2 * ECC_P256_INTEGER_SIZE_IN_DIGITS,
                         g_Ecurve.gorder,     
                         ECC_P256_INTEGER_SIZE_IN_DIGITS,  
                         NULL,    
                         NULL,      
                         rgdSigElement ), 
                 CRYPTO_E_P256_ECDSA_SIGNING_ERROR );   

        /*  
        ** Chk to make sure that our signature element is not zero, if it is try again!
        */
        if( significant_digit_count( rgdSigElement,  ECC_P256_INTEGER_SIZE_IN_DIGITS ) == 0 )
        {
            continue;
        } /* end if */  

        /*
        ** We must have created a good signature at this point, so lets end the loop
        */
        break;
    }/* end for */

    /*
    ** Pop out the second signature element into the output buff in BE Bytes
    */
    ChkDR( Convert_P256_DigitsToBigEndianBytes( rgdSigElement,
                                               &f_pSignature[ ECC_P256_INTEGER_SIZE_IN_BYTES ] ) );
  
ErrorExit: 

    /*
    ** Be safe and zero some critical buffers
    */
    memset( rgdRandNum,   0,  sizeof( digit_t ) * ECC_P256_INTEGER_SIZE_IN_DIGITS );
    memset( rgdRandNumInverse,   0, sizeof( digit_t ) * ECC_P256_INTEGER_SIZE_IN_DIGITS );
    memset( rgdIntermediateVal1, 0, sizeof( digit_t ) * 2 * ECC_P256_INTEGER_SIZE_IN_DIGITS ); 
    memset( rgdIntermediateVal2, 0, sizeof( digit_t ) * 2 * ECC_P256_INTEGER_SIZE_IN_DIGITS ); 
    memset( rgdIntermediateVal2, 0, sizeof( digit_t ) * 2 * ECC_P256_INTEGER_SIZE_IN_DIGITS ); 
    memset( rgdSigElement,   0, sizeof( digit_t ) * ECC_P256_INTEGER_SIZE_IN_DIGITS ); 


    return dr; 
} /* end ECDSAV_Sign */

#if 0
/*************************************************************************************************
**
**  Function: CRYPTO_ECDSA_Verify_P256
**
**  Synopsis: Test to see if a message and a ECDSA signature match
**
**  Algorithm: x = message, P = public key, G = generator pt (
**             (s,t) = signature, q = field order and the ECDSA modulus
**             w = inverse( t ) MOD q
**             i = w * SHA1(x) MOD q
**             j = w * s MOD q
**             (u, v) = iG + jP
**             Verify(x, (s, t) ) := u MOQ q == s
**
**  Arguments:
**   IN   [f_rgbMessage ]:   Message to check signature
**   IN   [f_cbMessageLen]: Message length in bytes
**   IN   [f_pPubkey]:      Pointer to ECC Public Key struct containing the pubkey
**   IN   [f_pSignature ]:   Pointer to the signature for the message 
**     OUT[f_pfVerified]:   Returned true if signature was valid, else false
**        [f_pBigCtx] :   Pointer to DRMBIGNUM_CONTEXT_STRUCT for temporary memory allocations.
**
**  Returns:    S_OK if not errors in the function, else corresponding
**              CRYPTO_RESULT error code. [f_pfVerified] param tells if the
**              signature matched the message ( and pub key )
**
*************************************************************************************************/
CRYPTO_RESULT CRYPTO_ECDSA_Verify_P256(
            const  CRYPTO_BYTE          f_rgbMessage[],
            const  CRYPTO_DWORD         f_cbMessageLen,
            const  PUBKEY_P256          *f_pPubkey,
            const  SIGNATURE_P256       *f_pSignature,
            struct bigctx_t             *f_pBigCtx )
{
    /*
    ** Decls
    */
    CRYPTO_RESULT  dr        = CRYPTO_SUCCESS;
    CRYPTO_DWORD   cdGCDLen  = 0;
    digit_t     rgdSigTInverse[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]   = { 0 };
    digit_t     rgdGCD[ 2 * ECC_P256_INTEGER_SIZE_IN_DIGITS ]       = { 0 };
    digit_t     rgdSigS[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]          = { 0 };
    digit_t     rgdSigT[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]          = { 0 };
    digit_t     rgdTempVar1[ 2 * ECC_P256_INTEGER_SIZE_IN_DIGITS ]  = { 0 };
    digit_t     rgdTempVar2[ 2 * ECC_P256_INTEGER_SIZE_IN_DIGITS ]  = { 0 };
    digit_t     rgdMsgHash[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]       = { 0 };
    digit_t     rgdSuppliedTemps[ ECC_P256_VERIFY_TEMPS ]           = { 0 }; 
    digit_t  rgptA[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]           = { 0 };
    digit_t  rgptB[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]           = { 0 };
    digit_t  rgptP[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]           = { 0 };
    CRYPTO_BYTE    rgbU[ __CB_DECL( ECC_P256_INTEGER_SIZE_IN_BYTES ) ] = { 0 };


    /*
    ** Arg Checks
    */
    ChkArg( NULL  !=  f_pPubkey );
    ChkArg( NULL  !=  f_rgbMessage );
    ChkArg( 0     <   f_cbMessageLen );
    ChkArg( NULL  !=  f_pSignature );
    ChkArg( NULL != f_pBigCtx );

    CRYPTO_ECC_PKInit( f_pBigCtx, NULL );
    /*
    ** Convert our public key into EC Point ( modular ) format
    */
    ChkDR( Convert_P256_BigEndianBytesToPoint( f_pPubkey->m_rgbPubkey,
                                              &g_Ecurve,
                                               rgptP,
                                               f_pBigCtx ) );

    /*
    ** Hash the message
    */
    {
        CRYPTO_SHA256_Digest  shaDigest;
        CRYPTO_SHA256_Context shaData;  
      
        ChkDR( CRYPTO_SHA256_Init( &shaData ) );

        ChkDR( CRYPTO_SHA256_Update( &shaData,
                                   f_rgbMessage, 
                                   f_cbMessageLen ) );
        ChkDR( CRYPTO_SHA256_Finalize( &shaData, &shaDigest ) );

        /*
        ** Convert the data into digits MOD order
        */
        ChkDR( Convert_P256_BigEndianBytesToDigitsModOrder( shaDigest.m_rgbDigest, 
                                                           &g_Ecurve,
                                                            rgdMsgHash ) );
    } /* end Hashing block */

    /*
    ** Convert the signature to digits
    */
    ChkDR( Convert_P256_BigEndianBytesToDigits( f_pSignature->m_rgbSignature, rgdSigS ) );
    ChkDR( Convert_P256_BigEndianBytesToDigits( &f_pSignature->m_rgbSignature[ ECC_P256_INTEGER_SIZE_IN_BYTES ],
                                                 rgdSigT ) );
    /*
    ** make sure that our sig was not all zeros (should have caused
    ** an error condition while signing )
    */
    ChkBOOL( (   significant_digit_count( rgdSigS,  ECC_P256_INTEGER_SIZE_IN_DIGITS ) != 0 
              && significant_digit_count( rgdSigT,  ECC_P256_INTEGER_SIZE_IN_DIGITS ) != 0 ),
            CRYPTO_E_P256_INVALID_SIGNATURE );

    /*
    ** Test to see if either halves of the signature >= the curve order. They should not 
    ** ever be >= to this value ( alway less ) if they are then the signature used a larger
    ** modulus thus we have to fail!
    */
    ChkBOOL( (   compare_same( rgdSigS, g_Ecurve.gorder, ECC_P256_INTEGER_SIZE_IN_DIGITS ) < 0
              && compare_same( rgdSigT, g_Ecurve.gorder, ECC_P256_INTEGER_SIZE_IN_DIGITS ) < 0 ),
            CRYPTO_E_P256_INVALID_SIGNATURE );  

    /*
    ** calculate inverse(T) = w
    */
    ChkBOOL( mp_gcdex( rgdSigT,
                       ECC_P256_INTEGER_SIZE_IN_DIGITS,
                       g_Ecurve.gorder,
                       ECC_P256_INTEGER_SIZE_IN_DIGITS,
                       rgdSigTInverse,
                       NULL,
                       rgdGCD,
                       NULL,
                      &cdGCDLen,
                       rgdSuppliedTemps,
                       f_pBigCtx ),
             CRYPTO_E_P256_ECDSA_VERIFICATION_ERROR );

    /*
    ** Make sure that t and the modulus are coprimes (GCD == 1) if not
    ** then there was no inverse and we fail
    */
    ChkBOOL( (   1 == cdGCDLen 
              || 1 == rgdGCD[ 0 ] ),
            CRYPTO_E_P256_INVALID_SIGNATURE );

    /*
    ** Calculate i = w * SHA(x) mod Q
    */
    ChkBOOL( multiply( rgdSigTInverse, 
                     ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                     rgdMsgHash, 
                     ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                     rgdTempVar1 ),
            CRYPTO_E_P256_ECDSA_VERIFICATION_ERROR );      
    ChkBOOL( divide( rgdTempVar1,
                     2 * ECC_P256_INTEGER_SIZE_IN_DIGITS,
                     g_Ecurve.gorder, 
                     ECC_P256_INTEGER_SIZE_IN_DIGITS,
                     NULL, 
                     NULL, 
                     rgdTempVar2 ),
             CRYPTO_E_P256_ECDSA_VERIFICATION_ERROR );

    /*
    ** Calculate A=iG, where G is the generator point
    */
#if CRYPTO_PRECOMPUTE_GTABLE


    ChkBOOL( ecaffine_exponentiation_tabular( TABLE, 
                                              ECC_P256_TABLE_SPACING, 
                                              ECC_P256_TABLE_LAST, 
                                              rgdTempVar2, 
                                              ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                                              rgptA,
                                             &g_Ecurve,
                                              f_pBigCtx ),
             CRYPTO_E_P256_ECDSA_VERIFICATION_ERROR );
#else

    ChkBOOL( ecaffine_exponentiation( g_Ecurve.generator, 
                                      rgdTempVar2, 
                                      ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                                      rgptA, 
                                     &g_Ecurve, 
                                      f_pBigCtx ),
             CRYPTO_E_P256_ECDSA_VERIFICATION_ERROR );
#endif

    /*
    ** j = ws*mod(Q)
    */
    ChkBOOL( multiply( rgdSigTInverse, 
                       ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                       rgdSigS,
                       ECC_P256_INTEGER_SIZE_IN_DIGITS,
                       rgdTempVar1 ),
             CRYPTO_E_P256_ECDSA_VERIFICATION_ERROR );
    ChkBOOL( divide( rgdTempVar1, 
                     2 * ECC_P256_INTEGER_SIZE_IN_DIGITS,
                     g_Ecurve.gorder,
                     ECC_P256_INTEGER_SIZE_IN_DIGITS,
                     NULL,
                     NULL,
                     rgdTempVar2 ),
             CRYPTO_E_P256_ECDSA_VERIFICATION_ERROR );

    /*
    ** Calculate B=jP, where P is the public key
    */
    ChkBOOL( ecaffine_exponentiation( rgptP,
                                      rgdTempVar2, 
                                      ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                                      rgptB, 
                                     &g_Ecurve, 
                                      f_pBigCtx ),
             CRYPTO_E_P256_ECDSA_VERIFICATION_ERROR );

    /*
    ** Calculate (u,v) = iA + jB ( in our variables we have A = A + B
    */
    ChkBOOL( ecaffine_addition( rgptA,
                                rgptB,
                                rgptA,
                                ECC_POINT_ADDITION,
                               &g_Ecurve,
                                rgdSuppliedTemps,
                                f_pBigCtx ),
             CRYPTO_E_P256_ECDSA_VERIFICATION_ERROR );

    /*
    ** Check to make sure the pt is not the pt at infinity, ECDSA does not allow this
    */
    ChkBOOL( !ecaffine_is_infinite( rgptA, &g_Ecurve, NULL ),
              CRYPTO_E_P256_INVALID_SIGNATURE );

    /*
    ** Convert (u,v) into integers so we can compare them to (s,t ) or rather 
    ** compare u to s
    */
    ChkDR( Convert_P256_ModularIntToBigEndianBytesModOrder( rgptA,
                                                           &g_Ecurve,
                                                            rgbU ) );

    /*
    ** If the two numbers match then we have validated the signature! 
    */
  if (0 != MEMCMP( f_pSignature->m_rgbSignature, 
                   rgbU,
                   ECC_P256_INTEGER_SIZE_IN_BYTES ) )
  {
    ChkDR(CRYPTO_E_INVALID_SIGNATURE);
  } /* end if */

ErrorExit:
   

    return dr;
} /* end CRYPTO_ECDSA_Verify_P256 */

#endif

/**********************************************************************
** Function:   Crypto_Debug_Assert
**
** Synopsis:   Implements assert functionality. Can either create visual 
**             feedback or log to file depending on implementation.
**
** Arguments:  [f_fAssert]   -- Condiiton to test. If FALSE - rise assert
**             [f_assertcmd] -- Text string explainin the condition.
**             [f_file]      -- File where assert happened.
**             [f_line-      -- Line where assert happened.
**
** Returns:       None
**
***********************************************************************/
CRYPTO_VOID Crypto_Debug_Assert
(
     CRYPTO_BOOL f_fAssert, 
     CRYPTO_CHAR *f_assertcmd, 
     CRYPTO_CHAR *f_file, 
     CRYPTO_INT f_line )
{

    if (f_fAssert != 0)
    {
        //Printf ("%s,%d\n", f_file, f_line);
    }
}

