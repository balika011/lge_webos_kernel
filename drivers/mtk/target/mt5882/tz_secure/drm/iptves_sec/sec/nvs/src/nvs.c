/*
 * Marlin IPTV-ES Client SDK version 3.1
 *
 * Any code and mechanism in this module must not be used
 * in any form without permissions.
 *
 * Copyright 2006,2007,2008,2009 Sony Corporation
 */
#include "basic_types_iptves.h"
#include "dbg_api_iptves.h"
#include "exh_api_iptves.h"
#include "fio_api_iptves.h"
#include "mutex_api_iptves.h"
#include "byte_api_iptves.h"
#include "crypto_api_iptves.h"
#include "nvs_api.h"

COMPONENT(NVS);

/*============================================================================
 * Macro Definitions
 *==========================================================================*/
#define NVS_FNAME_READONLY      ".nvs_ro"
#define NVS_FNAME_READWRITE     ".nvs_rw"

#define NVS_FMODE_READ          0
#define NVS_FMODE_WRITE         1

#define NVS_VERSION_1           1
#define NVS_CUR_VERSION         NVS_VERSION_1
#define NVS_HEADER_LEN          (16 + CRYPTO_SHA256_DIGEST_LEN)

#define NVS_CTX_INIT()          { FIO_NULL, 0 }

unsigned char *nvs_ro = NULL;
int nvs_ro_len = 0;

unsigned char *nvs_rw = NULL;
int nvs_rw_len = 0;



/*============================================================================
 * Type Definitions
 *==========================================================================*/
typedef struct {

	unsigned char *		mem_io_handle;
	int					mem_io_offset;
	int 				mem_io_len;
	
} nvs_ctx_t;

/*============================================================================
 * Global Variables
 *==========================================================================*/
static mutex_t  l_lock[1];

/*============================================================================
 * Local Functions
 *==========================================================================*/


unsigned char nvs_test[1457] = {
	
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x05, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9c, 0xe2, 0x27, 0xb8, 0x96, 0x7c, 0x52, 0x29, 0xdb, 0x93, 0xed, 0x2b, 0xee, 0x93, 0x4e, 0x53,
	0x7b, 0x14, 0x3f, 0xb9, 0x08, 0x2f, 0x10, 0x62, 0x85, 0x29, 0xd7, 0xb2, 0x34, 0xb9, 0x19, 0xf5,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0x00, 0x00, 0x00, 0x01,
	0x30, 0x82, 0x01, 0x7b, 0x30, 0x82, 0x01, 0x28, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x08, 0x00,
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d,
	0x04, 0x03, 0x02, 0x30, 0x2d, 0x31, 0x2b, 0x30, 0x29, 0x06, 0x0b, 0x2b, 0x06, 0x01, 0x04, 0x01,
	0x81, 0xb9, 0x2f, 0x01, 0x01, 0x01, 0x0c, 0x1a, 0x75, 0x72, 0x6e, 0x3a, 0x6d, 0x61, 0x72, 0x6c,
	0x69, 0x6e, 0x3a, 0x70, 0x65, 0x65, 0x72, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x61, 0x63, 0x74, 0x69,
	0x6f, 0x6e, 0x30, 0x1e, 0x17, 0x0d, 0x30, 0x36, 0x30, 0x31, 0x30, 0x31, 0x30, 0x39, 0x30, 0x30,
	0x30, 0x30, 0x5a, 0x17, 0x0d, 0x33, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x39, 0x30, 0x30, 0x30,
	0x30, 0x5a, 0x30, 0x2d, 0x31, 0x2b, 0x30, 0x29, 0x06, 0x0b, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x81,
	0xb9, 0x2f, 0x01, 0x01, 0x01, 0x0c, 0x1a, 0x75, 0x72, 0x6e, 0x3a, 0x6d, 0x61, 0x72, 0x6c, 0x69,
	0x6e, 0x3a, 0x70, 0x65, 0x65, 0x72, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6f,
	0x6e, 0x30, 0x49, 0x30, 0x0b, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x05, 0x00,
	0x03, 0x3a, 0x00, 0x04, 0x9f, 0xf3, 0xc2, 0x4e, 0xea, 0xcf, 0xf4, 0x84, 0x65, 0xe8, 0x58, 0xf1,
	0x31, 0xea, 0x78, 0x9c, 0x4c, 0xb0, 0xf8, 0xb9, 0xff, 0x9b, 0x4b, 0x62, 0xe5, 0x07, 0x10, 0x4a,
	0xc9, 0x0f, 0xad, 0xf8, 0x47, 0x5e, 0x6c, 0x3a, 0xd3, 0x54, 0x5a, 0xb0, 0xba, 0xce, 0x0b, 0x10,
	0x78, 0xb2, 0x20, 0x3d, 0x31, 0x1b, 0x22, 0x44, 0x86, 0xc8, 0x64, 0x33, 0xa3, 0x42, 0x30, 0x40,
	0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0x9d, 0xae, 0xe6, 0xfb, 0x9f,
	0x45, 0x5d, 0xe0, 0xa0, 0x42, 0x19, 0x24, 0x7d, 0x07, 0x85, 0x95, 0xd3, 0xc0, 0x6d, 0xe6, 0x30,
	0x0e, 0x06, 0x03, 0x55, 0x1d, 0x0f, 0x01, 0x01, 0xff, 0x04, 0x04, 0x03, 0x02, 0x01, 0x06, 0x30,
	0x0f, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x01, 0x01, 0xff, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff,
	0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02, 0x03, 0x41, 0x00, 0x30,
	0x3e, 0x02, 0x1d, 0x00, 0xb6, 0x2a, 0xd7, 0xd7, 0x7e, 0x9b, 0xe8, 0x68, 0xcb, 0x06, 0x05, 0x88,
	0x4f, 0x7a, 0x89, 0x0b, 0x60, 0x1f, 0x39, 0x08, 0x64, 0x5e, 0xd4, 0x42, 0xe2, 0xed, 0xe3, 0x56,
	0x02, 0x1d, 0x00, 0x8b, 0x5e, 0x61, 0xff, 0xb7, 0xbd, 0x66, 0xd2, 0xc7, 0x55, 0xa7, 0x9a, 0xbc,
	0xa4, 0x4a, 0x16, 0x9b, 0x15, 0x76, 0xaf, 0x7e, 0xc4, 0x1e, 0x13, 0x82, 0x0b, 0xc7, 0x89, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xb6, 0x00, 0x00, 0x00, 0x01, 0x30,
	0x82, 0x03, 0xb2, 0x30, 0x82, 0x02, 0x05, 0x30, 0x82, 0x01, 0xb3, 0xa0, 0x03, 0x02, 0x01, 0x02,
	0x02, 0x08, 0x29, 0xfd, 0x58, 0x8b, 0xea, 0xdd, 0xde, 0x64, 0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86,
	0x48, 0xce, 0x3d, 0x04, 0x03, 0x02, 0x30, 0x2d, 0x31, 0x2b, 0x30, 0x29, 0x06, 0x0b, 0x2b, 0x06,
	0x01, 0x04, 0x01, 0x81, 0xb9, 0x2f, 0x01, 0x01, 0x01, 0x0c, 0x1a, 0x75, 0x72, 0x6e, 0x3a, 0x6d,
	0x61, 0x72, 0x6c, 0x69, 0x6e, 0x3a, 0x70, 0x65, 0x65, 0x72, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x61,
	0x63, 0x74, 0x69, 0x6f, 0x6e, 0x30, 0x1e, 0x17, 0x0d, 0x30, 0x37, 0x30, 0x31, 0x30, 0x39, 0x30,
	0x33, 0x34, 0x38, 0x34, 0x33, 0x5a, 0x17, 0x0d, 0x32, 0x37, 0x30, 0x31, 0x30, 0x39, 0x30, 0x33,
	0x34, 0x38, 0x34, 0x33, 0x5a, 0x30, 0x53, 0x31, 0x51, 0x30, 0x4f, 0x06, 0x0b, 0x2b, 0x06, 0x01,
	0x04, 0x01, 0x81, 0xb9, 0x2f, 0x01, 0x01, 0x01, 0x0c, 0x40, 0x75, 0x72, 0x6e, 0x3a, 0x6d, 0x61,
	0x72, 0x6c, 0x69, 0x6e, 0x3a, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x63, 0x61, 0x3a, 0x69, 0x6e,
	0x74, 0x65, 0x72, 0x74, 0x72, 0x75, 0x73, 0x74, 0x2d, 0x70, 0x64, 0x63, 0x2d, 0x63, 0x6c, 0x69,
	0x65, 0x6e, 0x74, 0x2d, 0x63, 0x61, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e,
	0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x30, 0x49, 0x30, 0x0b, 0x06, 0x07,
	0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x05, 0x00, 0x03, 0x3a, 0x00, 0x04, 0x00, 0x08, 0x14,
	0x07, 0x88, 0x1c, 0x25, 0x3f, 0xb0, 0x76, 0xd7, 0x40, 0xbf, 0x73, 0x3a, 0x6f, 0x96, 0x39, 0x6b,
	0xef, 0x78, 0x0e, 0x59, 0x1b, 0xaa, 0x7c, 0x2a, 0xc0, 0xa8, 0xa1, 0xe2, 0xde, 0x83, 0x96, 0x9e,
	0x76, 0xa3, 0x25, 0x79, 0x1e, 0x2c, 0xb4, 0x19, 0x0b, 0x1a, 0xf5, 0x55, 0x8d, 0x38, 0x7c, 0x55,
	0xc8, 0xe6, 0xa6, 0x6a, 0xaf, 0xa3, 0x81, 0xa6, 0x30, 0x81, 0xa3, 0x30, 0x1f, 0x06, 0x03, 0x55,
	0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x9d, 0xae, 0xe6, 0xfb, 0x9f, 0x45, 0x5d, 0xe0,
	0xa0, 0x42, 0x19, 0x24, 0x7d, 0x07, 0x85, 0x95, 0xd3, 0xc0, 0x6d, 0xe6, 0x30, 0x1d, 0x06, 0x03,
	0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xd6, 0xe1, 0x78, 0x3f, 0xf4, 0x22, 0xee, 0xb7, 0xc5,
	0x19, 0x57, 0x58, 0x75, 0x84, 0xfb, 0xdf, 0x4f, 0xba, 0xac, 0xf4, 0x30, 0x0e, 0x06, 0x03, 0x55,
	0x1d, 0x0f, 0x01, 0x01, 0xff, 0x04, 0x04, 0x03, 0x02, 0x02, 0x04, 0x30, 0x0f, 0x06, 0x03, 0x55,
	0x1d, 0x13, 0x01, 0x01, 0xff, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x40, 0x06, 0x03,
	0x55, 0x1d, 0x1f, 0x04, 0x39, 0x30, 0x37, 0x30, 0x35, 0xa0, 0x33, 0xa0, 0x31, 0x86, 0x2f, 0x68,
	0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x69, 0x70, 0x74, 0x76, 0x2d, 0x63, 0x72, 0x6c, 0x2e, 0x6d,
	0x61, 0x72, 0x6c, 0x69, 0x6e, 0x2d, 0x74, 0x6d, 0x6f, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x72,
	0x6c, 0x2f, 0x69, 0x70, 0x74, 0x76, 0x63, 0x72, 0x6c, 0x73, 0x2e, 0x63, 0x72, 0x6c, 0x30, 0x0a,
	0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02, 0x03, 0x40, 0x00, 0x30, 0x3d, 0x02,
	0x1d, 0x00, 0x87, 0x1b, 0x38, 0x4a, 0x62, 0x54, 0x41, 0x00, 0xcf, 0xde, 0xa6, 0x1d, 0x64, 0x8e,
	0xa9, 0xa0, 0x63, 0x57, 0x03, 0x5e, 0xae, 0x28, 0xd0, 0xb7, 0x23, 0x0a, 0xc7, 0xaf, 0x02, 0x1c,
	0x2f, 0x32, 0x14, 0xdb, 0xe8, 0xfa, 0x5e, 0x86, 0xa3, 0x81, 0x46, 0x0b, 0xfe, 0x53, 0x69, 0x9e,
	0x3f, 0x2b, 0x3e, 0x06, 0xc6, 0x7e, 0x40, 0x69, 0x57, 0x1c, 0x9e, 0x41, 0x30, 0x82, 0x01, 0xa5,
	0x30, 0x82, 0x01, 0x54, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x08, 0x31, 0x0f, 0xd5, 0xc2, 0x6c,
	0x9c, 0x5e, 0x5b, 0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02, 0x30,
	0x53, 0x31, 0x51, 0x30, 0x4f, 0x06, 0x0b, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x81, 0xb9, 0x2f, 0x01,
	0x01, 0x01, 0x0c, 0x40, 0x75, 0x72, 0x6e, 0x3a, 0x6d, 0x61, 0x72, 0x6c, 0x69, 0x6e, 0x3a, 0x63,
	0x6c, 0x69, 0x65, 0x6e, 0x74, 0x63, 0x61, 0x3a, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x74, 0x72, 0x75,
	0x73, 0x74, 0x2d, 0x70, 0x64, 0x63, 0x2d, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x2d, 0x63, 0x61,
	0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e,
	0x2e, 0x2e, 0x2e, 0x2e, 0x30, 0x1e, 0x17, 0x0d, 0x30, 0x37, 0x30, 0x32, 0x30, 0x31, 0x30, 0x32,
	0x30, 0x30, 0x34, 0x36, 0x5a, 0x17, 0x0d, 0x32, 0x37, 0x30, 0x32, 0x30, 0x31, 0x30, 0x32, 0x30,
	0x30, 0x34, 0x36, 0x5a, 0x30, 0x23, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x0b, 0x2b, 0x06, 0x01, 0x04,
	0x01, 0x81, 0xb9, 0x2f, 0x03, 0x01, 0x01, 0x0c, 0x10, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
	0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x64, 0x38, 0x63, 0x30, 0x49, 0x30, 0x0b, 0x06, 0x07, 0x2a,
	0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x05, 0x00, 0x03, 0x3a, 0x00, 0x04, 0x89, 0x04, 0x62, 0x83,
	0xd6, 0x96, 0xdb, 0x95, 0x97, 0x78, 0x82, 0x90, 0x4d, 0xf6, 0x32, 0x1d, 0xe3, 0x7d, 0xe8, 0x49,
	0xdf, 0x53, 0x5b, 0x4d, 0xbb, 0xa8, 0xe4, 0x13, 0x3e, 0xc1, 0x5d, 0xcb, 0x81, 0x36, 0xd9, 0x7f,
	0x10, 0x4e, 0xb0, 0xdf, 0x4d, 0xd5, 0x4d, 0xe3, 0xf6, 0xb7, 0x25, 0xa3, 0x19, 0x66, 0x37, 0x12,
	0xfa, 0x92, 0xb2, 0x14, 0xa3, 0x52, 0x30, 0x50, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04,
	0x18, 0x30, 0x16, 0x80, 0x14, 0xd6, 0xe1, 0x78, 0x3f, 0xf4, 0x22, 0xee, 0xb7, 0xc5, 0x19, 0x57,
	0x58, 0x75, 0x84, 0xfb, 0xdf, 0x4f, 0xba, 0xac, 0xf4, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e,
	0x04, 0x16, 0x04, 0x14, 0x0a, 0xc7, 0xa5, 0x50, 0xcd, 0x30, 0x66, 0x25, 0x2c, 0xf2, 0xe3, 0x31,
	0x54, 0x2e, 0x59, 0x3b, 0x59, 0xfe, 0x03, 0x17, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x1d, 0x0f, 0x01,
	0x01, 0xff, 0x04, 0x04, 0x03, 0x02, 0x07, 0x80, 0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce,
	0x3d, 0x04, 0x03, 0x02, 0x03, 0x3f, 0x00, 0x30, 0x3c, 0x02, 0x1c, 0x17, 0x70, 0xb2, 0x1b, 0x99,
	0x35, 0x28, 0xfb, 0x29, 0x70, 0xf2, 0x1b, 0xc4, 0x33, 0x05, 0xc1, 0xce, 0x3d, 0x66, 0x6d, 0x57,
	0x15, 0x9f, 0x01, 0x4d, 0x1d, 0xd1, 0x4d, 0x02, 0x1c, 0x45, 0xe2, 0xd2, 0x5c, 0x18, 0xff, 0xc4,
	0x79, 0x78, 0xf9, 0x48, 0xfc, 0x6e, 0xcc, 0x3c, 0xfc, 0xe1, 0x6d, 0x20, 0x50, 0xe3, 0x2b, 0x3a,
	0x84, 0x66, 0xfb, 0xe6, 0xe0, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1c, 0x00, 0x00, 0x00, 0x01, 0xbf, 0xa4, 0xd9, 0x46, 0xd8, 0xf7, 0x38, 0x40, 0x0e, 0x0b, 0x34,
	0x1d, 0x02, 0xce, 0x7f, 0x70, 0x3e, 0x56, 0xf9, 0xbf, 0x82, 0xae, 0x52, 0x4c, 0xe5, 0x7a, 0x5f,
	0x02


};



static int
l_Open(nvs_ctx_t               *io_ctx,
       nvs_ftype_t              in_type,
       u_int32_t                in_mode)
{

    exh_InitOk();
    MSGENT();

    switch (in_type) 
	{
	    case NVS_FTYPE_READONLY:  
		{ 
			io_ctx->mem_io_handle	= nvs_ro;
			io_ctx->mem_io_len		= nvs_ro_len;
			
			dprintf("\n\nnvs_ro(%x) l_open len:%d\n", nvs_ro, nvs_ro_len);
			
			break; 
		}
		
	    case NVS_FTYPE_READWRITE: 
		{ 
			io_ctx->mem_io_handle	= nvs_rw;
			io_ctx->mem_io_len		= nvs_rw_len;

			dprintf("\n\nnvs_rw(%x) l_open len:%d\n", nvs_rw, nvs_rw_len);

			break; 
		}
	    default:                  
		{ 
			return RET_INTERNALERROR;   
			break; 
		}
    }
	io_ctx->mem_io_offset	=	0;

	dprintf("%s  mode:%d[read:%d]\n", __FUNCTION__,  in_mode, NVS_FMODE_READ);
	dprintf("%s	in_type in_mode\n", __FUNCTION__,in_type, in_mode);

	if(NULL == io_ctx->mem_io_handle && in_mode == NVS_FMODE_READ)
	{

		exh_Throw(RET_NVS_NOT_EXIST);
				
	}
	else if(NULL == io_ctx->mem_io_handle && in_mode == NVS_FMODE_WRITE)
	{
		//nvs rw, should do malloc
		if(NVS_FTYPE_READWRITE == in_type)
		{
			dprintf("%s	malloc size 1\n", __FUNCTION__);
			io_ctx->mem_io_handle = malloc(1);
			if(io_ctx->mem_io_handle == NULL)
			{
				exh_Throw(RET_NVS_NOT_EXIST);
			}
			io_ctx->mem_io_len = 0;
			
		}
	}

	io_ctx->mem_io_offset = 0;

	dprintf("%s	Open ok offset:%d\n", __FUNCTION__, io_ctx->mem_io_offset);

exh_CLEANUP:

    MSGEXT(exh_Get());
    exh_Return();
}

static int
l_Close(nvs_ctx_t              *io_ctx)
{
    exh_InitOk();
    MSGENT();

	// to-do?
	io_ctx->mem_io_handle = NULL;
	io_ctx->mem_io_len = 0;
	io_ctx->mem_io_offset = 0;
	

    MSGEXT(exh_Get());
    exh_Return();
}

/* delete */
static int
l_Remove(nvs_ctx_t             *io_ctx,
         nvs_ftype_t            in_type)
{
	/* reserved */
	
	return 0;
}

static int
l_Read(nvs_ctx_t               *io_ctx,
       u_int8_t                *out_buf,
       u_int32_t                in_len)
{

	u_int32_t           len;

	unsigned char *src_buff = NULL;
	int max_len = 0;



	if(io_ctx == NULL || out_buf == NULL || io_ctx->mem_io_handle == NULL || in_len<=0)
	{
		return 2;
	}



	//dprintf("\t%s mem_io_offset %d  len %d\n", __FUNCTION__, io_ctx->mem_io_offset, io_ctx->mem_io_len);

	src_buff = io_ctx->mem_io_handle + io_ctx->mem_io_offset;
	
	max_len = io_ctx->mem_io_len - io_ctx->mem_io_offset;
	


	if(in_len>max_len)
	{
		dprintf("%s in_Len(%d) too long max_len(%d)\n", __FUNCTION__, in_len, max_len);
		len = max_len;
	}
	else
	{
		len = in_len;
	}


	//DumpHex("nvs read src_buf", src_buff, len);

	memset(out_buf, 0, len);

	// s2s
	memcpy(out_buf, src_buff, len);

	//DumpHex("nvs read out_buf", out_buf, len);

	io_ctx->mem_io_offset += len;

	iptv_tee_log_enable = 1;
	DumpHex("cache_r:", out_buf, in_len);
	iptv_tee_log_enable = 0;
	

	return 0;

}

/* just rw, the nvs_rw gets longer */
static int
l_Write(nvs_ctx_t              *io_ctx,
        const u_int8_t         *in_buf,
        u_int32_t               in_len)
{

	unsigned char *src_buff = NULL;
	int dst_mem_len = 0;
	int old_mem_len = 0;
	if(io_ctx == NULL || in_buf == NULL || io_ctx->mem_io_handle == NULL || in_len<=0)
	{
		return -1;
	}


	/* makes rw longer */
	old_mem_len = io_ctx->mem_io_len;
	//dst_mem_len = in_len + io_ctx->mem_io_len;
	dst_mem_len = in_len + io_ctx->mem_io_offset;
	if(NULL == nvs_rw)
	{
		nvs_rw = malloc(dst_mem_len);
	}
	else
	{
		nvs_rw = realloc(nvs_rw, dst_mem_len);
	}
	
	
	nvs_rw_len = dst_mem_len;
	if(NULL == nvs_rw)
	{
		dprintf("nvs malloc nvs_rw error\n");
		return 2;
	}
	io_ctx->mem_io_handle = nvs_rw;
	io_ctx->mem_io_len = dst_mem_len;


	src_buff = io_ctx->mem_io_handle + io_ctx->mem_io_offset;
	
	// s2s
	memcpy(src_buff, in_buf, in_len);

	io_ctx->mem_io_offset += in_len;

	dprintf("%s nvs_rw get longer(%d) --> (%d) at offset(%d)\n", __FUNCTION__, old_mem_len, io_ctx->mem_io_len, io_ctx->mem_io_offset);

	iptv_tee_log_enable = 1;
	DumpHex("cache_w:", in_buf, in_len);
	iptv_tee_log_enable = 0;
	

	dprintf("\n\n\n");

	return 0;

}

static int
l_MakeHeader(nvs_ctx_t         *io_ctx,
             const u_int8_t    *in_buf,
             u_int32_t          in_len,
             u_int8_t          *out_header)
{
    u_int8_t   *p = out_header;

    exh_InitOk();
    MSGENT();

    /* set version */
    byte_BE4WI(p, NVS_CUR_VERSION);

    /* set data length */
    byte_BE4WI(p, in_len);

    /* reserved field */
    byte_SETWI(p, 0, 8);

    /* set digest */
    exh_Set(crypto_Sha256Hash(in_buf, in_len, p));
    if (!exh_IsOk()) exh_Throw(RET_INTERNALERROR);

exh_CLEANUP:
    MSGEXT(exh_Get());
    exh_Return();
}

static int
l_VerifyHeader(nvs_ctx_t       *io_ctx,
               u_int8_t        *in_buf,
               u_int32_t        in_len,
               u_int8_t        *in_header)
{
    u_int8_t   *p = in_header;
    u_int32_t   ver;
    u_int32_t   len;
    u_int8_t    digest[CRYPTO_SHA256_DIGEST_LEN] = {0x0};

    exh_InitOk();
    MSGENT();

    /* check version */
    byte_BE4RI(p, ver);
	//dprintf("%s:nvs ver:%d\n", __FUNCTION__, ver);
    if (ver != NVS_CUR_VERSION) {
        dprintf("*** ERROR: NVS version is mismatched...\n"
              "      expected = %d, actual = %d\n",
              NVS_CUR_VERSION, ver);
        exh_Throw(RET_NVS_VERIFY_ERROR);
    }

    /* check data length */
    byte_BE4RI(p, len);
	//dprintf("%s:nvs len:%d in_len:%D\n", __FUNCTION__, len, in_len);	
    if (len != in_len) {
        dprintf("*** ERROR: Data length is mismatched...\n"
              "      expected = %d, actual = %d\n",
              len, in_len);
        exh_Throw(RET_NVS_VERIFY_ERROR);
    }

    /* not check reserved field */
    p += 8;


	//DumpHex("in_buf", in_buf, in_len);

    /* verify digest */
    exh_Set(crypto_Sha256Hash(in_buf, in_len, digest));
    


	//DumpHex("digest", digest, CRYPTO_SHA256_DIGEST_LEN);
	//DumpHex("p", p, CRYPTO_SHA256_DIGEST_LEN);

	if (!exh_IsOk()) exh_Throw(RET_INTERNALERROR);
	
    if (memcmp(digest, p, CRYPTO_SHA256_DIGEST_LEN) != 0) {
        dprintf("*** ERROR: Digest is mismatched...\n");
        exh_Throw(RET_NVS_VERIFY_ERROR);
    }

exh_CLEANUP:
    MSGEXT(exh_Get());
    exh_Return();
}

/*============================================================================
 * Global Functions
 *==========================================================================*/
int
nvs_Init(void)
{
    exh_InitOk();
    MSGENT();

    exh_Set(mutex_Init(l_lock));
    if (!exh_IsOk()) exh_Throw(RET_INTERNALERROR);

exh_CLEANUP:
    MSGEXT(exh_Get());
    exh_Return();
}

int
nvs_Fin(void)
{
    exh_InitOk();
    MSGENT();

    exh_Set(mutex_Fin(l_lock));
    if (!exh_IsOk()) exh_Throw(RET_INTERNALERROR);

exh_CLEANUP:
    MSGEXT(exh_Get());
    exh_Return();
}

int
nvs_CleanupNVS(nvs_ftype_t      in_type)
{
	dprintf(">>>>nvs_CleanupNVS @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
	/* reserved */
#if 0
    nvs_ctx_t   ctx = NVS_CTX_INIT();

    exh_InitOk();
    MSGENT();

    if (in_type < NVS_FTYPE_READONLY || NVS_FTYPE_READWRITE < in_type)
        exh_Throw(RET_ILLEGALARGS);

    exh_Check(l_Remove(&ctx, in_type));

exh_CLEANUP:
    l_Close(&ctx);

    MSGEXT(exh_Get());
    exh_Return();
#endif

	return 0;
}


int
nvs_Load(nvs_ftype_t            in_type,
         u_int8_t              *out_buf,
         u_int32_t             *io_len)
{
    nvs_ctx_t   ctx = NVS_CTX_INIT();
    u_int8_t    header[NVS_HEADER_LEN];
    u_int32_t   len;
    bool_t      is_locked = FALSE;

    exh_InitOk();
    MSGENT();

	//dprintf(">>nvs_Load\n");


    if (in_type < NVS_FTYPE_READONLY || NVS_FTYPE_READWRITE < in_type)
        exh_Throw(RET_ILLEGALARGS);
    if (io_len == NULL)
        exh_Throw(RET_ILLEGALARGS);

    exh_Set(mutex_Lock(l_lock));
    if (!exh_IsOk()) exh_Throw(RET_INTERNALERROR);

    is_locked = TRUE;

    exh_Check(l_Open(&ctx, in_type, NVS_FMODE_READ));
    if ((ctx.mem_io_len- sizeof(header)) < 0) {
        MSG1(("*** ERROR: NVS data length is wrong... (%d)\n", ctx.mem_io_len));
        exh_Throw(RET_NVS_VERIFY_ERROR);
    }
    len = ctx.mem_io_len - sizeof(header);

    if (out_buf) {
        if (*io_len < len) {
            MSG1(("*** ERROR: Input buffer is too short to store all data...\n"));
            exh_Throw(RET_NVS_BUFFER_SHORT);
        }
        exh_Check(l_Read(&ctx, header, sizeof(header)));
		//DumpHex("header", header, sizeof(header));
        exh_Check(l_Read(&ctx, out_buf, len));
		//DumpHex("out_buf", out_buf, len);		
        exh_Check(l_VerifyHeader(&ctx, out_buf, len, header));
    }

    *io_len = len;

exh_CLEANUP:
    l_Close(&ctx);
    if (is_locked) mutex_Unlock(l_lock);

    MSGEXT(exh_Get());
    exh_Return();
}

int
nvs_Save(nvs_ftype_t            in_type,
         const u_int8_t        *in_buf,
         u_int32_t              in_len)
{
    nvs_ctx_t   ctx = NVS_CTX_INIT();
    u_int8_t    header[NVS_HEADER_LEN];
    bool_t      is_locked = FALSE;

    exh_InitOk();
    MSGENT();

    if (in_type < NVS_FTYPE_READONLY || NVS_FTYPE_READWRITE < in_type)
        exh_Throw(RET_ILLEGALARGS);
    if ((in_buf && in_len == 0) || (!in_buf && in_len != 0))
        exh_Throw(RET_ILLEGALARGS);

    exh_Set(mutex_Lock(l_lock));
    if (!exh_IsOk()) exh_Throw(RET_INTERNALERROR);

    is_locked = TRUE;

    if (in_buf && in_len != 0) {
        exh_Check(l_Open(&ctx, in_type, NVS_FMODE_WRITE));
        exh_Check(l_MakeHeader(&ctx, in_buf, in_len, header));
        exh_Check(l_Write(&ctx, header, sizeof(header)));
        exh_Check(l_Write(&ctx, in_buf, in_len));
    } else {
        exh_Check(l_Remove(&ctx, in_type));
    }

exh_CLEANUP:
    l_Close(&ctx);
    if (is_locked) mutex_Unlock(l_lock);

    MSGEXT(exh_Get());
    exh_Return();
}


int nvs_mem_init(char *in_ro, int in_ro_len, char *in_rw, int in_rw_len)
{
	int ret = 0;

	dprintf("\n>>%s:nvs_mem_init ro_len(%d) rw_len(%d)\n", __FUNCTION__, in_ro_len, in_rw_len);

	if(in_ro != NULL && in_ro_len >0)
	{
		nvs_ro = malloc(in_ro_len);

		dprintf("nvs_mem_init nvs_ro[%x]\n", nvs_ro);
		if(NULL == nvs_ro)
		{
			ret = -1;
			
		}
		else
		{
			memset(nvs_ro, 0, in_ro_len);
			memcpy(nvs_ro, in_ro, in_ro_len);
			nvs_ro_len = in_ro_len;
		}
		
	}

	/* in_rw_len may be 0 and in_rw maybe NULL*/
	if(in_rw != NULL && in_rw_len >0)
	{
		nvs_rw = malloc(in_rw_len);

		dprintf("nvs_mem_init nvs_rw[%x]\n", nvs_rw);
		
		if(NULL == nvs_rw)
		{
			ret = -2;

		}
		else
		{
			memset(nvs_rw, 0, in_rw_len);
			memcpy(nvs_rw, in_rw, in_rw_len);
			nvs_rw_len = in_rw_len;			
	
		}
	}

	dprintf("nvs_mem_init ret[%d]\n", ret);

end:
	return ret;
}


int nvs_mem_fin(char *out_rw, int out_rw_len)
{


	//dprintf("nvs_mem_fin out_rw[%x] out_rw_len[%d]\n", out_rw, out_rw_len);

	if(NULL != nvs_ro)
	{
		//dprintf("nvs_mem_fin free nvs_ro[%p]\n", nvs_ro);
		free(nvs_ro);
		nvs_ro_len = 0;
	}


	if(NULL != nvs_rw)
	{
		memcpy(out_rw, nvs_rw, out_rw_len);
		
		//dprintf("nvs_mem_fin free nvs_rw[%p]\n", nvs_ro);
		free(nvs_rw);
		nvs_rw_len = 0;
	}


	return 0;
}



int nvs_mem_rw_len(int *out_rw_len)
{
	if(NULL != out_rw_len)
	{
		*out_rw_len = nvs_rw_len;
		
		 dprintf("nvs_mem_rw_len:nvs_mem_fin free nvs_rw[%p]\n",  nvs_rw_len);
		
		return 0;
	}
	
	return -1;
}

